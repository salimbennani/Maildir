Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  24 Dec 2018 15:48:18 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga005.fm.intel.com (fmsmga005.fm.intel.com [10.253.24.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 58E4C580261;
	Fri, 21 Dec 2018 01:18:06 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by fmsmga005-1.fm.intel.com with ESMTP; 21 Dec 2018 01:18:05 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ALY1lrxwcmtOM+HbXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0e8XKfad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWpPUMhPWSJcAY28?=
 =?us-ascii?q?YYQAAPYcMulaoYb9vEMOoBmlCAmwGO/i0CNEimPs0KEk1ekqDAHI3BYnH9ILqH?=
 =?us-ascii?q?nasNL1NKIIXuC0yqnD0C/NYO1M2Tf89ofIaA0qrPaWXbJ3dMre00gvFwXfglWI?=
 =?us-ascii?q?t4PlJTKV2foXs2WA4OpgUPigi28jqw1rvjevwcIsh5DPi4kIxF7E8iB5z5w0Jd?=
 =?us-ascii?q?2+UEN0esOkEJVKuyGbMYt7RN4pTWJwuCsi1LEKpZq2cDIXxJkp2RLTceGLfouU?=
 =?us-ascii?q?7h75VeucIy90iXxndb6lhRu+7VKsxvPgWsS1ylpGsytInsfKu3sQzRLc8NKHRe?=
 =?us-ascii?q?F4/kq52TaAyQTT6uZcLEAqmqrUNYQhzqQzlpUNq0TDGDH5mEHsgK+RbEUk9fCk?=
 =?us-ascii?q?6+XhYrr4up+RL5F4hh36P6g0h8CyD/o0PhITU2WY5eiwzrzu8E/hTLVPlPI2k6?=
 =?us-ascii?q?3ZsJ7AJcQco660GwtV0ocl6xaiADaqydcYkmcdLFJDZh2Hi5HlO1bAIfD+E/i/?=
 =?us-ascii?q?mU+hkClkx//YJL3tGJbNIWbZkLfnY7l971RQyA0pzdBQ/55UEK0OIOrvWk/ts9?=
 =?us-ascii?q?zVFhs5Mw23w+n5Etl82Z4eVHmLAq+YNqPSrFCJ6vguI+mKeI8apjL9J+I56P7p?=
 =?us-ascii?q?iH8zgUUdcrWx3ZsLdHC4GexrI0WDbnrtntcOC2AKshA+TOz3klKCVzFTam22X6?=
 =?us-ascii?q?I94DE7FY2nAZ3CRoCrnLyOwiO7EodKaWBBD1CGCW3oeJmcW/cQdCKSJddsnSYf?=
 =?us-ascii?q?VbihTI8h1guitBXgxLplNefU/iwYtZT+1Nl6/eHTlBcy9SBqAMSZyW2CU2Z0nm?=
 =?us-ascii?q?YQTT8swK9/uVB9ykuE0aVggPxXD9pT6+lNUgc7L5HcyeN6Bsv2WgLAeNeJVVmn?=
 =?us-ascii?q?Ts+nATE3UtI+3dsOb1xhFNWlixDJxzCqDKMNl7yXGJw09brR0GXrKMZj1XnKzq?=
 =?us-ascii?q?khgEMgQstUK2KmgKlz9wzQB47Ml0WUjKKqdaUa3C7Q+2aP12uOvEdEUAFuVaXJ?=
 =?us-ascii?q?R2wQZkzTrd7h/EPNU6euCag7MgtG0cONN7FFasP3gllcRPfsItLeY3mvlGe2Hh?=
 =?us-ascii?q?uIwrKMbIz3e2QSxindCU4EkxwN8naCLwQxGiCho2fGBjx0CV3ve1/s8fV5qH6j?=
 =?us-ascii?q?Uk80zgSKb0p917q1+h8Zn+CcR+kU3rIevCchqjN0HFmm0tLSCtqAoRdhfapGbd?=
 =?us-ascii?q?M85ldHyXzWtwhnMpO8KKBig0YUcx5rsEP2yxV3FoJAnNAwo3Mu0gVzJryX0VNb?=
 =?us-ascii?q?ezyDwJD/J6fYKm/x/BCoda7bwVXe0NeQ+qcS5/U0sVTjvAe1FkU893VrycVa03?=
 =?us-ascii?q?yZ5p/SFgodTYrxUlor9xh9v7zbYjQ965nI2nF2MKi0siXN29QmBOY+zhagftFf?=
 =?us-ascii?q?ML6LFQPoEs0aAdSuJ/Ium1Szch0EO+VS/rYuP8y6b/uGxLKrPOF4kTK8jGRI/J?=
 =?us-ascii?q?py0liR+Cp7UOLI2YgKw+uZ3geeSzjzllOhvd3ploBeYjESGHGyySzlBI5Xe61z?=
 =?us-ascii?q?cpwHCWaoI82r2Np+g4ThVGJf9F6mH1kGwtOmeQKOb1zh2g1dzUQWoX29lSq41T?=
 =?us-ascii?q?B0iCwprqyE0SzKwuTicgcHO2FRSGlji1fsPZa7j9QAUEe0aAgpkQOv5VzmyKhD?=
 =?us-ascii?q?uKR/M27TTF9KfyfsNWFiUaiwtr2Yb85U8pwosiZXUOW6YV+ETL7wuB8a0yLlH2?=
 =?us-ascii?q?tDyzE3bTCqupPlnxNkjGKRNmp8rH3cecto3xfQ+MTcReJN3joBXCR5iSPYBl+m?=
 =?us-ascii?q?M9mr/NWUkYzOsuS/V2KnS51SfjPnzYKGtCun+2JqBQezkOy0mt3iCQI6yzP018?=
 =?us-ascii?q?F2VSXUqxbxeorr2L67Me59fkloGUXz68x1GoxlloswhZcQ2WUVh5mP/HoHl3vz?=
 =?us-ascii?q?Pstf2a7kcHUNQjsLycbP4Af5wE1jMm6Jx4XhW3WYw8thZMO1bnkY2y0j9MBKFL?=
 =?us-ascii?q?mb7KZfkiRruFq4ohncYfx8njcb1Psv52QWg+APuAox0CqdBqoeElVfPSzpjx6I?=
 =?us-ascii?q?9cyxrL1LZGazdri9zFZ+ndekDL2YowBTQnD5eoo5HS9r78VyK1bM0Hz16oH5d9?=
 =?us-ascii?q?jcd9MTthuIkxjei+hZMo4+lv0PhSB/I2LyoWUly/InjRxpxZy1p5KIK2Jp/KKk?=
 =?us-ascii?q?GBJYMiD1atgX+jHsi6Zeg8mX05quHpVnBjUEQp/oQei0HzIVsPTtLxyOHyEkqn?=
 =?us-ascii?q?eHBbrfGheS6EV8oHLKDZ+rLGubJGUDwdVhWRmdJ1FfgAYOUzUhhZM5EgGqxMr8?=
 =?us-ascii?q?cEZ2/DwR51j4qgdSxeJsLRXwTmDfpAKwYDcuVJefNAZW7h1F50rNMc2e6f9zHz?=
 =?us-ascii?q?hF/pK7qgyBMHebZwNODWEGQUGEA1HjPr+z5djP6eSYB+y+L+fQbrWKs+BRS/CI?=
 =?us-ascii?q?xZe32It84zmMLtmPPmVlD/Aj2kpMQ3F5G8famzUOUSAXlDjNb8mUpBii4C13s9?=
 =?us-ascii?q?u//e/vWALu44uPFrRTPc9u+xCwnaeMKeqQiDxlJjZf05MG3WXIx6QH3F4OlyFu?=
 =?us-ascii?q?cCGgHq4dtSHWVqLfhK9WAwQfayNyL8ZI66M83g9QOc/UkN/117h4juIrBFdBT1?=
 =?us-ascii?q?DuhsapZckSKWGnKFzHHFqLNKiBJTDT38H3YKa8RadMg+lOqxKwuSiUE0n4MzSH?=
 =?us-ascii?q?ljnpUQ2vMO5WgCGaOhxepJ+ychJ3BWf/S9LmbwWxMMVrgj0u3b00mnTKOHYcMD?=
 =?us-ascii?q?dmdUNNq7yQ7SVAjfR+G2xO9HxlLeafliad7unYLIsWsPRxDiR1keJa/Go1y79P?=
 =?us-ascii?q?4C5YQ/x1nXiaktk7hVipm6G01yBqSxpNtzNCnsqxsEFmOO2N8JBPUDDf4QgA9m?=
 =?us-ascii?q?WTFhEDvZ1/B9nruohAy9zOkrK1IzBHpZac98wGBtOSItiKInslNR3vMDTTCxcB?=
 =?us-ascii?q?TDjtPmbawwRYkeiP+3nTtJErrJHosJAJTaNfVVpzHfQfWWp/G9lXGpByVzIi2Y?=
 =?us-ascii?q?aWls8F/zLqth7UTcRc+IjKTPOfG93gLT+Yif9PYB5ekuCwFpgaKoCugx8qUVJ9?=
 =?us-ascii?q?homfXhOIBd0=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ADAADFrhxch0O0hNFkGQEBAQEBAQEBA?=
 =?us-ascii?q?QEBAQcBAQEBAQGBUQQBAQEBAQsBAYJogQInjBZfimg1gg0UaI1KiRkUgWMPAQE?=
 =?us-ascii?q?YAxABhECCbiI0CQ0BAwEBAQEBAQIBEwEBAQgNCQgpIwxCAQ4BBgGBYSkBgmcBA?=
 =?us-ascii?q?gMBAhcBDBMGARsdAQMCCQEBBQUYCSUDDAUNAhEBBQELFwEJCQWDHQGBaAEDFQQ?=
 =?us-ascii?q?BmmQ8jBUWBQEXgncFhEYKGScNXoE3AgYSixGBHIFXP4ERgl01gleBbxUOAUODD?=
 =?us-ascii?q?YImAok5CAoJDYV7gVKPXTMHAoIlBIQmQoNFg12DJyQKAoFUTYdNN4cuiVCGDYo?=
 =?us-ascii?q?PBgIJBw8hgSWCDjMaI4M8CYISCQMXEoM4hUKFEj8yAYEEAQEhgTaHKYJMgkwBA?=
 =?us-ascii?q?Q?=
X-IPAS-Result: =?us-ascii?q?A0ADAADFrhxch0O0hNFkGQEBAQEBAQEBAQEBAQcBAQEBAQG?=
 =?us-ascii?q?BUQQBAQEBAQsBAYJogQInjBZfimg1gg0UaI1KiRkUgWMPAQEYAxABhECCbiI0C?=
 =?us-ascii?q?Q0BAwEBAQEBAQIBEwEBAQgNCQgpIwxCAQ4BBgGBYSkBgmcBAgMBAhcBDBMGARs?=
 =?us-ascii?q?dAQMCCQEBBQUYCSUDDAUNAhEBBQELFwEJCQWDHQGBaAEDFQQBmmQ8jBUWBQEXg?=
 =?us-ascii?q?ncFhEYKGScNXoE3AgYSixGBHIFXP4ERgl01gleBbxUOAUODDYImAok5CAoJDYV?=
 =?us-ascii?q?7gVKPXTMHAoIlBIQmQoNFg12DJyQKAoFUTYdNN4cuiVCGDYoPBgIJBw8hgSWCD?=
 =?us-ascii?q?jMaI4M8CYISCQMXEoM4hUKFEj8yAYEEAQEhgTaHKYJMgkwBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,380,1539673200"; 
   d="scan'208";a="44960633"
X-Amp-Result: UNSCANNABLE
X-Amp-File-Uploaded: False
Unscannable: 2
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 21 Dec 2018 01:18:02 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1731591AbeLUJR7 (ORCPT <rfc822;like.xu@linux.intel.com>
        + 22 others); Fri, 21 Dec 2018 04:17:59 -0500
Received: from mail-wr1-f68.google.com ([209.85.221.68]:32924 "EHLO
        mail-wr1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1725860AbeLUJR7 (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 21 Dec 2018 04:17:59 -0500
Received: by mail-wr1-f68.google.com with SMTP id c14so4452808wrr.0
        for <linux-kernel@vger.kernel.org>; Fri, 21 Dec 2018 01:17:55 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:date:to:cc:subject:message-id:references:mime-version
         :content-disposition:in-reply-to:user-agent;
        bh=T443h+nWQpHD9R5egT+lnMLmdVDnr/36GuiQXpa859E=;
        b=mzid8bqsvqlGktow8wfJzzImvDeWqoV/zrh793N45H8If+qjRY+EqwxmRAof39fuLo
         AGN1WBiHH88dCe8rW1B/9uZl96iuV5agAdW9gzj516WhoF+UHabkTLU5Kyl7ahUtmv1a
         h3IzaUtUo6DyCqPrVDgtXBvgaDBUVFdOa2/VCiv5nPjnaXQ0E5KKuaNGqFWv5PKiPIS4
         /xFSP5ZQLijv9muRqmRHm355mqrxTUnYWZZODyDkUYCnHOE5CoTDdA5S2DdeyntqWYaS
         fGM4L3+8f5Qm1vjcvSJzbdql/Z9sbo6PniKp0mwUTj99pqu4KrVA7ZjnajYgrLuZdtuY
         rTLg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:date:to:cc:subject:message-id:references
         :mime-version:content-disposition:in-reply-to:user-agent;
        bh=T443h+nWQpHD9R5egT+lnMLmdVDnr/36GuiQXpa859E=;
        b=tBQogNyCNwdlyQ/iGrYIerUwzilhLZ049trQ28ZMdI4z4wUPzGkL+uRyWdsBwWYrGd
         ZfF7Cwngd/eUf5u2bVk3QMt/25xDkL/+64Qa7AVC8vn0IsWLTZC6GFD5ipExiLc8mGXq
         r1vfmmK0v54I8g8S2IcGKixm3LPcaly2FpvUqGVLZRHq5rI9LM8KTQIzdGlSq6ES5NE4
         poxDegXEJXS0Qp1kwaOy1+xr+uhQRgTX5ev1IHW3P0tDuyWNTbGmMNEWOPnM1xMpGxQr
         1vk5EAa53G7jcWjEW4rFp0giXqzyd+y3FNVMQashITUMnOTZ+jnyQYqzdqpshX5aeS72
         NwxA==
X-Gm-Message-State: AJcUukdbO6EYvci2HRKdPO1aH3EZnxmVBkTt5am8Z/fYNsST6xtSefaC
        +mde1Zd/fQUI4rQ2eJU60hE=
X-Google-Smtp-Source: ALg8bN7/QRwbZQwrNSGyDkMXczT8dZR5iqYmKUSGq5eYJtX558+dVw+auGh8eP7cPwE0jPU4OJ8gHA==
X-Received: by 2002:a5d:49cd:: with SMTP id t13mr1732290wrs.144.1545383873974;
        Fri, 21 Dec 2018 01:17:53 -0800 (PST)
Received: from hp-probook-450 (162.206.70.37.rev.sfr.net. [37.70.206.162])
        by smtp.gmail.com with ESMTPSA id k135sm16559408wmd.42.2018.12.21.01.17.52
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Fri, 21 Dec 2018 01:17:52 -0800 (PST)
From: Romain Perier <romain.perier@gmail.com>
X-Google-Original-From: Romain Perier <gmailemailhere>
Date: Fri, 21 Dec 2018 10:17:50 +0100
To: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>,
        boris.brezillon@bootlin.com, miquel.raynal@bootlin.com
Cc: linux-mtd@lists.infradead.org, peterpandong@micron.com,
        linux-kernel@vger.kernel.org
Subject: Re: [LINUX PATCH v12] mtd: rawnand: pl353: Add basic driver for arm
 pl353 smc nand interface
Message-ID: <20181221091750.GA19470@hp-probook-450>
References: <1533620414-3332-1-git-send-email-naga.sureshkumar.relli@xilinx.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <1533620414-3332-1-git-send-email-naga.sureshkumar.relli@xilinx.com>
User-Agent: Mutt/1.10.1 (2018-07-13)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Hello,

I have rebased this patch onto 4.19.11. I use it on a Zynq7000-based
board with a NAND chip Micron MT29F4G08ABADAH4, since ~2 weeks now.
The only problem I have to report is that when I boot with an unchanged
driver on my board, I get the following logs:

[    1.988797] nand: device found, Manufacturer ID: 0x2c, Chip ID: 0xdc
[    1.995184] nand: Micron MT29F4G08ABADAH4
[    1.999187] nand: 512 MiB, SLC, erase size: 128 KiB, page size: 2048, OOB size: 64
[    2.402661] nand: timeout while waiting for chip to become ready
[    2.408665] nand: timing mode 5 not acknowledged by the NAND chip
[    2.416251] Bad block table not found for chip 0
[    2.422278] Bad block table not found for chip 0
[    2.426903] Scanning device for bad blocks
[    2.431024] Bad eraseblock 0 at 0x000000000000
[    2.435509] Bad eraseblock 1 at 0x000000020000
[    2.439978] Bad eraseblock 2 at 0x000000040000
[    2.444465] Bad eraseblock 3 at 0x000000060000
[    2.448936] Bad eraseblock 4 at 0x000000080000
[    2.453423] Bad eraseblock 5 at 0x0000000a0000
[    2.457893] Bad eraseblock 6 at 0x0000000c0000
[    2.462354] Bad eraseblock 7 at 0x0000000e0000
[    2.466841] Bad eraseblock 8 at 0x000000100000
[    2.471304] Bad eraseblock 9 at 0x000000120000
[    2.475793] Bad eraseblock 10 at 0x000000140000
[    2.480349] Bad eraseblock 11 at 0x000000160000

[...]


After investigation, it seems that during the nand_scan phase, the NAND
subsystem tests different timing modes on the NAND chip (mode 0 seems to be
apply during reset, and then it tries to detect the best mode supported by the
NAND chip). Only the mode 0 works here, trying the use the mode 5 resuls in an
error (as you can see in the log) and a bad BBT detection. Both modes are
supported by the NAND chip. In order to fix this, I had to put the nfc timing
into the device node of the nfc, inside the DT (that's not a real fix, ihmo).
Except this, everything is working as expected. Everything is stable with correct
performances.

If I can provide more informations, feel free to ask.


On Tue, Aug 07, 2018 at 11:10:14AM +0530, Naga Sureshkumar Relli wrote:
> Add driver for arm pl353 static memory controller nand interface with
> HW ECC support. This controller is used in Xilinx Zynq SoC for
> interfacing the NAND flash memory.
> 
> Signed-off-by: Naga Sureshkumar Relli <naga.sureshkumar.relli@xilinx.com>
Tested-by: Romain Perier <romain.perier@gmail.com>

> ---
> Changes in v12:
>  - Rebased the driver on top of v4.19 nand tree
>  - Removed nand_scan_ident() and nand_scan_tail(), and added nand_controller_ops
>    with ->attach_chip() and used nand_scan() instead.
>  - Renamed pl353_nand_info structure to pl353_nand_controller
>  - Renamed nand_base and nandaddr in pl353_nand_controller to 'regs' and 'buf_addr'
>  - Added new API pl353_wait_for_ecc_done() to wait for ecc done and call it from
>    pl353_nand_write_page_hwecc() and pl353_nand_read_page_hwecc()
>  - Defined new macro for max ECC blocks
>  - Added return value check for ecc.calculate()
>  - Renamed pl353_nand_cmd_function() to pl353_nand_exec_op_cmd()
>  - Added x16 bus-width support
>  - The dependent driver pl353-smc is already reviewed and hence dropped the
>    smc driver
> Changes in v11:
>  - Removed Documentation patch and added the required info in driver as
>    per Boris comments.
>  - Removed unwanted variables from pl353_nand_info as per Miquel comments
>  - Removed IO_ADDR_R/W.
>  - Replaced onhot() with hweight32()
>  - Defined macros for static values in function pl353_nand_correct_data()
>  - Removed all unnecessary delays
>  - Used nand_wait_ready() where ever is required
>  - Modifed the pl353_setup_data_interface() logic as per Miquel comments.
>  - Taken array instead of 7 values in pl353_setup_data_interface() and pass
>    it to smc driver.
>  - Added check to collect the return value of mtd_device_register().
> Changes in 10:
>  - Typos correction like nand to NAND and soc to SOC etc..
>  - Defined macros for the values in pl353_nand_calculate_hwecc()
>  - Modifed ecc_status from int to char in pl353_nand_calculate_hwecc()
>  - Changed the return type form int to bool to the function
>    onehot()
>  - Removed udelay(1000) in pl353_cmd_function, as it is not required
>  - Dropped ecc->hwctl = NULL in pl353_ecc_init()
>  - Added an error message in pl353_ecc_init(), when there is no matching
>    oobsize
>  - Changed the variable from xnand to xnfc
>  - Added logic to get mtd->name from DT, if it is specified in DT
> Changes in v9:
>  - Addressed the below comments given by Miquel
>  - instead of using pl353_nand_write32, use directly writel_relaxed
>  - Fixed check patch warnings
>  - Renamed write_buf/read_buf to write_data_op/read_data_op
>  - use BIT macro instead of 1 << nr
>  - Use NAND_ROW_ADDR_3 flag
>  - Use nand_wait_ready()
>  - Removed swecc functions
>  - Use address cycles as per size, instead of reading it from Parameter page
>  - Instead of writing too many patterns, use optional property
> Changes in v8:
>  - Added exec_op() implementation
>  - Fixed the below v7 review comments
>  - removed mtd_info from pl353_nand_info struct
>  - Corrected ecc layout offsets
>  - Added on-die ecc support
> Changes in v7:
>  - Currently not implemented the memclk rate adjustments. I will
>    look into this later and once the basic driver is accepted.
>  - Fixed GPL licence ident
> Changes in v6:
>  - Fixed the checkpatch.pl reported warnings
>  - Using the address cycles information from the onfi param page
>    earlier it is hardcoded to 5 in driver
> Changes in v5:
>  - Configure the nand timing parameters as per the onfi spec Changes in v4:
>  - Updated the driver to sync with pl353_smc driver APIs
> Changes in v3:
>  - implemented the proper error codes
>  - further breakdown this patch to multiple sets
>  - added the controller and driver details to Documentation section
>  - updated the licenece to GPLv2
>  - reorganized the pl353_nand_ecc_init function
> Changes in v2:
>  - use "depends on" rather than "select" option in kconfig
>  - remove unused variable parts
> ---
>  drivers/mtd/nand/raw/Kconfig      |    8 +
>  drivers/mtd/nand/raw/Makefile     |    1 +
>  drivers/mtd/nand/raw/pl353_nand.c | 1398 +++++++++++++++++++++++++++++++++++++
>  3 files changed, 1407 insertions(+)
>  create mode 100644 drivers/mtd/nand/raw/pl353_nand.c
> 
> diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
> index b6738ec..e87591e 100644
> --- a/drivers/mtd/nand/raw/Kconfig
> +++ b/drivers/mtd/nand/raw/Kconfig
> @@ -560,4 +560,12 @@ config MTD_NAND_TEGRA
>  	  is supported. Extra OOB bytes when using HW ECC are currently
>  	  not supported.
>  
> +config MTD_NAND_PL353
> +	tristate "ARM Pl353 NAND flash driver"
> +	depends on MTD_NAND && ARM
> +	depends on PL353_SMC
> +	help
> +	  Enables support for PrimeCell Static Memory Controller PL353.
> +
> +
>  endif # MTD_NAND
> diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
> index d5a5f98..dc5c332 100644
> --- a/drivers/mtd/nand/raw/Makefile
> +++ b/drivers/mtd/nand/raw/Makefile
> @@ -57,6 +57,7 @@ obj-$(CONFIG_MTD_NAND_BRCMNAND)		+= brcmnand/
>  obj-$(CONFIG_MTD_NAND_QCOM)		+= qcom_nandc.o
>  obj-$(CONFIG_MTD_NAND_MTK)		+= mtk_ecc.o mtk_nand.o
>  obj-$(CONFIG_MTD_NAND_TEGRA)		+= tegra_nand.o
> +obj-$(CONFIG_MTD_NAND_PL353)		+= pl353_nand.o
>  
>  nand-objs := nand_base.o nand_bbt.o nand_timings.o nand_ids.o
>  nand-objs += nand_amd.o
> diff --git a/drivers/mtd/nand/raw/pl353_nand.c b/drivers/mtd/nand/raw/pl353_nand.c
> new file mode 100644
> index 0000000..73c6655
> --- /dev/null
> +++ b/drivers/mtd/nand/raw/pl353_nand.c
> @@ -0,0 +1,1398 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * ARM PL353 NAND flash controller driver
> + *
> + * Copyright (C) 2017 Xilinx, Inc
> + * Author: Punnaiah chowdary kalluri <punnaiah@xilinx.com>
> + * Author: Naga Sureshkumar Relli <nagasure@xilinx.com>
> + *
> + */
> +
> +#include <linux/err.h>
> +#include <linux/delay.h>
> +#include <linux/interrupt.h>
> +#include <linux/io.h>
> +#include <linux/ioport.h>
> +#include <linux/irq.h>
> +#include <linux/module.h>
> +#include <linux/moduleparam.h>
> +#include <linux/mtd/mtd.h>
> +#include <linux/mtd/rawnand.h>
> +#include <linux/mtd/nand_ecc.h>
> +#include <linux/mtd/partitions.h>
> +#include <linux/of_address.h>
> +#include <linux/of_device.h>
> +#include <linux/of_platform.h>
> +#include <linux/platform_device.h>
> +#include <linux/slab.h>
> +#include <linux/pl353-smc.h>
> +#include <linux/clk.h>
> +
> +#define PL353_NAND_DRIVER_NAME "pl353-nand"
> +
> +/* NAND flash driver defines */
> +#define PL353_NAND_CMD_PHASE	1	/* End command valid in command phase */
> +#define PL353_NAND_DATA_PHASE	2	/* End command valid in data phase */
> +#define PL353_NAND_ECC_SIZE	512	/* Size of data for ECC operation */
> +
> +/* Flash memory controller operating parameters */
> +
> +#define PL353_NAND_ECC_CONFIG	(BIT(4)  |	/* ECC read at end of page */ \
> +				 (0 << 5))	/* No Jumping */
> +
> +/* AXI Address definitions */
> +#define START_CMD_SHIFT		3
> +#define END_CMD_SHIFT		11
> +#define END_CMD_VALID_SHIFT	20
> +#define ADDR_CYCLES_SHIFT	21
> +#define CLEAR_CS_SHIFT		21
> +#define ECC_LAST_SHIFT		10
> +#define COMMAND_PHASE		(0 << 19)
> +#define DATA_PHASE		BIT(19)
> +
> +#define PL353_NAND_ECC_LAST	BIT(ECC_LAST_SHIFT)	/* Set ECC_Last */
> +#define PL353_NAND_CLEAR_CS	BIT(CLEAR_CS_SHIFT)	/* Clear chip select */
> +
> +#define ONDIE_ECC_FEATURE_ADDR	0x90
> +#define PL353_NAND_ECC_BUSY_TIMEOUT	(1 * HZ)
> +#define PL353_NAND_DEV_BUSY_TIMEOUT	(1 * HZ)
> +#define PL353_NAND_LAST_TRANSFER_LENGTH	4
> +#define PL353_NAND_ECC_VALID_SHIFT	24
> +#define PL353_NAND_ECC_VALID_MASK	0x40
> +#define PL353_ECC_BITS_BYTEOFF_MASK	0x1FF
> +#define PL353_ECC_BITS_BITOFF_MASK	0x7
> +#define PL353_ECC_BIT_MASK		0xFFF
> +#define PL353_TREA_MAX_VALUE		1
> +#define PL353_MAX_ECC_CHUNKS		4
> +#define PL353_MAX_ECC_BYTES		3
> +
> +struct pl353_nfc_op {
> +	u32 cmnds[4];
> +	u32 end_cmd;
> +	u32 addrs;
> +	u32 len;
> +	u32 naddrs;
> +	u32 addr5;
> +	u32 addr6;
> +	unsigned int data_instr_idx;
> +	unsigned int rdy_timeout_ms;
> +	unsigned int rdy_delay_ns;
> +	unsigned int cle_ale_delay_ns;
> +	const struct nand_op_instr *data_instr;
> +};
> +
> +/**
> + * struct pl353_nand_controller - Defines the NAND flash controller driver
> + *				  instance
> + * @chip:		NAND chip information structure
> + * @dev:		Parent device (used to print error messages)
> + * @regs:		Virtual address of the NAND flash device
> + * @buf_addr:		Virtual address of the NAND flash device for
> + *			data read/writes
> + * @addr_cycles:	Address cycles
> + * @mclk:		Memory controller clock
> + * @buswidth:		Bus width 8 or 16
> + */
> +struct pl353_nand_controller {
> +	struct nand_chip chip;
> +	struct device *dev;
> +	void __iomem *regs;
> +	void __iomem *buf_addr;
> +	u8 addr_cycles;
> +	struct clk *mclk;
> +	u32 buswidth;
> +};
> +
> +static int pl353_ecc_ooblayout16_ecc(struct mtd_info *mtd, int section,
> +				     struct mtd_oob_region *oobregion)
> +{
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +
> +	if (section >= chip->ecc.steps)
> +		return -ERANGE;
> +
> +	oobregion->offset = (section * chip->ecc.bytes);
> +	oobregion->length = chip->ecc.bytes;
> +
> +	return 0;
> +}
> +
> +static int pl353_ecc_ooblayout16_free(struct mtd_info *mtd, int section,
> +				      struct mtd_oob_region *oobregion)
> +{
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +
> +	if (section >= chip->ecc.steps)
> +		return -ERANGE;
> +
> +	oobregion->offset = (section * chip->ecc.bytes) + 8;
> +	oobregion->length = 8;
> +
> +	return 0;
> +}
> +
> +static const struct mtd_ooblayout_ops pl353_ecc_ooblayout16_ops = {
> +	.ecc = pl353_ecc_ooblayout16_ecc,
> +	.free = pl353_ecc_ooblayout16_free,
> +};
> +
> +static int pl353_ecc_ooblayout64_ecc(struct mtd_info *mtd, int section,
> +				     struct mtd_oob_region *oobregion)
> +{
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +
> +	if (section >= chip->ecc.steps)
> +		return -ERANGE;
> +
> +	oobregion->offset = (section * chip->ecc.bytes) + 52;
> +	oobregion->length = chip->ecc.bytes;
> +
> +	return 0;
> +}
> +
> +static int pl353_ecc_ooblayout64_free(struct mtd_info *mtd, int section,
> +				      struct mtd_oob_region *oobregion)
> +{
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +
> +	if (section)
> +		return -ERANGE;
> +
> +	if (section >= chip->ecc.steps)
> +		return -ERANGE;
> +
> +	oobregion->offset = (section * chip->ecc.bytes) + 2;
> +	oobregion->length = 50;
> +
> +	return 0;
> +}
> +
> +static const struct mtd_ooblayout_ops pl353_ecc_ooblayout64_ops = {
> +	.ecc = pl353_ecc_ooblayout64_ecc,
> +	.free = pl353_ecc_ooblayout64_free,
> +};
> +
> +/* Generic flash bbt decriptors */
> +static u8 bbt_pattern[] = { 'B', 'b', 't', '0' };
> +static u8 mirror_pattern[] = { '1', 't', 'b', 'B' };
> +
> +static struct nand_bbt_descr bbt_main_descr = {
> +	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
> +		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
> +	.offs = 4,
> +	.len = 4,
> +	.veroffs = 20,
> +	.maxblocks = 4,
> +	.pattern = bbt_pattern
> +};
> +
> +static struct nand_bbt_descr bbt_mirror_descr = {
> +	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
> +		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
> +	.offs = 4,
> +	.len = 4,
> +	.veroffs = 20,
> +	.maxblocks = 4,
> +	.pattern = mirror_pattern
> +};
> +
> +static void pl353_nfc_force_byte_access(struct nand_chip *chip,
> +					  bool force_8bit)
> +{
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +
> +	if (xnfc->buswidth == 8)
> +		return;
> +
> +	if (force_8bit)
> +		pl353_smc_set_buswidth(PL353_SMC_MEM_WIDTH_8);
> +	else
> +		pl353_smc_set_buswidth(PL353_SMC_MEM_WIDTH_16);
> +}
> +
> +/**
> + * pl353_nand_read_data_op - read chip data into buffer
> + * @chip:	Pointer to the NAND chip info structure
> + * @in:		Pointer to the buffer to store read data
> + * @len:	Number of bytes to read
> + * @force_8bit:	Force 8-bit bus access
> + * Return:	Always return zero
> + */
> +static int pl353_nand_read_data_op(struct nand_chip *chip,
> +				   u8 *in,
> +				   unsigned int len, bool force_8bit)
> +{
> +	int i;
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +
> +	if (force_8bit)
> +		pl353_nfc_force_byte_access(chip, true);
> +
> +	if ((IS_ALIGNED((uint32_t)in, sizeof(uint32_t)) &&
> +	    IS_ALIGNED(len, sizeof(uint32_t))) || (!force_8bit)) {
> +		u32 *ptr = (u32 *)in;
> +
> +		len /= 4;
> +		for (i = 0; i < len; i++)
> +			ptr[i] = readl(xnfc->buf_addr);
> +	} else {
> +		for (i = 0; i < len; i++)
> +			in[i] = readb(xnfc->buf_addr);
> +	}
> +	if (force_8bit)
> +		pl353_nfc_force_byte_access(chip, false);
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_write_buf - write buffer to chip
> + * @mtd:	Pointer to the mtd info structure
> + * @buf:	Pointer to the buffer to store write data
> + * @len:	Number of bytes to write
> + * @force_8bit:	Force 8-bit bus access
> + */
> +static void pl353_nand_write_data_op(struct mtd_info *mtd, const u8 *buf,
> +				     int len, bool force_8bit)
> +{
> +	int i;
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +
> +	if (force_8bit)
> +		pl353_nfc_force_byte_access(chip, true);
> +
> +	if ((IS_ALIGNED((uint32_t)buf, sizeof(uint32_t)) &&
> +	    IS_ALIGNED(len, sizeof(uint32_t))) || (!force_8bit)) {
> +		u32 *ptr = (u32 *)buf;
> +
> +		len /= 4;
> +		for (i = 0; i < len; i++)
> +			writel(ptr[i], xnfc->buf_addr);
> +	} else {
> +		for (i = 0; i < len; i++)
> +			writeb(buf[i], xnfc->buf_addr);
> +	}
> +	if (force_8bit)
> +		pl353_nfc_force_byte_access(chip, false);
> +}
> +
> +static int pl353_wait_for_ecc_done(void)
> +{
> +	unsigned long timeout = jiffies + PL353_NAND_ECC_BUSY_TIMEOUT;
> +
> +	do {
> +		if (pl353_smc_ecc_is_busy())
> +			cpu_relax();
> +		else
> +			break;
> +	} while (!time_after_eq(jiffies, timeout));
> +
> +	if (time_after_eq(jiffies, timeout)) {
> +		pr_err("%s timed out\n", __func__);
> +		return -ETIMEDOUT;
> +	}
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_calculate_hwecc - Calculate Hardware ECC
> + * @mtd:	Pointer to the mtd_info structure
> + * @data:	Pointer to the page data
> + * @ecc:	Pointer to the ECC buffer where ECC data needs to be stored
> + *
> + * This function retrieves the Hardware ECC data from the controller and returns
> + * ECC data back to the MTD subsystem.
> + * It operates on a number of 512 byte blocks of NAND memory and can be
> + * programmed to store the ECC codes after the data in memory. For writes,
> + * the ECC is written to the spare area of the page. For reads, the result of
> + * a block ECC check are made available to the device driver.
> + *
> + * ------------------------------------------------------------------------
> + * |               n * 512 blocks                  | extra  | ecc    |     |
> + * |                                               | block  | codes  |     |
> + * ------------------------------------------------------------------------
> + *
> + * The ECC calculation uses a simple Hamming code, using 1-bit correction 2-bit
> + * detection. It starts when a valid read or write command with a 512 byte
> + * aligned address is detected on the memory interface.
> + *
> + * Return:	0 on success or error value on failure
> + */
> +static int pl353_nand_calculate_hwecc(struct mtd_info *mtd,
> +				      const u8 *data, u8 *ecc)
> +{
> +	u32 ecc_value;
> +	u8 chunk, ecc_byte, ecc_status;
> +
> +	for (chunk = 0; chunk < PL353_MAX_ECC_CHUNKS; chunk++) {
> +		/* Read ECC value for each block */
> +		ecc_value = pl353_smc_get_ecc_val(chunk);
> +		ecc_status = (ecc_value >> PL353_NAND_ECC_VALID_SHIFT);
> +
> +		/* ECC value valid */
> +		if (ecc_status & PL353_NAND_ECC_VALID_MASK) {
> +			for (ecc_byte = 0; ecc_byte < PL353_MAX_ECC_BYTES;
> +			     ecc_byte++) {
> +				/* Copy ECC bytes to MTD buffer */
> +				*ecc = ~ecc_value & 0xFF;
> +				ecc_value = ecc_value >> 8;
> +				ecc++;
> +			}
> +		} else {
> +			pr_warn("%s status failed\n", __func__);
> +			return -1;
> +		}
> +	}
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_correct_data - ECC correction function
> + * @mtd:	Pointer to the mtd_info structure
> + * @buf:	Pointer to the page data
> + * @read_ecc:	Pointer to the ECC value read from spare data area
> + * @calc_ecc:	Pointer to the calculated ECC value
> + *
> + * This function corrects the ECC single bit errors & detects 2-bit errors.
> + *
> + * Return:	0 if no ECC errors found
> + *		1 if single bit error found and corrected.
> + *		-1 if multiple uncorrectable ECC errors found.
> + */
> +static int pl353_nand_correct_data(struct mtd_info *mtd, unsigned char *buf,
> +				   unsigned char *read_ecc,
> +				   unsigned char *calc_ecc)
> +{
> +	unsigned char bit_addr;
> +	unsigned int byte_addr;
> +	unsigned short ecc_odd, ecc_even, read_ecc_lower, read_ecc_upper;
> +	unsigned short calc_ecc_lower, calc_ecc_upper;
> +
> +	read_ecc_lower = (read_ecc[0] | (read_ecc[1] << 8)) &
> +			  PL353_ECC_BIT_MASK;
> +	read_ecc_upper = ((read_ecc[1] >> 4) | (read_ecc[2] << 4)) &
> +			  PL353_ECC_BIT_MASK;
> +
> +	calc_ecc_lower = (calc_ecc[0] | (calc_ecc[1] << 8)) &
> +			  PL353_ECC_BIT_MASK;
> +	calc_ecc_upper = ((calc_ecc[1] >> 4) | (calc_ecc[2] << 4)) &
> +			  PL353_ECC_BIT_MASK;
> +
> +	ecc_odd = read_ecc_lower ^ calc_ecc_lower;
> +	ecc_even = read_ecc_upper ^ calc_ecc_upper;
> +
> +	/* no error */
> +	if (!ecc_odd && !ecc_even)
> +		return 0;
> +
> +	if (ecc_odd == (~ecc_even & PL353_ECC_BIT_MASK)) {
> +		/* bits [11:3] of error code is byte offset */
> +		byte_addr = (ecc_odd >> 3) & PL353_ECC_BITS_BYTEOFF_MASK;
> +		/* bits [2:0] of error code is bit offset */
> +		bit_addr = ecc_odd & PL353_ECC_BITS_BITOFF_MASK;
> +		/* Toggling error bit */
> +		buf[byte_addr] ^= (BIT(bit_addr));
> +		return 1;
> +	}
> +
> +	/* one error in parity */
> +	if (hweight32(ecc_odd | ecc_even) == 1)
> +		return 1;
> +
> +	/* Uncorrectable error */
> +	return -1;
> +}
> +
> +static void pl353_prepare_cmd(struct mtd_info *mtd, struct nand_chip *chip,
> +			      int page, int column, int start_cmd, int end_cmd,
> +			      bool read)
> +{
> +	unsigned long data_phase_addr;
> +	u32 end_cmd_valid = 0;
> +	unsigned long cmd_phase_addr = 0, cmd_phase_data = 0;
> +
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +
> +	end_cmd_valid = read ? 1 : 0;
> +
> +	cmd_phase_addr = (unsigned long __force)xnfc->regs +
> +			 ((xnfc->addr_cycles
> +			 << ADDR_CYCLES_SHIFT) |
> +			 (end_cmd_valid << END_CMD_VALID_SHIFT) |
> +			 (COMMAND_PHASE) |
> +			 (end_cmd << END_CMD_SHIFT) |
> +			 (start_cmd << START_CMD_SHIFT));
> +
> +	/* Get the data phase address */
> +	data_phase_addr = (unsigned long __force)xnfc->regs +
> +			  ((0x0 << CLEAR_CS_SHIFT) |
> +			  (0 << END_CMD_VALID_SHIFT) |
> +			  (DATA_PHASE) |
> +			  (end_cmd << END_CMD_SHIFT) |
> +			  (0x0 << ECC_LAST_SHIFT));
> +
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +
> +	if (chip->options & NAND_BUSWIDTH_16)
> +		column /= 2;
> +	cmd_phase_data = column;
> +	if (mtd->writesize > PL353_NAND_ECC_SIZE) {
> +		cmd_phase_data |= page << 16;
> +		/* Another address cycle for devices > 128MiB */
> +		if (chip->options & NAND_ROW_ADDR_3) {
> +			writel_relaxed(cmd_phase_data,
> +				       (void __iomem * __force)cmd_phase_addr);
> +			cmd_phase_data = (page >> 16);
> +		}
> +	} else {
> +		cmd_phase_data |= page << 8;
> +	}
> +
> +	writel_relaxed(cmd_phase_data, (void __iomem * __force)cmd_phase_addr);
> +}
> +
> +/**
> + * pl353_nand_read_oob - [REPLACEABLE] the most common OOB data read function
> + * @mtd:	Pointer to the mtd_info structure
> + * @chip:	Pointer to the nand_chip structure
> + * @page:	Page number to read
> + *
> + * Return:	Always return zero
> + */
> +static int pl353_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
> +			       int page)
> +{
> +	unsigned long data_phase_addr;
> +	u8 *p;
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long nand_offset = (unsigned long __force)xnfc->regs;
> +
> +	chip->pagebuf = -1;
> +	if (mtd->writesize < PL353_NAND_ECC_SIZE)
> +		return 0;
> +
> +	pl353_prepare_cmd(mtd, chip, page, mtd->writesize, NAND_CMD_READ0,
> +			  NAND_CMD_READSTART, 1);
> +
> +	nand_wait_ready(mtd);
> +
> +	p = chip->oob_poi;
> +	pl353_nand_read_data_op(chip, p,
> +				(mtd->oobsize -
> +				PL353_NAND_LAST_TRANSFER_LENGTH), false);
> +	p += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_CLEAR_CS;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +	pl353_nand_read_data_op(chip, p, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				false);
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_write_oob - [REPLACEABLE] the most common OOB data write function
> + * @mtd:	Pointer to the mtd info structure
> + * @chip:	Pointer to the NAND chip info structure
> + * @page:	Page number to write
> + *
> + * Return:	Zero on success and EIO on failure
> + */
> +static int pl353_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
> +				int page)
> +{
> +	const u8 *buf = chip->oob_poi;
> +	unsigned long data_phase_addr;
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long nand_offset = (unsigned long __force)xnfc->regs;
> +	u32 addrcycles = 0;
> +
> +	chip->pagebuf = -1;
> +	addrcycles = xnfc->addr_cycles;
> +	pl353_prepare_cmd(mtd, chip, page, mtd->writesize, NAND_CMD_SEQIN,
> +			  NAND_CMD_PAGEPROG, 0);
> +
> +	pl353_nand_write_data_op(mtd, buf,
> +				 (mtd->oobsize -
> +				 PL353_NAND_LAST_TRANSFER_LENGTH), false);
> +	buf += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_CLEAR_CS;
> +	data_phase_addr |= (1 << END_CMD_VALID_SHIFT);
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +	pl353_nand_write_data_op(mtd, buf, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				 false);
> +	nand_wait_ready(mtd);
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_read_page_raw - [Intern] read raw page data without ecc
> + * @mtd:		Pointer to the mtd info structure
> + * @chip:		Pointer to the NAND chip info structure
> + * @buf:		Pointer to the data buffer
> + * @oob_required:	Caller requires OOB data read to chip->oob_poi
> + * @page:		Page number to read
> + *
> + * Return:	Always return zero
> + */
> +static int pl353_nand_read_page_raw(struct mtd_info *mtd,
> +				    struct nand_chip *chip,
> +				    u8 *buf, int oob_required, int page)
> +{
> +	unsigned long data_phase_addr;
> +	u8 *p;
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long nand_offset = (unsigned long __force)xnfc->regs;
> +
> +	pl353_prepare_cmd(mtd, chip, page, 0, NAND_CMD_READ0,
> +		  NAND_CMD_READSTART, 1);
> +	nand_wait_ready(mtd);
> +	pl353_nand_read_data_op(chip, buf, mtd->writesize, false);
> +	p = chip->oob_poi;
> +	pl353_nand_read_data_op(chip, p,
> +				(mtd->oobsize -
> +				PL353_NAND_LAST_TRANSFER_LENGTH), false);
> +	p += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_CLEAR_CS;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +
> +	pl353_nand_read_data_op(chip, p, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				false);
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_write_page_raw - [Intern] raw page write function
> + * @mtd:		Pointer to the mtd info structure
> + * @chip:		Pointer to the NAND chip info structure
> + * @buf:		Pointer to the data buffer
> + * @oob_required:	Caller requires OOB data read to chip->oob_poi
> + * @page:		Page number to write
> + *
> + * Return:	Always return zero
> + */
> +static int pl353_nand_write_page_raw(struct mtd_info *mtd,
> +				     struct nand_chip *chip,
> +				     const u8 *buf, int oob_required,
> +				     int page)
> +{
> +	unsigned long data_phase_addr;
> +	u8 *p;
> +
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long nand_offset = (unsigned long __force)xnfc->regs;
> +
> +	pl353_prepare_cmd(mtd, chip, page, 0, NAND_CMD_SEQIN,
> +			  NAND_CMD_PAGEPROG, 0);
> +	pl353_nand_write_data_op(mtd, buf, mtd->writesize, false);
> +	p = chip->oob_poi;
> +	pl353_nand_write_data_op(mtd, p,
> +				 (mtd->oobsize -
> +				 PL353_NAND_LAST_TRANSFER_LENGTH), false);
> +	p += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_CLEAR_CS;
> +	data_phase_addr |= (1 << END_CMD_VALID_SHIFT);
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +	pl353_nand_write_data_op(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				 false);
> +
> +	return 0;
> +}
> +
> +/**
> + * nand_write_page_hwecc - Hardware ECC based page write function
> + * @mtd:		Pointer to the mtd info structure
> + * @chip:		Pointer to the NAND chip info structure
> + * @buf:		Pointer to the data buffer
> + * @oob_required:	Caller requires OOB data read to chip->oob_poi
> + * @page:		Page number to write
> + *
> + * This functions writes data and hardware generated ECC values in to the page.
> + *
> + * Return:	Always return zero
> + */
> +static int pl353_nand_write_page_hwecc(struct mtd_info *mtd,
> +				       struct nand_chip *chip,
> +				       const u8 *buf, int oob_required,
> +				       int page)
> +{
> +	int eccsize = chip->ecc.size;
> +	int eccsteps = chip->ecc.steps;
> +	u8 *ecc_calc = chip->ecc.calc_buf;
> +	u8 *oob_ptr;
> +	const u8 *p = buf;
> +	u32 ret;
> +	unsigned long data_phase_addr;
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long nand_offset = (unsigned long __force)xnfc->regs;
> +
> +	pl353_prepare_cmd(mtd, chip, page, 0, NAND_CMD_SEQIN,
> +			  NAND_CMD_PAGEPROG, 0);
> +
> +	for ( ; (eccsteps - 1); eccsteps--) {
> +		pl353_nand_write_data_op(mtd, p, eccsize, false);
> +		p += eccsize;
> +	}
> +	pl353_nand_write_data_op(mtd, p,
> +				 (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH),
> +				 false);
> +	p += (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +
> +	/* Set ECC Last bit to 1 */
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_ECC_LAST;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +	pl353_nand_write_data_op(mtd, p, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				 false);
> +
> +	/* Wait till the ECC operation is complete or timeout */
> +	ret = pl353_wait_for_ecc_done();
> +	if (ret)
> +		dev_err(xnfc->dev, "ECC Timeout\n");
> +	p = buf;
> +	ret = chip->ecc.calculate(mtd, p, &ecc_calc[0]);
> +	if (ret)
> +		return ret;
> +
> +	/* Wait for ECC to be calculated and read the error values */
> +	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi,
> +					 0, chip->ecc.total);
> +	if (ret)
> +		return ret;
> +	/* Clear ECC last bit */
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr &= ~PL353_NAND_ECC_LAST;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +
> +	/* Write the spare area with ECC bytes */
> +	oob_ptr = chip->oob_poi;
> +	pl353_nand_write_data_op(mtd, oob_ptr,
> +				 (mtd->oobsize -
> +				 PL353_NAND_LAST_TRANSFER_LENGTH), false);
> +
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_CLEAR_CS;
> +	data_phase_addr |= (1 << END_CMD_VALID_SHIFT);
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +	oob_ptr += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +	pl353_nand_write_data_op(mtd, oob_ptr, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				 false);
> +	nand_wait_ready(mtd);
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_read_page_hwecc - Hardware ECC based page read function
> + * @mtd:		Pointer to the mtd info structure
> + * @chip:		Pointer to the NAND chip info structure
> + * @buf:		Pointer to the buffer to store read data
> + * @oob_required:	Caller requires OOB data read to chip->oob_poi
> + * @page:		Page number to read
> + *
> + * This functions reads data and checks the data integrity by comparing
> + * hardware generated ECC values and read ECC values from spare area.
> + * There is a limitation in SMC controller, that we must set ECC LAST on
> + * last data phase access, to tell ECC block not to expect any data further.
> + * Ex:  When number of ECC STEPS are 4, then till 3 we will write to flash
> + * using SMC with HW ECC enabled. And for the last ECC STEP, we will subtract
> + * 4bytes from page size, and will initiate a transfer. And the remaining 4 as
> + * one more transfer with ECC_LAST bit set in NAND data phase register to
> + * notify ECC block not to expect any more data. The last block should be align
> + * with end of 512 byte block. Because of this limitation, we are not using
> + * core routines.
> + *
> + * Return:	0 always and updates ECC operation status in to MTD structure
> + */
> +static int pl353_nand_read_page_hwecc(struct mtd_info *mtd,
> +				      struct nand_chip *chip,
> +				      u8 *buf, int oob_required, int page)
> +{
> +	int i, stat, eccsize = chip->ecc.size;
> +	int eccbytes = chip->ecc.bytes;
> +	int eccsteps = chip->ecc.steps;
> +	u8 *p = buf;
> +	u8 *ecc_calc = chip->ecc.calc_buf;
> +	u8 *ecc = chip->ecc.code_buf;
> +	unsigned int max_bitflips = 0;
> +	u8 *oob_ptr;
> +	u32 ret;
> +	unsigned long data_phase_addr;
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long nand_offset = (unsigned long __force)xnfc->regs;
> +
> +	pl353_prepare_cmd(mtd, chip, page, 0, NAND_CMD_READ0,
> +			  NAND_CMD_READSTART, 1);
> +	nand_wait_ready(mtd);
> +
> +	for ( ; (eccsteps - 1); eccsteps--) {
> +		pl353_nand_read_data_op(chip, p, eccsize, false);
> +		p += eccsize;
> +	}
> +	pl353_nand_read_data_op(chip, p,
> +				(eccsize - PL353_NAND_LAST_TRANSFER_LENGTH),
> +				false);
> +	p += (eccsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +
> +	/* Set ECC Last bit to 1 */
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_ECC_LAST;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +	pl353_nand_read_data_op(chip, p, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				false);
> +
> +	/* Wait till the ECC operation is complete or timeout */
> +	ret = pl353_wait_for_ecc_done();
> +	if (ret)
> +		dev_err(xnfc->dev, "ECC Timeout\n");
> +
> +	/* Read the calculated ECC value */
> +	p = buf;
> +	ret = chip->ecc.calculate(mtd, p, &ecc_calc[0]);
> +	if (ret)
> +		return ret;
> +
> +	/* Clear ECC last bit */
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr &= ~PL353_NAND_ECC_LAST;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +
> +	/* Read the stored ECC value */
> +	oob_ptr = chip->oob_poi;
> +	pl353_nand_read_data_op(chip, oob_ptr,
> +				(mtd->oobsize -
> +				PL353_NAND_LAST_TRANSFER_LENGTH), false);
> +
> +	/* de-assert chip select */
> +	data_phase_addr = (unsigned long __force)xnfc->buf_addr;
> +	data_phase_addr -= nand_offset;
> +	data_phase_addr |= PL353_NAND_CLEAR_CS;
> +	data_phase_addr += nand_offset;
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +
> +	oob_ptr += (mtd->oobsize - PL353_NAND_LAST_TRANSFER_LENGTH);
> +	pl353_nand_read_data_op(chip, oob_ptr, PL353_NAND_LAST_TRANSFER_LENGTH,
> +				false);
> +
> +	ret = mtd_ooblayout_get_eccbytes(mtd, ecc, chip->oob_poi, 0,
> +					 chip->ecc.total);
> +	if (ret)
> +		return ret;
> +
> +	eccsteps = chip->ecc.steps;
> +	p = buf;
> +
> +	/* Check ECC error for all blocks and correct if it is correctable */
> +	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
> +		stat = chip->ecc.correct(mtd, p, &ecc[i], &ecc_calc[i]);
> +		if (stat < 0) {
> +			mtd->ecc_stats.failed++;
> +		} else {
> +			mtd->ecc_stats.corrected += stat;
> +			max_bitflips = max_t(unsigned int, max_bitflips, stat);
> +		}
> +	}
> +
> +	return max_bitflips;
> +}
> +
> +/**
> + * pl353_nand_select_chip - Select the flash device
> + * @mtd:	Pointer to the mtd info structure
> + * @chip:	Pointer to the NAND chip info structure
> + *
> + * This function is empty as the NAND controller handles chip select line
> + * internally based on the chip address passed in command and data phase.
> + */
> +static void pl353_nand_select_chip(struct mtd_info *mtd, int chip)
> +{
> +}
> +
> +/* NAND framework ->exec_op() hooks and related helpers */
> +static void pl353_nfc_parse_instructions(struct nand_chip *chip,
> +					 const struct nand_subop *subop,
> +					 struct pl353_nfc_op *nfc_op)
> +{
> +	const struct nand_op_instr *instr = NULL;
> +	unsigned int op_id, offset, naddrs;
> +	int i, len;
> +	const u8 *addrs;
> +
> +	memset(nfc_op, 0, sizeof(struct pl353_nfc_op));
> +	for (op_id = 0; op_id < subop->ninstrs; op_id++) {
> +		nfc_op->len = nand_subop_get_data_len(subop, op_id);
> +		len = nand_subop_get_data_len(subop, op_id);
> +		instr = &subop->instrs[op_id];
> +
> +		switch (instr->type) {
> +		case NAND_OP_CMD_INSTR:
> +			if (op_id)
> +				nfc_op->cmnds[1] = instr->ctx.cmd.opcode;
> +			else
> +				nfc_op->cmnds[0] = instr->ctx.cmd.opcode;
> +			nfc_op->cle_ale_delay_ns = instr->delay_ns;
> +			break;
> +
> +		case NAND_OP_ADDR_INSTR:
> +			offset = nand_subop_get_addr_start_off(subop, op_id);
> +			naddrs = nand_subop_get_num_addr_cyc(subop, op_id);
> +			addrs = &instr->ctx.addr.addrs[offset];
> +			nfc_op->addrs = instr->ctx.addr.addrs[offset];
> +			for (i = 0; i < min_t(unsigned int, 4, naddrs); i++) {
> +				nfc_op->addrs |= instr->ctx.addr.addrs[i] <<
> +						 (8 * i);
> +			}
> +
> +			if (naddrs >= 5)
> +				nfc_op->addr5 = addrs[4];
> +			if (naddrs >= 6)
> +				nfc_op->addr6 = addrs[5];
> +			nfc_op->naddrs = nand_subop_get_num_addr_cyc(subop,
> +								     op_id);
> +			nfc_op->cle_ale_delay_ns = instr->delay_ns;
> +			break;
> +
> +		case NAND_OP_DATA_IN_INSTR:
> +			nfc_op->data_instr = instr;
> +			nfc_op->data_instr_idx = op_id;
> +			break;
> +
> +		case NAND_OP_DATA_OUT_INSTR:
> +			nfc_op->data_instr = instr;
> +			nfc_op->data_instr_idx = op_id;
> +			break;
> +
> +		case NAND_OP_WAITRDY_INSTR:
> +			nfc_op->rdy_timeout_ms = instr->ctx.waitrdy.timeout_ms;
> +			nfc_op->rdy_delay_ns = instr->delay_ns;
> +			break;
> +		}
> +	}
> +}
> +
> +static void cond_delay(unsigned int ns)
> +{
> +	if (!ns)
> +		return;
> +
> +	if (ns < 10000)
> +		ndelay(ns);
> +	else
> +		udelay(DIV_ROUND_UP(ns, 1000));
> +}
> +
> +/**
> + * pl353_nand_exec_op_cmd - Send command to NAND device
> + * @chip:	Pointer to the NAND chip info structure
> + * @subop:	Pointer to array of instructions
> + * Return:	Always return zero
> + */
> +static int pl353_nand_exec_op_cmd(struct nand_chip *chip,
> +				   const struct nand_subop *subop)
> +{
> +	struct mtd_info *mtd = nand_to_mtd(chip);
> +	const struct nand_op_instr *instr;
> +	struct pl353_nfc_op nfc_op = {};
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	unsigned long cmd_phase_data = 0, end_cmd_valid = 0;
> +	unsigned long cmd_phase_addr, data_phase_addr, end_cmd;
> +	unsigned int op_id, len, offset;
> +	bool reading;
> +
> +	pl353_nfc_parse_instructions(chip, subop, &nfc_op);
> +	instr = nfc_op.data_instr;
> +	op_id = nfc_op.data_instr_idx;
> +	len = nand_subop_get_data_len(subop, op_id);
> +	offset = nand_subop_get_data_start_off(subop, op_id);
> +
> +	pl353_smc_clr_nand_int();
> +	/* Get the command phase address */
> +	if (nfc_op.cmnds[1] != 0) {
> +		if (nfc_op.cmnds[0] == NAND_CMD_SEQIN)
> +			end_cmd_valid = 0;
> +		else
> +			end_cmd_valid = 1;
> +		end_cmd = nfc_op.cmnds[1];
> +	}  else {
> +		end_cmd = 0x0;
> +	}
> +
> +	/*
> +	 * The SMC defines two phases of commands when transferring data to or
> +	 * from NAND flash.
> +	 * Command phase: Commands and optional address information are written
> +	 * to the NAND flash.The command and address can be associated with
> +	 * either a data phase operation to write to or read from the array,
> +	 * or a status/ID register transfer.
> +	 * Data phase: Data is either written to or read from the NAND flash.
> +	 * This data can be either data transferred to or from the array,
> +	 * or status/ID register information.
> +	 */
> +	cmd_phase_addr = (unsigned long __force)xnfc->regs +
> +			 ((nfc_op.naddrs << ADDR_CYCLES_SHIFT) |
> +			 (end_cmd_valid << END_CMD_VALID_SHIFT) |
> +			 (COMMAND_PHASE) |
> +			 (end_cmd << END_CMD_SHIFT) |
> +			 (nfc_op.cmnds[0] << START_CMD_SHIFT));
> +
> +	/* Get the data phase address */
> +	end_cmd_valid = 0;
> +
> +	data_phase_addr = (unsigned long __force)xnfc->regs +
> +			  ((0x0 << CLEAR_CS_SHIFT) |
> +			  (end_cmd_valid << END_CMD_VALID_SHIFT) |
> +			  (DATA_PHASE) |
> +			  (end_cmd << END_CMD_SHIFT) |
> +			  (0x0 << ECC_LAST_SHIFT));
> +	xnfc->buf_addr = (void __iomem * __force)data_phase_addr;
> +
> +	/* Command phase AXI Read & Write */
> +	if (nfc_op.naddrs >= 5) {
> +		if (mtd->writesize > PL353_NAND_ECC_SIZE) {
> +			cmd_phase_data = nfc_op.addrs;
> +			/* Another address cycle for devices > 128MiB */
> +			if (chip->options & NAND_ROW_ADDR_3) {
> +				writel_relaxed(cmd_phase_data,
> +					       (void __iomem * __force)
> +					       cmd_phase_addr);
> +				cmd_phase_data = nfc_op.addr5;
> +				if (nfc_op.naddrs >= 6)
> +					cmd_phase_data |= (nfc_op.addr6 << 8);
> +			}
> +		}
> +	}  else {
> +		if (nfc_op.addrs != -1) {
> +			int column = nfc_op.addrs;
> +			/*
> +			 * Change read/write column, read id etc
> +			 * Adjust columns for 16 bit bus width
> +			 */
> +			if ((chip->options & NAND_BUSWIDTH_16) &&
> +			    (nfc_op.cmnds[0] == NAND_CMD_READ0 ||
> +				nfc_op.cmnds[0] == NAND_CMD_SEQIN ||
> +				nfc_op.cmnds[0] == NAND_CMD_RNDOUT ||
> +				nfc_op.cmnds[0] == NAND_CMD_RNDIN)) {
> +				column >>= 1;
> +			}
> +			cmd_phase_data = column;
> +		}
> +	}
> +	writel_relaxed(cmd_phase_data, (void __iomem * __force)cmd_phase_addr);
> +
> +	if (!nfc_op.data_instr) {
> +		if (nfc_op.rdy_timeout_ms)
> +			nand_wait_ready(mtd);
> +		return 0;
> +	}
> +
> +	reading = (nfc_op.data_instr->type == NAND_OP_DATA_IN_INSTR);
> +	if (!reading) {
> +		pl353_nand_write_data_op(mtd, instr->ctx.data.buf.out,
> +					 len, instr->ctx.data.force_8bit);
> +		if (nfc_op.rdy_timeout_ms)
> +			nand_wait_ready(mtd);
> +		cond_delay(nfc_op.rdy_delay_ns);
> +	}
> +	if (reading) {
> +		cond_delay(nfc_op.rdy_delay_ns);
> +		if (nfc_op.rdy_timeout_ms)
> +			nand_wait_ready(mtd);
> +		pl353_nand_read_data_op(chip, instr->ctx.data.buf.in, len,
> +					instr->ctx.data.force_8bit);
> +	}
> +
> +	return 0;
> +}
> +
> +static const struct nand_op_parser pl353_nfc_op_parser = NAND_OP_PARSER
> +	(NAND_OP_PARSER_PATTERN
> +		(pl353_nand_exec_op_cmd,
> +		NAND_OP_PARSER_PAT_CMD_ELEM(true),
> +		NAND_OP_PARSER_PAT_ADDR_ELEM(true, 7),
> +		NAND_OP_PARSER_PAT_WAITRDY_ELEM(true),
> +		NAND_OP_PARSER_PAT_DATA_IN_ELEM(false, 2048)),
> +	NAND_OP_PARSER_PATTERN
> +		(pl353_nand_exec_op_cmd,
> +		NAND_OP_PARSER_PAT_CMD_ELEM(false),
> +		NAND_OP_PARSER_PAT_ADDR_ELEM(false, 7),
> +		NAND_OP_PARSER_PAT_CMD_ELEM(false),
> +		NAND_OP_PARSER_PAT_WAITRDY_ELEM(false),
> +		NAND_OP_PARSER_PAT_DATA_IN_ELEM(false, 2048)),
> +	NAND_OP_PARSER_PATTERN
> +		(pl353_nand_exec_op_cmd,
> +		NAND_OP_PARSER_PAT_CMD_ELEM(false),
> +		NAND_OP_PARSER_PAT_ADDR_ELEM(true, 7),
> +		NAND_OP_PARSER_PAT_CMD_ELEM(true),
> +		NAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),
> +	NAND_OP_PARSER_PATTERN
> +		(pl353_nand_exec_op_cmd,
> +		NAND_OP_PARSER_PAT_CMD_ELEM(false),
> +		NAND_OP_PARSER_PAT_ADDR_ELEM(false, 8),
> +		NAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, 2048),
> +		NAND_OP_PARSER_PAT_CMD_ELEM(true),
> +		NAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),
> +	NAND_OP_PARSER_PATTERN
> +		(pl353_nand_exec_op_cmd,
> +		NAND_OP_PARSER_PAT_CMD_ELEM(false)),
> +	);
> +
> +static int pl353_nfc_exec_op(struct nand_chip *chip,
> +			     const struct nand_operation *op,
> +			     bool check_only)
> +{
> +	return nand_op_parser_exec_op(chip, &pl353_nfc_op_parser,
> +					      op, check_only);
> +}
> +
> +/**
> + * pl353_nand_device_ready - Check device ready/busy line
> + * @mtd:	Pointer to the mtd_info structure
> + *
> + * Return:	0 on busy or 1 on ready state
> + */
> +static int pl353_nand_device_ready(struct mtd_info *mtd)
> +{
> +	if (pl353_smc_get_nand_int_status_raw()) {
> +		pl353_smc_clr_nand_int();
> +		return 1;
> +	}
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_ecc_init - Initialize the ecc information as per the ecc mode
> + * @mtd:	Pointer to the mtd_info structure
> + * @ecc:	Pointer to ECC control structure
> + * @ecc_mode:	ondie ecc status
> + *
> + * This function initializes the ecc block and functional pointers as per the
> + * ecc mode
> + *
> + * Return:	0 on success or negative errno.
> + */
> +static int pl353_nand_ecc_init(struct mtd_info *mtd, struct nand_ecc_ctrl *ecc,
> +				int ecc_mode)
> +{
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	int err = 0;
> +
> +	ecc->write_page_raw = pl353_nand_write_page_raw;
> +	ecc->read_page_raw = pl353_nand_read_page_raw;
> +	ecc->read_oob = pl353_nand_read_oob;
> +	ecc->write_oob = pl353_nand_write_oob;
> +
> +	if (ecc_mode == NAND_ECC_ON_DIE) {
> +		pl353_smc_set_ecc_mode(PL353_SMC_ECCMODE_BYPASS);
> +		/*
> +		 * On-Die ECC spare bytes offset 8 is used for ECC codes
> +		 * Use the BBT pattern descriptors
> +		 */
> +		chip->bbt_td = &bbt_main_descr;
> +		chip->bbt_md = &bbt_mirror_descr;
> +	} else {
> +
> +		ecc->mode = NAND_ECC_HW;
> +		/* Hardware ECC generates 3 bytes ECC code for each 512 bytes */
> +		ecc->bytes = 3;
> +		ecc->strength = 1;
> +		ecc->calculate = pl353_nand_calculate_hwecc;
> +		ecc->correct = pl353_nand_correct_data;
> +		ecc->read_page = pl353_nand_read_page_hwecc;
> +		ecc->size = PL353_NAND_ECC_SIZE;
> +		ecc->read_page = pl353_nand_read_page_hwecc;
> +		ecc->write_page = pl353_nand_write_page_hwecc;
> +		pl353_smc_set_ecc_pg_size(mtd->writesize);
> +		switch (mtd->writesize) {
> +		case SZ_512:
> +		case SZ_1K:
> +		case SZ_2K:
> +			pl353_smc_set_ecc_mode(PL353_SMC_ECCMODE_APB);
> +			break;
> +		default:
> +			ecc->calculate = nand_calculate_ecc;
> +			ecc->correct = nand_correct_data;
> +			ecc->size = 256;
> +			break;
> +		}
> +
> +		if (mtd->oobsize == 16) {
> +			mtd_set_ooblayout(mtd, &pl353_ecc_ooblayout16_ops);
> +		} else if (mtd->oobsize == 64) {
> +			mtd_set_ooblayout(mtd, &pl353_ecc_ooblayout64_ops);
> +		} else {
> +			err = -ENXIO;
> +			dev_err(xnfc->dev, "Unsupported oob Layout\n");
> +		}
> +	}
> +
> +	return err;
> +}
> +
> +static int pl353_setup_data_interface(struct mtd_info *mtd, int csline,
> +				       const struct nand_data_interface *conf)
> +{
> +	struct nand_chip *chip = mtd_to_nand(mtd);
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	const struct nand_sdr_timings *sdr;
> +	u32 timings[7], mckperiodps;
> +
> +	if (csline == NAND_DATA_IFACE_CHECK_ONLY)
> +		return 0;
> +
> +	sdr = nand_get_sdr_timings(conf);
> +	if (IS_ERR(sdr))
> +		return PTR_ERR(sdr);
> +
> +	/*
> +	 * SDR timings are given in pico-seconds while NFC timings must be
> +	 * expressed in NAND controller clock cycles.
> +	 */
> +	mckperiodps = NSEC_PER_SEC / clk_get_rate(xnfc->mclk);
> +	mckperiodps *= 1000;
> +	if (sdr->tRC_min <= 20000)
> +		/*
> +		 * PL353 SMC needs one extra read cycle in SDR Mode 5
> +		 * This is not written anywhere in the datasheet but
> +		 * the results observed during testing.
> +		 */
> +		timings[0] = DIV_ROUND_UP(sdr->tRC_min, mckperiodps) + 1;
> +	else
> +		timings[0] = DIV_ROUND_UP(sdr->tRC_min, mckperiodps);
> +
> +	timings[1] = DIV_ROUND_UP(sdr->tWC_min, mckperiodps);
> +	/*
> +	 * For all SDR modes, PL353 SMC needs tREA max value as 1,
> +	 * Results observed during testing.
> +	 */
> +	timings[2] = PL353_TREA_MAX_VALUE;
> +	timings[3] = DIV_ROUND_UP(sdr->tWP_min, mckperiodps);
> +	timings[4] = DIV_ROUND_UP(sdr->tCLR_min, mckperiodps);
> +	timings[5] = DIV_ROUND_UP(sdr->tAR_min, mckperiodps);
> +	timings[6] = DIV_ROUND_UP(sdr->tRR_min, mckperiodps);
> +	pl353_smc_set_cycles(timings);
> +
> +	return 0;
> +}

If I hack this function in order to limit the timings only to mode 0,
everything works. Otherwise it hangs when it tries to apply mode 5.


> +
> +static int pl353_nand_attach_chip(struct nand_chip *chip)
> +{
> +	struct mtd_info *mtd = nand_to_mtd(chip);
> +	struct pl353_nand_controller *xnfc =
> +		container_of(chip, struct pl353_nand_controller, chip);
> +	u32 ret;
> +
> +	if (chip->options & NAND_BUSWIDTH_16)
> +		pl353_smc_set_buswidth(PL353_SMC_MEM_WIDTH_16);
> +
> +	if (mtd->writesize <= SZ_512)
> +		xnfc->addr_cycles = 1;
> +	else
> +		xnfc->addr_cycles = 2;
> +
> +	if (chip->options & NAND_ROW_ADDR_3)
> +		xnfc->addr_cycles += 3;
> +	else
> +		xnfc->addr_cycles += 2;
> +
> +	ret = pl353_nand_ecc_init(mtd, &chip->ecc, chip->ecc.mode);
> +	if (ret) {
> +		dev_err(xnfc->dev, "ECC init failed\n");
> +		return ret;
> +	}
> +
> +	if (!mtd->name) {
> +		/*
> +		 * If the new bindings are used and the bootloader has not been
> +		 * updated to pass a new mtdparts parameter on the cmdline, you
> +		 * should define the following property in your NAND node, ie:
> +		 *
> +		 *	label = "pl353-nand";
> +		 *
> +		 * This way, mtd->name will be set by the core when
> +		 * nand_set_flash_node() is called.
> +		 */
> +		mtd->name = devm_kasprintf(xnfc->dev, GFP_KERNEL,
> +					   "%s", PL353_NAND_DRIVER_NAME);
> +		if (!mtd->name) {
> +			dev_err(xnfc->dev, "Failed to allocate mtd->name\n");
> +			return -ENOMEM;
> +		}
> +	}
> +
> +	return 0;
> +
> +}
> +
> +static const struct nand_controller_ops pl353_nand_controller_ops = {
> +	.attach_chip = pl353_nand_attach_chip,
> +};
> +
> +/**
> + * pl353_nand_probe - Probe method for the NAND driver
> + * @pdev:	Pointer to the platform_device structure
> + *
> + * This function initializes the driver data structures and the hardware.
> + * The NAND driver has dependency with the pl353_smc memory controller
> + * driver for initializing the NAND timing parameters, bus width, ECC modes,
> + * control and status information.
> + *
> + * Return:	0 on success or error value on failure
> + */
> +static int pl353_nand_probe(struct platform_device *pdev)
> +{
> +	struct pl353_nand_controller *xnfc;
> +	struct mtd_info *mtd;
> +	struct nand_chip *chip;
> +	struct resource *res;
> +	struct device_node *np, *dn;
> +	u32 ret, val;
> +
> +	xnfc = devm_kzalloc(&pdev->dev, sizeof(*xnfc), GFP_KERNEL);
> +	if (!xnfc)
> +		return -ENOMEM;
> +	xnfc->dev = &pdev->dev;
> +
> +	/* Map physical address of NAND flash */
> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
> +	xnfc->regs = devm_ioremap_resource(xnfc->dev, res);
> +	if (IS_ERR(xnfc->regs))
> +		return PTR_ERR(xnfc->regs);
> +
> +	chip = &xnfc->chip;
> +	mtd = nand_to_mtd(chip);
> +	chip->exec_op = pl353_nfc_exec_op;
> +	nand_set_controller_data(chip, xnfc);
> +	mtd->priv = chip;
> +	mtd->owner = THIS_MODULE;
> +
> +	nand_set_flash_node(chip, xnfc->dev->of_node);
> +
> +	/* Set the driver entry points for MTD */
> +	chip->dev_ready = pl353_nand_device_ready;
> +	chip->select_chip = pl353_nand_select_chip;
> +	/* If we don't set this delay driver sets 20us by default */
> +	np = of_get_next_parent(xnfc->dev->of_node);
> +	xnfc->mclk = of_clk_get(np, 0);
> +	if (IS_ERR(xnfc->mclk)) {
> +		dev_err(xnfc->dev, "Failed to retrieve MCK clk\n");
> +		return PTR_ERR(xnfc->mclk);
> +	}
> +
> +	dn = nand_get_flash_node(chip);
> +	ret = of_property_read_u32(dn, "nand-bus-width", &val);
> +	if (ret)
> +		val = 8;
> +
> +	xnfc->buswidth = val;
> +	chip->chip_delay = 30;
> +	/* Set the device option and flash width */
> +	chip->options = NAND_BUSWIDTH_AUTO;
> +	chip->bbt_options = NAND_BBT_USE_FLASH;
> +	platform_set_drvdata(pdev, xnfc);
> +	chip->setup_data_interface = pl353_setup_data_interface;
> +	chip->dummy_controller.ops = &pl353_nand_controller_ops;
> +	ret = nand_scan(mtd, 1);
> +	if (ret) {
> +		dev_err(xnfc->dev, "could not scan the nand chip\n");
> +		return ret;
> +	}
> +
> +	ret = mtd_device_register(mtd, NULL, 0);
> +	if (ret) {
> +		dev_err(xnfc->dev, "Failed to register mtd device: %d\n", ret);
> +		nand_cleanup(chip);
> +		return ret;
> +	}
> +
> +	return 0;
> +}
> +
> +/**
> + * pl353_nand_remove - Remove method for the NAND driver
> + * @pdev:	Pointer to the platform_device structure
> + *
> + * This function is called if the driver module is being unloaded. It frees all
> + * resources allocated to the device.
> + *
> + * Return:	0 on success or error value on failure
> + */
> +static int pl353_nand_remove(struct platform_device *pdev)
> +{
> +	struct pl353_nand_controller *xnfc = platform_get_drvdata(pdev);
> +	struct mtd_info *mtd = nand_to_mtd(&xnfc->chip);
> +
> +	/* Release resources, unregister device */
> +	nand_release(mtd);
> +
> +	return 0;
> +}
> +
> +/* Match table for device tree binding */
> +static const struct of_device_id pl353_nand_of_match[] = {
> +	{ .compatible = "arm,pl353-nand-r2p1" },
> +	{},
> +};
> +MODULE_DEVICE_TABLE(of, pl353_nand_of_match);
> +
> +/*
> + * pl353_nand_driver - This structure defines the NAND subsystem platform driver
> + */
> +static struct platform_driver pl353_nand_driver = {
> +	.probe		= pl353_nand_probe,
> +	.remove		= pl353_nand_remove,
> +	.driver		= {
> +		.name	= PL353_NAND_DRIVER_NAME,
> +		.of_match_table = pl353_nand_of_match,
> +	},
> +};
> +
> +module_platform_driver(pl353_nand_driver);
> +
> +MODULE_AUTHOR("Xilinx, Inc.");
> +MODULE_ALIAS("platform:" PL353_NAND_DRIVER_NAME);
> +MODULE_DESCRIPTION("ARM PL353 NAND Flash Driver");
> +MODULE_LICENSE("GPL");
> -- 
> 2.7.4
> 
