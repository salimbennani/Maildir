Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  18 Dec 2018 08:45:08 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga004.fm.intel.com (fmsmga004.fm.intel.com [10.253.24.48])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 4132D5805CF;
	Mon, 17 Dec 2018 06:47:30 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by fmsmga004-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 17 Dec 2018 06:47:28 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ANodWQhDxuI6JN4sqxdH4UyQJP3N1i/DPJgcQr6Af?=
 =?us-ascii?q?oPdwSP78oM6wAkXT6L1XgUPTWs2DsrQY07qQ6/iocFdDyK7JiGoFfp1IWk1Nou?=
 =?us-ascii?q?QttCtkPvS4D1bmJuXhdS0wEZcKflZk+3amLRodQ56mNBXdrXKo8DEdBAj0OxZr?=
 =?us-ascii?q?KeTpAI7SiNm82/yv95HJbAhEmDmwbaluIBmqsA7cqtQYjYx+J6gr1xDHuGFIe+?=
 =?us-ascii?q?NYxWNpIVKcgRPx7dqu8ZBg7ipdpesv+9ZPXqvmcas4S6dYDCk9PGAu+MLrrxjD?=
 =?us-ascii?q?QhCR6XYaT24bjwBHAwnB7BH9Q5fxri73vfdz1SWGIcH7S60/VC+85Kl3VhDnlC?=
 =?us-ascii?q?YHNyY48G7JjMxwkLlbqw+lqxBm3oLYfJ2ZOP94c6jAf90VWHBBU95RWSJfH428?=
 =?us-ascii?q?c4UBAekPPelaronyu1QAohSlBQm0Bu7i0SNIhmbq0aEmz+gtDR/K0Qo9FNwOqn?=
 =?us-ascii?q?TUq9D1Ob8QX++vyqnD0DTMb+5L0jr66IjHaBYhreuDXLJtasfRz0YuFxvfglqM?=
 =?us-ascii?q?rozlOiqY2+IQuGaV6OpgUPigi28hqwxpuTev28kshpPIhoITzF3P6CZ3wJ4tKN?=
 =?us-ascii?q?GmVEJ2ZcSoHIZeui2ELYd6X8AvT31ytCs7yLAKoZ+2cScQxJg6xxPSaeaLf5aH?=
 =?us-ascii?q?7x79TuqdPyl0iGx9dLKxmRm/8lSsx+j5W8S1zVlHrClIn9zOu30P0xHf9s2KR/?=
 =?us-ascii?q?9z80qg2juC0h3f5fxZLU8uk6fQNoQvzaQqlpUJtETOBi/2l1vyjK+Rbkgk5Oeo?=
 =?us-ascii?q?5Pr9Yrn8pZ+TKZV0igfgPaQqgMC/Bv44MgcWU2ia/+SzyqHj8FXnTLlWivA6iL?=
 =?us-ascii?q?TVvZ7EKcgBu6K0ABNZ3pwi5hu9Fzum1c4XnXgDLFJLYhKHiI3pNknKIPD5C/e/?=
 =?us-ascii?q?nlutnC5ox//YJL3hBIvCLnzanLfmc7d97VBTyBAowNBB6JJbFKsBLOjwWkDvrt?=
 =?us-ascii?q?zYCAE2Mwiuz+bgEtV92ZsSWXiTDa+BLKPSrViI6/orI+mNZ48apizxKvc45/P1?=
 =?us-ascii?q?iX85mFkdfbSm3JcNaXC4GOhmLFudYXb2ntgBFmIKtBIkTOP2kF2CTSJTZ3GqUq?=
 =?us-ascii?q?I8/D47CZ6mAp3ERoy3gLyBwT20HptZZm1dDlCMEHHod5iLWvsWaSKSJNNhnSIA?=
 =?us-ascii?q?VbS7V4Ah0hSuvhfgy7V7NurU5jEYtZX72dh34O3ciws+9T9zD8Sb1WGNSHp5nm?=
 =?us-ascii?q?cJRz8wwaB+rlZxylaF0ahknfNYEcZf6O9OUgc/LZTc1fB1C8juWgLdedeEUEyp?=
 =?us-ascii?q?Qs6mATE2TdI92cUObFx/G9i5ihDD3iyqA6IalrCRBZw09L7c0Gb1J8pn13nG06?=
 =?us-ascii?q?whhUE8QsRTLW2mmrJ/9w/LCo7KiUqZkbymdaAd3CHX8meDwnGDvEVZUA52TKXE?=
 =?us-ascii?q?UmoTZkrQrdTl+EzCS6WiBqggMgtE0cSCMLdFasX1jVVaQ/fuIMnRbHivm2iuHx?=
 =?us-ascii?q?qIxqmDbIzxe2oD2iXRD0wEkwMW/XaCLgU+Aiaho2TDDD1hD17vYkXs8fVgp3O/?=
 =?us-ascii?q?VEM70waKb0h53bqv5hEVneCcS+8U3r8cpSgusSt0E0in09LWEdWAoRFhc7taYd?=
 =?us-ascii?q?4m5FdH1GTZtxFyP5C6LqBigEIefBpzv0/0yxp3DYBAm9AwrHw21ApyNb6Y0FRZ?=
 =?us-ascii?q?ejOE3JDwP7rXKnXy/BGvcaLWxkvS0NGM+qcL6fQ4rVrjsRqtFkoj9XVnztZU32?=
 =?us-ascii?q?Gd5pXMEAodT5bxXlwr+Bh9orHQejM96J/M1X1wLam0tSfP1MgtBOQ7xRevYdde?=
 =?us-ascii?q?PLmfGw/vDsIVHc6uKO8tm1i3dR8EOOFS9KgpP8KpbfeG2airPPp+kzKil2hI/I?=
 =?us-ascii?q?d90keU/SpmVuHIx4oFw+2f3gafVzb8kU2tvdztlYFFZTEdBGy/ySf/CY5VZ61y?=
 =?us-ascii?q?e5sLCGi0L822wNV+m4DiW3pC+FG/AFMG3dejeQCOYFzlwQ1QyUMXrGS9mSu50z?=
 =?us-ascii?q?N7iSspobeY3CDUxeTtagAHOm9SSGZ+l1jsJZW7gM4AXEivaQgkjx+l5Uf8x6hG?=
 =?us-ascii?q?q6VzNWjTQUFUfyfoK2FuSLe/tr2HY8RX8pMnrT1XUPigYVCdUrP8oxoa3znjHm?=
 =?us-ascii?q?dE3zA7ajeqt479nxx7jmKdMXlyoGDYecF22RfQ+tjcSeRN0ToBQSlykSPXCUSk?=
 =?us-ascii?q?P9m14dWUkI/OsuKkWGK7VZ1Tci7rwZmbtCSh5m1qAhy/n/atld3hCgU61S7719?=
 =?us-ascii?q?93VSTHthr8Y4/r17ikPuJjZEVnGFj8689iEIFkjoQwnI0Q2WQdhpiN/XsIi2Dz?=
 =?us-ascii?q?Pc9Z2aL/anoAXjoLw9/T4Aj410xvNHOJx4TlVnqDxsttfcW1YmQT2igl9cBFFL?=
 =?us-ascii?q?+U7KBYnStyule4rhjeYflnkjcd1Psh8ngag+4StQopzyWdBK0SHEZCMSztkRSI?=
 =?us-ascii?q?886xrKFNaGmzdriw0VJ0ncq9A7GavgFcRHH5d48nHS9x7cVwKkjA0XPt5YH/ZN?=
 =?us-ascii?q?nfc8gTuQaKnBfagOhYM5YxlvsMhSp6NmPxp3wly+gnjRNw2ZG2ppSIK2Jo/Kih?=
 =?us-ascii?q?GB5XKiX1Z98P+jHqlategsGW34W1EpRgADoLWoboTemzEDITrvnnMweOEDshqn?=
 =?us-ascii?q?aUA7bfHAmf6Ft4oHLLCZykK3aXJHwBx9V4WBadPFBfgBwTXDgihZE2DAeqxMj8?=
 =?us-ascii?q?cEtj4jAR+0X1qh9NyuJuKhn+XX3TpAauajcoVpefKABa4R1F50fQKcae9P58Hz?=
 =?us-ascii?q?lE/p29qwyAMm6baB5NDW4XQUyIHUzjMqOt5dnd8OiYG+y+IOHVYbiVrexeVvGI?=
 =?us-ascii?q?xY+g04d8/jaMMNmPMWdmD/EhxkVDWnV5EdzDmzoTUywXiz7Nb8mDqRa8/S13s9?=
 =?us-ascii?q?m/8OnxVwLp/4ePELxSMdNg+x2thaeDNuiQhDt2KDpC15MMw2PIx6Yb3FIIly5u?=
 =?us-ascii?q?cDytG6watSHRVKLQhrNXDxkDZiNzKsRI7qE83gpMOcLBidP1zLl4jvErBFdfSF?=
 =?us-ascii?q?zhgdqkZcgLI2G7KVPGC1yHNLWAJT3X3c73ZbmwRqFXjOVRrxewoyqUE1f/PjSf?=
 =?us-ascii?q?kDnkTwqgMfxXgyGBIhNfuJuxchJsCWX4SNLmaxu7MMJ4jDEswL00gG/KOnAYMT?=
 =?us-ascii?q?Rmb0xNqbiQ5ztCgvpjA2xB8mZlLe6cliaF7unYL4wavudxDitol+JV/nI6xqBR?=
 =?us-ascii?q?7CFFQvx1hSTTosRvo1GgjumA1D5nXABSpTZMgYKBpV9iNrnB9plcRXbE+woA7G?=
 =?us-ascii?q?WKBBQMottlC9vvtLhRy9jPjq3zLjhC/snQ/csdAcjUNc2GPGAgMRrvBD7bEg8F?=
 =?us-ascii?q?QSS3OmHYgkwO2M2Vo0aeroI3r4Di0LQUS7JXWUZ9Qv0AC0lpEcZEO5x3RD4hib?=
 =?us-ascii?q?Czj8kO+WC5ql/dSZMe9trDV/SPEbDqNDqxibhfewBOwLX2N40fO4T3nUt4ZRMy?=
 =?us-ascii?q?yIDLHVfAGNVRrgVlbxQouwNM9nZkR2E+0k6jbRmitjtbX/SzhB8tzAFkbPYs8D?=
 =?us-ascii?q?Pr5X89IV3WoCo21kI2nJ+t1TqWaj/qaq2qUJNXDy7zsWA7NZTnRwdzKwa1mBog?=
 =?us-ascii?q?fH3ARrRMn/57bWFDlgDRo91MFORaQKkCZwUfj7nDY/QuzEQZsT2m7VFI6PGDCp?=
 =?us-ascii?q?Z4kgYuN5m2oCQEkydqdtM2bZLZP7dVhgxVj7iDvWm23/ss3CcRIk8M9CWZfyte?=
 =?us-ascii?q?/AQtP6MlbwCy+fNqoViIgTxEfmkBf/knuPRn8gU6IevWnAz61LsWCkm3f9yCZ/?=
 =?us-ascii?q?eZsm6GhdOgREMokEgPkh8WrvBNzc4/fh/MBAgUx7yLGkFMbJKaJA=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAAAgthdch0O0hNFkGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYEwUGlzBAsnCoc5A4RPiyxKgg0UiQGOQxSBYw8BGAMQAYR?=
 =?us-ascii?q?AAoMUIjQJDQEDAQEBAQEBAgETAQEBCgsJCCkjDII2JAGCYQEBAQEDAQIXAQwTB?=
 =?us-ascii?q?gEBNwEFBgMBAQEBCBEEAQEfEAMeBwodCAIEAQkEBQUDgxoBgWgDFQECAp0lAoo?=
 =?us-ascii?q?KgWwzgnYBAQWBBQGDcw2CFAiMPoFXP4ERRoJMgleBZAskg1CCJokgGgqBdIQXg?=
 =?us-ascii?q?U+Ecoo1Jy8HAg2CG4glgm1wg0iBXYhNhyiJPIEFhQOCGYROgxICBAIEBQINAQE?=
 =?us-ascii?q?FgUaCDnCDPAmCEgkDF4NKhEqFUgE2coEFAQEhiwEPFwOBBQGBHgEB?=
X-IPAS-Result: =?us-ascii?q?A0AEAAAgthdch0O0hNFkGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYEwUGlzBAsnCoc5A4RPiyxKgg0UiQGOQxSBYw8BGAMQAYRAAoMUIjQJDQEDA?=
 =?us-ascii?q?QEBAQEBAgETAQEBCgsJCCkjDII2JAGCYQEBAQEDAQIXAQwTBgEBNwEFBgMBAQE?=
 =?us-ascii?q?BCBEEAQEfEAMeBwodCAIEAQkEBQUDgxoBgWgDFQECAp0lAooKgWwzgnYBAQWBB?=
 =?us-ascii?q?QGDcw2CFAiMPoFXP4ERRoJMgleBZAskg1CCJokgGgqBdIQXgU+Ecoo1Jy8HAg2?=
 =?us-ascii?q?CG4glgm1wg0iBXYhNhyiJPIEFhQOCGYROgxICBAIEBQINAQEFgUaCDnCDPAmCE?=
 =?us-ascii?q?gkDF4NKhEqFUgE2coEFAQEhiwEPFwOBBQGBHgEB?=
X-IronPort-AV: E=Sophos;i="5.56,365,1539673200"; 
   d="scan'208";a="45282359"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 17 Dec 2018 06:47:26 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1733082AbeLQOrX (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Mon, 17 Dec 2018 09:47:23 -0500
Received: from mail-eopbgr60042.outbound.protection.outlook.com ([40.107.6.42]:27360
        "EHLO EUR04-DB3-obe.outbound.protection.outlook.com"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1731785AbeLQOrW (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 17 Dec 2018 09:47:22 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=nxp.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=kgFJLpvxMz4dOyEtUJS9KzZhHx96Ei19IdAHo+cBSi4=;
 b=hY8HKr8r5M8IcY09rxJQMIciYeo8jKe+hcYNNv+D6Pbo46qSfBc2gYp/cJWXE0NO/DzEC2mqeESFW6Rbhhk4EBY+JC3n1J1yVvYzZOOO5kNTRuwrifenAqw7bDraz0XIVDq2824PfYjUOpWFqk8Kb6yAVqcvcuTqtbka7+PUi8c=
Received: from AM6PR04MB4967.eurprd04.prod.outlook.com (20.177.33.210) by
 AM6PR04MB4438.eurprd04.prod.outlook.com (20.177.39.154) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1425.19; Mon, 17 Dec 2018 14:46:50 +0000
Received: from AM6PR04MB4967.eurprd04.prod.outlook.com
 ([fe80::6d78:7790:9368:1d1a]) by AM6PR04MB4967.eurprd04.prod.outlook.com
 ([fe80::6d78:7790:9368:1d1a%3]) with mapi id 15.20.1425.021; Mon, 17 Dec 2018
 14:46:50 +0000
From: Han Xu <han.xu@nxp.com>
To: Schrempf Frieder <frieder.schrempf@kontron.de>,
        "linux-mtd@lists.infradead.org" <linux-mtd@lists.infradead.org>,
        "boris.brezillon@bootlin.com" <boris.brezillon@bootlin.com>,
        "linux-spi@vger.kernel.org" <linux-spi@vger.kernel.org>,
        Marek Vasut <marek.vasut@gmail.com>,
        Mark Brown <broonie@kernel.org>
CC: "dwmw2@infradead.org" <dwmw2@infradead.org>,
        "computersforpeace@gmail.com" <computersforpeace@gmail.com>,
        "richard@nod.at" <richard@nod.at>,
        "miquel.raynal@bootlin.com" <miquel.raynal@bootlin.com>,
        David Wolfe <david.wolfe@nxp.com>,
        Fabio Estevam <fabio.estevam@nxp.com>,
        Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>,
        Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>,
        "shawnguo@kernel.org" <shawnguo@kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: RE: [PATCH v7 3/9] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Topic: [PATCH v7 3/9] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Index: AQHUi9vWkN/m1Yv6j0W7U5OONjiVOqWDFshw
Date: Mon, 17 Dec 2018 14:46:50 +0000
Message-ID: <AM6PR04MB4967A9EC167C971A149EC4B997BC0@AM6PR04MB4967.eurprd04.prod.outlook.com>
References: <1543932685-15011-1-git-send-email-frieder.schrempf@kontron.de>
 <1543932685-15011-4-git-send-email-frieder.schrempf@kontron.de>
In-Reply-To: <1543932685-15011-4-git-send-email-frieder.schrempf@kontron.de>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: spf=none (sender IP is ) smtp.mailfrom=han.xu@nxp.com; 
x-originating-ip: [64.157.242.222]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1;AM6PR04MB4438;6:a5LE8BfQDs99KwXal7WexSqQhmD/lIX2aCJ/H1runMOsYNvU+PNB+i7F7dU3wMb0RHuG1U92HbYu/h29as+nv48zdo56skcAnFSZsgmKWA+CjXnnQ32+FmRtAyl2qbBTMh1auF8wh6mlxZTHa+Xcwpj3KKwlagtWTOBn9zT9pAkJ4YU+nSSTShfrO+b/CFPgaqqGDDz0LU+9gbOHmP6CWgymfStZuO2f2V6dSjn3QSPchhNiom9ZwAzM2z2GdDLcsBSrF4pP0T+KZ/qVgFB4OpzVihRwvEXr22nbUrtLSEBmh6OIEwrFU36QLgz6kddf6iagK7kaEqAGwkmFLAhUZcQ6Dox+mhqie/nn1ENKNw7ChBfG3/34sVhQ0o2Y01Ak3MXeSDQzO7zxRKBnKrvY5KvR+gBRPktQSpfkA8g3jMNxzwuk+Mz64o1OAFEM6Wo4tks+X+oxZSH4bxquSB94Fw==;5:S8N0CmcsyDH8Yz2LwPrhWp6iEDfxOK7ENYSSRlOi0YtQOK+/tM2IXN6VT/+HLnTWV1zPOXJvnisTHb2uDgosNCitFxrQ2hBYmEeI2Pr3TCOhynNVEGg6cgABxahRmQsn/POY9uXiRACfRF2GJqwKoin9qMwIYX27JZCuRHcTURU=;7:ZI8i1lyTCfQ5w/f+xpEU+SRjj19u2nCAiZMuTjDrGz+3edNjrTCepEkk2lXYhr+EGdgV82vW9QmDZpILhxfJQwYg+SIXsA4Y+wV7J83fZNnYaXhLNLPsKumRmzwZiMEavmAKsO//kUIPiWUU+/Dxmg==
x-ms-exchange-antispam-srfa-diagnostics: SOS;
x-ms-office365-filtering-correlation-id: be4f87e8-34a6-40c5-cad3-08d6642e7a86
x-ms-office365-filtering-ht: Tenant
x-microsoft-antispam: BCL:0;PCL:0;RULEID:(2390118)(7020095)(4652040)(8989299)(4534185)(4627221)(201703031133081)(201702281549075)(8990200)(5600074)(711020)(4618075)(2017052603328)(7153060)(7193020);SRVR:AM6PR04MB4438;
x-ms-traffictypediagnostic: AM6PR04MB4438:
x-microsoft-antispam-prvs: <AM6PR04MB44388EEA84BC9D32523E73E697BC0@AM6PR04MB4438.eurprd04.prod.outlook.com>
x-ms-exchange-senderadcheck: 1
x-exchange-antispam-report-cfa-test: BCL:0;PCL:0;RULEID:(8211001083)(3230021)(999002)(6040522)(2401047)(5005006)(8121501046)(10201501046)(3002001)(3231475)(944501520)(52105112)(93006095)(93001095)(6055026)(148016)(149066)(150057)(6041310)(20161123558120)(20161123560045)(20161123564045)(20161123562045)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(201708071742011)(7699051)(76991095);SRVR:AM6PR04MB4438;BCL:0;PCL:0;RULEID:;SRVR:AM6PR04MB4438;
x-forefront-prvs: 08897B549D
x-forefront-antispam-report: SFV:NSPM;SFS:(10009020)(376002)(346002)(136003)(366004)(39860400002)(396003)(189003)(199004)(13464003)(486006)(6246003)(7696005)(478600001)(33656002)(53936002)(14454004)(8676002)(11346002)(81156014)(39060400002)(44832011)(3846002)(8936002)(575784001)(86362001)(446003)(68736007)(81166006)(97736004)(4744004)(2201001)(71200400001)(71190400001)(66066001)(4326008)(476003)(229853002)(316002)(74316002)(55016002)(6116002)(9686003)(7736002)(5660300001)(105586002)(256004)(106356001)(7416002)(102836004)(53946003)(54906003)(6436002)(2501003)(305945005)(6506007)(99286004)(25786009)(26005)(2906002)(110136005)(76176011)(14444005)(186003)(53546011)(579004)(569006);DIR:OUT;SFP:1101;SCL:1;SRVR:AM6PR04MB4438;H:AM6PR04MB4967.eurprd04.prod.outlook.com;FPR:;SPF:None;LANG:en;PTR:InfoNoRecords;MX:1;A:1;
x-microsoft-antispam-message-info: 7GXER99PcSKZUgqXCbmd2ADYogdDoeAgO1qw9OE0CT+pg94CSD2DKIWFBwFzrD9IHxoZ6yDWbfEKqphAVKz2QEmeVyTH8oVv1qld/tSY1bXYd4ehmChq4gj4Adoph9utXS08qRKPUn+k1gS30P+PFylVHh2J10BIl/1pByfPwxm8e86Zp9VC0dAyQ6IIkxWPJSSlEURGaXPhOeI5x6mjrGdQL8tnXj7hrCAyBXZBDJ0vSpYuPgpzJ0XLxrum6TswIEGzgfD1hhklVUfi/IpWWqWamvD19AzL4LqbWl2g/BVvofJ+7XN9fNzGtuMZ/RIM
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-OriginatorOrg: nxp.com
X-MS-Exchange-CrossTenant-Network-Message-Id: be4f87e8-34a6-40c5-cad3-08d6642e7a86
X-MS-Exchange-CrossTenant-originalarrivaltime: 17 Dec 2018 14:46:50.5460
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 686ea1d3-bc2b-4c6f-a92c-d99c5c301635
X-MS-Exchange-Transport-CrossTenantHeadersStamped: AM6PR04MB4438
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org



> -----Original Message-----
> From: Schrempf Frieder <frieder.schrempf@kontron.de>
> Sent: Tuesday, December 4, 2018 8:15 AM
> To: linux-mtd@lists.infradead.org; boris.brezillon@bootlin.com; linux-
> spi@vger.kernel.org; Marek Vasut <marek.vasut@gmail.com>; Mark Brown
> <broonie@kernel.org>; Han Xu <han.xu@nxp.com>
> Cc: dwmw2@infradead.org; computersforpeace@gmail.com;
> richard@nod.at; miquel.raynal@bootlin.com; David Wolfe
> <david.wolfe@nxp.com>; Fabio Estevam <fabio.estevam@nxp.com>;
> Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>; Yogesh Narayan
> Gaur <yogeshnarayan.gaur@nxp.com>; shawnguo@kernel.org; Schrempf
> Frieder <frieder.schrempf@kontron.de>; linux-kernel@vger.kernel.org
> Subject: [PATCH v7 3/9] spi: Add a driver for the Freescale/NXP QuadSPI
> controller
>=20
> From: Frieder Schrempf <frieder.schrempf@kontron.de>
>=20
> This driver is derived from the SPI NOR driver at mtd/spi-nor/fsl-quadspi=
.c. It
> uses the new SPI memory interface of the SPI framework to issue flash
> memory operations to up to four connected flash chips (2 buses with 2 CS
> each).
>=20
> The controller does not support generic SPI messages.
>=20
> This patch also disables the build of the "old" driver and reuses its Kco=
nfig
> option CONFIG_SPI_FSL_QUADSPI to replace it.
>=20
> Signed-off-by: Frieder Schrempf <frieder.schrempf@kontron.de>
> ---
>  drivers/mtd/spi-nor/Kconfig  |   9 -
>  drivers/mtd/spi-nor/Makefile |   1 -
>  drivers/spi/Kconfig          |  11 +
>  drivers/spi/Makefile         |   1 +
>  drivers/spi/spi-fsl-qspi.c   | 966
> ++++++++++++++++++++++++++++++++++++++
>  5 files changed, 978 insertions(+), 10 deletions(-)
>=20
> diff --git a/drivers/mtd/spi-nor/Kconfig b/drivers/mtd/spi-nor/Kconfig in=
dex
> 6cc9c92..d1ca307 100644
> --- a/drivers/mtd/spi-nor/Kconfig
> +++ b/drivers/mtd/spi-nor/Kconfig
> @@ -59,15 +59,6 @@ config SPI_CADENCE_QUADSPI
>  	  device with a Cadence QSPI controller and want to access the
>  	  Flash as an MTD device.
>=20
> -config SPI_FSL_QUADSPI
> -	tristate "Freescale Quad SPI controller"
> -	depends on ARCH_MXC || SOC_LS1021A || ARCH_LAYERSCAPE ||
> COMPILE_TEST
> -	depends on HAS_IOMEM
> -	help
> -	  This enables support for the Quad SPI controller in master mode.
> -	  This controller does not support generic SPI. It only supports
> -	  SPI NOR.
> -
>  config SPI_HISI_SFC
>  	tristate "Hisilicon SPI-NOR Flash Controller(SFC)"
>  	depends on ARCH_HISI || COMPILE_TEST
> diff --git a/drivers/mtd/spi-nor/Makefile b/drivers/mtd/spi-nor/Makefile
> index f4c61d2..3f160c2e3 100644
> --- a/drivers/mtd/spi-nor/Makefile
> +++ b/drivers/mtd/spi-nor/Makefile
> @@ -3,7 +3,6 @@ obj-$(CONFIG_MTD_SPI_NOR)	+=3D spi-nor.o
>  obj-$(CONFIG_SPI_ASPEED_SMC)	+=3D aspeed-smc.o
>  obj-$(CONFIG_SPI_ATMEL_QUADSPI)	+=3D atmel-quadspi.o
>  obj-$(CONFIG_SPI_CADENCE_QUADSPI)	+=3D cadence-quadspi.o
> -obj-$(CONFIG_SPI_FSL_QUADSPI)	+=3D fsl-quadspi.o
>  obj-$(CONFIG_SPI_HISI_SFC)	+=3D hisi-sfc.o
>  obj-$(CONFIG_MTD_MT81xx_NOR)    +=3D mtk-quadspi.o
>  obj-$(CONFIG_SPI_NXP_SPIFI)	+=3D nxp-spifi.o
> diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig index 7d3a5c9..8c8=
4186
> 100644
> --- a/drivers/spi/Kconfig
> +++ b/drivers/spi/Kconfig
> @@ -259,6 +259,17 @@ config SPI_FSL_LPSPI
>  	help
>  	  This enables Freescale i.MX LPSPI controllers in master mode.
>=20
> +config SPI_FSL_QUADSPI
> +	tristate "Freescale QSPI controller"
> +	depends on ARCH_MXC || SOC_LS1021A || ARCH_LAYERSCAPE ||
> COMPILE_TEST
> +	depends on HAS_IOMEM
> +	help
> +	  This enables support for the Quad SPI controller in master mode.
> +	  Up to four flash chips can be connected on two buses with two
> +	  chipselects each.
> +	  This controller does not support generic SPI messages. It only
> +	  supports the high-level SPI memory interface.
> +
>  config SPI_GPIO
>  	tristate "GPIO-based bitbanging SPI Master"
>  	depends on GPIOLIB || COMPILE_TEST
> diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile index
> 3575205..5377e61 100644
> --- a/drivers/spi/Makefile
> +++ b/drivers/spi/Makefile
> @@ -44,6 +44,7 @@ obj-$(CONFIG_SPI_FSL_DSPI)		+=3D spi-fsl-
> dspi.o
>  obj-$(CONFIG_SPI_FSL_LIB)		+=3D spi-fsl-lib.o
>  obj-$(CONFIG_SPI_FSL_ESPI)		+=3D spi-fsl-espi.o
>  obj-$(CONFIG_SPI_FSL_LPSPI)		+=3D spi-fsl-lpspi.o
> +obj-$(CONFIG_SPI_FSL_QUADSPI)		+=3D spi-fsl-qspi.o
>  obj-$(CONFIG_SPI_FSL_SPI)		+=3D spi-fsl-spi.o
>  obj-$(CONFIG_SPI_GPIO)			+=3D spi-gpio.o
>  obj-$(CONFIG_SPI_IMG_SPFI)		+=3D spi-img-spfi.o
> diff --git a/drivers/spi/spi-fsl-qspi.c b/drivers/spi/spi-fsl-qspi.c new =
file mode
> 100644 index 0000000..f0a3400
> --- /dev/null
> +++ b/drivers/spi/spi-fsl-qspi.c
> @@ -0,0 +1,966 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +
> +/*
> + * Freescale QuadSPI driver.
> + *
> + * Copyright (C) 2013 Freescale Semiconductor, Inc.
> + * Copyright (C) 2018 Bootlin
> + * Copyright (C) 2018 exceet electronics GmbH
> + * Copyright (C) 2018 Kontron Electronics GmbH
> + *
> + * Transition to SPI MEM interface:
> + * Authors:
> + *     Boris Brezillion <boris.brezillon@bootlin.com>
> + *     Frieder Schrempf <frieder.schrempf@kontron.de>
> + *     Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
> + *     Suresh Gupta <suresh.gupta@nxp.com>
> + *
> + * Based on the original fsl-quadspi.c spi-nor driver:
> + * Author: Freescale Semiconductor, Inc.
> + *
> + */
> +
> +#include <linux/bitops.h>
> +#include <linux/clk.h>
> +#include <linux/completion.h>
> +#include <linux/delay.h>
> +#include <linux/err.h>
> +#include <linux/errno.h>
> +#include <linux/interrupt.h>
> +#include <linux/io.h>
> +#include <linux/iopoll.h>
> +#include <linux/jiffies.h>
> +#include <linux/kernel.h>
> +#include <linux/module.h>
> +#include <linux/mutex.h>
> +#include <linux/of.h>
> +#include <linux/of_device.h>
> +#include <linux/platform_device.h>
> +#include <linux/pm_qos.h>
> +#include <linux/sizes.h>
> +
> +#include <linux/spi/spi.h>
> +#include <linux/spi/spi-mem.h>
> +
> +/*
> + * The driver only uses one single LUT entry, that is updated on
> + * each call of exec_op(). Index 0 is preset at boot with a basic
> + * read operation, so let's use the last entry (15).
> + */
> +#define	SEQID_LUT			15
> +
> +/* Registers used by the driver */
> +#define QUADSPI_MCR			0x00
> +#define QUADSPI_MCR_RESERVED_MASK	GENMASK(19, 16)
> +#define QUADSPI_MCR_MDIS_MASK		BIT(14)
> +#define QUADSPI_MCR_CLR_TXF_MASK	BIT(11)
> +#define QUADSPI_MCR_CLR_RXF_MASK	BIT(10)
> +#define QUADSPI_MCR_DDR_EN_MASK		BIT(7)
> +#define QUADSPI_MCR_END_CFG_MASK	GENMASK(3, 2)
> +#define QUADSPI_MCR_SWRSTHD_MASK	BIT(1)
> +#define QUADSPI_MCR_SWRSTSD_MASK	BIT(0)
> +
> +#define QUADSPI_IPCR			0x08
> +#define QUADSPI_IPCR_SEQID(x)		((x) << 24)
> +
> +#define QUADSPI_BUF3CR			0x1c
> +#define QUADSPI_BUF3CR_ALLMST_MASK	BIT(31)
> +#define QUADSPI_BUF3CR_ADATSZ(x)	((x) << 8)
> +#define QUADSPI_BUF3CR_ADATSZ_MASK	GENMASK(15, 8)
> +
> +#define QUADSPI_BFGENCR			0x20
> +#define QUADSPI_BFGENCR_SEQID(x)	((x) << 12)
> +
> +#define QUADSPI_BUF0IND			0x30
> +#define QUADSPI_BUF1IND			0x34
> +#define QUADSPI_BUF2IND			0x38
> +#define QUADSPI_SFAR			0x100
> +
> +#define QUADSPI_SMPR			0x108
> +#define QUADSPI_SMPR_DDRSMP_MASK	GENMASK(18, 16)
> +#define QUADSPI_SMPR_FSDLY_MASK		BIT(6)
> +#define QUADSPI_SMPR_FSPHS_MASK		BIT(5)
> +#define QUADSPI_SMPR_HSENA_MASK		BIT(0)
> +
> +#define QUADSPI_RBCT			0x110
> +#define QUADSPI_RBCT_WMRK_MASK		GENMASK(4, 0)
> +#define QUADSPI_RBCT_RXBRD_USEIPS	BIT(8)
> +
> +#define QUADSPI_TBDR			0x154
> +
> +#define QUADSPI_SR			0x15c
> +#define QUADSPI_SR_IP_ACC_MASK		BIT(1)
> +#define QUADSPI_SR_AHB_ACC_MASK		BIT(2)
> +
> +#define QUADSPI_FR			0x160
> +#define QUADSPI_FR_TFF_MASK		BIT(0)
> +
> +#define QUADSPI_SPTRCLR			0x16c
> +#define QUADSPI_SPTRCLR_IPPTRC		BIT(8)
> +#define QUADSPI_SPTRCLR_BFPTRC		BIT(0)
> +
> +#define QUADSPI_SFA1AD			0x180
> +#define QUADSPI_SFA2AD			0x184
> +#define QUADSPI_SFB1AD			0x188
> +#define QUADSPI_SFB2AD			0x18c
> +#define QUADSPI_RBDR(x)			(0x200 + ((x) * 4))
> +
> +#define QUADSPI_LUTKEY			0x300
> +#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
> +
> +#define QUADSPI_LCKCR			0x304
> +#define QUADSPI_LCKER_LOCK		BIT(0)
> +#define QUADSPI_LCKER_UNLOCK		BIT(1)
> +
> +#define QUADSPI_RSER			0x164
> +#define QUADSPI_RSER_TFIE		BIT(0)
> +
> +#define QUADSPI_LUT_BASE		0x310
> +#define QUADSPI_LUT_OFFSET		(SEQID_LUT * 4 * 4)
> +#define QUADSPI_LUT_REG(idx) \
> +	(QUADSPI_LUT_BASE + QUADSPI_LUT_OFFSET + (idx) * 4)
> +
> +/* Instruction set for the LUT register */
> +#define LUT_STOP		0
> +#define LUT_CMD			1
> +#define LUT_ADDR		2
> +#define LUT_DUMMY		3
> +#define LUT_MODE		4
> +#define LUT_MODE2		5
> +#define LUT_MODE4		6
> +#define LUT_FSL_READ		7
> +#define LUT_FSL_WRITE		8
> +#define LUT_JMP_ON_CS		9
> +#define LUT_ADDR_DDR		10
> +#define LUT_MODE_DDR		11
> +#define LUT_MODE2_DDR		12
> +#define LUT_MODE4_DDR		13
> +#define LUT_FSL_READ_DDR	14
> +#define LUT_FSL_WRITE_DDR	15
> +#define LUT_DATA_LEARN		16
> +
> +/*
> + * The PAD definitions for LUT register.
> + *
> + * The pad stands for the number of IO lines [0:3].
> + * For example, the quad read needs four IO lines,
> + * so you should use LUT_PAD(4).
> + */
> +#define LUT_PAD(x) (fls(x) - 1)
> +
> +/*
> + * Macro for constructing the LUT entries with the following
> + * register layout:
> + *
> + *  ---------------------------------------------------
> + *  | INSTR1 | PAD1 | OPRND1 | INSTR0 | PAD0 | OPRND0 |
> + *  ---------------------------------------------------
> + */
> +#define LUT_DEF(idx, ins, pad, opr)					\
> +	((((ins) << 10) | ((pad) << 8) | (opr)) << (((idx) % 2) * 16))
> +
> +/* Controller needs driver to swap endianness */
> +#define QUADSPI_QUIRK_SWAP_ENDIAN	BIT(0)
> +
> +/* Controller needs 4x internal clock */
> +#define QUADSPI_QUIRK_4X_INT_CLK	BIT(1)
> +
> +/*
> + * TKT253890, the controller needs the driver to fill the txfifo with
> + * 16 bytes at least to trigger a data transfer, even though the extra
> + * data won't be transferred.
> + */
> +#define QUADSPI_QUIRK_TKT253890		BIT(2)
> +
> +/* TKT245618, the controller cannot wake up from wait mode */
> +#define QUADSPI_QUIRK_TKT245618		BIT(3)
> +
> +/*
> + * Controller adds QSPI_AMBA_BASE (base address of the mapped memory)
> + * internally. No need to add it when setting SFXXAD and SFAR registers
> +*/
> +#define QUADSPI_QUIRK_BASE_INTERNAL	BIT(4)
> +
> +struct fsl_qspi_devtype_data {
> +	unsigned int rxfifo;
> +	unsigned int txfifo;
> +	unsigned int ahb_buf_size;
> +	unsigned int quirks;
> +	bool little_endian;
> +};
> +
> +static const struct fsl_qspi_devtype_data vybrid_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_SWAP_ENDIAN,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx6sx_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_4X_INT_CLK |
> QUADSPI_QUIRK_TKT245618,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx7d_data =3D {
> +	.rxfifo =3D SZ_512,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 |
> QUADSPI_QUIRK_4X_INT_CLK,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx6ul_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 |
> QUADSPI_QUIRK_4X_INT_CLK,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data ls1021a_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D 0,
> +	.little_endian =3D false,
> +};
> +
> +static const struct fsl_qspi_devtype_data ls2080a_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 |
> QUADSPI_QUIRK_BASE_INTERNAL,
> +	.little_endian =3D true,
> +};
> +
> +struct fsl_qspi {
> +	void __iomem *iobase;
> +	void __iomem *ahb_addr;
> +	u32 memmap_phy;
> +	struct clk *clk, *clk_en;
> +	struct device *dev;
> +	struct completion c;
> +	const struct fsl_qspi_devtype_data *devtype_data;
> +	struct mutex lock;
> +	struct pm_qos_request pm_qos_req;
> +	int selected;
> +};
> +
> +static inline int needs_swap_endian(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_SWAP_ENDIAN; }
> +
> +static inline int needs_4x_clock(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_4X_INT_CLK; }
> +
> +static inline int needs_fill_txfifo(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT253890; }
> +
> +static inline int needs_wakeup_wait_mode(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT245618; }
> +
> +static inline int needs_amba_base_offset(struct fsl_qspi *q) {
> +	return !(q->devtype_data->quirks &
> QUADSPI_QUIRK_BASE_INTERNAL); }
> +
> +/*
> + * An IC bug makes it necessary to rearrange the 32-bit data.
> + * Later chips, such as IMX6SLX, have fixed this bug.
> + */
> +static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a) {
> +	return needs_swap_endian(q) ? __swab32(a) : a; }
> +
> +/*
> + * R/W functions for big- or little-endian registers:
> + * The QSPI controller's endianness is independent of
> + * the CPU core's endianness. So far, although the CPU
> + * core is little-endian the QSPI controller can use
> + * big-endian or little-endian.
> + */
> +static void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem
> +*addr) {
> +	if (q->devtype_data->little_endian)
> +		iowrite32(val, addr);
> +	else
> +		iowrite32be(val, addr);
> +}
> +
> +static u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr) {
> +	if (q->devtype_data->little_endian)
> +		return ioread32(addr);
> +
> +	return ioread32be(addr);
> +}
> +
> +static irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id) {
> +	struct fsl_qspi *q =3D dev_id;
> +	u32 reg;
> +
> +	/* clear interrupt */
> +	reg =3D qspi_readl(q, q->iobase + QUADSPI_FR);
> +	qspi_writel(q, reg, q->iobase + QUADSPI_FR);
> +
> +	if (reg & QUADSPI_FR_TFF_MASK)
> +		complete(&q->c);
> +
> +	dev_dbg(q->dev, "QUADSPI_FR : 0x%.8x:0x%.8x\n", 0, reg);
> +	return IRQ_HANDLED;
> +}
> +
> +static int fsl_qspi_check_buswidth(struct fsl_qspi *q, u8 width) {
> +	switch (width) {
> +	case 1:
> +	case 2:
> +	case 4:
> +		return 0;
> +	}
> +
> +	return -ENOTSUPP;
> +}
> +
> +static bool fsl_qspi_supports_op(struct spi_mem *mem,
> +				 const struct spi_mem_op *op)
> +{
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	int ret;
> +
> +	ret =3D fsl_qspi_check_buswidth(q, op->cmd.buswidth);
> +
> +	if (op->addr.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->addr.buswidth);
> +
> +	if (op->dummy.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->dummy.buswidth);
> +
> +	if (op->data.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->data.buswidth);
> +
> +	if (ret)
> +		return false;
> +
> +	/*
> +	 * The number of instructions needed for the op, needs
> +	 * to fit into a single LUT entry.
> +	 */
> +	if (op->addr.nbytes +
> +	   (op->dummy.nbytes ? 1:0) +
> +	   (op->data.nbytes ? 1:0) > 6)
> +		return false;
> +
> +	/* Max 64 dummy clock cycles supported */
> +	if (op->dummy.nbytes &&
> +	    (op->dummy.nbytes * 8 / op->dummy.buswidth > 64))
> +		return false;
> +
> +	/* Max data length, check controller limits and alignment */
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_IN &&
> +	    (op->data.nbytes > q->devtype_data->ahb_buf_size ||
> +	     (op->data.nbytes > q->devtype_data->rxfifo - 4 &&
> +	      !IS_ALIGNED(op->data.nbytes, 8))))
> +		return false;
> +
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT &&
> +	    op->data.nbytes > q->devtype_data->txfifo)
> +		return false;
> +
> +	return true;
> +}
> +
> +static void fsl_qspi_prepare_lut(struct fsl_qspi *q,
> +				 const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	u32 lutval[4] =3D {};
> +	int lutidx =3D 1, i;
> +
> +	lutval[0] |=3D LUT_DEF(0, LUT_CMD, LUT_PAD(op->cmd.buswidth),
> +			     op->cmd.opcode);
> +
> +	/*
> +	 * For some unknown reason, using LUT_ADDR doesn't work in some
> +	 * cases (at least with only one byte long addresses), so
> +	 * let's use LUT_MODE to write the address bytes one by one
> +	 */
> +	for (i =3D 0; i < op->addr.nbytes; i++) {
> +		u8 addrbyte =3D op->addr.val >> (8 * (op->addr.nbytes - i - 1));
> +
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_MODE,
> +					      LUT_PAD(op->addr.buswidth),
> +					      addrbyte);
> +		lutidx++;
> +	}
> +
> +	if (op->dummy.nbytes) {
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_DUMMY,
> +					      LUT_PAD(op->dummy.buswidth),
> +					      op->dummy.nbytes * 8 /
> +					      op->dummy.buswidth);
> +		lutidx++;
> +	}
> +
> +	if (op->data.nbytes) {
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx,
> +					      op->data.dir =3D=3D
> SPI_MEM_DATA_IN ?
> +					      LUT_FSL_READ : LUT_FSL_WRITE,
> +					      LUT_PAD(op->data.buswidth),
> +					      0);
> +		lutidx++;
> +	}
> +
> +	lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_STOP, 0, 0);
> +
> +	/* unlock LUT */
> +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase +
> QUADSPI_LUTKEY);
> +	qspi_writel(q, QUADSPI_LCKER_UNLOCK, q->iobase +
> QUADSPI_LCKCR);
> +
> +	/* fill LUT */
> +	for (i =3D 0; i < ARRAY_SIZE(lutval); i++)
> +		qspi_writel(q, lutval[i], base + QUADSPI_LUT_REG(i));
> +
> +	/* lock LUT */
> +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase +
> QUADSPI_LUTKEY);
> +	qspi_writel(q, QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR); }
> +
> +static int fsl_qspi_clk_prep_enable(struct fsl_qspi *q) {
> +	int ret;
> +
> +	ret =3D clk_prepare_enable(q->clk_en);
> +	if (ret)
> +		return ret;
> +
> +	ret =3D clk_prepare_enable(q->clk);
> +	if (ret) {
> +		clk_disable_unprepare(q->clk_en);
> +		return ret;
> +	}
> +
> +	if (needs_wakeup_wait_mode(q))
> +		pm_qos_add_request(&q->pm_qos_req,
> PM_QOS_CPU_DMA_LATENCY, 0);
> +
> +	return 0;
> +}
> +
> +static void fsl_qspi_clk_disable_unprep(struct fsl_qspi *q) {
> +	if (needs_wakeup_wait_mode(q))
> +		pm_qos_remove_request(&q->pm_qos_req);
> +
> +	clk_disable_unprepare(q->clk);
> +	clk_disable_unprepare(q->clk_en);
> +}
> +
> +/*
> + * If we have changed the content of the flash by writing or erasing,
> +or if we
> + * read from flash with a different offset into the page buffer, we
> +need to
> + * invalidate the AHB buffer. If we do not do so, we may read out the
> +wrong
> + * data. The spec tells us reset the AHB domain and Serial Flash domain
> +at
> + * the same time.
> + */
> +static void fsl_qspi_invalidate(struct fsl_qspi *q) {
> +	u32 reg;
> +
> +	reg =3D qspi_readl(q, q->iobase + QUADSPI_MCR);
> +	reg |=3D QUADSPI_MCR_SWRSTHD_MASK |
> QUADSPI_MCR_SWRSTSD_MASK;
> +	qspi_writel(q, reg, q->iobase + QUADSPI_MCR);
> +
> +	/*
> +	 * The minimum delay : 1 AHB + 2 SFCK clocks.
> +	 * Delay 1 us is enough.
> +	 */
> +	udelay(1);
> +
> +	reg &=3D ~(QUADSPI_MCR_SWRSTHD_MASK |
> QUADSPI_MCR_SWRSTSD_MASK);
> +	qspi_writel(q, reg, q->iobase + QUADSPI_MCR); }
> +
> +static void fsl_qspi_select_mem(struct fsl_qspi *q, struct spi_device
> +*spi) {
> +	unsigned long rate =3D spi->max_speed_hz;
> +	int ret;
> +
> +	if (q->selected =3D=3D spi->chip_select)
> +		return;
> +
> +	if (needs_4x_clock(q))
> +		rate *=3D 4;
> +
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	ret =3D clk_set_rate(q->clk, rate);
> +	if (ret)
> +		return;
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret)
> +		return;
> +
> +	q->selected =3D spi->chip_select;
> +
> +	fsl_qspi_invalidate(q);
> +}
> +
> +static void fsl_qspi_read_ahb(struct fsl_qspi *q, const struct
> +spi_mem_op *op) {
> +	memcpy_fromio(op->data.buf.in,
> +		      q->ahb_addr + q->selected * q->devtype_data-
> >ahb_buf_size,
> +		      op->data.nbytes);
> +}
> +
> +static void fsl_qspi_fill_txfifo(struct fsl_qspi *q,
> +				 const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	int i;
> +	u32 val;
> +
> +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> +		memcpy(&val, op->data.buf.out + i, 4);
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		qspi_writel(q, val, base + QUADSPI_TBDR);
> +	}
> +
> +	if (i < op->data.nbytes) {
> +		memcpy(&val, op->data.buf.out + i, op->data.nbytes - i);
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		qspi_writel(q, val, base + QUADSPI_TBDR);
> +	}
> +
> +	if (needs_fill_txfifo(q)) {
> +		for (i =3D op->data.nbytes; i < 16; i +=3D 4)
> +			qspi_writel(q, 0, base + QUADSPI_TBDR);
> +	}
> +}
> +
> +static void fsl_qspi_read_rxfifo(struct fsl_qspi *q,
> +			  const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	int i;
> +	u8 *buf =3D op->data.buf.in;
> +	u32 val;
> +
> +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		memcpy(buf + i, &val, 4);
> +	}
> +
> +	if (i < op->data.nbytes) {
> +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		memcpy(buf + i, &val, op->data.nbytes - i);
> +	}
> +}
> +
> +static int fsl_qspi_do_op(struct fsl_qspi *q, const struct spi_mem_op
> +*op) {
> +	void __iomem *base =3D q->iobase;
> +	int err =3D 0;
> +
> +	init_completion(&q->c);
> +
> +	/*
> +	 * Always start the sequence at the same index since we update
> +	 * the LUT at each exec_op() call. And also specify the DATA
> +	 * length, since it's has not been specified in the LUT.
> +	 */
> +	qspi_writel(q, op->data.nbytes | QUADSPI_IPCR_SEQID(SEQID_LUT),
> +		    base + QUADSPI_IPCR);
> +
> +	/* Wait for the interrupt. */
> +	if (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000)))
> +		err =3D -ETIMEDOUT;
> +
> +	if (!err && op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_IN)
> +		fsl_qspi_read_rxfifo(q, op);
> +
> +	return err;
> +}
> +
> +static int fsl_qspi_readl_poll_tout(struct fsl_qspi *q, void __iomem *ba=
se,
> +				    u32 mask, u32 delay_us, u32 timeout_us) {
> +	u32 reg;
> +
> +	if (!q->devtype_data->little_endian)
> +		mask =3D (u32)cpu_to_be32(mask);
> +
> +	return readl_poll_timeout(base, reg, !(reg & mask), delay_us,
> +				  timeout_us);
> +}
> +
> +static int fsl_qspi_exec_op(struct spi_mem *mem, const struct
> +spi_mem_op *op) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	void __iomem *base =3D q->iobase;
> +	u32 addr_offset =3D 0;
> +	int err =3D 0;
> +
> +	mutex_lock(&q->lock);
> +
> +	/* wait for the controller being ready */
> +	fsl_qspi_readl_poll_tout(q, base + QUADSPI_SR,
> (QUADSPI_SR_IP_ACC_MASK |
> +				 QUADSPI_SR_AHB_ACC_MASK), 10, 1000);
> +
> +	fsl_qspi_select_mem(q, mem->spi);
> +
> +	if (needs_amba_base_offset(q))
> +		addr_offset =3D q->memmap_phy;
> +
> +	qspi_writel(q,
> +		    q->selected * q->devtype_data->ahb_buf_size +
> addr_offset,
> +		    base + QUADSPI_SFAR);
> +
> +	qspi_writel(q, qspi_readl(q, base + QUADSPI_MCR) |
> +		    QUADSPI_MCR_CLR_RXF_MASK |
> QUADSPI_MCR_CLR_TXF_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	qspi_writel(q, QUADSPI_SPTRCLR_BFPTRC |
> QUADSPI_SPTRCLR_IPPTRC,
> +		    base + QUADSPI_SPTRCLR);
> +
> +	fsl_qspi_prepare_lut(q, op);
> +
> +	/*
> +	 * If we have large chunks of data, we read them through the AHB
> bus
> +	 * by accessing the mapped memory. In all other cases we use
> +	 * IP commands to access the flash.
> +	 */
> +	if (op->data.nbytes > (q->devtype_data->rxfifo - 4) &&
> +	    op->data.dir =3D=3D SPI_MEM_DATA_IN) {
> +		fsl_qspi_read_ahb(q, op);
> +	} else {
> +		qspi_writel(q, QUADSPI_RBCT_WMRK_MASK |
> +			    QUADSPI_RBCT_RXBRD_USEIPS, base +
> QUADSPI_RBCT);
> +
> +		if (op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_OUT)
> +			fsl_qspi_fill_txfifo(q, op);
> +
> +		err =3D fsl_qspi_do_op(q, op);
> +	}
> +
> +	/* Invalidate the data in the AHB buffer. */
> +	fsl_qspi_invalidate(q);
> +
> +	mutex_unlock(&q->lock);
> +
> +	return err;
> +}
> +
> +static int fsl_qspi_adjust_op_size(struct spi_mem *mem, struct
> +spi_mem_op *op) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT) {
> +		if (op->data.nbytes > q->devtype_data->txfifo)
> +			op->data.nbytes =3D q->devtype_data->txfifo;
> +	} else {
> +		if (op->data.nbytes > q->devtype_data->ahb_buf_size)
> +			op->data.nbytes =3D q->devtype_data->ahb_buf_size;
> +		else if (op->data.nbytes > (q->devtype_data->rxfifo - 4))
> +			op->data.nbytes =3D ALIGN_DOWN(op->data.nbytes, 8);
> +	}
> +
> +	return 0;
> +}
> +
> +static int fsl_qspi_default_setup(struct fsl_qspi *q) {
> +	void __iomem *base =3D q->iobase;
> +	u32 reg, addr_offset =3D 0;
> +	int ret;
> +
> +	/* disable and unprepare clock to avoid glitch pass to controller */
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	/* the default frequency, we will change it later if necessary. */
> +	ret =3D clk_set_rate(q->clk, 66000000);
> +	if (ret)
> +		return ret;
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret)
> +		return ret;
> +
> +	/* Reset the module */
> +	qspi_writel(q, QUADSPI_MCR_SWRSTSD_MASK |
> QUADSPI_MCR_SWRSTHD_MASK,
> +		    base + QUADSPI_MCR);
> +	udelay(1);
> +
> +	/* Disable the module */
> +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK |
> QUADSPI_MCR_RESERVED_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	reg =3D qspi_readl(q, base + QUADSPI_SMPR);
> +	qspi_writel(q, reg & ~(QUADSPI_SMPR_FSDLY_MASK
> +			| QUADSPI_SMPR_FSPHS_MASK
> +			| QUADSPI_SMPR_HSENA_MASK
> +			| QUADSPI_SMPR_DDRSMP_MASK), base +
> QUADSPI_SMPR);
> +
> +	/* We only use the buffer3 for AHB read */
> +	qspi_writel(q, 0, base + QUADSPI_BUF0IND);
> +	qspi_writel(q, 0, base + QUADSPI_BUF1IND);
> +	qspi_writel(q, 0, base + QUADSPI_BUF2IND);
> +
> +	qspi_writel(q, QUADSPI_BFGENCR_SEQID(SEQID_LUT),
> +		    q->iobase + QUADSPI_BFGENCR);
> +	qspi_writel(q, QUADSPI_RBCT_WMRK_MASK, base + QUADSPI_RBCT);
> +	qspi_writel(q, QUADSPI_BUF3CR_ALLMST_MASK |
> +		    QUADSPI_BUF3CR_ADATSZ(q->devtype_data-
> >ahb_buf_size / 8),
> +		    base + QUADSPI_BUF3CR);
> +
> +	if (needs_amba_base_offset(q))
> +		addr_offset =3D q->memmap_phy;
> +
> +	/*
> +	 * In HW there can be a maximum of four chips on two buses with
> +	 * two chip selects on each bus. We use four chip selects in SW
> +	 * to differentiate between the four chips.
> +	 * We use ahb_buf_size for each chip and set SFA1AD, SFA2AD,
> SFB1AD,
> +	 * SFB2AD accordingly.
> +	 */
> +	qspi_writel(q, q->devtype_data->ahb_buf_size + addr_offset,
> +		    base + QUADSPI_SFA1AD);
> +	qspi_writel(q, q->devtype_data->ahb_buf_size * 2 + addr_offset,
> +		    base + QUADSPI_SFA2AD);
> +	qspi_writel(q, q->devtype_data->ahb_buf_size * 3 + addr_offset,
> +		    base + QUADSPI_SFB1AD);
> +	qspi_writel(q, q->devtype_data->ahb_buf_size * 4 + addr_offset,
> +		    base + QUADSPI_SFB2AD);
> +
> +	q->selected =3D -1;
> +
> +	/* Enable the module */
> +	qspi_writel(q, QUADSPI_MCR_RESERVED_MASK |
> QUADSPI_MCR_END_CFG_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	/* clear all interrupt status */
> +	qspi_writel(q, 0xffffffff, q->iobase + QUADSPI_FR);
> +
> +	/* enable the interrupt */
> +	qspi_writel(q, QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);
> +
> +	return 0;
> +}
> +
> +static const char *fsl_qspi_get_name(struct spi_mem *mem) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	struct device *dev =3D &mem->spi->dev;
> +	const char *name;
> +
> +	/*
> +	 * In order to keep mtdparts compatible with the old MTD driver at
> +	 * mtd/spi-nor/fsl-quadspi.c, we set a custom name derived from the
> +	 * platform_device of the controller.
> +	 */
> +	if (of_get_available_child_count(q->dev->of_node) =3D=3D 1)
> +		return dev_name(q->dev);
> +
> +	name =3D devm_kasprintf(dev, GFP_KERNEL,
> +			      "%s-%d", dev_name(q->dev),
> +			      mem->spi->chip_select);
> +
> +	if (!name) {
> +		dev_err(dev, "failed to get memory for custom flash
> name\n");
> +		return ERR_PTR(-ENOMEM);
> +	}
> +
> +	return name;
> +}
> +
> +static const struct spi_controller_mem_ops fsl_qspi_mem_ops =3D {
> +	.adjust_op_size =3D fsl_qspi_adjust_op_size,
> +	.supports_op =3D fsl_qspi_supports_op,
> +	.exec_op =3D fsl_qspi_exec_op,
> +	.get_name =3D fsl_qspi_get_name,
> +};
> +
> +static int fsl_qspi_probe(struct platform_device *pdev) {
> +	struct spi_controller *ctlr;
> +	struct device *dev =3D &pdev->dev;
> +	struct device_node *np =3D dev->of_node;
> +	struct resource *res;
> +	struct fsl_qspi *q;
> +	int ret;
> +
> +	ctlr =3D spi_alloc_master(&pdev->dev, sizeof(*q));
> +	if (!ctlr)
> +		return -ENOMEM;
> +
> +	ctlr->mode_bits =3D SPI_RX_DUAL | SPI_RX_QUAD |
> +			  SPI_TX_DUAL | SPI_TX_QUAD;
> +
> +	q =3D spi_controller_get_devdata(ctlr);
> +	q->dev =3D dev;
> +	q->devtype_data =3D of_device_get_match_data(dev);
> +	if (!q->devtype_data) {
> +		ret =3D -ENODEV;
> +		goto err_put_ctrl;
> +	}
> +
> +	platform_set_drvdata(pdev, q);
> +
> +	/* find the resources */
> +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> "QuadSPI");
> +	q->iobase =3D devm_ioremap_resource(dev, res);
> +	if (IS_ERR(q->iobase)) {
> +		ret =3D PTR_ERR(q->iobase);
> +		goto err_put_ctrl;
> +	}
> +
> +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> +					"QuadSPI-memory");
> +	q->ahb_addr =3D devm_ioremap_resource(dev, res);
> +	if (IS_ERR(q->ahb_addr)) {
> +		ret =3D PTR_ERR(q->ahb_addr);
> +		goto err_put_ctrl;
> +	}
> +
> +	q->memmap_phy =3D res->start;
> +
> +	/* find the clocks */
> +	q->clk_en =3D devm_clk_get(dev, "qspi_en");
> +	if (IS_ERR(q->clk_en)) {
> +		ret =3D PTR_ERR(q->clk_en);
> +		goto err_put_ctrl;
> +	}
> +
> +	q->clk =3D devm_clk_get(dev, "qspi");
> +	if (IS_ERR(q->clk)) {
> +		ret =3D PTR_ERR(q->clk);
> +		goto err_put_ctrl;
> +	}
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret) {
> +		dev_err(dev, "can not enable the clock\n");
> +		goto err_put_ctrl;
> +	}
> +
> +	/* find the irq */
> +	ret =3D platform_get_irq(pdev, 0);
> +	if (ret < 0) {
> +		dev_err(dev, "failed to get the irq: %d\n", ret);
> +		goto err_disable_clk;
> +	}
> +
> +	ret =3D devm_request_irq(dev, ret,
> +			fsl_qspi_irq_handler, 0, pdev->name, q);
> +	if (ret) {
> +		dev_err(dev, "failed to request irq: %d\n", ret);
> +		goto err_disable_clk;
> +	}
> +
> +	mutex_init(&q->lock);
> +
> +	ctlr->bus_num =3D -1;
> +	ctlr->num_chipselect =3D 4;
> +	ctlr->mem_ops =3D &fsl_qspi_mem_ops;
> +
> +	fsl_qspi_default_setup(q);
> +
> +	ctlr->dev.of_node =3D np;
> +
> +	ret =3D spi_register_controller(ctlr);
> +	if (ret)
> +		goto err_destroy_mutex;
> +
> +	return 0;
> +
> +err_destroy_mutex:
> +	mutex_destroy(&q->lock);
> +
> +err_disable_clk:
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +err_put_ctrl:
> +	spi_controller_put(ctlr);
> +
> +	dev_err(dev, "Freescale QuadSPI probe failed\n");
> +	return ret;
> +}
> +
> +static int fsl_qspi_remove(struct platform_device *pdev) {
> +	struct fsl_qspi *q =3D platform_get_drvdata(pdev);
> +
> +	/* disable the hardware */
> +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK, q->iobase +
> QUADSPI_MCR);
> +	qspi_writel(q, 0x0, q->iobase + QUADSPI_RSER);
> +
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	mutex_destroy(&q->lock);
> +
> +	return 0;
> +}
> +
> +static int fsl_qspi_suspend(struct device *dev) {
> +	return 0;
> +}
> +
> +static int fsl_qspi_resume(struct device *dev) {
> +	struct fsl_qspi *q =3D dev_get_drvdata(dev);
> +
> +	fsl_qspi_default_setup(q);
> +
> +	return 0;
> +}
> +
> +static const struct of_device_id fsl_qspi_dt_ids[] =3D {
> +	{ .compatible =3D "fsl,vf610-qspi", .data =3D &vybrid_data, },
> +	{ .compatible =3D "fsl,imx6sx-qspi", .data =3D &imx6sx_data, },
> +	{ .compatible =3D "fsl,imx7d-qspi", .data =3D &imx7d_data, },
> +	{ .compatible =3D "fsl,imx6ul-qspi", .data =3D &imx6ul_data, },
> +	{ .compatible =3D "fsl,ls1021a-qspi", .data =3D &ls1021a_data, },
> +	{ .compatible =3D "fsl,ls2080a-qspi", .data =3D &ls2080a_data, },
> +	{ /* sentinel */ }
> +};
> +MODULE_DEVICE_TABLE(of, fsl_qspi_dt_ids);
> +
> +static const struct dev_pm_ops fsl_qspi_pm_ops =3D {
> +	.suspend	=3D fsl_qspi_suspend,
> +	.resume		=3D fsl_qspi_resume,
> +};
> +
> +static struct platform_driver fsl_qspi_driver =3D {
> +	.driver =3D {
> +		.name	=3D "fsl-quadspi",
> +		.of_match_table =3D fsl_qspi_dt_ids,
> +		.pm =3D   &fsl_qspi_pm_ops,
> +	},
> +	.probe          =3D fsl_qspi_probe,
> +	.remove		=3D fsl_qspi_remove,
> +};
> +module_platform_driver(fsl_qspi_driver);
> +
> +MODULE_DESCRIPTION("Freescale QuadSPI Controller Driver");
> +MODULE_AUTHOR("Freescale Semiconductor Inc.");
> MODULE_AUTHOR("Boris
> +Brezillion <boris.brezillon@bootlin.com>"); MODULE_AUTHOR("Frieder
> +Schrempf <frieder.schrempf@kontron.de>"); MODULE_AUTHOR("Yogesh
> Gaur
> +<yogeshnarayan.gaur@nxp.com>"); MODULE_AUTHOR("Suresh Gupta
> +<suresh.gupta@nxp.com>"); MODULE_LICENSE("GPL v2");
> --
> 2.7.4

Acked-by: Han Xu <han.xu@nxp.com>
Tested-by: Han Xu <han.xu@nxp.com>

