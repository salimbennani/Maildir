Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  19 Dec 2018 08:44:48 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 8D6F858055F;
	Tue, 18 Dec 2018 14:19:37 -0800 (PST)
Received: from orsmga102-1.jf.intel.com (HELO mga09.intel.com) ([10.7.208.27])
  by fmsmga001-1.fm.intel.com with ESMTP; 18 Dec 2018 14:19:36 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3A9zGkmxdm1CmacphPYuruLhfmlGMj4u6mDksu8pMi?=
 =?us-ascii?q?zoh2WeGdxc68bRCN2/xhgRfzUJnB7Loc0qyK6/CmATRIyK3CmUhKSIZLWR4BhJ?=
 =?us-ascii?q?detC0bK+nBN3fGKuX3ZTcxBsVIWQwt1Xi6NU9IBJS2PAWK8TW94jEIBxrwKxd+?=
 =?us-ascii?q?KPjrFY7OlcS30P2594HObwlSizexfbB/IA+qoQnNq8IbnZZsJqEtxxXTv3BGYf?=
 =?us-ascii?q?5WxWRmJVKSmxbz+MK994N9/ipTpvws6ddOXb31cKokQ7NYCi8mM30u683wqRbD?=
 =?us-ascii?q?VwqP6WACXWgQjxFFHhLK7BD+Xpf2ryv6qu9w0zSUMMHqUbw5Xymp4qF2QxHqlS?=
 =?us-ascii?q?gHLSY0/m/XhMJzlqJUohyhqQJizYDTb46bO+Zxcb7GfdMCR2dMRdpRWi9bD4+g?=
 =?us-ascii?q?dYYDE+gMMOBFpIf9vVsOqh6+CBGwBOPu0j9En2T53aom0+88HwHG2xYgFM8Qvn?=
 =?us-ascii?q?TUq9X1Mb0dUfuox6fJyTXMcfJW2Dj76IfWaBAqvPaBXa5xccrJ0kYvEB/Fg06R?=
 =?us-ascii?q?qI3lIzOV0f4Nv3KH4OpnUOKikmgqoBx/rDiow8cjkIjJhoQNx1DH6yp52oA1Ks?=
 =?us-ascii?q?O8SEJhZt6kCpRQuieHPIV1WsMvW39ktDo+x7EcpJK2cjYGxI46yxPcd/CLaYmF?=
 =?us-ascii?q?7xD7WOqMJTp1h2hpdK+xihuw60Ss1PHwWteu3FpXoCdIk9/BvW0X2RPJ8MiIUP?=
 =?us-ascii?q?5981+h2TmR0wDT7flJIV47laXFMZ4t2L0wmYQJsUTFACD2nF/6jKiMdkUr4uSo?=
 =?us-ascii?q?6uLnbav6ppKEKYN4lgXzPr4zlsGxH+g0KBUCUmuH9eim1bDu/1X1QLBQgf03lq?=
 =?us-ascii?q?nZvoraJcMepqOhBw9V04Aj6wuwDju/09QXg2MHLFRbdxKDloTpPF/PIPbmAvel?=
 =?us-ascii?q?mFmsjjhryO7cPrH7AZXCMGLDkLH/crZ58UJczxAzzd9H65JOFr4BOO7zWlP2tN?=
 =?us-ascii?q?HACh85Mg+0zPj9BNRyy4MTQmaPAq6fMKPPvl6E/OMvI++QZIALvDbxMeQq5/nr?=
 =?us-ascii?q?jXUhg18SYbGp3YcLaHC/BvlmI1+WYXvwgtgbFmcGpAo+TPHwh12EXj5efHKyX6?=
 =?us-ascii?q?M65jEmB4OqF4bDRoaxgLOf2Ce3BIFZZmdDClqUC3fna52EW+sQaCKVOsJhkDsE?=
 =?us-ascii?q?Wqa7R48i0hGusgn6y718I+rQ+y0Ys4/j1ddv6+3SkxEy6SJ7D8CH326RSGF0m3?=
 =?us-ascii?q?sCRyUq06BnvUx91lCD3LBijPxDFdxT4PBJXh0gNZHGzex3ENTyWgPHfteUR1eq?=
 =?us-ascii?q?WNSmATctTt0vx98CeVpyG9KnjhrbxSqlH6cVl6CXBJwz6q/c3GL+J8Bnx3bC1a?=
 =?us-ascii?q?kulV8mQsRUOG2ih65/8RXTBoHTn0WYkaaqaboT3CrX+GifymqOuVlSUBRsXqXd?=
 =?us-ascii?q?QXAfekzWoMzk6UzYUb+hF64rMgtbxs6EMatFdNvpgVJCRPfgPdTeZ3m8m2OxBR?=
 =?us-ascii?q?aO27ONY5Dme2Qb3CXBFkcElxof8mqBNQg7Hi2huX7RDCRyFVLzZEPh6fRxp2ml?=
 =?us-ascii?q?TkAq1Q2Kb1du17yu+hELg/yRUPcT3rMCuCc8pDR4Ble939TKC9WeowptZrlTYd?=
 =?us-ascii?q?Q44F1fz2LWqxR9PoC8L6BlnlMebwV3v0bp1xVrCoVBkdImrG8wwAp1M6KY1FJB?=
 =?us-ascii?q?dzWX3Z3rPr3XK2/y/A2gaqLM21He1sqW9bkL6Pgit1rjuwSpHFI483p7y9lVz2?=
 =?us-ascii?q?ec5pLSAQUIVZL+TEk2+AZ6pr3AeSY9+p7b2mdqMam3tT/CxckkBO8kyhamYtde?=
 =?us-ascii?q?P7mIFA70E80GGceuLPYmlESubhIBJOpS7rI7P9u6d/ua366mJOZhnC+8gWtb+o?=
 =?us-ascii?q?x800KM+DB6Su7HxJsFx/CY3g2aVzbzlluhs8b3mZxaajEWBGaw1S/kBItJbK1o?=
 =?us-ascii?q?YYkLEXuuI9GwxthmnZ7tWmJX+0S5B1wb38+lYxySYELn3Q1RzEgYvWaomS+lwD?=
 =?us-ascii?q?NqiTEpqayf0TfKw+TjchoHJ2FKSHNjjVfqPYi7kdQaUFK0YAgukRuv/Vz6yLRD?=
 =?us-ascii?q?pKRjM2nTRl9Ffij3L214Uqq8rKGCY9NJ6J4ztSVXUeK8YU2VS7Lnohsa1T/jEH?=
 =?us-ascii?q?VaxDwhaz6qvZD5lQRgiG2BNHZzsGbZecZoyBfd/tPcX/1R3jkBRCVikjnYHFu8?=
 =?us-ascii?q?P9qo/dWSiZjDtPuzV2agVp1VbCnqwpmMtCq95W12HxK/m+q/lcHgEQg/ySX7zc?=
 =?us-ascii?q?VlVT3UrBbgZYnmz6S7PvhgfkVyBl/86sx6F5p6kosxgpEQxHcbio+U/XoBjWf8?=
 =?us-ascii?q?L9Fb1bjiY3oKQD4B28TV7xT92E1/MnKJwJr0VnaHzctgfdW6Yn4W1Tg778BFE6?=
 =?us-ascii?q?qU6L1EnS1oolu3tw7RYP59nisDxvsq8nIVn+YJuA81xCWHHr8SBVVYPTDrlxmQ?=
 =?us-ascii?q?6tC+raZXa3y1fbm+ykV+hsyhA6+Yog5HRnn5YJgiEDR07sV+NlLMzXLy5pvleN?=
 =?us-ascii?q?nWcdIcqBmUnw3cgOhSLZI7juAKijZ/OWLhoX0lzPY2jQBp3ZG/poSGKn9i/KSk?=
 =?us-ascii?q?Ah5DLT31Ztge+jXsjaZYg8aX0JqjHpRnGjUXQpToSeikHy4VtfTiLwyOCiEzqm?=
 =?us-ascii?q?+HGbrDGg+S8FxpoGjIE5CvKnGbPn0Zzch5SRmZJUxfhh0UXTogkp44EACq2NLu?=
 =?us-ascii?q?cENj6j8N4V74rwNGyvh0OBnnTmffuACoZy82SJeFKRpZ8BpC613JMcCE7eJzAi?=
 =?us-ascii?q?JY/oCnrAOXMWyWfABIDWAPWkyZCFHvJLiu5d/c8+eGAuqyNefBYbKLqeZGTfeH?=
 =?us-ascii?q?2Yqv0pd6/zaLLsiOPn5iD+Ai2kpeR395Hd7Vmy4ISywRmCLAdMqbpBa6+i1qoc?=
 =?us-ascii?q?Gz6vXrWATz5YSRD7teK8lg+xezga2bLe6fmD55KSpE1pML3XLIyKYQ3F8RiyFt?=
 =?us-ascii?q?djmhC7cAtTTKTKLfhKBXFQMbazhoOctM7qI82BRNOMHBhtP00L54kuA6C1NfWV?=
 =?us-ascii?q?P9ncGpYNQAI3uhO1PfGEaLKLOGKCXRzMHqeqy8U6NfjeVOux20uDaWCEvjPjWF?=
 =?us-ascii?q?lzn0WBGjK+BMjCeHPBNAvIGxaApiCW/mTNj+cB20LMd3jSEqwb0znn7KKW8cMT?=
 =?us-ascii?q?1mf0xRtLGf8SNYjet5G2Fa6nplLO+EmzuW7uXCK5YWt+drDTpwl+5A/Hs6zL5V?=
 =?us-ascii?q?5jleRPNpgCvSssJuo1a+n+iP0DVnVh9OqjdNhI2TvERiOb/W9p9PWXvf+BIN7G?=
 =?us-ascii?q?OQCwkFptd/C93vvbxQxcbLlK7pNDhC9NfUroMgAJ3QKcSaID89MAKsEznRCQoZ?=
 =?us-ascii?q?Vha1OmzFwU9Qivef8juStJdpkJX0nIsyTepeVVo6EdsZB15jEdhEJ414Gns/jb?=
 =?us-ascii?q?qapMoJ42eu6hjbQYNRuZWDHuqfHfj1Oh6Yi7debhcFyL++Kp4ccsX71k1hbR9x?=
 =?us-ascii?q?lZ7RB0fWRvhBr2tgZApyq0JItDB6T2suywfmZxmr7Xs7C/G5hFg1hxF4bOBr8y?=
 =?us-ascii?q?3jpx8rKV7ajC8xllQtg9LjgCDXfDO1ZKuuXYhMFwL1sUYrO5/2Sgozahe92QR/?=
 =?us-ascii?q?PSzETrZ5jLZ6c21vzgjGtt8HGeZVZb9VfBgKg/qQYqYGy1NZ/zmm3QpN4veNB5?=
 =?us-ascii?q?x43DcqdpultDpv3w9ifNg4P+SEOKtRxF9MrrCfoiiykOs2xVlNdA427GqOdXtQ?=
 =?us-ascii?q?6wQzPb48Kn/w8w=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0BNAADdcRlch0O0hNFjHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBVAQBAQsBgmmBAieDfYh4ixsBgiGXZoFTEwEBGAsIAYcdIjcGDQEDAQEBAQE?=
 =?us-ascii?q?BAgETAQEBCgsJCCkjDII2IoJlAwMBAiAEBQYBRgYJAQEkAiYCAgNUGQUDgxoBg?=
 =?us-ascii?q?gAFCqcIfDMehA8BgQOEeAUTeIs0F4F/gRGGMAQYhE+CVwKJQocOkFQJhw+KaZF?=
 =?us-ascii?q?XjjuLEQIEAgQFAhSBXIF4TSMVOweBLQ4LAQw1XROCFBeIXoVgHgEyAQEIewEBj?=
 =?us-ascii?q?WABAQ?=
X-IPAS-Result: =?us-ascii?q?A0BNAADdcRlch0O0hNFjHAEBAQQBAQcEAQGBVAQBAQsBgmm?=
 =?us-ascii?q?BAieDfYh4ixsBgiGXZoFTEwEBGAsIAYcdIjcGDQEDAQEBAQEBAgETAQEBCgsJC?=
 =?us-ascii?q?CkjDII2IoJlAwMBAiAEBQYBRgYJAQEkAiYCAgNUGQUDgxoBggAFCqcIfDMehA8?=
 =?us-ascii?q?BgQOEeAUTeIs0F4F/gRGGMAQYhE+CVwKJQocOkFQJhw+KaZFXjjuLEQIEAgQFA?=
 =?us-ascii?q?hSBXIF4TSMVOweBLQ4LAQw1XROCFBeIXoVgHgEyAQEIewEBjWABAQ?=
X-IronPort-AV: E=Sophos;i="5.56,370,1539673200"; 
   d="scan'208";a="58033135"
X-Amp-Result: UNSCANNABLE
X-Amp-File-Uploaded: False
Unscannable: 2
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 18 Dec 2018 14:19:35 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727380AbeLRWTb (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Tue, 18 Dec 2018 17:19:31 -0500
Received: from terminus.zytor.com ([198.137.202.136]:33511 "EHLO
        terminus.zytor.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726570AbeLRWTb (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 18 Dec 2018 17:19:31 -0500
Received: from terminus.zytor.com (localhost [127.0.0.1])
        by terminus.zytor.com (8.15.2/8.15.2) with ESMTPS id wBIMIre22990413
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=NO);
        Tue, 18 Dec 2018 14:18:53 -0800
Received: (from tipbot@localhost)
        by terminus.zytor.com (8.15.2/8.15.2/Submit) id wBIMIqBH2990410;
        Tue, 18 Dec 2018 14:18:52 -0800
Date: Tue, 18 Dec 2018 14:18:52 -0800
X-Authentication-Warning: terminus.zytor.com: tipbot set sender to tipbot@zytor.com using -f
From: tip-bot for Thomas Gleixner <tipbot@zytor.com>
Message-ID: <tip-da791a667536bf8322042e38ca85d55a78d3c273@git.kernel.org>
Cc: peterz@infradead.org, stli@linux.ibm.com, mingo@kernel.org,
        linux-kernel@vger.kernel.org, heiko.carstens@de.ibm.com,
        hpa@zytor.com, sashal@kernel.org, dvhart@infradead.org,
        tglx@linutronix.de
Reply-To: mingo@kernel.org, stli@linux.ibm.com, peterz@infradead.org,
          heiko.carstens@de.ibm.com, linux-kernel@vger.kernel.org,
          tglx@linutronix.de, dvhart@infradead.org, sashal@kernel.org,
          hpa@zytor.com
In-Reply-To: <20181210152311.986181245@linutronix.de>
References: <20181210152311.986181245@linutronix.de>
To: linux-tip-commits@vger.kernel.org
Subject: [tip:locking/urgent] futex: Cure exit race
Git-Commit-ID: da791a667536bf8322042e38ca85d55a78d3c273
X-Mailer: tip-git-log-daemon
Robot-ID: <tip-bot.git.kernel.org>
Robot-Unsubscribe: Contact <mailto:hpa@kernel.org> to get blacklisted from
 these emails
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain; charset=UTF-8
Content-Disposition: inline
X-Spam-Status: No, score=-2.9 required=5.0 tests=ALL_TRUSTED,BAYES_00,
        T_DATE_IN_FUTURE_96_Q autolearn=ham autolearn_force=no version=3.4.2
X-Spam-Checker-Version: SpamAssassin 3.4.2 (2018-09-13) on terminus.zytor.com
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Commit-ID:  da791a667536bf8322042e38ca85d55a78d3c273
Gitweb:     https://git.kernel.org/tip/da791a667536bf8322042e38ca85d55a78d3c273
Author:     Thomas Gleixner <tglx@linutronix.de>
AuthorDate: Mon, 10 Dec 2018 14:35:14 +0100
Committer:  Thomas Gleixner <tglx@linutronix.de>
CommitDate: Tue, 18 Dec 2018 23:13:15 +0100

futex: Cure exit race

Stefan reported, that the glibc tst-robustpi4 test case fails
occasionally. That case creates the following race between
sys_exit() and sys_futex_lock_pi():

 CPU0				CPU1

 sys_exit()			sys_futex()
  do_exit()			 futex_lock_pi()
   exit_signals(tsk)		  No waiters:
    tsk->flags |= PF_EXITING;	  *uaddr == 0x00000PID
  mm_release(tsk)		  Set waiter bit
   exit_robust_list(tsk) {	  *uaddr = 0x80000PID;
      Set owner died		  attach_to_pi_owner() {
    *uaddr = 0xC0000000;	   tsk = get_task(PID);
   }				   if (!tsk->flags & PF_EXITING) {
  ...				     attach();
  tsk->flags |= PF_EXITPIDONE;	   } else {
				     if (!(tsk->flags & PF_EXITPIDONE))
				       return -EAGAIN;
				     return -ESRCH; <--- FAIL
				   }

ESRCH is returned all the way to user space, which triggers the glibc test
case assert. Returning ESRCH unconditionally is wrong here because the user
space value has been changed by the exiting task to 0xC0000000, i.e. the
FUTEX_OWNER_DIED bit is set and the futex PID value has been cleared. This
is a valid state and the kernel has to handle it, i.e. taking the futex.

Cure it by rereading the user space value when PF_EXITING and PF_EXITPIDONE
is set in the task which 'owns' the futex. If the value has changed, let
the kernel retry the operation, which includes all regular sanity checks
and correctly handles the FUTEX_OWNER_DIED case.

If it hasn't changed, then return ESRCH as there is no way to distinguish
this case from malfunctioning user space. This happens when the exiting
task did not have a robust list, the robust list was corrupted or the user
space value in the futex was simply bogus.

Reported-by: Stefan Liebler <stli@linux.ibm.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Acked-by: Peter Zijlstra <peterz@infradead.org>
Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
Cc: Darren Hart <dvhart@infradead.org>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Sasha Levin <sashal@kernel.org>
Cc: stable@vger.kernel.org
Link: https://bugzilla.kernel.org/show_bug.cgi?id=200467
Link: https://lkml.kernel.org/r/20181210152311.986181245@linutronix.de
---
 kernel/futex.c | 69 +++++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 63 insertions(+), 6 deletions(-)

diff --git a/kernel/futex.c b/kernel/futex.c
index f423f9b6577e..5cc8083a4c89 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -1148,11 +1148,65 @@ out_error:
 	return ret;
 }
 
+static int handle_exit_race(u32 __user *uaddr, u32 uval,
+			    struct task_struct *tsk)
+{
+	u32 uval2;
+
+	/*
+	 * If PF_EXITPIDONE is not yet set, then try again.
+	 */
+	if (tsk && !(tsk->flags & PF_EXITPIDONE))
+		return -EAGAIN;
+
+	/*
+	 * Reread the user space value to handle the following situation:
+	 *
+	 * CPU0				CPU1
+	 *
+	 * sys_exit()			sys_futex()
+	 *  do_exit()			 futex_lock_pi()
+	 *                                futex_lock_pi_atomic()
+	 *   exit_signals(tsk)		    No waiters:
+	 *    tsk->flags |= PF_EXITING;	    *uaddr == 0x00000PID
+	 *  mm_release(tsk)		    Set waiter bit
+	 *   exit_robust_list(tsk) {	    *uaddr = 0x80000PID;
+	 *      Set owner died		    attach_to_pi_owner() {
+	 *    *uaddr = 0xC0000000;	     tsk = get_task(PID);
+	 *   }				     if (!tsk->flags & PF_EXITING) {
+	 *  ...				       attach();
+	 *  tsk->flags |= PF_EXITPIDONE;     } else {
+	 *				       if (!(tsk->flags & PF_EXITPIDONE))
+	 *				         return -EAGAIN;
+	 *				       return -ESRCH; <--- FAIL
+	 *				     }
+	 *
+	 * Returning ESRCH unconditionally is wrong here because the
+	 * user space value has been changed by the exiting task.
+	 *
+	 * The same logic applies to the case where the exiting task is
+	 * already gone.
+	 */
+	if (get_futex_value_locked(&uval2, uaddr))
+		return -EFAULT;
+
+	/* If the user space value has changed, try again. */
+	if (uval2 != uval)
+		return -EAGAIN;
+
+	/*
+	 * The exiting task did not have a robust list, the robust list was
+	 * corrupted or the user space value in *uaddr is simply bogus.
+	 * Give up and tell user space.
+	 */
+	return -ESRCH;
+}
+
 /*
  * Lookup the task for the TID provided from user space and attach to
  * it after doing proper sanity checks.
  */
-static int attach_to_pi_owner(u32 uval, union futex_key *key,
+static int attach_to_pi_owner(u32 __user *uaddr, u32 uval, union futex_key *key,
 			      struct futex_pi_state **ps)
 {
 	pid_t pid = uval & FUTEX_TID_MASK;
@@ -1162,12 +1216,15 @@ static int attach_to_pi_owner(u32 uval, union futex_key *key,
 	/*
 	 * We are the first waiter - try to look up the real owner and attach
 	 * the new pi_state to it, but bail out when TID = 0 [1]
+	 *
+	 * The !pid check is paranoid. None of the call sites should end up
+	 * with pid == 0, but better safe than sorry. Let the caller retry
 	 */
 	if (!pid)
-		return -ESRCH;
+		return -EAGAIN;
 	p = find_get_task_by_vpid(pid);
 	if (!p)
-		return -ESRCH;
+		return handle_exit_race(uaddr, uval, NULL);
 
 	if (unlikely(p->flags & PF_KTHREAD)) {
 		put_task_struct(p);
@@ -1187,7 +1244,7 @@ static int attach_to_pi_owner(u32 uval, union futex_key *key,
 		 * set, we know that the task has finished the
 		 * cleanup:
 		 */
-		int ret = (p->flags & PF_EXITPIDONE) ? -ESRCH : -EAGAIN;
+		int ret = handle_exit_race(uaddr, uval, p);
 
 		raw_spin_unlock_irq(&p->pi_lock);
 		put_task_struct(p);
@@ -1244,7 +1301,7 @@ static int lookup_pi_state(u32 __user *uaddr, u32 uval,
 	 * We are the first waiter - try to look up the owner based on
 	 * @uval and attach to it.
 	 */
-	return attach_to_pi_owner(uval, key, ps);
+	return attach_to_pi_owner(uaddr, uval, key, ps);
 }
 
 static int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)
@@ -1352,7 +1409,7 @@ static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,
 	 * attach to the owner. If that fails, no harm done, we only
 	 * set the FUTEX_WAITERS bit in the user space variable.
 	 */
-	return attach_to_pi_owner(uval, key, ps);
+	return attach_to_pi_owner(uaddr, newval, key, ps);
 }
 
 /**
