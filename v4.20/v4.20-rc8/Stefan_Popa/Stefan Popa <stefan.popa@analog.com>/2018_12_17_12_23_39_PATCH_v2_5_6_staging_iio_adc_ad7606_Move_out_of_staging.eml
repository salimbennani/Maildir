Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  18 Dec 2018 08:43:20 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga006.jf.intel.com (orsmga006.jf.intel.com [10.7.209.51])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 8F7045805AD;
	Mon, 17 Dec 2018 04:27:57 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga006-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 17 Dec 2018 04:27:57 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AlUIDKhTBeY9e77JUYR2fEh7xrdpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YByEt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KptVRTmij?=
 =?us-ascii?q?oINyQh/W/XlMJ+kaxVrhGmqRN9zY7bb52aNOFmfq7fZt4aWXZNU9xNWyFbHo+w?=
 =?us-ascii?q?c40CBPcBM+ZCqIn9okMDowaiBQayCuPg0DlIjWLs0609y+QuCxzN0Qs7H9ISrn?=
 =?us-ascii?q?vUos/6NKEIXeCty6nI1S/MYuhM1jf78ofIdhchof6WUb1sdsrRzFAiGgXYhVue?=
 =?us-ascii?q?rozlOima1uULs2WD9eVgU/igi2ogqwF+uDSg2sAsiozPi4kIyV7E7T10zJgpKd?=
 =?us-ascii?q?C8UkJ3fNCpHIVKuy2HNIZ6XtkuTmBqtSoi17ELt5y2cDIIxZg63RLTdfyKf5KI?=
 =?us-ascii?q?7x/jUuuaPC12i2h/eL2lgha/6UigxfP4VsmzyFtKsCVFncfWtnwX1Bzc9NKHSv?=
 =?us-ascii?q?1j8UelwzqP0BrT6u5cLUA1k6rUNYIhz6YumpYPtUnPBDL6lUvogKOMa0kp+fSk?=
 =?us-ascii?q?5/7mb7jkvpOcMpV7igD6MqQggMy/BuE4PxAKX2ia/+S8ybLi8VT6QLpUlP02lL?=
 =?us-ascii?q?fWsJTDKcQcqK+5BRFa0pw45hahADepzs4YkWMELF1bYhKHiZbmO1XULPD/F/e/?=
 =?us-ascii?q?jEygkC13yPDeIr3hHpLNI2DHkLfgfrZy9VRQyQUuzd1E45JUC7cBIO/8W0Prtd?=
 =?us-ascii?q?zYCAM5PBKww+r9FNp90YYeU3qVAqCFKKPSrUOI5uU3LumMfoAVuSr9JOIi5/L0?=
 =?us-ascii?q?jX85hEUSfa+m3ZYMbHC4H/JmI1iWYHb2g9cBF3sKsRQ6TODwlFKCVjtTbW6oX6?=
 =?us-ascii?q?0g/jE7FJ6mDYDbS4Cvh7yOwj23Hp5RZmBADFCMFmzld4GFW/cKdSKTLdVtkj0C?=
 =?us-ascii?q?Vbi9VYAh0QuiuxP9y7piNuDU4DEXtYr/1Nhp4O3ejQs99Sd0D8Sa0GGBVXt0kX?=
 =?us-ascii?q?kKRzIt2KB/oEp9ykqM0KRigvxYE8BT6O1NUgsgKZHcyOl6AcjoWg3dZteJVEqm?=
 =?us-ascii?q?QtK+DDEyVN0xxcUCY0J8G9q4iBDD0DGnA7sUl7yNGZw1/bjQ33n3J8Zh1XnG0L?=
 =?us-ascii?q?MtgEUhQstKLWemnLJw9xDPB47VlEWUj7uler4C3CHT7muDzXCBvEdDUAFuV6XJ?=
 =?us-ascii?q?WnQfZkjTrdT9/U7CS76uCbI6MgpO08KCK61KasH3glVCXvvsJNPeY2epkWeqGR?=
 =?us-ascii?q?mI3q+MbJbte2gFwSrSElYEnB4J8XaGLwc+ADyhrHzYDDF1EVLvYkXs8fRxqX+h?=
 =?us-ascii?q?T080yR2KYFNl17av5hEVgvmcQesJ3r0YoCchtyl0HFGl0tLKCtqAog1hfLlcYd?=
 =?us-ascii?q?I9+ltHyXjVtwtnPpykLqBigFEefh9zv0Pv0RV3F4pBndIrrHMs0Ap9N6aY3Eld?=
 =?us-ascii?q?eDOf2JD6IqfXJXXq/BCzd67W3UnT38yS+qgR5/U3tVXisBuyGUo/7npoyd9V03?=
 =?us-ascii?q?ib5pXUFwcSVZPxUkAq9xl1vb3aYy8955/K2n1oK6W7rjjC29cxDus/1hmgZ8tf?=
 =?us-ascii?q?ML+DFALqE8waGtKiJ/Awl1mobhILJuZS9KEvMsOidvuG3rOrPel6kDKni2RH/J?=
 =?us-ascii?q?5y0kaW+yVgTe7I2o4Pw+uE0QufSzf8kFChv9jtmYBFeT4dBHC/xjXjBIJLYK19?=
 =?us-ascii?q?Y5wLCWa3L8Kr3Np+g4PiVGBC9F6kAVMLw8upeRuUb1zg0gxcz0UXoXq7mSSmyz?=
 =?us-ascii?q?x4iS0mrq2a3CbW2eTtaAIHOnJXRGlllVrtIYm0g8oaXUSydAgpiR2l6F3+x6ha?=
 =?us-ascii?q?oqR/MmbSTV1JfyjwM2FtTK+wuqCebM5I7ZMiqT9XX/ikYVCGVr79pAMX0yH5EG?=
 =?us-ascii?q?tExzA7dDaqto/inxNgi2KdL3dzrHzHdsF23hrf4N3cRfhM3jsJXiV4iD/XBkSi?=
 =?us-ascii?q?MNmt59mbi5DDsuWmXWK7SpJTaTXrzZ+HtCaj5WxlGxq/k+qxmt3mFwg3yiv719?=
 =?us-ascii?q?hsVSXVoxfweIjr16KmMe15eklkHkPz681/GotmiIs/mIkQ2WQGhpWS5XcHkn38?=
 =?us-ascii?q?MdRB1aL+cXoCXzgLw9HO7Qjh2U1jKG+Jxo3jWnWcxMthe8e1YmcM1i0h6MBKDb?=
 =?us-ascii?q?+e7KZYkittvlq4sQXRbOB4njccyvsh8mQWgu8Xtwo20iWSHKoSElJGMiz2mBSF?=
 =?us-ascii?q?9NS+rKRRZGayfrm8zkt+nda9DL6cpgFQQmr2epAnHSVo9MVwLErM0GHv6oHjYN?=
 =?us-ascii?q?TQcdUTthiOnxbBledVLo8xluERhSpmIm/9uXwly+gmjR1hx526vY6HK3lz86K9?=
 =?us-ascii?q?GBJXKjr1Z8YL8DH3kalehtqW35yoHph5AToERpzoTfa1ED4IsfTnKh2DEDk9qn?=
 =?us-ascii?q?edBLreEhWT6EZgr3LTDZ+rM2ubK2UezdVnXBOdPlBQgBgIXDUmmZ40DgKqy9bk?=
 =?us-ascii?q?cEhn/TAd/EL4pgFPyuJ1NBn/T2Hfqx2zajovTJifLRxW7hxN5kvPMMye6P5zED?=
 =?us-ascii?q?9c/pG7sAONLWmbbRxSDW4VQkyEG0zjPr626NjA9OiYG/O+L+bUbrWIs+BeTPCI?=
 =?us-ascii?q?xZSg0oZ9+zaMN8OPPmRtDvEh20pDW2x5FNrdmzkVVyMXkCfNZdaBpBig4i13st?=
 =?us-ascii?q?y/8PPzVQLv+4SPCrhSMdZu+xysgqeDLemQhClnJjZCy5MM3mTFyLwe3F4UliFv?=
 =?us-ascii?q?eCOhEbUGtS7RUq3QnrVbAAIcayN2LMFI9b4z3hFROc7HjdP4zqR3juMuBFdfS1?=
 =?us-ascii?q?PgmtulZcgLI2ymMFPHBUCLNKmJJDHRwsH3Z7+8RqNUjOlOqxKwvjObGVf5Pjuf?=
 =?us-ascii?q?jznpSwyvMeZUgSGHPRxevZuxfQp3BWf/TNLpdBu7PcRzjT03x700m3zLOXQdMT?=
 =?us-ascii?q?h6b0NCsLmQ4TlEjfV4HmxL9mBlIvWcmyaF8+nYLY4bsPtxDSRykuJa4XI6xKNU?=
 =?us-ascii?q?7SFEXvN1niTSo8Vqo1GnlOmP1zVmXABPqjZNmIKEo0FiNb/F+ZlHXHaXtC4KuD?=
 =?us-ascii?q?GSCh9Q/PNmB8fptqQWzcLAwua7fC1F+dKX8dc0BMXOLs+Ddn07PkytUGrRBREG?=
 =?us-ascii?q?CyS2KWXWgUB1meuXsHaSq85phILrnc81VrJVXVp9LvQCAwwxB8APLp5xGCsjib?=
 =?us-ascii?q?ezhcgB4X2x6hLWQZMJ7dj8SvuODKC3e36ihr5eak5QzA=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ARAAAIlRdch0O0hNFkHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBgTBQaXMHCCeHRAGEUIssgmuXRBSBEANQDgEBGAsIAYdVIjQJDQE?=
 =?us-ascii?q?DAQEBAQEBAgETAQEBCgsJCCkjDII2IoJlAwMBAhcBDBkBATcBBQkBAVADVAYBC?=
 =?us-ascii?q?QQFBQ+DDgGBaAMVAQICCp0GAgKKCIFsM4J2AQEFhHgYggkIh31Vg2yBVz8Sf4d?=
 =?us-ascii?q?YHwUMhWqJOgoogUyEF4FPj30HAoIkBIRlik0CFoFdiE2HKIgPgS2EdosLAgICA?=
 =?us-ascii?q?gQFAg0BAQQBgUaCDjMaI4M8CYISDBeDSopVcIEFAQGLJCuCIAEB?=
X-IPAS-Result: =?us-ascii?q?A0ARAAAIlRdch0O0hNFkHAEBAQQBAQcEAQGBUQcBAQsBgTB?=
 =?us-ascii?q?QaXMHCCeHRAGEUIssgmuXRBSBEANQDgEBGAsIAYdVIjQJDQEDAQEBAQEBAgETA?=
 =?us-ascii?q?QEBCgsJCCkjDII2IoJlAwMBAhcBDBkBATcBBQkBAVADVAYBCQQFBQ+DDgGBaAM?=
 =?us-ascii?q?VAQICCp0GAgKKCIFsM4J2AQEFhHgYggkIh31Vg2yBVz8Sf4dYHwUMhWqJOgoog?=
 =?us-ascii?q?UyEF4FPj30HAoIkBIRlik0CFoFdiE2HKIgPgS2EdosLAgICAgQFAg0BAQQBgUa?=
 =?us-ascii?q?CDjMaI4M8CYISDBeDSopVcIEFAQGLJCuCIAEB?=
X-IronPort-AV: E=Sophos;i="5.56,365,1539673200"; 
   d="scan'208";a="56650209"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 17 Dec 2018 04:27:51 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1732803AbeLQM1r (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Mon, 17 Dec 2018 07:27:47 -0500
Received: from mail-eopbgr740055.outbound.protection.outlook.com ([40.107.74.55]:18762
        "EHLO NAM01-BN3-obe.outbound.protection.outlook.com"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1726938AbeLQM1q (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 17 Dec 2018 07:27:46 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=analog.onmicrosoft.com; s=selector1-analog-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=5J2euVfYvogJ9rk2LM3EysI3aCz0xMeP+G0wAOlD1No=;
 b=EFIt14RUFrp4HIpXpp0XA5vvWTmWbSoxn1zeUN57tSRZw2Uis1SLfCENR9XQVIQXIcVnVe3soY4h5+HXUAR8XXDUmkmgkXg33+oChposm3mS3rxnEZ9gfiHzXL/d1M26y7cDZt3h6fqkmtnzy3e2A/Q//1xkIVPqwWrCyMC3GQU=
Received: from MWHPR03CA0045.namprd03.prod.outlook.com (2603:10b6:301:3b::34)
 by DM6PR03MB3721.namprd03.prod.outlook.com (2603:10b6:5:ac::14) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.1425.18; Mon, 17 Dec
 2018 12:26:26 +0000
Received: from BN1BFFO11FD026.protection.gbl (2a01:111:f400:7c10::1:194) by
 MWHPR03CA0045.outlook.office365.com (2603:10b6:301:3b::34) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1425.19 via Frontend Transport; Mon, 17 Dec 2018 12:26:26 +0000
Authentication-Results: spf=pass (sender IP is 137.71.25.55)
 smtp.mailfrom=analog.com; gmx.de; dkim=none (message not signed)
 header.d=none;gmx.de; dmarc=bestguesspass action=none header.from=analog.com;
Received: from nwd2mta1.analog.com (137.71.25.55) by
 BN1BFFO11FD026.mail.protection.outlook.com (10.58.144.89) with Microsoft SMTP
 Server (version=TLS1_0, cipher=TLS_RSA_WITH_AES_256_CBC_SHA) id 15.20.1446.11
 via Frontend Transport; Mon, 17 Dec 2018 12:26:25 +0000
Received: from NWD2HUBCAS7.ad.analog.com (nwd2hubcas7.ad.analog.com [10.64.69.107])
        by nwd2mta1.analog.com (8.13.8/8.13.8) with ESMTP id wBHCQPdj016802
        (version=TLSv1/SSLv3 cipher=AES256-SHA bits=256 verify=OK);
        Mon, 17 Dec 2018 04:26:25 -0800
Received: from linux.analog.com (10.50.1.118) by NWD2HUBCAS7.ad.analog.com
 (10.64.69.107) with Microsoft SMTP Server id 14.3.408.0; Mon, 17 Dec 2018
 07:26:24 -0500
From: Stefan Popa <stefan.popa@analog.com>
To: <jic23@kernel.org>, <robh+dt@kernel.org>, <mark.rutland@arm.com>
CC: Stefan Popa <stefan.popa@analog.com>,
        <Michael.Hennerich@analog.com>, <knaack.h@gmx.de>,
        <lars@metafoo.de>, <pmeerw@pmeerw.net>,
        <gregkh@linuxfoundation.org>, <linux-kernel@vger.kernel.org>,
        <linux-iio@vger.kernel.org>, <devel@driverdev.osuosl.org>
Subject: [PATCH v2 5/6] staging: iio: adc: ad7606: Move out of staging
Date: Mon, 17 Dec 2018 14:23:39 +0200
Message-ID: <1545049420-16484-6-git-send-email-stefan.popa@analog.com>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <1545049420-16484-1-git-send-email-stefan.popa@analog.com>
References: <1545049420-16484-1-git-send-email-stefan.popa@analog.com>
MIME-Version: 1.0
Content-Type: text/plain
X-ADIRoutedOnPrem: True
X-EOPAttributedMessage: 0
X-MS-Office365-Filtering-HT: Tenant
X-Forefront-Antispam-Report: CIP:137.71.25.55;IPV:NLI;CTRY:US;EFV:NLI;SFV:NSPM;SFS:(10009020)(396003)(39860400002)(346002)(376002)(136003)(2980300002)(3190300001)(199004)(189003)(246002)(126002)(11346002)(446003)(36756003)(116002)(2906002)(486006)(48376002)(44832011)(2616005)(51416003)(26005)(14444005)(106466001)(476003)(336012)(7696005)(426003)(186003)(50466002)(72206003)(5660300001)(966005)(6666004)(7416002)(53416004)(50226002)(77096007)(53946003)(356004)(8936002)(4744004)(6306002)(478600001)(305945005)(47776003)(16586007)(54906003)(110136005)(106002)(4326008)(7636002)(8676002)(316002)(76176011)(579004)(559001);DIR:OUT;SFP:1101;SCL:1;SRVR:DM6PR03MB3721;H:nwd2mta1.analog.com;FPR:;SPF:Pass;LANG:en;PTR:nwd2mail10.analog.com;A:1;MX:1;
X-Microsoft-Exchange-Diagnostics: 1;BN1BFFO11FD026;1:CHA7zVNdGUeo2Y7jpkb+KL4sAK3CuZ/7lxbrjQux/LqdhfGaid+s+8tfrJWAkNkwilpwciQMcRKIjeFumnotKkMWGH+/ist7ielRTtrh2T45ObnnOyvK5z81OUODC6Ww
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: 17756b6d-3e0d-4118-4005-08d6641add14
X-Microsoft-Antispam: BCL:0;PCL:0;RULEID:(2390118)(7020095)(4652040)(8989299)(4534185)(4627221)(201703031133081)(201702281549075)(8990200)(5600074)(711020)(4608076)(2017052603328)(7153060);SRVR:DM6PR03MB3721;
X-Microsoft-Exchange-Diagnostics: 1;DM6PR03MB3721;3:nGKMkgAsMO4fC19ER3Kf4iMIuuzeoo7+CkmoL/XbAARs5NFNQDMFGHn9V2Hg4QqvLVUOrYpGi9F0miv3tjXuGpGqDUDj6qIuTc/VjNy/jyP7pFRSGUjaKooCcEPYNNAxo3XU8k42M3OjDlOi43Kqd8iyoC7OXvb73drrzZjlx47dVr8AgieK7agJxQiOrKdnifrQbW+3wqKw8AMrxE+yB9jMSECljt5u8KDSpirTVGCNNORbp9kTp63KG3C6MkSeIsCsxTCCcXJXEeu/Q966jdpmRmILawxJuozD3BVlD/FDzRFuJlgmYjccgq15ffI6m8sN5xLN+r5kyx8IFpLI4vWGgC+iYdLJw8CV14TA7ME=;25:1vRjDQeFbGP9njMNgMkrSWGsYbUxMQHdEUVEWuiW66uCXqz/fA/Pkop8rREjmwAOQDfFLJoFc1ndTtLUAmPvHH3qAIPbuvm9odRqUB0+alLFE7Ev94CdnMxYU8CUw0LipYAVSPPEZDKpvg8op2aTGYGfQRqT0Q7Gh1DUNpINJGHfu9qNWLij2ZqzK60gvF9hMY4ySZYq6vRXP4jOk0HD5dN24XXAciN/dgg2Bbcqv9HkDklk9kfJWnno80jktVxcXs9n/A9+MEz/Ww7s3Qy5F1Z7UePrJPhVwZz1bIXNtIRbwFt4qNIxfHTTN/PjL/gWYqsqqrLY1TIyqdp1pNovAQ==
X-MS-TrafficTypeDiagnostic: DM6PR03MB3721:
X-Microsoft-Exchange-Diagnostics: 1;DM6PR03MB3721;31:98RuUFqAJhAdz4tx/iQxfxs2A1zX9w16EM141m3WBpyldxq30kBP6kCLYCZdtuRxFZOBE5ZQLOKTvA9/Aw6KdRFLfDWqFCUqrb6vkz7cFULSQV1BiFSd+XZmTyqbTrk8HAcsoyDLPUkvO8sUzlH2Qh01F3dx2Wf4hIU3g80CH5uRYcsORv8yV2VoPY7GeDgRoJJS8giK1xynsIMQCneSBD7Rmfa4GNXyosrp0hMz8Kg=;20:8o+lISLRHXCJVz8WPFyQggmnd4Zas7RdhdBLfZrbMMJnpNd9/p5xY6Ptsd8nRkOzWjIWrHKqJJtkWtpuWhz+h6akfaO4qlNxpP1CG7uiiCjxPyJnl+3kk/fMk9esRu2UEGlqzT+H7ziloN0jis13lGgbxWd5SuzGH5S1pMj2DoZ3+4fzXbz0cD6FLAsZDyUzjw6dSy2dNLxuZooyt5CHiY5hC5BUHtid/br4TZ5OnLkho4J61q1+ZiC6SBBkLCwFrkv0k4IBogBMMtuP0Hja2v5RyEKQPWkVdpxU2ZRE2b73MTwIcOSh15PyfueJiFuifHtrT9s2GkSENPZHpxP0sm7BI5OLxJanQni1nxOoJ09oKW0KvQasUKSH8vwUT3XAyqDph+8HtgcgIxyeNpaH7aJDw5aLsicwnl2PRCB8Duz6+F6NOMUSK2iWlUOfpEtArO8jeUdEI5YLop21mvXAtOfLAgTrFFAud3C6cpE5GxpZQ17/Tfqsxxw3N//bLbwf
X-Microsoft-Antispam-PRVS: <DM6PR03MB37219CD4D0B2FB17425863B99DBC0@DM6PR03MB3721.namprd03.prod.outlook.com>
X-MS-Exchange-SenderADCheck: 1
X-Exchange-Antispam-Report-CFA-Test: BCL:0;PCL:0;RULEID:(8211001083)(3230021)(999002)(6040522)(2401047)(8121501046)(5005006)(10201501046)(3231475)(944501520)(4982022)(52105112)(3002001)(93006095)(93004095)(6055026)(148016)(149066)(150057)(6041310)(20161123562045)(20161123560045)(20161123558120)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(20161123564045)(201708071742011)(7699051)(76991095);SRVR:DM6PR03MB3721;BCL:0;PCL:0;RULEID:;SRVR:DM6PR03MB3721;
X-Microsoft-Exchange-Diagnostics: 1;DM6PR03MB3721;4:onQReeQgulUWOjOmn2GDHAtI6htGGjxlNyoeEtaQ1hReVTF6b4/CJ5cqCF6YB0cwWvnkTB6oNnJ1rxYUp+pUzqBz3yob96QYYLg2UTNb9Ktv8UmS7vhm4kFOUnWpLXHgdhPDRW1RjLKjG4X1t67XJsCu1hnkUQ3E0OSzX8GQuF7uRBFNICOybYeEOjkNUIeTbR15xDMqKVaAoIOTKnqQ3LJmLHeQtb8TKAw3tcZWjKJ1rYDcPdv+doDERp/xD+NoEJ0MkOGPzK94XYxlzuBDhg==
X-Forefront-PRVS: 08897B549D
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1;DM6PR03MB3721;23:+9fEagdtMwfmT2Nccqm6Jaqr9Ko77C6jx0LnDvmOj?=
 =?us-ascii?Q?X0jiFy3trjmPJeFnCmU6awa4JH7w3nDG4A5wxk3H/Ezabhk6Dwpz+qSmpP3h?=
 =?us-ascii?Q?v52z577nm3r7CeVgVvTTFJONAvs/PTUorIezs1ioEoXuN8NSvrQ/uI9o0yhK?=
 =?us-ascii?Q?xbjTXUKq+KH1Z+55yXnhOfQ9nxlgXoKVijyIB0kvlHw8KDddYqH13ioNn5T6?=
 =?us-ascii?Q?7c9YvSiuq3V2Cx7hKMzOOib1UzD3vbEwc6uwSldpJ67lyWUQwp5ljEOOD3/7?=
 =?us-ascii?Q?0zKfP3ZueXNzpUjsWchqHV4Io/UwdORyhWyEIlL/sa5hcVnIq8EqU0oiS3qE?=
 =?us-ascii?Q?5rX6wDY9pwhQtieaQUpXp9U/yyVTcT6tbcOacsKUzjBpdR8xmSkXnvxDkoCA?=
 =?us-ascii?Q?+Qh6e98lDABQy85DaU3epKG21rJFgZ7mzCspSnxQncBtUeS52RUIgBpZuOLk?=
 =?us-ascii?Q?VTzM7Kpv9UNUD1VJZ2fSaGLqAh5mAkwPkKeP0rT8EQWdeodPsVkaqCFQLKzv?=
 =?us-ascii?Q?+BGnqahlNkU9a0qXEC9+jFUWUHAqB/DAguopZg9dlPcH4Yv2YkGs14l1pMu8?=
 =?us-ascii?Q?A2kD6NdKmC+479qy28teUYvF2WcyFXeClsleBoK9sMJus/ydVXeYZWOw7nP+?=
 =?us-ascii?Q?jC7X4JhFBOu0a/9d+Jf4iZ5B0XlH/Cui7ABw+NmW1wKriTKwG5YiDWOXFT94?=
 =?us-ascii?Q?mJDympiA6a+lsY341Yv/V6GYo/+o4sPvGSyEdCzwpKinRbDHG6e6QwcUlkAL?=
 =?us-ascii?Q?lp3joCoOh0lSjtm0ivBt4OAjF2fKDcoO1CnvmOoeXloRtSk3uKokuonY9RIc?=
 =?us-ascii?Q?lsSGAyCtPt2yOhKeAiCRBd88Ey2pn4H1Y9cHNdImAzJBPBSV5x7m7N81Ln67?=
 =?us-ascii?Q?bw42/y/EcsVkNx3N9xZqRB9zlPKMf7FJ81klbSjo8HVYcGjXhzs2l6MYEpIg?=
 =?us-ascii?Q?LncocbSj4iskEuXUqHXNXwPXxpdhQH8l9OppnoXwwQxyirVEluSWWHizoBY1?=
 =?us-ascii?Q?zkSjau0eype/SECoMMDjVb5a+LTNML3TM2K7C9qc169zDaR7ume0/Xc1ZpFr?=
 =?us-ascii?Q?qelSAPizcMk3kcAdpZ1wRBlBbWFpwsqoMKcvlSmK1xl4Am+N5h6oXXH+HLoi?=
 =?us-ascii?Q?o/U4OuzJ2e3MMw07VxLbR/wGxUoszuRA2/BzrEYelvXfdqhyPVnNoLhCKRYP?=
 =?us-ascii?Q?+vGTAr4rBUscO1G/d639VSdYyKn0Uv3WLY23CFzLuTHuOTBCY/jTeCb0Q=3D?=
 =?us-ascii?Q?=3D?=
X-Microsoft-Antispam-Message-Info: ZhyTsNejAMpW/46pfX3lOwWVSRkdGvsm1hjtupaUTPH2LGEXZgZ2V5Sjzsp4eDdlQskMygrOScSt+2yTYgWb1sE/z53SCjOWRK+rg8FBe4raSlq2rJxYRI7dawCH4Rc5EkthVVizccRF7NcgiVU1Wn85+itdEUkl9oFQro9Yz/k9jS+xGymRmW0C0xOn9rxXRUKzaDwzGJIQjok9D4+pmGUhGjDXwU5AvlHxXbuHTVPsP8lbEUXE9CqjzPyTfc1kvQmrhxtEElNIk7IslAC7Ac50Pof2qJ2vC0ejd9Ag0PQYXQk5jktzIqPukpOJSP7g
X-Microsoft-Exchange-Diagnostics: 1;DM6PR03MB3721;6:4FGnJWkYzKgYNCBLm0NBErvbTlcMUrr1a1n1S1lQPTJ3KENvtrINXCLkzw1M7uJmodQ+WMqmtVCOUbPt8tgexVowky5xUcygQLv/j9opr2ft/wxzWZccVWHqibY3s2JyfqxVV5cl38pw8Xy3RYUKFavZ3+qRCHZiFLjn+VErxLlxxuGSPXLE7imUVTP8bv2xgUlT/98PUSTpoo75JhbkWCQDvhHBEkcbu0Abmwstg2+C/NPpuZ/zwGmEm3x03tvO6+6UOEGyPlibGh//eNiGf6xjoiFSuWlojtMKM2ROjwVmguaheGKN1NSyohXmBtBDlz/DpwmcMeq2VwJsNci5La/K/ck/2b6vMktLo4xVjHIk6AIoSH4DdetF/wQILMBQtZGF68lCJWyxyK6VWDcqUr2vuphoc31UY5DNIPhaASmNEg2RujwD6rszu7cS0AkEMu/xgSIHKIu0lZb6Nje7Og==;5:veQGZxWLxN36kb9p7kkwx3vZFnl1HsnISdwdo+UdKjpq3M46wBrL3i8KZWMlfsVnuUI2dh71M03pmiOwcXMSIQqKpeLAqB/rK688JxLKDf9FVjudT+bgRbBdRJkY92uxeq7NfZe8KzZePSF/C+3L+ov8sUmZdP8Pp8ecZI/oBZ4=;7:lWFr6rgqFNzFb6Rb3BdDGpnMc40FnMV7RzS742jAPY2hGMFIT3RibF8qvQejhVc386zpWSnxpJyT0tABnP7lC/FoRblAdETPRh3UnFX/PL0U6b+T3fd7fmhn8AgzkXOtGCTegX4vwvQHg5OSchZI+Q==
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-OriginatorOrg: analog.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Dec 2018 12:26:25.9273
 (UTC)
X-MS-Exchange-CrossTenant-Network-Message-Id: 17756b6d-3e0d-4118-4005-08d6641add14
X-MS-Exchange-CrossTenant-Id: eaa689b4-8f87-40e0-9c6f-7228de4d754a
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=eaa689b4-8f87-40e0-9c6f-7228de4d754a;Ip=[137.71.25.55];Helo=[nwd2mta1.analog.com]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM6PR03MB3721
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Move ad7606 ADC driver out of staging and into the mainline.

Signed-off-by: Stefan Popa <stefan.popa@analog.com>
---
 MAINTAINERS                          |   7 +
 drivers/iio/adc/Kconfig              |  27 ++
 drivers/iio/adc/Makefile             |   3 +
 drivers/iio/adc/ad7606.c             | 583 +++++++++++++++++++++++++++++++++++
 drivers/iio/adc/ad7606.h             |  99 ++++++
 drivers/iio/adc/ad7606_par.c         | 105 +++++++
 drivers/iio/adc/ad7606_spi.c         |  82 +++++
 drivers/staging/iio/adc/Kconfig      |  27 --
 drivers/staging/iio/adc/Makefile     |   4 -
 drivers/staging/iio/adc/ad7606.c     | 583 -----------------------------------
 drivers/staging/iio/adc/ad7606.h     |  99 ------
 drivers/staging/iio/adc/ad7606_par.c | 105 -------
 drivers/staging/iio/adc/ad7606_spi.c |  82 -----
 13 files changed, 906 insertions(+), 900 deletions(-)
 create mode 100644 drivers/iio/adc/ad7606.c
 create mode 100644 drivers/iio/adc/ad7606.h
 create mode 100644 drivers/iio/adc/ad7606_par.c
 create mode 100644 drivers/iio/adc/ad7606_spi.c
 delete mode 100644 drivers/staging/iio/adc/ad7606.c
 delete mode 100644 drivers/staging/iio/adc/ad7606.h
 delete mode 100644 drivers/staging/iio/adc/ad7606_par.c
 delete mode 100644 drivers/staging/iio/adc/ad7606_spi.c

diff --git a/MAINTAINERS b/MAINTAINERS
index db9fcf2..bc9f816 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -854,6 +854,13 @@ S:	Supported
 F:	drivers/iio/adc/ad7124.c
 F:	Documentation/devicetree/bindings/iio/adc/adi,ad7124.txt
 
+ANALOG DEVICES INC AD7606 DRIVER
+M:	Stefan Popa <stefan.popa@analog.com>
+L:	linux-iio@vger.kernel.org
+W:	http://ez.analog.com/community/linux-device-drivers
+S:	Supported
+F:	drivers/iio/adc/ad7606.c
+
 ANALOG DEVICES INC AD9389B DRIVER
 M:	Hans Verkuil <hans.verkuil@cisco.com>
 L:	linux-media@vger.kernel.org
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 7a3ca4e..f3cc7a3 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -69,6 +69,33 @@ config AD7476
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad7476.
 
+config AD7606
+	tristate
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+
+config AD7606_IFACE_PARALLEL
+	tristate "Analog Devices AD7606 ADC driver with parallel interface support"
+	depends on HAS_IOMEM
+	select AD7606
+	help
+	  Say yes here to build parallel interface support for Analog Devices:
+	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ad7606_parallel.
+
+config AD7606_IFACE_SPI
+	tristate "Analog Devices AD7606 ADC driver with spi interface support"
+	depends on SPI
+	select AD7606
+	help
+	  Say yes here to build spi interface support for Analog Devices:
+	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ad7606_spi.
+
 config AD7766
 	tristate "Analog Devices AD7766/AD7767 ADC driver"
 	depends on SPI_MASTER
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index 07df37f..ea50313 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -11,6 +11,9 @@ obj-$(CONFIG_AD7291) += ad7291.o
 obj-$(CONFIG_AD7298) += ad7298.o
 obj-$(CONFIG_AD7923) += ad7923.o
 obj-$(CONFIG_AD7476) += ad7476.o
+obj-$(CONFIG_AD7606_IFACE_PARALLEL) += ad7606_par.o
+obj-$(CONFIG_AD7606_IFACE_SPI) += ad7606_spi.o
+obj-$(CONFIG_AD7606) += ad7606.o
 obj-$(CONFIG_AD7766) += ad7766.o
 obj-$(CONFIG_AD7791) += ad7791.o
 obj-$(CONFIG_AD7793) += ad7793.o
diff --git a/drivers/iio/adc/ad7606.c b/drivers/iio/adc/ad7606.c
new file mode 100644
index 0000000..32854f1
--- /dev/null
+++ b/drivers/iio/adc/ad7606.c
@@ -0,0 +1,583 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * AD7606 SPI ADC driver
+ *
+ * Copyright 2011 Analog Devices Inc.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/util_macros.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+
+#include "ad7606.h"
+
+/*
+ * Scales are computed as 5000/32768 and 10000/32768 respectively,
+ * so that when applied to the raw values they provide mV values
+ */
+static const unsigned int scale_avail[2] = {
+	152588, 305176
+};
+
+static const unsigned int ad7606_oversampling_avail[7] = {
+	1, 2, 4, 8, 16, 32, 64,
+};
+
+static int ad7606_reset(struct ad7606_state *st)
+{
+	if (st->gpio_reset) {
+		gpiod_set_value(st->gpio_reset, 1);
+		ndelay(100); /* t_reset >= 100ns */
+		gpiod_set_value(st->gpio_reset, 0);
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int ad7606_read_samples(struct ad7606_state *st)
+{
+	unsigned int num = st->chip_info->num_channels;
+	u16 *data = st->data;
+	int ret;
+
+	/*
+	 * The frstdata signal is set to high while and after reading the sample
+	 * of the first channel and low for all other channels. This can be used
+	 * to check that the incoming data is correctly aligned. During normal
+	 * operation the data should never become unaligned, but some glitch or
+	 * electrostatic discharge might cause an extra read or clock cycle.
+	 * Monitoring the frstdata signal allows to recover from such failure
+	 * situations.
+	 */
+
+	if (st->gpio_frstdata) {
+		ret = st->bops->read_block(st->dev, 1, data);
+		if (ret)
+			return ret;
+
+		if (!gpiod_get_value(st->gpio_frstdata)) {
+			ad7606_reset(st);
+			return -EIO;
+		}
+
+		data++;
+		num--;
+	}
+
+	return st->bops->read_block(st->dev, num, data);
+}
+
+static irqreturn_t ad7606_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct ad7606_state *st = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	ret = ad7606_read_samples(st);
+	if (ret == 0)
+		iio_push_to_buffers_with_timestamp(indio_dev, st->data,
+						   iio_get_time_ns(indio_dev));
+
+	iio_trigger_notify_done(indio_dev->trig);
+	/* The rising edge of the CONVST signal starts a new conversion. */
+	gpiod_set_value(st->gpio_convst, 1);
+
+	mutex_unlock(&st->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned int ch)
+{
+	struct ad7606_state *st = iio_priv(indio_dev);
+	int ret;
+
+	gpiod_set_value(st->gpio_convst, 1);
+	ret = wait_for_completion_timeout(&st->completion,
+					  msecs_to_jiffies(1000));
+	if (!ret) {
+		ret = -ETIMEDOUT;
+		goto error_ret;
+	}
+
+	ret = ad7606_read_samples(st);
+	if (ret == 0)
+		ret = st->data[ch];
+
+error_ret:
+	gpiod_set_value(st->gpio_convst, 0);
+
+	return ret;
+}
+
+static int ad7606_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val,
+			   int *val2,
+			   long m)
+{
+	int ret;
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	switch (m) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		ret = ad7606_scan_direct(indio_dev, chan->address);
+		iio_device_release_direct_mode(indio_dev);
+
+		if (ret < 0)
+			return ret;
+		*val = (short)ret;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = scale_avail[st->range];
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*val = st->oversampling;
+		return IIO_VAL_INT;
+	}
+	return -EINVAL;
+}
+
+static ssize_t in_voltage_scale_available_show(struct device *dev,
+					       struct device_attribute *attr,
+					       char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < ARRAY_SIZE(scale_avail); i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
+				 scale_avail[i]);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static IIO_DEVICE_ATTR_RO(in_voltage_scale_available, 0);
+
+static int ad7606_write_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int val,
+			    int val2,
+			    long mask)
+{
+	struct ad7606_state *st = iio_priv(indio_dev);
+	DECLARE_BITMAP(values, 3);
+	int i;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		mutex_lock(&st->lock);
+		i = find_closest(val2, scale_avail, ARRAY_SIZE(scale_avail));
+		gpiod_set_value(st->gpio_range, i);
+		st->range = i;
+		mutex_unlock(&st->lock);
+
+		return 0;
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		if (val2)
+			return -EINVAL;
+		i = find_closest(val, ad7606_oversampling_avail,
+				 ARRAY_SIZE(ad7606_oversampling_avail));
+
+		values[0] = i;
+
+		mutex_lock(&st->lock);
+		gpiod_set_array_value(ARRAY_SIZE(values), st->gpio_os->desc,
+				      st->gpio_os->info, values);
+		st->oversampling = ad7606_oversampling_avail[i];
+		mutex_unlock(&st->lock);
+
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static IIO_CONST_ATTR(oversampling_ratio_available, "1 2 4 8 16 32 64");
+
+static struct attribute *ad7606_attributes_os_and_range[] = {
+	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
+	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ad7606_attribute_group_os_and_range = {
+	.attrs = ad7606_attributes_os_and_range,
+};
+
+static struct attribute *ad7606_attributes_os[] = {
+	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ad7606_attribute_group_os = {
+	.attrs = ad7606_attributes_os,
+};
+
+static struct attribute *ad7606_attributes_range[] = {
+	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ad7606_attribute_group_range = {
+	.attrs = ad7606_attributes_range,
+};
+
+#define AD760X_CHANNEL(num, mask) {				\
+		.type = IIO_VOLTAGE,				\
+		.indexed = 1,					\
+		.channel = num,					\
+		.address = num,					\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\
+		.info_mask_shared_by_all = mask,		\
+		.scan_index = num,				\
+		.scan_type = {					\
+			.sign = 's',				\
+			.realbits = 16,				\
+			.storagebits = 16,			\
+			.endianness = IIO_CPU,			\
+		},						\
+}
+
+#define AD7605_CHANNEL(num)	\
+	AD760X_CHANNEL(num, 0)
+
+#define AD7606_CHANNEL(num)	\
+	AD760X_CHANNEL(num, BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO))
+
+static const struct iio_chan_spec ad7605_channels[] = {
+	IIO_CHAN_SOFT_TIMESTAMP(4),
+	AD7605_CHANNEL(0),
+	AD7605_CHANNEL(1),
+	AD7605_CHANNEL(2),
+	AD7605_CHANNEL(3),
+};
+
+static const struct iio_chan_spec ad7606_channels[] = {
+	IIO_CHAN_SOFT_TIMESTAMP(8),
+	AD7606_CHANNEL(0),
+	AD7606_CHANNEL(1),
+	AD7606_CHANNEL(2),
+	AD7606_CHANNEL(3),
+	AD7606_CHANNEL(4),
+	AD7606_CHANNEL(5),
+	AD7606_CHANNEL(6),
+	AD7606_CHANNEL(7),
+};
+
+static const struct ad7606_chip_info ad7606_chip_info_tbl[] = {
+	/* More devices added in future */
+	[ID_AD7605_4] = {
+		.channels = ad7605_channels,
+		.num_channels = 5,
+	},
+	[ID_AD7606_8] = {
+		.channels = ad7606_channels,
+		.num_channels = 9,
+		.has_oversampling = true,
+	},
+	[ID_AD7606_6] = {
+		.channels = ad7606_channels,
+		.num_channels = 7,
+		.has_oversampling = true,
+	},
+	[ID_AD7606_4] = {
+		.channels = ad7606_channels,
+		.num_channels = 5,
+		.has_oversampling = true,
+	},
+};
+
+static int ad7606_request_gpios(struct ad7606_state *st)
+{
+	struct device *dev = st->dev;
+
+	st->gpio_convst = devm_gpiod_get(dev, "adi,conversion-start",
+					 GPIOD_OUT_LOW);
+	if (IS_ERR(st->gpio_convst))
+		return PTR_ERR(st->gpio_convst);
+
+	st->gpio_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(st->gpio_reset))
+		return PTR_ERR(st->gpio_reset);
+
+	st->gpio_range = devm_gpiod_get_optional(dev, "adi,range",
+						 GPIOD_OUT_LOW);
+	if (IS_ERR(st->gpio_range))
+		return PTR_ERR(st->gpio_range);
+
+	st->gpio_standby = devm_gpiod_get_optional(dev, "standby",
+						   GPIOD_OUT_HIGH);
+	if (IS_ERR(st->gpio_standby))
+		return PTR_ERR(st->gpio_standby);
+
+	st->gpio_frstdata = devm_gpiod_get_optional(dev, "adi,first-data",
+						    GPIOD_IN);
+	if (IS_ERR(st->gpio_frstdata))
+		return PTR_ERR(st->gpio_frstdata);
+
+	if (!st->chip_info->has_oversampling)
+		return 0;
+
+	st->gpio_os = devm_gpiod_get_array_optional(dev,
+						    "adi,oversampling-ratio",
+						    GPIOD_OUT_LOW);
+	return PTR_ERR_OR_ZERO(st->gpio_os);
+}
+
+/*
+ * The BUSY signal indicates when conversions are in progress, so when a rising
+ * edge of CONVST is applied, BUSY goes logic high and transitions low at the
+ * end of the entire conversion process. The falling edge of the BUSY signal
+ * triggers this interrupt.
+ */
+static irqreturn_t ad7606_interrupt(int irq, void *dev_id)
+{
+	struct iio_dev *indio_dev = dev_id;
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	if (iio_buffer_enabled(indio_dev)) {
+		gpiod_set_value(st->gpio_convst, 0);
+		iio_trigger_poll_chained(st->trig);
+	} else {
+		complete(&st->completion);
+	}
+
+	return IRQ_HANDLED;
+};
+
+static int ad7606_validate_trigger(struct iio_dev *indio_dev,
+				   struct iio_trigger *trig)
+{
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	if (st->trig != trig)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int ad7606_buffer_postenable(struct iio_dev *indio_dev)
+{
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	iio_triggered_buffer_postenable(indio_dev);
+	gpiod_set_value(st->gpio_convst, 1);
+
+	return 0;
+}
+
+static int ad7606_buffer_predisable(struct iio_dev *indio_dev)
+{
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	gpiod_set_value(st->gpio_convst, 0);
+
+	return iio_triggered_buffer_predisable(indio_dev);
+}
+
+static const struct iio_buffer_setup_ops ad7606_buffer_ops = {
+	.postenable = &ad7606_buffer_postenable,
+	.predisable = &ad7606_buffer_predisable,
+};
+
+static const struct iio_info ad7606_info_no_os_or_range = {
+	.read_raw = &ad7606_read_raw,
+	.validate_trigger = &ad7606_validate_trigger,
+};
+
+static const struct iio_info ad7606_info_os_and_range = {
+	.read_raw = &ad7606_read_raw,
+	.write_raw = &ad7606_write_raw,
+	.attrs = &ad7606_attribute_group_os_and_range,
+	.validate_trigger = &ad7606_validate_trigger,
+};
+
+static const struct iio_info ad7606_info_os = {
+	.read_raw = &ad7606_read_raw,
+	.write_raw = &ad7606_write_raw,
+	.attrs = &ad7606_attribute_group_os,
+	.validate_trigger = &ad7606_validate_trigger,
+};
+
+static const struct iio_info ad7606_info_range = {
+	.read_raw = &ad7606_read_raw,
+	.write_raw = &ad7606_write_raw,
+	.attrs = &ad7606_attribute_group_range,
+	.validate_trigger = &ad7606_validate_trigger,
+};
+
+static const struct iio_trigger_ops ad7606_trigger_ops = {
+	.validate_device = iio_trigger_validate_own_device,
+};
+
+static void ad7606_regulator_disable(void *data)
+{
+	struct ad7606_state *st = data;
+
+	regulator_disable(st->reg);
+}
+
+int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
+		 const char *name, unsigned int id,
+		 const struct ad7606_bus_ops *bops)
+{
+	struct ad7606_state *st;
+	int ret;
+	struct iio_dev *indio_dev;
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*st));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	st = iio_priv(indio_dev);
+	dev_set_drvdata(dev, indio_dev);
+
+	st->dev = dev;
+	mutex_init(&st->lock);
+	st->bops = bops;
+	st->base_address = base_address;
+	/* tied to logic low, analog input range is +/- 5V */
+	st->range = 0;
+	st->oversampling = 1;
+
+	st->reg = devm_regulator_get(dev, "avcc");
+	if (IS_ERR(st->reg))
+		return PTR_ERR(st->reg);
+
+	ret = regulator_enable(st->reg);
+	if (ret) {
+		dev_err(dev, "Failed to enable specified AVcc supply\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev, ad7606_regulator_disable, st);
+	if (ret)
+		return ret;
+
+	st->chip_info = &ad7606_chip_info_tbl[id];
+
+	ret = ad7606_request_gpios(st);
+	if (ret)
+		return ret;
+
+	indio_dev->dev.parent = dev;
+	if (st->gpio_os) {
+		if (st->gpio_range)
+			indio_dev->info = &ad7606_info_os_and_range;
+		else
+			indio_dev->info = &ad7606_info_os;
+	} else {
+		if (st->gpio_range)
+			indio_dev->info = &ad7606_info_range;
+		else
+			indio_dev->info = &ad7606_info_no_os_or_range;
+	}
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->name = name;
+	indio_dev->channels = st->chip_info->channels;
+	indio_dev->num_channels = st->chip_info->num_channels;
+
+	init_completion(&st->completion);
+
+	ret = ad7606_reset(st);
+	if (ret)
+		dev_warn(st->dev, "failed to RESET: no RESET GPIO specified\n");
+
+	st->trig = devm_iio_trigger_alloc(dev, "%s-dev%d",
+					  indio_dev->name, indio_dev->id);
+	if (!st->trig)
+		return -ENOMEM;
+
+	st->trig->ops = &ad7606_trigger_ops;
+	st->trig->dev.parent = dev;
+	iio_trigger_set_drvdata(st->trig, indio_dev);
+	ret = devm_iio_trigger_register(dev, st->trig);
+	if (ret)
+		return ret;
+
+	indio_dev->trig = iio_trigger_get(st->trig);
+
+	ret = devm_request_threaded_irq(dev, irq,
+					NULL,
+					&ad7606_interrupt,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					name, indio_dev);
+	if (ret)
+		return ret;
+
+	ret = devm_iio_triggered_buffer_setup(dev, indio_dev,
+					      &iio_pollfunc_store_time,
+					      &ad7606_trigger_handler,
+					      &ad7606_buffer_ops);
+	if (ret)
+		return ret;
+
+	return devm_iio_device_register(dev, indio_dev);
+}
+EXPORT_SYMBOL_GPL(ad7606_probe);
+
+#ifdef CONFIG_PM_SLEEP
+
+static int ad7606_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	if (st->gpio_standby) {
+		gpiod_set_value(st->gpio_range, 1);
+		gpiod_set_value(st->gpio_standby, 0);
+	}
+
+	return 0;
+}
+
+static int ad7606_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	if (st->gpio_standby) {
+		gpiod_set_value(st->gpio_range, st->range);
+		gpiod_set_value(st->gpio_standby, 1);
+		ad7606_reset(st);
+	}
+
+	return 0;
+}
+
+SIMPLE_DEV_PM_OPS(ad7606_pm_ops, ad7606_suspend, ad7606_resume);
+EXPORT_SYMBOL_GPL(ad7606_pm_ops);
+
+#endif
+
+MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
+MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/ad7606.h b/drivers/iio/adc/ad7606.h
new file mode 100644
index 0000000..5d12410
--- /dev/null
+++ b/drivers/iio/adc/ad7606.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * AD7606 ADC driver
+ *
+ * Copyright 2011 Analog Devices Inc.
+ */
+
+#ifndef IIO_ADC_AD7606_H_
+#define IIO_ADC_AD7606_H_
+
+/**
+ * struct ad7606_chip_info - chip specific information
+ * @channels:		channel specification
+ * @num_channels:	number of channels
+ * @has_oversampling:   whether the device has oversampling support
+ */
+struct ad7606_chip_info {
+	const struct iio_chan_spec	*channels;
+	unsigned int			num_channels;
+	bool				has_oversampling;
+};
+
+/**
+ * struct ad7606_state - driver instance specific data
+ * @dev		pointer to kernel device
+ * @chip_info		entry in the table of chips that describes this device
+ * @reg		regulator info for the the power supply of the device
+ * @bops		bus operations (SPI or parallel)
+ * @range		voltage range selection, selects which scale to apply
+ * @oversampling	oversampling selection
+ * @base_address	address from where to read data in parallel operation
+ * @lock		protect sensor state from concurrent accesses to GPIOs
+ * @gpio_convst	GPIO descriptor for conversion start signal (CONVST)
+ * @gpio_reset		GPIO descriptor for device hard-reset
+ * @gpio_range		GPIO descriptor for range selection
+ * @gpio_standby	GPIO descriptor for stand-by signal (STBY),
+ *			controls power-down mode of device
+ * @gpio_frstdata	GPIO descriptor for reading from device when data
+ *			is being read on the first channel
+ * @gpio_os		GPIO descriptors to control oversampling on the device
+ * @complete		completion to indicate end of conversion
+ * @trig		The IIO trigger associated with the device.
+ * @data		buffer for reading data from the device
+ */
+struct ad7606_state {
+	struct device			*dev;
+	const struct ad7606_chip_info	*chip_info;
+	struct regulator		*reg;
+	const struct ad7606_bus_ops	*bops;
+	unsigned int			range;
+	unsigned int			oversampling;
+	void __iomem			*base_address;
+
+	struct mutex			lock; /* protect sensor state */
+	struct gpio_desc		*gpio_convst;
+	struct gpio_desc		*gpio_reset;
+	struct gpio_desc		*gpio_range;
+	struct gpio_desc		*gpio_standby;
+	struct gpio_desc		*gpio_frstdata;
+	struct gpio_descs		*gpio_os;
+	struct iio_trigger		*trig;
+	struct completion		completion;
+
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 * 8 * 16-bit samples + 64-bit timestamp
+	 */
+	unsigned short			data[12] ____cacheline_aligned;
+};
+
+/**
+ * struct ad7606_bus_ops - driver bus operations
+ * @read_block		function pointer for reading blocks of data
+ */
+struct ad7606_bus_ops {
+	/* more methods added in future? */
+	int (*read_block)(struct device *dev, int num, void *data);
+};
+
+int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
+		 const char *name, unsigned int id,
+		 const struct ad7606_bus_ops *bops);
+
+enum ad7606_supported_device_ids {
+	ID_AD7605_4,
+	ID_AD7606_8,
+	ID_AD7606_6,
+	ID_AD7606_4
+};
+
+#ifdef CONFIG_PM_SLEEP
+extern const struct dev_pm_ops ad7606_pm_ops;
+#define AD7606_PM_OPS (&ad7606_pm_ops)
+#else
+#define AD7606_PM_OPS NULL
+#endif
+
+#endif /* IIO_ADC_AD7606_H_ */
diff --git a/drivers/iio/adc/ad7606_par.c b/drivers/iio/adc/ad7606_par.c
new file mode 100644
index 0000000..df607c7
--- /dev/null
+++ b/drivers/iio/adc/ad7606_par.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * AD7606 Parallel Interface ADC driver
+ *
+ * Copyright 2011 Analog Devices Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <linux/iio/iio.h>
+#include "ad7606.h"
+
+static int ad7606_par16_read_block(struct device *dev,
+				   int count, void *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	insw((unsigned long)st->base_address, buf, count);
+
+	return 0;
+}
+
+static const struct ad7606_bus_ops ad7606_par16_bops = {
+	.read_block = ad7606_par16_read_block,
+};
+
+static int ad7606_par8_read_block(struct device *dev,
+				  int count, void *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7606_state *st = iio_priv(indio_dev);
+
+	insb((unsigned long)st->base_address, buf, count * 2);
+
+	return 0;
+}
+
+static const struct ad7606_bus_ops ad7606_par8_bops = {
+	.read_block = ad7606_par8_read_block,
+};
+
+static int ad7606_par_probe(struct platform_device *pdev)
+{
+	const struct platform_device_id *id = platform_get_device_id(pdev);
+	struct resource *res;
+	void __iomem *addr;
+	resource_size_t remap_size;
+	int irq;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "no irq: %d\n", irq);
+		return irq;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(addr))
+		return PTR_ERR(addr);
+
+	remap_size = resource_size(res);
+
+	return ad7606_probe(&pdev->dev, irq, addr,
+			    id->name, id->driver_data,
+			    remap_size > 1 ? &ad7606_par16_bops :
+			    &ad7606_par8_bops);
+}
+
+static const struct platform_device_id ad7606_driver_ids[] = {
+	{ .name	= "ad7605-4", .driver_data = ID_AD7605_4, },
+	{ .name	= "ad7606-4", .driver_data = ID_AD7606_4, },
+	{ .name	= "ad7606-6", .driver_data = ID_AD7606_6, },
+	{ .name	= "ad7606-8", .driver_data = ID_AD7606_8, },
+	{ }
+};
+MODULE_DEVICE_TABLE(platform, ad7606_driver_ids);
+
+static const struct of_device_id ad7606_of_match[] = {
+	{ .compatible = "adi,ad7605-4" },
+	{ .compatible = "adi,ad7606-4" },
+	{ .compatible = "adi,ad7606-6" },
+	{ .compatible = "adi,ad7606-8" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ad7606_of_match);
+
+static struct platform_driver ad7606_driver = {
+	.probe = ad7606_par_probe,
+	.id_table = ad7606_driver_ids,
+	.driver = {
+		.name = "ad7606",
+		.pm = AD7606_PM_OPS,
+		.of_match_table = ad7606_of_match,
+	},
+};
+module_platform_driver(ad7606_driver);
+
+MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
+MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/ad7606_spi.c b/drivers/iio/adc/ad7606_spi.c
new file mode 100644
index 0000000..f842eba
--- /dev/null
+++ b/drivers/iio/adc/ad7606_spi.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * AD7606 SPI ADC driver
+ *
+ * Copyright 2011 Analog Devices Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/err.h>
+
+#include <linux/iio/iio.h>
+#include "ad7606.h"
+
+#define MAX_SPI_FREQ_HZ		23500000	/* VDRIVE above 4.75 V */
+
+static int ad7606_spi_read_block(struct device *dev,
+				 int count, void *buf)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	int i, ret;
+	unsigned short *data = buf;
+	__be16 *bdata = buf;
+
+	ret = spi_read(spi, buf, count * 2);
+	if (ret < 0) {
+		dev_err(&spi->dev, "SPI read error\n");
+		return ret;
+	}
+
+	for (i = 0; i < count; i++)
+		data[i] = be16_to_cpu(bdata[i]);
+
+	return 0;
+}
+
+static const struct ad7606_bus_ops ad7606_spi_bops = {
+	.read_block = ad7606_spi_read_block,
+};
+
+static int ad7606_spi_probe(struct spi_device *spi)
+{
+	const struct spi_device_id *id = spi_get_device_id(spi);
+
+	return ad7606_probe(&spi->dev, spi->irq, NULL,
+			    id->name, id->driver_data,
+			    &ad7606_spi_bops);
+}
+
+static const struct spi_device_id ad7606_id_table[] = {
+	{ "ad7605-4", ID_AD7605_4 },
+	{ "ad7606-4", ID_AD7606_4 },
+	{ "ad7606-6", ID_AD7606_6 },
+	{ "ad7606-8", ID_AD7606_8 },
+	{}
+};
+MODULE_DEVICE_TABLE(spi, ad7606_id_table);
+
+static const struct of_device_id ad7606_of_match[] = {
+	{ .compatible = "adi,ad7605-4" },
+	{ .compatible = "adi,ad7606-4" },
+	{ .compatible = "adi,ad7606-6" },
+	{ .compatible = "adi,ad7606-8" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ad7606_of_match);
+
+static struct spi_driver ad7606_driver = {
+	.driver = {
+		.name = "ad7606",
+		.of_match_table = ad7606_of_match,
+		.pm = AD7606_PM_OPS,
+	},
+	.probe = ad7606_spi_probe,
+	.id_table = ad7606_id_table,
+};
+module_spi_driver(ad7606_driver);
+
+MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
+MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/iio/adc/Kconfig b/drivers/staging/iio/adc/Kconfig
index 302639a..7a93d3a 100644
--- a/drivers/staging/iio/adc/Kconfig
+++ b/drivers/staging/iio/adc/Kconfig
@@ -3,33 +3,6 @@
 #
 menu "Analog to digital converters"
 
-config AD7606
-	tristate
-	select IIO_BUFFER
-	select IIO_TRIGGERED_BUFFER
-
-config AD7606_IFACE_PARALLEL
-	tristate "Analog Devices AD7606 ADC driver with parallel interface support"
-	depends on HAS_IOMEM
-	select AD7606
-	help
-	  Say yes here to build parallel interface support for Analog Devices:
-	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called ad7606_parallel.
-
-config AD7606_IFACE_SPI
-	tristate "Analog Devices AD7606 ADC driver with spi interface support"
-	depends on SPI
-	select AD7606
-	help
-	  Say yes here to build spi interface support for Analog Devices:
-	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called ad7606_spi.
-
 config AD7780
 	tristate "Analog Devices AD7780 and similar ADCs driver"
 	depends on SPI
diff --git a/drivers/staging/iio/adc/Makefile b/drivers/staging/iio/adc/Makefile
index ebe83c1..7a42108 100644
--- a/drivers/staging/iio/adc/Makefile
+++ b/drivers/staging/iio/adc/Makefile
@@ -3,10 +3,6 @@
 # Makefile for industrial I/O ADC drivers
 #
 
-obj-$(CONFIG_AD7606_IFACE_PARALLEL) += ad7606_par.o
-obj-$(CONFIG_AD7606_IFACE_SPI) += ad7606_spi.o
-obj-$(CONFIG_AD7606) += ad7606.o
-
 obj-$(CONFIG_AD7780) += ad7780.o
 obj-$(CONFIG_AD7816) += ad7816.o
 obj-$(CONFIG_AD7192) += ad7192.o
diff --git a/drivers/staging/iio/adc/ad7606.c b/drivers/staging/iio/adc/ad7606.c
deleted file mode 100644
index 32854f1..0000000
--- a/drivers/staging/iio/adc/ad7606.c
+++ /dev/null
@@ -1,583 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * AD7606 SPI ADC driver
- *
- * Copyright 2011 Analog Devices Inc.
- */
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/gpio/consumer.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/regulator/consumer.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/sysfs.h>
-#include <linux/util_macros.h>
-
-#include <linux/iio/iio.h>
-#include <linux/iio/buffer.h>
-#include <linux/iio/sysfs.h>
-#include <linux/iio/trigger.h>
-#include <linux/iio/triggered_buffer.h>
-#include <linux/iio/trigger_consumer.h>
-
-#include "ad7606.h"
-
-/*
- * Scales are computed as 5000/32768 and 10000/32768 respectively,
- * so that when applied to the raw values they provide mV values
- */
-static const unsigned int scale_avail[2] = {
-	152588, 305176
-};
-
-static const unsigned int ad7606_oversampling_avail[7] = {
-	1, 2, 4, 8, 16, 32, 64,
-};
-
-static int ad7606_reset(struct ad7606_state *st)
-{
-	if (st->gpio_reset) {
-		gpiod_set_value(st->gpio_reset, 1);
-		ndelay(100); /* t_reset >= 100ns */
-		gpiod_set_value(st->gpio_reset, 0);
-		return 0;
-	}
-
-	return -ENODEV;
-}
-
-static int ad7606_read_samples(struct ad7606_state *st)
-{
-	unsigned int num = st->chip_info->num_channels;
-	u16 *data = st->data;
-	int ret;
-
-	/*
-	 * The frstdata signal is set to high while and after reading the sample
-	 * of the first channel and low for all other channels. This can be used
-	 * to check that the incoming data is correctly aligned. During normal
-	 * operation the data should never become unaligned, but some glitch or
-	 * electrostatic discharge might cause an extra read or clock cycle.
-	 * Monitoring the frstdata signal allows to recover from such failure
-	 * situations.
-	 */
-
-	if (st->gpio_frstdata) {
-		ret = st->bops->read_block(st->dev, 1, data);
-		if (ret)
-			return ret;
-
-		if (!gpiod_get_value(st->gpio_frstdata)) {
-			ad7606_reset(st);
-			return -EIO;
-		}
-
-		data++;
-		num--;
-	}
-
-	return st->bops->read_block(st->dev, num, data);
-}
-
-static irqreturn_t ad7606_trigger_handler(int irq, void *p)
-{
-	struct iio_poll_func *pf = p;
-	struct iio_dev *indio_dev = pf->indio_dev;
-	struct ad7606_state *st = iio_priv(indio_dev);
-	int ret;
-
-	mutex_lock(&st->lock);
-
-	ret = ad7606_read_samples(st);
-	if (ret == 0)
-		iio_push_to_buffers_with_timestamp(indio_dev, st->data,
-						   iio_get_time_ns(indio_dev));
-
-	iio_trigger_notify_done(indio_dev->trig);
-	/* The rising edge of the CONVST signal starts a new conversion. */
-	gpiod_set_value(st->gpio_convst, 1);
-
-	mutex_unlock(&st->lock);
-
-	return IRQ_HANDLED;
-}
-
-static int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned int ch)
-{
-	struct ad7606_state *st = iio_priv(indio_dev);
-	int ret;
-
-	gpiod_set_value(st->gpio_convst, 1);
-	ret = wait_for_completion_timeout(&st->completion,
-					  msecs_to_jiffies(1000));
-	if (!ret) {
-		ret = -ETIMEDOUT;
-		goto error_ret;
-	}
-
-	ret = ad7606_read_samples(st);
-	if (ret == 0)
-		ret = st->data[ch];
-
-error_ret:
-	gpiod_set_value(st->gpio_convst, 0);
-
-	return ret;
-}
-
-static int ad7606_read_raw(struct iio_dev *indio_dev,
-			   struct iio_chan_spec const *chan,
-			   int *val,
-			   int *val2,
-			   long m)
-{
-	int ret;
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	switch (m) {
-	case IIO_CHAN_INFO_RAW:
-		ret = iio_device_claim_direct_mode(indio_dev);
-		if (ret)
-			return ret;
-
-		ret = ad7606_scan_direct(indio_dev, chan->address);
-		iio_device_release_direct_mode(indio_dev);
-
-		if (ret < 0)
-			return ret;
-		*val = (short)ret;
-		return IIO_VAL_INT;
-	case IIO_CHAN_INFO_SCALE:
-		*val = 0;
-		*val2 = scale_avail[st->range];
-		return IIO_VAL_INT_PLUS_MICRO;
-	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
-		*val = st->oversampling;
-		return IIO_VAL_INT;
-	}
-	return -EINVAL;
-}
-
-static ssize_t in_voltage_scale_available_show(struct device *dev,
-					       struct device_attribute *attr,
-					       char *buf)
-{
-	int i, len = 0;
-
-	for (i = 0; i < ARRAY_SIZE(scale_avail); i++)
-		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
-				 scale_avail[i]);
-
-	buf[len - 1] = '\n';
-
-	return len;
-}
-
-static IIO_DEVICE_ATTR_RO(in_voltage_scale_available, 0);
-
-static int ad7606_write_raw(struct iio_dev *indio_dev,
-			    struct iio_chan_spec const *chan,
-			    int val,
-			    int val2,
-			    long mask)
-{
-	struct ad7606_state *st = iio_priv(indio_dev);
-	DECLARE_BITMAP(values, 3);
-	int i;
-
-	switch (mask) {
-	case IIO_CHAN_INFO_SCALE:
-		mutex_lock(&st->lock);
-		i = find_closest(val2, scale_avail, ARRAY_SIZE(scale_avail));
-		gpiod_set_value(st->gpio_range, i);
-		st->range = i;
-		mutex_unlock(&st->lock);
-
-		return 0;
-	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
-		if (val2)
-			return -EINVAL;
-		i = find_closest(val, ad7606_oversampling_avail,
-				 ARRAY_SIZE(ad7606_oversampling_avail));
-
-		values[0] = i;
-
-		mutex_lock(&st->lock);
-		gpiod_set_array_value(ARRAY_SIZE(values), st->gpio_os->desc,
-				      st->gpio_os->info, values);
-		st->oversampling = ad7606_oversampling_avail[i];
-		mutex_unlock(&st->lock);
-
-		return 0;
-	default:
-		return -EINVAL;
-	}
-}
-
-static IIO_CONST_ATTR(oversampling_ratio_available, "1 2 4 8 16 32 64");
-
-static struct attribute *ad7606_attributes_os_and_range[] = {
-	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
-	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
-	NULL,
-};
-
-static const struct attribute_group ad7606_attribute_group_os_and_range = {
-	.attrs = ad7606_attributes_os_and_range,
-};
-
-static struct attribute *ad7606_attributes_os[] = {
-	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
-	NULL,
-};
-
-static const struct attribute_group ad7606_attribute_group_os = {
-	.attrs = ad7606_attributes_os,
-};
-
-static struct attribute *ad7606_attributes_range[] = {
-	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
-	NULL,
-};
-
-static const struct attribute_group ad7606_attribute_group_range = {
-	.attrs = ad7606_attributes_range,
-};
-
-#define AD760X_CHANNEL(num, mask) {				\
-		.type = IIO_VOLTAGE,				\
-		.indexed = 1,					\
-		.channel = num,					\
-		.address = num,					\
-		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
-		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\
-		.info_mask_shared_by_all = mask,		\
-		.scan_index = num,				\
-		.scan_type = {					\
-			.sign = 's',				\
-			.realbits = 16,				\
-			.storagebits = 16,			\
-			.endianness = IIO_CPU,			\
-		},						\
-}
-
-#define AD7605_CHANNEL(num)	\
-	AD760X_CHANNEL(num, 0)
-
-#define AD7606_CHANNEL(num)	\
-	AD760X_CHANNEL(num, BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO))
-
-static const struct iio_chan_spec ad7605_channels[] = {
-	IIO_CHAN_SOFT_TIMESTAMP(4),
-	AD7605_CHANNEL(0),
-	AD7605_CHANNEL(1),
-	AD7605_CHANNEL(2),
-	AD7605_CHANNEL(3),
-};
-
-static const struct iio_chan_spec ad7606_channels[] = {
-	IIO_CHAN_SOFT_TIMESTAMP(8),
-	AD7606_CHANNEL(0),
-	AD7606_CHANNEL(1),
-	AD7606_CHANNEL(2),
-	AD7606_CHANNEL(3),
-	AD7606_CHANNEL(4),
-	AD7606_CHANNEL(5),
-	AD7606_CHANNEL(6),
-	AD7606_CHANNEL(7),
-};
-
-static const struct ad7606_chip_info ad7606_chip_info_tbl[] = {
-	/* More devices added in future */
-	[ID_AD7605_4] = {
-		.channels = ad7605_channels,
-		.num_channels = 5,
-	},
-	[ID_AD7606_8] = {
-		.channels = ad7606_channels,
-		.num_channels = 9,
-		.has_oversampling = true,
-	},
-	[ID_AD7606_6] = {
-		.channels = ad7606_channels,
-		.num_channels = 7,
-		.has_oversampling = true,
-	},
-	[ID_AD7606_4] = {
-		.channels = ad7606_channels,
-		.num_channels = 5,
-		.has_oversampling = true,
-	},
-};
-
-static int ad7606_request_gpios(struct ad7606_state *st)
-{
-	struct device *dev = st->dev;
-
-	st->gpio_convst = devm_gpiod_get(dev, "adi,conversion-start",
-					 GPIOD_OUT_LOW);
-	if (IS_ERR(st->gpio_convst))
-		return PTR_ERR(st->gpio_convst);
-
-	st->gpio_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
-	if (IS_ERR(st->gpio_reset))
-		return PTR_ERR(st->gpio_reset);
-
-	st->gpio_range = devm_gpiod_get_optional(dev, "adi,range",
-						 GPIOD_OUT_LOW);
-	if (IS_ERR(st->gpio_range))
-		return PTR_ERR(st->gpio_range);
-
-	st->gpio_standby = devm_gpiod_get_optional(dev, "standby",
-						   GPIOD_OUT_HIGH);
-	if (IS_ERR(st->gpio_standby))
-		return PTR_ERR(st->gpio_standby);
-
-	st->gpio_frstdata = devm_gpiod_get_optional(dev, "adi,first-data",
-						    GPIOD_IN);
-	if (IS_ERR(st->gpio_frstdata))
-		return PTR_ERR(st->gpio_frstdata);
-
-	if (!st->chip_info->has_oversampling)
-		return 0;
-
-	st->gpio_os = devm_gpiod_get_array_optional(dev,
-						    "adi,oversampling-ratio",
-						    GPIOD_OUT_LOW);
-	return PTR_ERR_OR_ZERO(st->gpio_os);
-}
-
-/*
- * The BUSY signal indicates when conversions are in progress, so when a rising
- * edge of CONVST is applied, BUSY goes logic high and transitions low at the
- * end of the entire conversion process. The falling edge of the BUSY signal
- * triggers this interrupt.
- */
-static irqreturn_t ad7606_interrupt(int irq, void *dev_id)
-{
-	struct iio_dev *indio_dev = dev_id;
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	if (iio_buffer_enabled(indio_dev)) {
-		gpiod_set_value(st->gpio_convst, 0);
-		iio_trigger_poll_chained(st->trig);
-	} else {
-		complete(&st->completion);
-	}
-
-	return IRQ_HANDLED;
-};
-
-static int ad7606_validate_trigger(struct iio_dev *indio_dev,
-				   struct iio_trigger *trig)
-{
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	if (st->trig != trig)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int ad7606_buffer_postenable(struct iio_dev *indio_dev)
-{
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	iio_triggered_buffer_postenable(indio_dev);
-	gpiod_set_value(st->gpio_convst, 1);
-
-	return 0;
-}
-
-static int ad7606_buffer_predisable(struct iio_dev *indio_dev)
-{
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	gpiod_set_value(st->gpio_convst, 0);
-
-	return iio_triggered_buffer_predisable(indio_dev);
-}
-
-static const struct iio_buffer_setup_ops ad7606_buffer_ops = {
-	.postenable = &ad7606_buffer_postenable,
-	.predisable = &ad7606_buffer_predisable,
-};
-
-static const struct iio_info ad7606_info_no_os_or_range = {
-	.read_raw = &ad7606_read_raw,
-	.validate_trigger = &ad7606_validate_trigger,
-};
-
-static const struct iio_info ad7606_info_os_and_range = {
-	.read_raw = &ad7606_read_raw,
-	.write_raw = &ad7606_write_raw,
-	.attrs = &ad7606_attribute_group_os_and_range,
-	.validate_trigger = &ad7606_validate_trigger,
-};
-
-static const struct iio_info ad7606_info_os = {
-	.read_raw = &ad7606_read_raw,
-	.write_raw = &ad7606_write_raw,
-	.attrs = &ad7606_attribute_group_os,
-	.validate_trigger = &ad7606_validate_trigger,
-};
-
-static const struct iio_info ad7606_info_range = {
-	.read_raw = &ad7606_read_raw,
-	.write_raw = &ad7606_write_raw,
-	.attrs = &ad7606_attribute_group_range,
-	.validate_trigger = &ad7606_validate_trigger,
-};
-
-static const struct iio_trigger_ops ad7606_trigger_ops = {
-	.validate_device = iio_trigger_validate_own_device,
-};
-
-static void ad7606_regulator_disable(void *data)
-{
-	struct ad7606_state *st = data;
-
-	regulator_disable(st->reg);
-}
-
-int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
-		 const char *name, unsigned int id,
-		 const struct ad7606_bus_ops *bops)
-{
-	struct ad7606_state *st;
-	int ret;
-	struct iio_dev *indio_dev;
-
-	indio_dev = devm_iio_device_alloc(dev, sizeof(*st));
-	if (!indio_dev)
-		return -ENOMEM;
-
-	st = iio_priv(indio_dev);
-	dev_set_drvdata(dev, indio_dev);
-
-	st->dev = dev;
-	mutex_init(&st->lock);
-	st->bops = bops;
-	st->base_address = base_address;
-	/* tied to logic low, analog input range is +/- 5V */
-	st->range = 0;
-	st->oversampling = 1;
-
-	st->reg = devm_regulator_get(dev, "avcc");
-	if (IS_ERR(st->reg))
-		return PTR_ERR(st->reg);
-
-	ret = regulator_enable(st->reg);
-	if (ret) {
-		dev_err(dev, "Failed to enable specified AVcc supply\n");
-		return ret;
-	}
-
-	ret = devm_add_action_or_reset(dev, ad7606_regulator_disable, st);
-	if (ret)
-		return ret;
-
-	st->chip_info = &ad7606_chip_info_tbl[id];
-
-	ret = ad7606_request_gpios(st);
-	if (ret)
-		return ret;
-
-	indio_dev->dev.parent = dev;
-	if (st->gpio_os) {
-		if (st->gpio_range)
-			indio_dev->info = &ad7606_info_os_and_range;
-		else
-			indio_dev->info = &ad7606_info_os;
-	} else {
-		if (st->gpio_range)
-			indio_dev->info = &ad7606_info_range;
-		else
-			indio_dev->info = &ad7606_info_no_os_or_range;
-	}
-	indio_dev->modes = INDIO_DIRECT_MODE;
-	indio_dev->name = name;
-	indio_dev->channels = st->chip_info->channels;
-	indio_dev->num_channels = st->chip_info->num_channels;
-
-	init_completion(&st->completion);
-
-	ret = ad7606_reset(st);
-	if (ret)
-		dev_warn(st->dev, "failed to RESET: no RESET GPIO specified\n");
-
-	st->trig = devm_iio_trigger_alloc(dev, "%s-dev%d",
-					  indio_dev->name, indio_dev->id);
-	if (!st->trig)
-		return -ENOMEM;
-
-	st->trig->ops = &ad7606_trigger_ops;
-	st->trig->dev.parent = dev;
-	iio_trigger_set_drvdata(st->trig, indio_dev);
-	ret = devm_iio_trigger_register(dev, st->trig);
-	if (ret)
-		return ret;
-
-	indio_dev->trig = iio_trigger_get(st->trig);
-
-	ret = devm_request_threaded_irq(dev, irq,
-					NULL,
-					&ad7606_interrupt,
-					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-					name, indio_dev);
-	if (ret)
-		return ret;
-
-	ret = devm_iio_triggered_buffer_setup(dev, indio_dev,
-					      &iio_pollfunc_store_time,
-					      &ad7606_trigger_handler,
-					      &ad7606_buffer_ops);
-	if (ret)
-		return ret;
-
-	return devm_iio_device_register(dev, indio_dev);
-}
-EXPORT_SYMBOL_GPL(ad7606_probe);
-
-#ifdef CONFIG_PM_SLEEP
-
-static int ad7606_suspend(struct device *dev)
-{
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	if (st->gpio_standby) {
-		gpiod_set_value(st->gpio_range, 1);
-		gpiod_set_value(st->gpio_standby, 0);
-	}
-
-	return 0;
-}
-
-static int ad7606_resume(struct device *dev)
-{
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	if (st->gpio_standby) {
-		gpiod_set_value(st->gpio_range, st->range);
-		gpiod_set_value(st->gpio_standby, 1);
-		ad7606_reset(st);
-	}
-
-	return 0;
-}
-
-SIMPLE_DEV_PM_OPS(ad7606_pm_ops, ad7606_suspend, ad7606_resume);
-EXPORT_SYMBOL_GPL(ad7606_pm_ops);
-
-#endif
-
-MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
-MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/iio/adc/ad7606.h b/drivers/staging/iio/adc/ad7606.h
deleted file mode 100644
index 5d12410..0000000
--- a/drivers/staging/iio/adc/ad7606.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * AD7606 ADC driver
- *
- * Copyright 2011 Analog Devices Inc.
- */
-
-#ifndef IIO_ADC_AD7606_H_
-#define IIO_ADC_AD7606_H_
-
-/**
- * struct ad7606_chip_info - chip specific information
- * @channels:		channel specification
- * @num_channels:	number of channels
- * @has_oversampling:   whether the device has oversampling support
- */
-struct ad7606_chip_info {
-	const struct iio_chan_spec	*channels;
-	unsigned int			num_channels;
-	bool				has_oversampling;
-};
-
-/**
- * struct ad7606_state - driver instance specific data
- * @dev		pointer to kernel device
- * @chip_info		entry in the table of chips that describes this device
- * @reg		regulator info for the the power supply of the device
- * @bops		bus operations (SPI or parallel)
- * @range		voltage range selection, selects which scale to apply
- * @oversampling	oversampling selection
- * @base_address	address from where to read data in parallel operation
- * @lock		protect sensor state from concurrent accesses to GPIOs
- * @gpio_convst	GPIO descriptor for conversion start signal (CONVST)
- * @gpio_reset		GPIO descriptor for device hard-reset
- * @gpio_range		GPIO descriptor for range selection
- * @gpio_standby	GPIO descriptor for stand-by signal (STBY),
- *			controls power-down mode of device
- * @gpio_frstdata	GPIO descriptor for reading from device when data
- *			is being read on the first channel
- * @gpio_os		GPIO descriptors to control oversampling on the device
- * @complete		completion to indicate end of conversion
- * @trig		The IIO trigger associated with the device.
- * @data		buffer for reading data from the device
- */
-struct ad7606_state {
-	struct device			*dev;
-	const struct ad7606_chip_info	*chip_info;
-	struct regulator		*reg;
-	const struct ad7606_bus_ops	*bops;
-	unsigned int			range;
-	unsigned int			oversampling;
-	void __iomem			*base_address;
-
-	struct mutex			lock; /* protect sensor state */
-	struct gpio_desc		*gpio_convst;
-	struct gpio_desc		*gpio_reset;
-	struct gpio_desc		*gpio_range;
-	struct gpio_desc		*gpio_standby;
-	struct gpio_desc		*gpio_frstdata;
-	struct gpio_descs		*gpio_os;
-	struct iio_trigger		*trig;
-	struct completion		completion;
-
-	/*
-	 * DMA (thus cache coherency maintenance) requires the
-	 * transfer buffers to live in their own cache lines.
-	 * 8 * 16-bit samples + 64-bit timestamp
-	 */
-	unsigned short			data[12] ____cacheline_aligned;
-};
-
-/**
- * struct ad7606_bus_ops - driver bus operations
- * @read_block		function pointer for reading blocks of data
- */
-struct ad7606_bus_ops {
-	/* more methods added in future? */
-	int (*read_block)(struct device *dev, int num, void *data);
-};
-
-int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
-		 const char *name, unsigned int id,
-		 const struct ad7606_bus_ops *bops);
-
-enum ad7606_supported_device_ids {
-	ID_AD7605_4,
-	ID_AD7606_8,
-	ID_AD7606_6,
-	ID_AD7606_4
-};
-
-#ifdef CONFIG_PM_SLEEP
-extern const struct dev_pm_ops ad7606_pm_ops;
-#define AD7606_PM_OPS (&ad7606_pm_ops)
-#else
-#define AD7606_PM_OPS NULL
-#endif
-
-#endif /* IIO_ADC_AD7606_H_ */
diff --git a/drivers/staging/iio/adc/ad7606_par.c b/drivers/staging/iio/adc/ad7606_par.c
deleted file mode 100644
index df607c7..0000000
--- a/drivers/staging/iio/adc/ad7606_par.c
+++ /dev/null
@@ -1,105 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * AD7606 Parallel Interface ADC driver
- *
- * Copyright 2011 Analog Devices Inc.
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <linux/err.h>
-#include <linux/io.h>
-
-#include <linux/iio/iio.h>
-#include "ad7606.h"
-
-static int ad7606_par16_read_block(struct device *dev,
-				   int count, void *buf)
-{
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	insw((unsigned long)st->base_address, buf, count);
-
-	return 0;
-}
-
-static const struct ad7606_bus_ops ad7606_par16_bops = {
-	.read_block = ad7606_par16_read_block,
-};
-
-static int ad7606_par8_read_block(struct device *dev,
-				  int count, void *buf)
-{
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
-	struct ad7606_state *st = iio_priv(indio_dev);
-
-	insb((unsigned long)st->base_address, buf, count * 2);
-
-	return 0;
-}
-
-static const struct ad7606_bus_ops ad7606_par8_bops = {
-	.read_block = ad7606_par8_read_block,
-};
-
-static int ad7606_par_probe(struct platform_device *pdev)
-{
-	const struct platform_device_id *id = platform_get_device_id(pdev);
-	struct resource *res;
-	void __iomem *addr;
-	resource_size_t remap_size;
-	int irq;
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "no irq: %d\n", irq);
-		return irq;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	addr = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(addr))
-		return PTR_ERR(addr);
-
-	remap_size = resource_size(res);
-
-	return ad7606_probe(&pdev->dev, irq, addr,
-			    id->name, id->driver_data,
-			    remap_size > 1 ? &ad7606_par16_bops :
-			    &ad7606_par8_bops);
-}
-
-static const struct platform_device_id ad7606_driver_ids[] = {
-	{ .name	= "ad7605-4", .driver_data = ID_AD7605_4, },
-	{ .name	= "ad7606-4", .driver_data = ID_AD7606_4, },
-	{ .name	= "ad7606-6", .driver_data = ID_AD7606_6, },
-	{ .name	= "ad7606-8", .driver_data = ID_AD7606_8, },
-	{ }
-};
-MODULE_DEVICE_TABLE(platform, ad7606_driver_ids);
-
-static const struct of_device_id ad7606_of_match[] = {
-	{ .compatible = "adi,ad7605-4" },
-	{ .compatible = "adi,ad7606-4" },
-	{ .compatible = "adi,ad7606-6" },
-	{ .compatible = "adi,ad7606-8" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, ad7606_of_match);
-
-static struct platform_driver ad7606_driver = {
-	.probe = ad7606_par_probe,
-	.id_table = ad7606_driver_ids,
-	.driver = {
-		.name = "ad7606",
-		.pm = AD7606_PM_OPS,
-		.of_match_table = ad7606_of_match,
-	},
-};
-module_platform_driver(ad7606_driver);
-
-MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
-MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/iio/adc/ad7606_spi.c b/drivers/staging/iio/adc/ad7606_spi.c
deleted file mode 100644
index f842eba..0000000
--- a/drivers/staging/iio/adc/ad7606_spi.c
+++ /dev/null
@@ -1,82 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * AD7606 SPI ADC driver
- *
- * Copyright 2011 Analog Devices Inc.
- */
-
-#include <linux/module.h>
-#include <linux/spi/spi.h>
-#include <linux/types.h>
-#include <linux/err.h>
-
-#include <linux/iio/iio.h>
-#include "ad7606.h"
-
-#define MAX_SPI_FREQ_HZ		23500000	/* VDRIVE above 4.75 V */
-
-static int ad7606_spi_read_block(struct device *dev,
-				 int count, void *buf)
-{
-	struct spi_device *spi = to_spi_device(dev);
-	int i, ret;
-	unsigned short *data = buf;
-	__be16 *bdata = buf;
-
-	ret = spi_read(spi, buf, count * 2);
-	if (ret < 0) {
-		dev_err(&spi->dev, "SPI read error\n");
-		return ret;
-	}
-
-	for (i = 0; i < count; i++)
-		data[i] = be16_to_cpu(bdata[i]);
-
-	return 0;
-}
-
-static const struct ad7606_bus_ops ad7606_spi_bops = {
-	.read_block = ad7606_spi_read_block,
-};
-
-static int ad7606_spi_probe(struct spi_device *spi)
-{
-	const struct spi_device_id *id = spi_get_device_id(spi);
-
-	return ad7606_probe(&spi->dev, spi->irq, NULL,
-			    id->name, id->driver_data,
-			    &ad7606_spi_bops);
-}
-
-static const struct spi_device_id ad7606_id_table[] = {
-	{ "ad7605-4", ID_AD7605_4 },
-	{ "ad7606-4", ID_AD7606_4 },
-	{ "ad7606-6", ID_AD7606_6 },
-	{ "ad7606-8", ID_AD7606_8 },
-	{}
-};
-MODULE_DEVICE_TABLE(spi, ad7606_id_table);
-
-static const struct of_device_id ad7606_of_match[] = {
-	{ .compatible = "adi,ad7605-4" },
-	{ .compatible = "adi,ad7606-4" },
-	{ .compatible = "adi,ad7606-6" },
-	{ .compatible = "adi,ad7606-8" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, ad7606_of_match);
-
-static struct spi_driver ad7606_driver = {
-	.driver = {
-		.name = "ad7606",
-		.of_match_table = ad7606_of_match,
-		.pm = AD7606_PM_OPS,
-	},
-	.probe = ad7606_spi_probe,
-	.id_table = ad7606_id_table,
-};
-module_spi_driver(ad7606_driver);
-
-MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
-MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
-MODULE_LICENSE("GPL");
-- 
2.7.4

