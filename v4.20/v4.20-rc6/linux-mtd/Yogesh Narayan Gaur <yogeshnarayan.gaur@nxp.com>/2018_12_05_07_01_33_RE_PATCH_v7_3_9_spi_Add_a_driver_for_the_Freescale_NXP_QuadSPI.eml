Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 06 Dec 2018 08:46:10 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 5007858014B;
	Tue,  4 Dec 2018 23:01:49 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 04 Dec 2018 23:01:48 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AFaYTnxFJEZxJAgpMGkQmPZ1GYnF86YWxBRYc798d?=
 =?us-ascii?q?s5kLTJ75r8u4bnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjm58axlVAHnhz?=
 =?us-ascii?q?sGNz4h8WHYlMpwjL5AoBm8oxBz2pPYbJ2JOPZ7eK7WYNEUSndbXstJVyJPHJ6y?=
 =?us-ascii?q?b5cBAeQCM+ZXrYj9qEcBoxSxHgmsHOHixyRUhn/vwaE2z/gtHR3Y0AEmAtkAsG?=
 =?us-ascii?q?7UrNLwNKoKU++1y6bIwivYb/NWxDzz8JLHcgo7rvCMR71wd9fax0g1GAPYlFWb?=
 =?us-ascii?q?tIvoPjOS1uQCrWeb9OpgVeS1hG49sQ5woiKgxsE2honGnI0V10rE+D5/wIc6Pd?=
 =?us-ascii?q?20UlJ0YdmhEJZJsSyRKoV4QsQnQ25yuSY6zKULtoWmfCgE0pgnxhjfZvqaeIaL?=
 =?us-ascii?q?+hLuTPidLSt8iX5/Zb6yiQi+/VK9xuD/SsW4yldHoyhdntXRuX0BzQHf58eZRv?=
 =?us-ascii?q?dn40us2jSC2xrO5uxFIE04jaTbJIAiz7Isk5cetETOEyv2lUrsiaKbckYp9+y0?=
 =?us-ascii?q?5+niYbjrqJuROo1xhwz+L6sjmtGzDOIlOQYURWeb4/6z1Lj78E35XrpKivo2n7?=
 =?us-ascii?q?HHsJDVO8sbvLS1AwxL3YY57RawETOm3M4fnXkdI1JJYBOHj473NFHSOP30E+uz?=
 =?us-ascii?q?jlC2nDt2yf3KIKftDojOI3TfirvsfLRw51ZZyAUpzNBf45xUCqsGIPL2QkLxsN?=
 =?us-ascii?q?3YDhkkMw272urnC8ty1pkYWW2RBq+VKaTSsFGO5u0xOemBf5EVuDnjJPg//fLu?=
 =?us-ascii?q?jmE2mUUbfaa32Zsbcne4Hu5pI0mBe3rjns8BEXsWvgo5VOHqjFyCUT1NaHqoUK?=
 =?us-ascii?q?M8+yo2CIanDYfFW4Csj6aN3Ca9Hp1KeG9GDkqAHmvvd4WBQ/0Mcj6dItd9kjwY?=
 =?us-ascii?q?UrisU48h2guvtA/m0bVnKfDY+i0FtZ350th16PbelRUz9TxyEsSc3HuBT2Bynm?=
 =?us-ascii?q?MUWTA22LpzrlB6yleGyaJ4meBXFcRP5/NVVQc3LZzcz+tkBNzoWQLBedGJSFCh?=
 =?us-ascii?q?Qti9BTExT9Qxw8IBYkpnGtWiiAzD0DSuA7MPi7OLA5k0+LrG33ftP8Z912rG1K?=
 =?us-ascii?q?45glY8WctPNWqmhq1l+wjJHYHJkV6Ul6KrdaQawS7M+32PzWuIvEFETgFwVb/J?=
 =?us-ascii?q?UmwYZkvTtd75/F/NT6eyCbQ7NQtM0c2CJbFMatHziVVGRe3sONLRY2+qn2ewBB?=
 =?us-ascii?q?CIxq6DbYbwemUd2jndB1YAkwwJ4XmGMg0+DD+7o23CFDxuCU7vY0T0/OZjsny7?=
 =?us-ascii?q?UFE7wxuKb0J70bq14QAahfqbR/MX3bIEvSMhpi5wHFa82dLWFtWBqxBgfKVafd?=
 =?us-ascii?q?My/lNH2XjFuAx6O5yqN7piiUIGcwRro0Pu0A16BZhansg0snwm1gpyJrie0FNa?=
 =?us-ascii?q?aTyY24v9OrnWKmn04RCuZLTa2lDY0NaK5KgP7O40pEnkvAGsDkAi6Wlo08FJ03?=
 =?us-ascii?q?uA4ZXHFBYSUZP0UkYw6xh6p7HbbjMh54/O0n1sK620sj7E29ImH+Ylzhegf9FC?=
 =?us-ascii?q?MKKLDgPyEssaB9SwJ+wugVSmchUEPOVK/q4uI8ymb+eG2LKsPOt4hj2miXpI4Y?=
 =?us-ascii?q?9j3UOM7SZzUfPI0IsfzPGe3QuHUCn8gUylssD2n4BEeD4TEnC+ySjiGI5eeKly?=
 =?us-ascii?q?cZwXBmepJs293s9+iIL1W35E6F6jAEsL2c+0eRaIc1PxxwxR1UQNrnyhliu11D?=
 =?us-ascii?q?h0kzAvrqqC0y3C2eXidBwbOmFVQGlul0vjIY+xj9oCRkincxAplAe55Ub936Vb?=
 =?us-ascii?q?vqV/IHXJTkdSYif2KHtuUq2uubqYYs5D8Y8nvj9TUOuhf1+aULn9ox0B3iPnHm?=
 =?us-ascii?q?tewi07dj6wtpX4mRx6lHySLHJpoHXFfsFwwA/V5MbASv5JwjoGWC54hCHXB1i9?=
 =?us-ascii?q?JdWo/c+Yl4zesuC4TG+hUpxTcS/2zYKPrie75GtqAQGhkPC3gNHoDQ860Srj3d?=
 =?us-ascii?q?lwSSrItAr8YpXs16miM+JoZFNoBFz/68p9AI1+iZE/hJIT2XgbgJWa43wHnHz3?=
 =?us-ascii?q?MdVa36L+cXUMSSQKw97T/AjqxkljImiVyIL+U3WX2tFhaMWiYmMKxiI96NhHCa?=
 =?us-ascii?q?eO47xDhyd1oFu4rQTKbPh5nzcdz+Yu6XEAj+EIvgot0juSArQIEUZEOizskgyC?=
 =?us-ascii?q?78qio6VPeGavbb+w2VJ9nd+7DbGOuAFcWGvjdZckEi999cF/MFPK0H3u5YDoYt?=
 =?us-ascii?q?jQbdQPthKKlxfMlfRaKJU0lvASnypoJXr9vWE5y+48lRFu2JC6vIudJGl38qO2?=
 =?us-ascii?q?HAVYNiHraMMJ4T7ik7xensmN0oCrH5VhHCgLXZTyQfKpFjISqeroNwKUHDIgrX?=
 =?us-ascii?q?ebHKLVHRWD50d+s3LPD5erOmmLJHkeyNVuXhicK1ZZgAAJRzU6hZ85GxuuxMzg?=
 =?us-ascii?q?dkd5+z8Q6kT5qhtK1uJnKR3/Xn3Dqwevbzc+UIKfIwZO7gFe+0fVNtST4flpEC?=
 =?us-ascii?q?Ff+p2hsRaBKmiGZwlTCWEJW0qEB03sP7W05NnA9fSYCfS6L/fUfbqOruleXe+S?=
 =?us-ascii?q?xZ2zyotm4yqMNsKXM3lgFfI731RMXWtjF8TFgTkPSDEXlyHQb86dvhi84TZ6rs?=
 =?us-ascii?q?S+8PTtRQLu6pGDC7pUMdVz5R+2hb2POPKXhCZ8MTxYzI8DxWfUyLgD214fkyFv?=
 =?us-ascii?q?dz6wEbQZqC7CVqTQlrVMDx4cbSNzO9BF76Y93glLJM7ahcn51r9+jv4pFVhFUU?=
 =?us-ascii?q?btld2uZcwPO2u9Lk/IBF6XNLSaIj3G28H3br29Sb1Tj+VUtge8uTWBE0/kMTSM?=
 =?us-ascii?q?iSPpVw20MexXiCGbPRpeuJyycxp3CGjjSs7mZQO/MNNtkTI2xrg0jGvQNWEAKT?=
 =?us-ascii?q?h8b19NrrqI4CxCn/VwAHZB4WRlLOWenyaZ7vLVKpIXsfttHyR1mPhW4HU8y7tJ?=
 =?us-ascii?q?8i5EQOZ5lzfVrt5ru1umiPWAyiJ7UBpSrTZGnJ6LvURnOanD6pZMQ2rL/BIT4m?=
 =?us-ascii?q?WWEBkKo9plCtvyu6Ff0NTPlaTzKCtc/NLQ58cTG8/UKMefOno7LRXpACLUDBcC?=
 =?us-ascii?q?TTOzNWDQnUpdkPST9n2Ttpc7q5jsl4AISr9UT1E1EvIaCkJ4HN0NOpt3XzUkka?=
 =?us-ascii?q?KFg84M/3axsB7RRMAJ9qzAA8mZAe/iLS6XxZdeZhYEzKmweYoJN4D31lYkcVJ6?=
 =?us-ascii?q?honPA0T4XtdLvjdmaEk4rRMJuDJ6T2suywfgdg+F5H4ICeXynxg4kAJybO0hsj?=
 =?us-ascii?q?D27B1/cl7LojYg1Uwtlf3hgCuNa3jwKqmqVI1bAiaysFI+ZNezCQxydwyp20Z+?=
 =?us-ascii?q?OSXFQ7ZWiZNqcmd3jA7a/5BIHLQUGadDeh4Lg/uNaucp1VBbrA2twkhb4erDT5?=
 =?us-ascii?q?BlkV1uOdSornRdy0d4dN8dO6PdPuxKw0JWi6bIuTWnnKhlxA4YOlZI63uTUDAH?=
 =?us-ascii?q?tVZONbQ8ISesuOt25lrG0x5KYmUPH8Qjue92vhc4Mv6NzGT+2qVeNmi+MuWeK+?=
 =?us-ascii?q?WSvG2W0YatS0kznmkSkFZDtex8y8AkdUuZf0Mi1r2cE1IOL8WUbUl1ZswaxGWb?=
 =?us-ascii?q?KSaHt6Pd3LpzL537HeftG7ygrqER13OjEwsyH8wq594ID5CqmG7RMN2veK8Cxh?=
 =?us-ascii?q?g25ALiPlyUBfIPdxuWih8Bs9n5x5hyi9oObgoBCHlwZH3kro3coRUn1b/aBI87?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAACKdgdch0O0hNFkGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYEwUGlzBAsnCoc2A4RPi0SCVxSIfo46FIFjDwEYAxABhEA?=
 =?us-ascii?q?CgwsiNAkNAQMBAQEBAQECARMBAQEIDQkIKSMMgjYkAYJhAQEBAQMBAhcBDBMGA?=
 =?us-ascii?q?QE3AQUGAwEBAQEIEQQBAR8JBwMeBwoUCQgCBAEJBAUFA4MZAYFpAxQBAQICmX0?=
 =?us-ascii?q?CigeBbDOCdgEBBYEEAQGEAA2CFAiMHoIWgRFGgkyCV4FkCySDTIImiRAaCoFvh?=
 =?us-ascii?q?BOBTIRsig4nLgcCijaCbXCDRoFbiDuHFokJgQOEcYIDhESDDgIEAgQFAg0BAQW?=
 =?us-ascii?q?BRl+BLjMaI4M8CYISCQMXg0qESoVSATZygQUBASGIOQ8XA4EFAYEeAQE?=
X-IPAS-Result: =?us-ascii?q?A0AEAACKdgdch0O0hNFkGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYEwUGlzBAsnCoc2A4RPi0SCVxSIfo46FIFjDwEYAxABhEACgwsiNAkNAQMBA?=
 =?us-ascii?q?QEBAQECARMBAQEIDQkIKSMMgjYkAYJhAQEBAQMBAhcBDBMGAQE3AQUGAwEBAQE?=
 =?us-ascii?q?IEQQBAR8JBwMeBwoUCQgCBAEJBAUFA4MZAYFpAxQBAQICmX0CigeBbDOCdgEBB?=
 =?us-ascii?q?YEEAQGEAA2CFAiMHoIWgRFGgkyCV4FkCySDTIImiRAaCoFvhBOBTIRsig4nLgc?=
 =?us-ascii?q?CijaCbXCDRoFbiDuHFokJgQOEcYIDhESDDgIEAgQFAg0BAQWBRl+BLjMaI4M8C?=
 =?us-ascii?q?YISCQMXg0qESoVSATZygQUBASGIOQ8XA4EFAYEeAQE?=
X-IronPort-AV: E=Sophos;i="5.56,317,1539673200"; 
   d="scan'208";a="54584401"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 04 Dec 2018 23:01:45 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727116AbeLEHBo (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Wed, 5 Dec 2018 02:01:44 -0500
Received: from mail-eopbgr30053.outbound.protection.outlook.com ([40.107.3.53]:13566
        "EHLO EUR03-AM5-obe.outbound.protection.outlook.com"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1726092AbeLEHBn (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Wed, 5 Dec 2018 02:01:43 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=nxp.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=wx5JXUCkCHH/9Bi/W2JTJPPCkj8DZZL2/IjFVZYFImU=;
 b=L+S+OQmS2eX8ZDpe53J3w7oR637VVd2s3zCL2TPna1KytIxzdca5ZmY6/XXNjBbxyOiN+zzzTOSHk9/hO46s6Wlr0OZFLIRBViPsHDSTNfQWLiNktEy9AvSuW8oSHq9gKKUSJeivtoBT+0sHkjarxwtC5pw8xvxDIYtzzRD5DxY=
Received: from VI1PR04MB5726.eurprd04.prod.outlook.com (20.178.127.24) by
 VI1PR04MB4272.eurprd04.prod.outlook.com (52.134.31.151) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1382.22; Wed, 5 Dec 2018 07:01:33 +0000
Received: from VI1PR04MB5726.eurprd04.prod.outlook.com
 ([fe80::595a:9890:8397:5d51]) by VI1PR04MB5726.eurprd04.prod.outlook.com
 ([fe80::595a:9890:8397:5d51%4]) with mapi id 15.20.1404.019; Wed, 5 Dec 2018
 07:01:33 +0000
From: Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>
To: Schrempf Frieder <frieder.schrempf@kontron.de>,
        "linux-mtd@lists.infradead.org" <linux-mtd@lists.infradead.org>,
        "boris.brezillon@bootlin.com" <boris.brezillon@bootlin.com>,
        "linux-spi@vger.kernel.org" <linux-spi@vger.kernel.org>,
        Marek Vasut <marek.vasut@gmail.com>,
        Mark Brown <broonie@kernel.org>, Han Xu <han.xu@nxp.com>
CC: "dwmw2@infradead.org" <dwmw2@infradead.org>,
        "computersforpeace@gmail.com" <computersforpeace@gmail.com>,
        "richard@nod.at" <richard@nod.at>,
        "miquel.raynal@bootlin.com" <miquel.raynal@bootlin.com>,
        David Wolfe <david.wolfe@nxp.com>,
        Fabio Estevam <fabio.estevam@nxp.com>,
        Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>,
        "shawnguo@kernel.org" <shawnguo@kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: RE: [PATCH v7 3/9] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Topic: [PATCH v7 3/9] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Index: AQHUi9vWAE0Oo4W6mEqTtVIHp+5UgqVvmyJA
Date: Wed, 5 Dec 2018 07:01:33 +0000
Message-ID: <VI1PR04MB57264CAEDFB449C6A603229299A80@VI1PR04MB5726.eurprd04.prod.outlook.com>
References: <1543932685-15011-1-git-send-email-frieder.schrempf@kontron.de>
 <1543932685-15011-4-git-send-email-frieder.schrempf@kontron.de>
In-Reply-To: <1543932685-15011-4-git-send-email-frieder.schrempf@kontron.de>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: spf=none (sender IP is )
 smtp.mailfrom=yogeshnarayan.gaur@nxp.com; 
x-originating-ip: [14.142.187.166]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1;VI1PR04MB4272;6:ekE4jOcq0i1niv7nUSE5GYY8/QryU1dBPCdCk5byTJEg2+sX4uUuq+shZCeUJ47hdJ9QtZ6qUbi8QetNxo9130Bpr+ymzY6qF8rY4lN/ZqnWp+gXuSUzTGHTpQxdvbD4pJ8AkZQnmnMHmA5i6SfhmiKTVl5WPKFJ+PGGl8C4oNbeLj2uB82y7qPzaz5J4Njd4/RMrBiLCeOMt6l++ruxHeWuzWxAdTox0jtkoLOJYdl2R9GsqPhiT5O4LtBTFqnKMtnjwC9lSyvvIDFWZYxCotBIMXiW/7TojSXaK5wGKIzi1Bcp5taEM89FupkYarAKEj8oBgdWal+nNUKcB/TxeVOIpktFSlR9dMty0fWtzPuyMEza/ar9KnYoW+AsZpkDORsgDWlM1+KRISbCkcJM6jWimCB0MZS84gLLcGli3UiJ50sJxqr7D2xsQSU8udd0Ubz54z2N5D9XJHNRad3VEQ==;5:0tdz6KAg+01LAYZOcVqCW7zXKKx5t+YRigWpSl/quE0HuLC8lCcr7lF4pj845scnhGl550VnnMpgl4bMSsLsVFffXmG233ruaGI7woWJKDhAokCaQbtpRd6PY7qGT9jo2P1JgvxckQX/BWRA5VT7iPd505zihZ10R+lhpOapJTg=;7:sDUTgTwYhWL7uz9Z/hbvsq7XkyvYEGzxFYX03/tIJiaGRAAaWzsJXpqrUAbgUDdJBWB1AbtQrS/cs2ucdoB6LxMCWzCubPkTqF2f+SxommgI0D36K8+T4qhu7apbYD9cBWfLQBHwdNW0oQpmuSHqkA==
x-ms-exchange-antispam-srfa-diagnostics: SOS;
x-ms-office365-filtering-correlation-id: 9d104f58-77eb-4a84-3376-08d65a7f7ddf
x-ms-office365-filtering-ht: Tenant
x-microsoft-antispam: BCL:0;PCL:0;RULEID:(2390098)(7020095)(4652040)(8989299)(4534185)(7168020)(4627221)(201703031133081)(201702281549075)(8990200)(5600074)(711020)(4618075)(2017052603328)(7153060)(7193020);SRVR:VI1PR04MB4272;
x-ms-traffictypediagnostic: VI1PR04MB4272:
x-microsoft-antispam-prvs: <VI1PR04MB42721991AD8E74ACFCABBF4C99A80@VI1PR04MB4272.eurprd04.prod.outlook.com>
x-ms-exchange-senderadcheck: 1
x-exchange-antispam-report-cfa-test: BCL:0;PCL:0;RULEID:(8211001083)(6040522)(2401047)(8121501046)(5005006)(10201501046)(3231455)(999002)(944501520)(52105112)(93006095)(93001095)(3002001)(6055026)(148016)(149066)(150057)(6041310)(20161123558120)(20161123560045)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(20161123562045)(20161123564045)(201708071742011)(7699051)(76991095);SRVR:VI1PR04MB4272;BCL:0;PCL:0;RULEID:;SRVR:VI1PR04MB4272;
x-forefront-prvs: 08770259B4
x-forefront-antispam-report: SFV:NSPM;SFS:(10009020)(346002)(376002)(396003)(39860400002)(136003)(366004)(13464003)(189003)(199004)(316002)(76176011)(33656002)(7696005)(105586002)(2201001)(575784001)(86362001)(106356001)(26005)(186003)(110136005)(8936002)(81166006)(68736007)(446003)(53546011)(6506007)(55236004)(102836004)(99286004)(54906003)(476003)(11346002)(6116002)(3846002)(14444005)(256004)(2906002)(66066001)(14454004)(6636002)(2501003)(486006)(97736004)(81156014)(4326008)(5660300001)(8676002)(25786009)(53936002)(4744004)(71200400001)(71190400001)(55016002)(39060400002)(78486014)(9686003)(6436002)(6246003)(7736002)(305945005)(229853002)(74316002)(7416002)(478600001)(53946003)(569006);DIR:OUT;SFP:1101;SCL:1;SRVR:VI1PR04MB4272;H:VI1PR04MB5726.eurprd04.prod.outlook.com;FPR:;SPF:None;LANG:en;PTR:InfoNoRecords;MX:1;A:1;
x-microsoft-antispam-message-info: fA+bjderC35WUlNbYX2zNBxCo8eplqlHZI7K92TJdUVlT+XTJOL89kM64hj1jcEygoInGc4svmfn/YFidHmH6jFcSDpFzEJh0/Wr80obYK9xVxHpEN+dZIQ3gS9yVuePjqtmdMMJlIHBVQxEa5i9w9wDvD7kENkQdI6pPyA6jkLdT5hAqLAWeBM1lXOag8W4lhkYsy8A5Dgz4TVmuUNE3psqBf4ghNUqTAkw2J5Sz3TtOvLkGhxj3mV2Z/fpoMlknBezCbF5kMcqGRJF7tjaZkoFUxhCqtBdWW5+p3dw9MhohJUca6b98YI5KECLSSp/VCg8+YyD43qu1wHSoK6uB0yHuFlQYT+3reHkeOcYNEo=
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-OriginatorOrg: nxp.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 9d104f58-77eb-4a84-3376-08d65a7f7ddf
X-MS-Exchange-CrossTenant-originalarrivaltime: 05 Dec 2018 07:01:33.7089
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 686ea1d3-bc2b-4c6f-a92c-d99c5c301635
X-MS-Exchange-Transport-CrossTenantHeadersStamped: VI1PR04MB4272
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Hi,

Verified patch on LS1088ardb this board is having two connected flash slave=
 devices on CS0 and CS1.

Verified with simple Read/Write/Erase operations along with JFFS2 mounting =
and booting from flash MTD partition for both slave devices.

> -----Original Message-----
> From: Schrempf Frieder [mailto:frieder.schrempf@kontron.de]
> Sent: Tuesday, December 4, 2018 7:45 PM
> To: linux-mtd@lists.infradead.org; boris.brezillon@bootlin.com; linux-
> spi@vger.kernel.org; Marek Vasut <marek.vasut@gmail.com>; Mark Brown
> <broonie@kernel.org>; Han Xu <han.xu@nxp.com>
> Cc: dwmw2@infradead.org; computersforpeace@gmail.com; richard@nod.at;
> miquel.raynal@bootlin.com; David Wolfe <david.wolfe@nxp.com>; Fabio
> Estevam <fabio.estevam@nxp.com>; Prabhakar Kushwaha
> <prabhakar.kushwaha@nxp.com>; Yogesh Narayan Gaur
> <yogeshnarayan.gaur@nxp.com>; shawnguo@kernel.org; Schrempf Frieder
> <frieder.schrempf@kontron.de>; linux-kernel@vger.kernel.org
> Subject: [PATCH v7 3/9] spi: Add a driver for the Freescale/NXP QuadSPI
> controller
>=20
> From: Frieder Schrempf <frieder.schrempf@kontron.de>
>=20
> This driver is derived from the SPI NOR driver at mtd/spi-nor/fsl-quadspi=
.c. It
> uses the new SPI memory interface of the SPI framework to issue flash mem=
ory
> operations to up to four connected flash chips (2 buses with 2 CS each).
>=20
> The controller does not support generic SPI messages.
>=20
> This patch also disables the build of the "old" driver and reuses its Kco=
nfig option
> CONFIG_SPI_FSL_QUADSPI to replace it.
>=20
> Signed-off-by: Frieder Schrempf <frieder.schrempf@kontron.de>
Reviewed-by: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
Tested-by: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>

--
Thanks
Yogesh Gaur

> ---
>  drivers/mtd/spi-nor/Kconfig  |   9 -
>  drivers/mtd/spi-nor/Makefile |   1 -
>  drivers/spi/Kconfig          |  11 +
>  drivers/spi/Makefile         |   1 +
>  drivers/spi/spi-fsl-qspi.c   | 966 +++++++++++++++++++++++++++++++++++++=
+
>  5 files changed, 978 insertions(+), 10 deletions(-)
>=20
> diff --git a/drivers/mtd/spi-nor/Kconfig b/drivers/mtd/spi-nor/Kconfig in=
dex
> 6cc9c92..d1ca307 100644
> --- a/drivers/mtd/spi-nor/Kconfig
> +++ b/drivers/mtd/spi-nor/Kconfig
> @@ -59,15 +59,6 @@ config SPI_CADENCE_QUADSPI
>  	  device with a Cadence QSPI controller and want to access the
>  	  Flash as an MTD device.
>=20
> -config SPI_FSL_QUADSPI
> -	tristate "Freescale Quad SPI controller"
> -	depends on ARCH_MXC || SOC_LS1021A || ARCH_LAYERSCAPE ||
> COMPILE_TEST
> -	depends on HAS_IOMEM
> -	help
> -	  This enables support for the Quad SPI controller in master mode.
> -	  This controller does not support generic SPI. It only supports
> -	  SPI NOR.
> -
>  config SPI_HISI_SFC
>  	tristate "Hisilicon SPI-NOR Flash Controller(SFC)"
>  	depends on ARCH_HISI || COMPILE_TEST
> diff --git a/drivers/mtd/spi-nor/Makefile b/drivers/mtd/spi-nor/Makefile =
index
> f4c61d2..3f160c2e3 100644
> --- a/drivers/mtd/spi-nor/Makefile
> +++ b/drivers/mtd/spi-nor/Makefile
> @@ -3,7 +3,6 @@ obj-$(CONFIG_MTD_SPI_NOR)	+=3D spi-nor.o
>  obj-$(CONFIG_SPI_ASPEED_SMC)	+=3D aspeed-smc.o
>  obj-$(CONFIG_SPI_ATMEL_QUADSPI)	+=3D atmel-quadspi.o
>  obj-$(CONFIG_SPI_CADENCE_QUADSPI)	+=3D cadence-quadspi.o
> -obj-$(CONFIG_SPI_FSL_QUADSPI)	+=3D fsl-quadspi.o
>  obj-$(CONFIG_SPI_HISI_SFC)	+=3D hisi-sfc.o
>  obj-$(CONFIG_MTD_MT81xx_NOR)    +=3D mtk-quadspi.o
>  obj-$(CONFIG_SPI_NXP_SPIFI)	+=3D nxp-spifi.o
> diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig index 7d3a5c9..8c8=
4186
> 100644
> --- a/drivers/spi/Kconfig
> +++ b/drivers/spi/Kconfig
> @@ -259,6 +259,17 @@ config SPI_FSL_LPSPI
>  	help
>  	  This enables Freescale i.MX LPSPI controllers in master mode.
>=20
> +config SPI_FSL_QUADSPI
> +	tristate "Freescale QSPI controller"
> +	depends on ARCH_MXC || SOC_LS1021A || ARCH_LAYERSCAPE ||
> COMPILE_TEST
> +	depends on HAS_IOMEM
> +	help
> +	  This enables support for the Quad SPI controller in master mode.
> +	  Up to four flash chips can be connected on two buses with two
> +	  chipselects each.
> +	  This controller does not support generic SPI messages. It only
> +	  supports the high-level SPI memory interface.
> +
>  config SPI_GPIO
>  	tristate "GPIO-based bitbanging SPI Master"
>  	depends on GPIOLIB || COMPILE_TEST
> diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile index 3575205..5=
377e61
> 100644
> --- a/drivers/spi/Makefile
> +++ b/drivers/spi/Makefile
> @@ -44,6 +44,7 @@ obj-$(CONFIG_SPI_FSL_DSPI)		+=3D spi-fsl-
> dspi.o
>  obj-$(CONFIG_SPI_FSL_LIB)		+=3D spi-fsl-lib.o
>  obj-$(CONFIG_SPI_FSL_ESPI)		+=3D spi-fsl-espi.o
>  obj-$(CONFIG_SPI_FSL_LPSPI)		+=3D spi-fsl-lpspi.o
> +obj-$(CONFIG_SPI_FSL_QUADSPI)		+=3D spi-fsl-qspi.o
>  obj-$(CONFIG_SPI_FSL_SPI)		+=3D spi-fsl-spi.o
>  obj-$(CONFIG_SPI_GPIO)			+=3D spi-gpio.o
>  obj-$(CONFIG_SPI_IMG_SPFI)		+=3D spi-img-spfi.o
> diff --git a/drivers/spi/spi-fsl-qspi.c b/drivers/spi/spi-fsl-qspi.c new =
file mode
> 100644 index 0000000..f0a3400
> --- /dev/null
> +++ b/drivers/spi/spi-fsl-qspi.c
> @@ -0,0 +1,966 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +
> +/*
> + * Freescale QuadSPI driver.
> + *
> + * Copyright (C) 2013 Freescale Semiconductor, Inc.
> + * Copyright (C) 2018 Bootlin
> + * Copyright (C) 2018 exceet electronics GmbH
> + * Copyright (C) 2018 Kontron Electronics GmbH
> + *
> + * Transition to SPI MEM interface:
> + * Authors:
> + *     Boris Brezillion <boris.brezillon@bootlin.com>
> + *     Frieder Schrempf <frieder.schrempf@kontron.de>
> + *     Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
> + *     Suresh Gupta <suresh.gupta@nxp.com>
> + *
> + * Based on the original fsl-quadspi.c spi-nor driver:
> + * Author: Freescale Semiconductor, Inc.
> + *
> + */
> +
> +#include <linux/bitops.h>
> +#include <linux/clk.h>
> +#include <linux/completion.h>
> +#include <linux/delay.h>
> +#include <linux/err.h>
> +#include <linux/errno.h>
> +#include <linux/interrupt.h>
> +#include <linux/io.h>
> +#include <linux/iopoll.h>
> +#include <linux/jiffies.h>
> +#include <linux/kernel.h>
> +#include <linux/module.h>
> +#include <linux/mutex.h>
> +#include <linux/of.h>
> +#include <linux/of_device.h>
> +#include <linux/platform_device.h>
> +#include <linux/pm_qos.h>
> +#include <linux/sizes.h>
> +
> +#include <linux/spi/spi.h>
> +#include <linux/spi/spi-mem.h>
> +
> +/*
> + * The driver only uses one single LUT entry, that is updated on
> + * each call of exec_op(). Index 0 is preset at boot with a basic
> + * read operation, so let's use the last entry (15).
> + */
> +#define	SEQID_LUT			15
> +
> +/* Registers used by the driver */
> +#define QUADSPI_MCR			0x00
> +#define QUADSPI_MCR_RESERVED_MASK	GENMASK(19, 16)
> +#define QUADSPI_MCR_MDIS_MASK		BIT(14)
> +#define QUADSPI_MCR_CLR_TXF_MASK	BIT(11)
> +#define QUADSPI_MCR_CLR_RXF_MASK	BIT(10)
> +#define QUADSPI_MCR_DDR_EN_MASK		BIT(7)
> +#define QUADSPI_MCR_END_CFG_MASK	GENMASK(3, 2)
> +#define QUADSPI_MCR_SWRSTHD_MASK	BIT(1)
> +#define QUADSPI_MCR_SWRSTSD_MASK	BIT(0)
> +
> +#define QUADSPI_IPCR			0x08
> +#define QUADSPI_IPCR_SEQID(x)		((x) << 24)
> +
> +#define QUADSPI_BUF3CR			0x1c
> +#define QUADSPI_BUF3CR_ALLMST_MASK	BIT(31)
> +#define QUADSPI_BUF3CR_ADATSZ(x)	((x) << 8)
> +#define QUADSPI_BUF3CR_ADATSZ_MASK	GENMASK(15, 8)
> +
> +#define QUADSPI_BFGENCR			0x20
> +#define QUADSPI_BFGENCR_SEQID(x)	((x) << 12)
> +
> +#define QUADSPI_BUF0IND			0x30
> +#define QUADSPI_BUF1IND			0x34
> +#define QUADSPI_BUF2IND			0x38
> +#define QUADSPI_SFAR			0x100
> +
> +#define QUADSPI_SMPR			0x108
> +#define QUADSPI_SMPR_DDRSMP_MASK	GENMASK(18, 16)
> +#define QUADSPI_SMPR_FSDLY_MASK		BIT(6)
> +#define QUADSPI_SMPR_FSPHS_MASK		BIT(5)
> +#define QUADSPI_SMPR_HSENA_MASK		BIT(0)
> +
> +#define QUADSPI_RBCT			0x110
> +#define QUADSPI_RBCT_WMRK_MASK		GENMASK(4, 0)
> +#define QUADSPI_RBCT_RXBRD_USEIPS	BIT(8)
> +
> +#define QUADSPI_TBDR			0x154
> +
> +#define QUADSPI_SR			0x15c
> +#define QUADSPI_SR_IP_ACC_MASK		BIT(1)
> +#define QUADSPI_SR_AHB_ACC_MASK		BIT(2)
> +
> +#define QUADSPI_FR			0x160
> +#define QUADSPI_FR_TFF_MASK		BIT(0)
> +
> +#define QUADSPI_SPTRCLR			0x16c
> +#define QUADSPI_SPTRCLR_IPPTRC		BIT(8)
> +#define QUADSPI_SPTRCLR_BFPTRC		BIT(0)
> +
> +#define QUADSPI_SFA1AD			0x180
> +#define QUADSPI_SFA2AD			0x184
> +#define QUADSPI_SFB1AD			0x188
> +#define QUADSPI_SFB2AD			0x18c
> +#define QUADSPI_RBDR(x)			(0x200 + ((x) * 4))
> +
> +#define QUADSPI_LUTKEY			0x300
> +#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
> +
> +#define QUADSPI_LCKCR			0x304
> +#define QUADSPI_LCKER_LOCK		BIT(0)
> +#define QUADSPI_LCKER_UNLOCK		BIT(1)
> +
> +#define QUADSPI_RSER			0x164
> +#define QUADSPI_RSER_TFIE		BIT(0)
> +
> +#define QUADSPI_LUT_BASE		0x310
> +#define QUADSPI_LUT_OFFSET		(SEQID_LUT * 4 * 4)
> +#define QUADSPI_LUT_REG(idx) \
> +	(QUADSPI_LUT_BASE + QUADSPI_LUT_OFFSET + (idx) * 4)
> +
> +/* Instruction set for the LUT register */
> +#define LUT_STOP		0
> +#define LUT_CMD			1
> +#define LUT_ADDR		2
> +#define LUT_DUMMY		3
> +#define LUT_MODE		4
> +#define LUT_MODE2		5
> +#define LUT_MODE4		6
> +#define LUT_FSL_READ		7
> +#define LUT_FSL_WRITE		8
> +#define LUT_JMP_ON_CS		9
> +#define LUT_ADDR_DDR		10
> +#define LUT_MODE_DDR		11
> +#define LUT_MODE2_DDR		12
> +#define LUT_MODE4_DDR		13
> +#define LUT_FSL_READ_DDR	14
> +#define LUT_FSL_WRITE_DDR	15
> +#define LUT_DATA_LEARN		16
> +
> +/*
> + * The PAD definitions for LUT register.
> + *
> + * The pad stands for the number of IO lines [0:3].
> + * For example, the quad read needs four IO lines,
> + * so you should use LUT_PAD(4).
> + */
> +#define LUT_PAD(x) (fls(x) - 1)
> +
> +/*
> + * Macro for constructing the LUT entries with the following
> + * register layout:
> + *
> + *  ---------------------------------------------------
> + *  | INSTR1 | PAD1 | OPRND1 | INSTR0 | PAD0 | OPRND0 |
> + *  ---------------------------------------------------
> + */
> +#define LUT_DEF(idx, ins, pad, opr)					\
> +	((((ins) << 10) | ((pad) << 8) | (opr)) << (((idx) % 2) * 16))
> +
> +/* Controller needs driver to swap endianness */
> +#define QUADSPI_QUIRK_SWAP_ENDIAN	BIT(0)
> +
> +/* Controller needs 4x internal clock */
> +#define QUADSPI_QUIRK_4X_INT_CLK	BIT(1)
> +
> +/*
> + * TKT253890, the controller needs the driver to fill the txfifo with
> + * 16 bytes at least to trigger a data transfer, even though the extra
> + * data won't be transferred.
> + */
> +#define QUADSPI_QUIRK_TKT253890		BIT(2)
> +
> +/* TKT245618, the controller cannot wake up from wait mode */
> +#define QUADSPI_QUIRK_TKT245618		BIT(3)
> +
> +/*
> + * Controller adds QSPI_AMBA_BASE (base address of the mapped memory)
> + * internally. No need to add it when setting SFXXAD and SFAR registers
> +*/
> +#define QUADSPI_QUIRK_BASE_INTERNAL	BIT(4)
> +
> +struct fsl_qspi_devtype_data {
> +	unsigned int rxfifo;
> +	unsigned int txfifo;
> +	unsigned int ahb_buf_size;
> +	unsigned int quirks;
> +	bool little_endian;
> +};
> +
> +static const struct fsl_qspi_devtype_data vybrid_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_SWAP_ENDIAN,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx6sx_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_4X_INT_CLK | QUADSPI_QUIRK_TKT245618,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx7d_data =3D {
> +	.rxfifo =3D SZ_512,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx6ul_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data ls1021a_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D 0,
> +	.little_endian =3D false,
> +};
> +
> +static const struct fsl_qspi_devtype_data ls2080a_data =3D {
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 |
> QUADSPI_QUIRK_BASE_INTERNAL,
> +	.little_endian =3D true,
> +};
> +
> +struct fsl_qspi {
> +	void __iomem *iobase;
> +	void __iomem *ahb_addr;
> +	u32 memmap_phy;
> +	struct clk *clk, *clk_en;
> +	struct device *dev;
> +	struct completion c;
> +	const struct fsl_qspi_devtype_data *devtype_data;
> +	struct mutex lock;
> +	struct pm_qos_request pm_qos_req;
> +	int selected;
> +};
> +
> +static inline int needs_swap_endian(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_SWAP_ENDIAN; }
> +
> +static inline int needs_4x_clock(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_4X_INT_CLK; }
> +
> +static inline int needs_fill_txfifo(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT253890; }
> +
> +static inline int needs_wakeup_wait_mode(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT245618; }
> +
> +static inline int needs_amba_base_offset(struct fsl_qspi *q) {
> +	return !(q->devtype_data->quirks &
> QUADSPI_QUIRK_BASE_INTERNAL); }
> +
> +/*
> + * An IC bug makes it necessary to rearrange the 32-bit data.
> + * Later chips, such as IMX6SLX, have fixed this bug.
> + */
> +static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a) {
> +	return needs_swap_endian(q) ? __swab32(a) : a; }
> +
> +/*
> + * R/W functions for big- or little-endian registers:
> + * The QSPI controller's endianness is independent of
> + * the CPU core's endianness. So far, although the CPU
> + * core is little-endian the QSPI controller can use
> + * big-endian or little-endian.
> + */
> +static void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem
> +*addr) {
> +	if (q->devtype_data->little_endian)
> +		iowrite32(val, addr);
> +	else
> +		iowrite32be(val, addr);
> +}
> +
> +static u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr) {
> +	if (q->devtype_data->little_endian)
> +		return ioread32(addr);
> +
> +	return ioread32be(addr);
> +}
> +
> +static irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id) {
> +	struct fsl_qspi *q =3D dev_id;
> +	u32 reg;
> +
> +	/* clear interrupt */
> +	reg =3D qspi_readl(q, q->iobase + QUADSPI_FR);
> +	qspi_writel(q, reg, q->iobase + QUADSPI_FR);
> +
> +	if (reg & QUADSPI_FR_TFF_MASK)
> +		complete(&q->c);
> +
> +	dev_dbg(q->dev, "QUADSPI_FR : 0x%.8x:0x%.8x\n", 0, reg);
> +	return IRQ_HANDLED;
> +}
> +
> +static int fsl_qspi_check_buswidth(struct fsl_qspi *q, u8 width) {
> +	switch (width) {
> +	case 1:
> +	case 2:
> +	case 4:
> +		return 0;
> +	}
> +
> +	return -ENOTSUPP;
> +}
> +
> +static bool fsl_qspi_supports_op(struct spi_mem *mem,
> +				 const struct spi_mem_op *op)
> +{
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	int ret;
> +
> +	ret =3D fsl_qspi_check_buswidth(q, op->cmd.buswidth);
> +
> +	if (op->addr.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->addr.buswidth);
> +
> +	if (op->dummy.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->dummy.buswidth);
> +
> +	if (op->data.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->data.buswidth);
> +
> +	if (ret)
> +		return false;
> +
> +	/*
> +	 * The number of instructions needed for the op, needs
> +	 * to fit into a single LUT entry.
> +	 */
> +	if (op->addr.nbytes +
> +	   (op->dummy.nbytes ? 1:0) +
> +	   (op->data.nbytes ? 1:0) > 6)
> +		return false;
> +
> +	/* Max 64 dummy clock cycles supported */
> +	if (op->dummy.nbytes &&
> +	    (op->dummy.nbytes * 8 / op->dummy.buswidth > 64))
> +		return false;
> +
> +	/* Max data length, check controller limits and alignment */
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_IN &&
> +	    (op->data.nbytes > q->devtype_data->ahb_buf_size ||
> +	     (op->data.nbytes > q->devtype_data->rxfifo - 4 &&
> +	      !IS_ALIGNED(op->data.nbytes, 8))))
> +		return false;
> +
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT &&
> +	    op->data.nbytes > q->devtype_data->txfifo)
> +		return false;
> +
> +	return true;
> +}
> +
> +static void fsl_qspi_prepare_lut(struct fsl_qspi *q,
> +				 const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	u32 lutval[4] =3D {};
> +	int lutidx =3D 1, i;
> +
> +	lutval[0] |=3D LUT_DEF(0, LUT_CMD, LUT_PAD(op->cmd.buswidth),
> +			     op->cmd.opcode);
> +
> +	/*
> +	 * For some unknown reason, using LUT_ADDR doesn't work in some
> +	 * cases (at least with only one byte long addresses), so
> +	 * let's use LUT_MODE to write the address bytes one by one
> +	 */
> +	for (i =3D 0; i < op->addr.nbytes; i++) {
> +		u8 addrbyte =3D op->addr.val >> (8 * (op->addr.nbytes - i - 1));
> +
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_MODE,
> +					      LUT_PAD(op->addr.buswidth),
> +					      addrbyte);
> +		lutidx++;
> +	}
> +
> +	if (op->dummy.nbytes) {
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_DUMMY,
> +					      LUT_PAD(op->dummy.buswidth),
> +					      op->dummy.nbytes * 8 /
> +					      op->dummy.buswidth);
> +		lutidx++;
> +	}
> +
> +	if (op->data.nbytes) {
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx,
> +					      op->data.dir =3D=3D
> SPI_MEM_DATA_IN ?
> +					      LUT_FSL_READ : LUT_FSL_WRITE,
> +					      LUT_PAD(op->data.buswidth),
> +					      0);
> +		lutidx++;
> +	}
> +
> +	lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_STOP, 0, 0);
> +
> +	/* unlock LUT */
> +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
> +	qspi_writel(q, QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);
> +
> +	/* fill LUT */
> +	for (i =3D 0; i < ARRAY_SIZE(lutval); i++)
> +		qspi_writel(q, lutval[i], base + QUADSPI_LUT_REG(i));
> +
> +	/* lock LUT */
> +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
> +	qspi_writel(q, QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR); }
> +
> +static int fsl_qspi_clk_prep_enable(struct fsl_qspi *q) {
> +	int ret;
> +
> +	ret =3D clk_prepare_enable(q->clk_en);
> +	if (ret)
> +		return ret;
> +
> +	ret =3D clk_prepare_enable(q->clk);
> +	if (ret) {
> +		clk_disable_unprepare(q->clk_en);
> +		return ret;
> +	}
> +
> +	if (needs_wakeup_wait_mode(q))
> +		pm_qos_add_request(&q->pm_qos_req,
> PM_QOS_CPU_DMA_LATENCY, 0);
> +
> +	return 0;
> +}
> +
> +static void fsl_qspi_clk_disable_unprep(struct fsl_qspi *q) {
> +	if (needs_wakeup_wait_mode(q))
> +		pm_qos_remove_request(&q->pm_qos_req);
> +
> +	clk_disable_unprepare(q->clk);
> +	clk_disable_unprepare(q->clk_en);
> +}
> +
> +/*
> + * If we have changed the content of the flash by writing or erasing,
> +or if we
> + * read from flash with a different offset into the page buffer, we
> +need to
> + * invalidate the AHB buffer. If we do not do so, we may read out the
> +wrong
> + * data. The spec tells us reset the AHB domain and Serial Flash domain
> +at
> + * the same time.
> + */
> +static void fsl_qspi_invalidate(struct fsl_qspi *q) {
> +	u32 reg;
> +
> +	reg =3D qspi_readl(q, q->iobase + QUADSPI_MCR);
> +	reg |=3D QUADSPI_MCR_SWRSTHD_MASK |
> QUADSPI_MCR_SWRSTSD_MASK;
> +	qspi_writel(q, reg, q->iobase + QUADSPI_MCR);
> +
> +	/*
> +	 * The minimum delay : 1 AHB + 2 SFCK clocks.
> +	 * Delay 1 us is enough.
> +	 */
> +	udelay(1);
> +
> +	reg &=3D ~(QUADSPI_MCR_SWRSTHD_MASK |
> QUADSPI_MCR_SWRSTSD_MASK);
> +	qspi_writel(q, reg, q->iobase + QUADSPI_MCR); }
> +
> +static void fsl_qspi_select_mem(struct fsl_qspi *q, struct spi_device
> +*spi) {
> +	unsigned long rate =3D spi->max_speed_hz;
> +	int ret;
> +
> +	if (q->selected =3D=3D spi->chip_select)
> +		return;
> +
> +	if (needs_4x_clock(q))
> +		rate *=3D 4;
> +
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	ret =3D clk_set_rate(q->clk, rate);
> +	if (ret)
> +		return;
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret)
> +		return;
> +
> +	q->selected =3D spi->chip_select;
> +
> +	fsl_qspi_invalidate(q);
> +}
> +
> +static void fsl_qspi_read_ahb(struct fsl_qspi *q, const struct
> +spi_mem_op *op) {
> +	memcpy_fromio(op->data.buf.in,
> +		      q->ahb_addr + q->selected * q->devtype_data-
> >ahb_buf_size,
> +		      op->data.nbytes);
> +}
> +
> +static void fsl_qspi_fill_txfifo(struct fsl_qspi *q,
> +				 const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	int i;
> +	u32 val;
> +
> +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> +		memcpy(&val, op->data.buf.out + i, 4);
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		qspi_writel(q, val, base + QUADSPI_TBDR);
> +	}
> +
> +	if (i < op->data.nbytes) {
> +		memcpy(&val, op->data.buf.out + i, op->data.nbytes - i);
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		qspi_writel(q, val, base + QUADSPI_TBDR);
> +	}
> +
> +	if (needs_fill_txfifo(q)) {
> +		for (i =3D op->data.nbytes; i < 16; i +=3D 4)
> +			qspi_writel(q, 0, base + QUADSPI_TBDR);
> +	}
> +}
> +
> +static void fsl_qspi_read_rxfifo(struct fsl_qspi *q,
> +			  const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	int i;
> +	u8 *buf =3D op->data.buf.in;
> +	u32 val;
> +
> +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		memcpy(buf + i, &val, 4);
> +	}
> +
> +	if (i < op->data.nbytes) {
> +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		memcpy(buf + i, &val, op->data.nbytes - i);
> +	}
> +}
> +
> +static int fsl_qspi_do_op(struct fsl_qspi *q, const struct spi_mem_op
> +*op) {
> +	void __iomem *base =3D q->iobase;
> +	int err =3D 0;
> +
> +	init_completion(&q->c);
> +
> +	/*
> +	 * Always start the sequence at the same index since we update
> +	 * the LUT at each exec_op() call. And also specify the DATA
> +	 * length, since it's has not been specified in the LUT.
> +	 */
> +	qspi_writel(q, op->data.nbytes | QUADSPI_IPCR_SEQID(SEQID_LUT),
> +		    base + QUADSPI_IPCR);
> +
> +	/* Wait for the interrupt. */
> +	if (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000)))
> +		err =3D -ETIMEDOUT;
> +
> +	if (!err && op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_IN)
> +		fsl_qspi_read_rxfifo(q, op);
> +
> +	return err;
> +}
> +
> +static int fsl_qspi_readl_poll_tout(struct fsl_qspi *q, void __iomem *ba=
se,
> +				    u32 mask, u32 delay_us, u32 timeout_us) {
> +	u32 reg;
> +
> +	if (!q->devtype_data->little_endian)
> +		mask =3D (u32)cpu_to_be32(mask);
> +
> +	return readl_poll_timeout(base, reg, !(reg & mask), delay_us,
> +				  timeout_us);
> +}
> +
> +static int fsl_qspi_exec_op(struct spi_mem *mem, const struct
> +spi_mem_op *op) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	void __iomem *base =3D q->iobase;
> +	u32 addr_offset =3D 0;
> +	int err =3D 0;
> +
> +	mutex_lock(&q->lock);
> +
> +	/* wait for the controller being ready */
> +	fsl_qspi_readl_poll_tout(q, base + QUADSPI_SR,
> (QUADSPI_SR_IP_ACC_MASK |
> +				 QUADSPI_SR_AHB_ACC_MASK), 10, 1000);
> +
> +	fsl_qspi_select_mem(q, mem->spi);
> +
> +	if (needs_amba_base_offset(q))
> +		addr_offset =3D q->memmap_phy;
> +
> +	qspi_writel(q,
> +		    q->selected * q->devtype_data->ahb_buf_size + addr_offset,
> +		    base + QUADSPI_SFAR);
> +
> +	qspi_writel(q, qspi_readl(q, base + QUADSPI_MCR) |
> +		    QUADSPI_MCR_CLR_RXF_MASK |
> QUADSPI_MCR_CLR_TXF_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	qspi_writel(q, QUADSPI_SPTRCLR_BFPTRC | QUADSPI_SPTRCLR_IPPTRC,
> +		    base + QUADSPI_SPTRCLR);
> +
> +	fsl_qspi_prepare_lut(q, op);
> +
> +	/*
> +	 * If we have large chunks of data, we read them through the AHB bus
> +	 * by accessing the mapped memory. In all other cases we use
> +	 * IP commands to access the flash.
> +	 */
> +	if (op->data.nbytes > (q->devtype_data->rxfifo - 4) &&
> +	    op->data.dir =3D=3D SPI_MEM_DATA_IN) {
> +		fsl_qspi_read_ahb(q, op);
> +	} else {
> +		qspi_writel(q, QUADSPI_RBCT_WMRK_MASK |
> +			    QUADSPI_RBCT_RXBRD_USEIPS, base +
> QUADSPI_RBCT);
> +
> +		if (op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_OUT)
> +			fsl_qspi_fill_txfifo(q, op);
> +
> +		err =3D fsl_qspi_do_op(q, op);
> +	}
> +
> +	/* Invalidate the data in the AHB buffer. */
> +	fsl_qspi_invalidate(q);
> +
> +	mutex_unlock(&q->lock);
> +
> +	return err;
> +}
> +
> +static int fsl_qspi_adjust_op_size(struct spi_mem *mem, struct
> +spi_mem_op *op) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT) {
> +		if (op->data.nbytes > q->devtype_data->txfifo)
> +			op->data.nbytes =3D q->devtype_data->txfifo;
> +	} else {
> +		if (op->data.nbytes > q->devtype_data->ahb_buf_size)
> +			op->data.nbytes =3D q->devtype_data->ahb_buf_size;
> +		else if (op->data.nbytes > (q->devtype_data->rxfifo - 4))
> +			op->data.nbytes =3D ALIGN_DOWN(op->data.nbytes, 8);
> +	}
> +
> +	return 0;
> +}
> +
> +static int fsl_qspi_default_setup(struct fsl_qspi *q) {
> +	void __iomem *base =3D q->iobase;
> +	u32 reg, addr_offset =3D 0;
> +	int ret;
> +
> +	/* disable and unprepare clock to avoid glitch pass to controller */
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	/* the default frequency, we will change it later if necessary. */
> +	ret =3D clk_set_rate(q->clk, 66000000);
> +	if (ret)
> +		return ret;
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret)
> +		return ret;
> +
> +	/* Reset the module */
> +	qspi_writel(q, QUADSPI_MCR_SWRSTSD_MASK |
> QUADSPI_MCR_SWRSTHD_MASK,
> +		    base + QUADSPI_MCR);
> +	udelay(1);
> +
> +	/* Disable the module */
> +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK |
> QUADSPI_MCR_RESERVED_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	reg =3D qspi_readl(q, base + QUADSPI_SMPR);
> +	qspi_writel(q, reg & ~(QUADSPI_SMPR_FSDLY_MASK
> +			| QUADSPI_SMPR_FSPHS_MASK
> +			| QUADSPI_SMPR_HSENA_MASK
> +			| QUADSPI_SMPR_DDRSMP_MASK), base +
> QUADSPI_SMPR);
> +
> +	/* We only use the buffer3 for AHB read */
> +	qspi_writel(q, 0, base + QUADSPI_BUF0IND);
> +	qspi_writel(q, 0, base + QUADSPI_BUF1IND);
> +	qspi_writel(q, 0, base + QUADSPI_BUF2IND);
> +
> +	qspi_writel(q, QUADSPI_BFGENCR_SEQID(SEQID_LUT),
> +		    q->iobase + QUADSPI_BFGENCR);
> +	qspi_writel(q, QUADSPI_RBCT_WMRK_MASK, base + QUADSPI_RBCT);
> +	qspi_writel(q, QUADSPI_BUF3CR_ALLMST_MASK |
> +		    QUADSPI_BUF3CR_ADATSZ(q->devtype_data->ahb_buf_size /
> 8),
> +		    base + QUADSPI_BUF3CR);
> +
> +	if (needs_amba_base_offset(q))
> +		addr_offset =3D q->memmap_phy;
> +
> +	/*
> +	 * In HW there can be a maximum of four chips on two buses with
> +	 * two chip selects on each bus. We use four chip selects in SW
> +	 * to differentiate between the four chips.
> +	 * We use ahb_buf_size for each chip and set SFA1AD, SFA2AD, SFB1AD,
> +	 * SFB2AD accordingly.
> +	 */
> +	qspi_writel(q, q->devtype_data->ahb_buf_size + addr_offset,
> +		    base + QUADSPI_SFA1AD);
> +	qspi_writel(q, q->devtype_data->ahb_buf_size * 2 + addr_offset,
> +		    base + QUADSPI_SFA2AD);
> +	qspi_writel(q, q->devtype_data->ahb_buf_size * 3 + addr_offset,
> +		    base + QUADSPI_SFB1AD);
> +	qspi_writel(q, q->devtype_data->ahb_buf_size * 4 + addr_offset,
> +		    base + QUADSPI_SFB2AD);
> +
> +	q->selected =3D -1;
> +
> +	/* Enable the module */
> +	qspi_writel(q, QUADSPI_MCR_RESERVED_MASK |
> QUADSPI_MCR_END_CFG_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	/* clear all interrupt status */
> +	qspi_writel(q, 0xffffffff, q->iobase + QUADSPI_FR);
> +
> +	/* enable the interrupt */
> +	qspi_writel(q, QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);
> +
> +	return 0;
> +}
> +
> +static const char *fsl_qspi_get_name(struct spi_mem *mem) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	struct device *dev =3D &mem->spi->dev;
> +	const char *name;
> +
> +	/*
> +	 * In order to keep mtdparts compatible with the old MTD driver at
> +	 * mtd/spi-nor/fsl-quadspi.c, we set a custom name derived from the
> +	 * platform_device of the controller.
> +	 */
> +	if (of_get_available_child_count(q->dev->of_node) =3D=3D 1)
> +		return dev_name(q->dev);
> +
> +	name =3D devm_kasprintf(dev, GFP_KERNEL,
> +			      "%s-%d", dev_name(q->dev),
> +			      mem->spi->chip_select);
> +
> +	if (!name) {
> +		dev_err(dev, "failed to get memory for custom flash name\n");
> +		return ERR_PTR(-ENOMEM);
> +	}
> +
> +	return name;
> +}
> +
> +static const struct spi_controller_mem_ops fsl_qspi_mem_ops =3D {
> +	.adjust_op_size =3D fsl_qspi_adjust_op_size,
> +	.supports_op =3D fsl_qspi_supports_op,
> +	.exec_op =3D fsl_qspi_exec_op,
> +	.get_name =3D fsl_qspi_get_name,
> +};
> +
> +static int fsl_qspi_probe(struct platform_device *pdev) {
> +	struct spi_controller *ctlr;
> +	struct device *dev =3D &pdev->dev;
> +	struct device_node *np =3D dev->of_node;
> +	struct resource *res;
> +	struct fsl_qspi *q;
> +	int ret;
> +
> +	ctlr =3D spi_alloc_master(&pdev->dev, sizeof(*q));
> +	if (!ctlr)
> +		return -ENOMEM;
> +
> +	ctlr->mode_bits =3D SPI_RX_DUAL | SPI_RX_QUAD |
> +			  SPI_TX_DUAL | SPI_TX_QUAD;
> +
> +	q =3D spi_controller_get_devdata(ctlr);
> +	q->dev =3D dev;
> +	q->devtype_data =3D of_device_get_match_data(dev);
> +	if (!q->devtype_data) {
> +		ret =3D -ENODEV;
> +		goto err_put_ctrl;
> +	}
> +
> +	platform_set_drvdata(pdev, q);
> +
> +	/* find the resources */
> +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> "QuadSPI");
> +	q->iobase =3D devm_ioremap_resource(dev, res);
> +	if (IS_ERR(q->iobase)) {
> +		ret =3D PTR_ERR(q->iobase);
> +		goto err_put_ctrl;
> +	}
> +
> +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> +					"QuadSPI-memory");
> +	q->ahb_addr =3D devm_ioremap_resource(dev, res);
> +	if (IS_ERR(q->ahb_addr)) {
> +		ret =3D PTR_ERR(q->ahb_addr);
> +		goto err_put_ctrl;
> +	}
> +
> +	q->memmap_phy =3D res->start;
> +
> +	/* find the clocks */
> +	q->clk_en =3D devm_clk_get(dev, "qspi_en");
> +	if (IS_ERR(q->clk_en)) {
> +		ret =3D PTR_ERR(q->clk_en);
> +		goto err_put_ctrl;
> +	}
> +
> +	q->clk =3D devm_clk_get(dev, "qspi");
> +	if (IS_ERR(q->clk)) {
> +		ret =3D PTR_ERR(q->clk);
> +		goto err_put_ctrl;
> +	}
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret) {
> +		dev_err(dev, "can not enable the clock\n");
> +		goto err_put_ctrl;
> +	}
> +
> +	/* find the irq */
> +	ret =3D platform_get_irq(pdev, 0);
> +	if (ret < 0) {
> +		dev_err(dev, "failed to get the irq: %d\n", ret);
> +		goto err_disable_clk;
> +	}
> +
> +	ret =3D devm_request_irq(dev, ret,
> +			fsl_qspi_irq_handler, 0, pdev->name, q);
> +	if (ret) {
> +		dev_err(dev, "failed to request irq: %d\n", ret);
> +		goto err_disable_clk;
> +	}
> +
> +	mutex_init(&q->lock);
> +
> +	ctlr->bus_num =3D -1;
> +	ctlr->num_chipselect =3D 4;
> +	ctlr->mem_ops =3D &fsl_qspi_mem_ops;
> +
> +	fsl_qspi_default_setup(q);
> +
> +	ctlr->dev.of_node =3D np;
> +
> +	ret =3D spi_register_controller(ctlr);
> +	if (ret)
> +		goto err_destroy_mutex;
> +
> +	return 0;
> +
> +err_destroy_mutex:
> +	mutex_destroy(&q->lock);
> +
> +err_disable_clk:
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +err_put_ctrl:
> +	spi_controller_put(ctlr);
> +
> +	dev_err(dev, "Freescale QuadSPI probe failed\n");
> +	return ret;
> +}
> +
> +static int fsl_qspi_remove(struct platform_device *pdev) {
> +	struct fsl_qspi *q =3D platform_get_drvdata(pdev);
> +
> +	/* disable the hardware */
> +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK, q->iobase + QUADSPI_MCR);
> +	qspi_writel(q, 0x0, q->iobase + QUADSPI_RSER);
> +
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	mutex_destroy(&q->lock);
> +
> +	return 0;
> +}
> +
> +static int fsl_qspi_suspend(struct device *dev) {
> +	return 0;
> +}
> +
> +static int fsl_qspi_resume(struct device *dev) {
> +	struct fsl_qspi *q =3D dev_get_drvdata(dev);
> +
> +	fsl_qspi_default_setup(q);
> +
> +	return 0;
> +}
> +
> +static const struct of_device_id fsl_qspi_dt_ids[] =3D {
> +	{ .compatible =3D "fsl,vf610-qspi", .data =3D &vybrid_data, },
> +	{ .compatible =3D "fsl,imx6sx-qspi", .data =3D &imx6sx_data, },
> +	{ .compatible =3D "fsl,imx7d-qspi", .data =3D &imx7d_data, },
> +	{ .compatible =3D "fsl,imx6ul-qspi", .data =3D &imx6ul_data, },
> +	{ .compatible =3D "fsl,ls1021a-qspi", .data =3D &ls1021a_data, },
> +	{ .compatible =3D "fsl,ls2080a-qspi", .data =3D &ls2080a_data, },
> +	{ /* sentinel */ }
> +};
> +MODULE_DEVICE_TABLE(of, fsl_qspi_dt_ids);
> +
> +static const struct dev_pm_ops fsl_qspi_pm_ops =3D {
> +	.suspend	=3D fsl_qspi_suspend,
> +	.resume		=3D fsl_qspi_resume,
> +};
> +
> +static struct platform_driver fsl_qspi_driver =3D {
> +	.driver =3D {
> +		.name	=3D "fsl-quadspi",
> +		.of_match_table =3D fsl_qspi_dt_ids,
> +		.pm =3D   &fsl_qspi_pm_ops,
> +	},
> +	.probe          =3D fsl_qspi_probe,
> +	.remove		=3D fsl_qspi_remove,
> +};
> +module_platform_driver(fsl_qspi_driver);
> +
> +MODULE_DESCRIPTION("Freescale QuadSPI Controller Driver");
> +MODULE_AUTHOR("Freescale Semiconductor Inc."); MODULE_AUTHOR("Boris
> +Brezillion <boris.brezillon@bootlin.com>"); MODULE_AUTHOR("Frieder
> +Schrempf <frieder.schrempf@kontron.de>"); MODULE_AUTHOR("Yogesh Gaur
> +<yogeshnarayan.gaur@nxp.com>"); MODULE_AUTHOR("Suresh Gupta
> +<suresh.gupta@nxp.com>"); MODULE_LICENSE("GPL v2");
> --
> 2.7.4
