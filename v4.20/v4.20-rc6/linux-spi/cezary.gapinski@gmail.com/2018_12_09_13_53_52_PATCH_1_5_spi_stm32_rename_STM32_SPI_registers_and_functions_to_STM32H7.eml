Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 10 Dec 2018 08:55:19 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga001.jf.intel.com (orsmga001.jf.intel.com [10.7.209.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id E7D4E5800CB;
	Sun,  9 Dec 2018 05:54:35 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga001-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 09 Dec 2018 05:54:35 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AF0In0hFv9k3zbhqNw35p751GYnF86YWxBRYc798d?=
 =?us-ascii?q?s5kLTJ75oc29bnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjm58axlVAHnhz?=
 =?us-ascii?q?sGNz4h8WHYlMpwjL5AoBm8oxBz2pPYbJ2JOPZ7eK7WYNEUSndbXstJVyJPHJ6y?=
 =?us-ascii?q?YYUMAeQGP+lYoZL9p0MMoBalGQWgGPnixiNSi3PqwaE31fkqHwHc3AwnGtIDqG?=
 =?us-ascii?q?jbo8v0NagIS+C0zLPEzTrZYPNO2Df97pPIchMgofyXUrJwdNDeyUgrFw/fklqQ?=
 =?us-ascii?q?ronlMjWI3eoOq2iW9/RsWf6rhmI9tg18rCajyt0xhoTKmo4Z0FHJ+CdhzIs2K9?=
 =?us-ascii?q?C0UlB3bNC+HJdNtSyXNZF6Tt0sTmxsvisx16cItoShfCcQzZQq3x7fZOKDc4iP?=
 =?us-ascii?q?+h/jSumRLilihH5/e7KwmQyy8U6+xe34TMW010xKriVdntnNsHACyQDT59CZRv?=
 =?us-ascii?q?dh+kqtwyuD2g7N5u1ePEw5lrbXJ4Qgz7MyjpYTtF7MHi7ymEX4lq+WcUAk9/Cs?=
 =?us-ascii?q?6+TmZLXmu5CdO5Z3ig7gKKQunNKwAeAhPggJUWmb//qz1Kf48E3nT7VFkOc2nr?=
 =?us-ascii?q?PasJ/EP8QboLC2AwtP3oYk8Ra/AC+q0M4EknkfMFJFZBWHgpDtO1HPI/D3E+2z?=
 =?us-ascii?q?gluxkDpww/DGP7vhAojCL3TZkbfhe6p95FBYyAYp0d9f4JdUAKkbIP3vQk/xqM?=
 =?us-ascii?q?DYDhghPgy02ennCcl92ZkZWW6VAq+ZLbndsVmH5u80J+mMZYkVuCvyKvQ/5v7u?=
 =?us-ascii?q?i2M5lkEZfaWzwZQXb3W4FOx8I0qFeXrsnssBEWASswo8S+zllkeOUT1UZ3a0Wa?=
 =?us-ascii?q?I84So2CIanDYfFW4Csj6aN3Ca9Hp1KeG9GDkqAHmvvd4WBQ/0Mcj6dItd9kjwY?=
 =?us-ascii?q?UrisU5Uu1QqutA/9yLprNPDU9TcatZ/40Nh15uvTlQw99DBuDsSd1X2NQH9wnm?=
 =?us-ascii?q?8SWzA226V/q1Rnylifyah4n+BYFdtL6vNKSAg6M4TQz+h7C9/oXALBccyESFKn?=
 =?us-ascii?q?QtWgHDEwQcg9w94IY0ZhBdqiigrP0DatA78Qj7aLHoA78rrA33jtIMZw02vJ27?=
 =?us-ascii?q?M/j1Y4WMdPNXephqhk9wfNAY7FlEGZl6WvdaQYxyPN8GaDzWyTvEBXSgJwUKPF?=
 =?us-ascii?q?XWwBaUvSt9j2+kTCT7q2A7Q9LgRB0dKCKrdNatDxkFpJXunjN8rEb2KxgWiwAw?=
 =?us-ascii?q?2Iya2KbIfxf2Ud3SPdCFULkgwJ/HaGMxQ+CTmlo27EEDNuElfvaVv28eZisHO7?=
 =?us-ascii?q?UlM0zwaSYk191rq1/xkVheCcS/ITxL4EpD0tqzJuHFa53tLWDdWAqhFlfKVdZ9?=
 =?us-ascii?q?M9/VhG2XjYtwx7IpyvMaRiikQCfARwukPkzw93BZlYkcg2sHMqyxJ/Jric0Fxf?=
 =?us-ascii?q?eDKXw5DxNqfMJWnv4R+gcajW2lLZ0NaI4aoP7PU4q1P+vACmDEYi8nNn08VL3H?=
 =?us-ascii?q?uY/JnFEA0SUZfpWEYt6xd6v63aYjU6547M1XxsLLO4vSPY19MoBOsq0BCgf9hE?=
 =?us-ascii?q?PaOAFQ/yFdAaBse0JOwrnVipcgwLPORI+KEoOMOmcuOM2LS3M+Z4gDKmkWNH7Z?=
 =?us-ascii?q?hn0kKN6yVzUPTI0IsCw/2C2AuISS38jFa4vs/rg49EYSwdEXSlySjjAo5cfaly?=
 =?us-ascii?q?fYcNCWezLMy73NR+h5jxW3FG8F6vHU8J2MiseRCKdVzywRVQ1VgLoXyggSa5zz?=
 =?us-ascii?q?10nyspr6aFxyzO3uLieQEDOm5KQmlikFjtLZK1j9AcQEincQwpmAG56kb9wqhR?=
 =?us-ascii?q?vL5/IHXLQUdUYyj2KHlvUqmqubqYYM5P65QovT9MUOumYlCaSb/9ox0E3CPlBG?=
 =?us-ascii?q?ZewDE7dze3upT2hRB6iWSdLGpto3rdY81/2RDf5NnET/5LwjUGXDV4iSXQBlWk?=
 =?us-ascii?q?P9im59KUm43BsuC/UWKsTZlTcSjtzYOduyq3/2xqARujn/+tnt3rCxQ10Sj+19?=
 =?us-ascii?q?NyTyXHsA78YpX316S9Ke9nfVNnBF7m58p6B4FxiI0whJ4L1Hgeh5WV+2cHkGjp?=
 =?us-ascii?q?PdVa36L+cGQCRToRz9HJ5wjl3VVpLmiVyILhSnWd3sxhasG/YmMX2SIy9dpGCa?=
 =?us-ascii?q?mK47xfgSt6vEC4ohnPbvhnkTcQ0v8u6H8cg+EUtwsh1CSdArYOHUZGOSzgjQiH?=
 =?us-ascii?q?79e7rK9PfmagbaCw1FZindCmFLyCvgZcWHPjdpYjByBw6Nh/MEnX0H3y8YzkfN?=
 =?us-ascii?q?jQbdQOthybiRvAju5VKI4vmfoOnyZoJWX9vXg9we4hkRNuxY26vJSAK2h15622?=
 =?us-ascii?q?GBlYNjnoZ88J/jHtkL1TnsKX34CpA5VgFS8HXJruTfK0Dj0Sse7rOBqJED05sn?=
 =?us-ascii?q?2bA6bQHReD6Ed6qHLCC5KrOGuSJHYH1tVuXgWdKFZcgAAJXzU6g5g5GRqxxMH6?=
 =?us-ascii?q?dEd55zYR5kP3qxdWy+JoMQX/XXnbpAuydjg0T52fJgJM7g5e/0fVLdCe7uVrEi?=
 =?us-ascii?q?BY+Z2hsRWNKnGBaAROF20JQUuEB1bsPrS14dnA8u6YBvexLvfUYLWOr/BeWOmM?=
 =?us-ascii?q?xZ61zoRm+DOMPN2VPnZ+F/07xlZDXXdhFsTZhToPSi8XlyHMb8KBpxe84Cp3rs?=
 =?us-ascii?q?+h//TxRQLv/pCCC79TMdVp5hC3jr2PN++WhCZlNzlY0okAymPPyLgaxFQSkT1h?=
 =?us-ascii?q?dyGxEbQcsi7AVLjfmrJMAB4BdSxyNNFE76Y93gRWPc7bi9X11qN3j/IvCldFU0?=
 =?us-ascii?q?Dhld+tZcAQP269M1bHDl6RNLuaPT3L3933YaSkRL1MjeVUsge8tiqBH0D/PjSM?=
 =?us-ascii?q?iT/pWgurMeFNiiGbIRNftJu8chZrFWjsUtbmZgenP99wiD082ac0iW/SNW4ALT?=
 =?us-ascii?q?h8dFtAr72K4iNeh/V/GmpB4WJkLOmEgSmZ6ebYJ40SsftqBCR0iu1b7G47y7tT?=
 =?us-ascii?q?8CFLWvh1lDHOod5pplH12tWInx9uShkGgCxMm4TD6U94PqLf95RoWnve+h8Jq2?=
 =?us-ascii?q?KKBEJO799kDMD//rtIy/DRm6/pbjRP6dTZ+Y0bHceQYMaGNmcxdAH1HWWOJBAZ?=
 =?us-ascii?q?CDuncGTWhkhYmffU7WGStJ0gp4DoidwFTbofHFg0EO4KT01/GZkBLY1xUzcMlb?=
 =?us-ascii?q?+AkNVO5HywthDdScxW+JfdWbbaBfTpNSbcjrReYRYM6a33IJ5VNYDh3UFmLF5g?=
 =?us-ascii?q?k8CCIU3aFfBAuDdgaAB89F9K+ng9QnEb2E//bA6ppngJGqjw1hI7lAp1bPg3+T?=
 =?us-ascii?q?rE/Vg6PBzJqTE2nU13ns/q0h6LdzukJ6qiVJtHTSX9r0k3KZD6awlwZAy220dj?=
 =?us-ascii?q?MWSXD4lNhqdtIDg4wDTXvoFCTLsFFfVJ?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0BXAABnHQ1ch0O0hNFcBxsBAQEBAwEBA?=
 =?us-ascii?q?QcDAQEBgWWBW4IRJ4xyiy+CDRRolmmBYw4BARgTAYddIjgSAQMBAQEBAQECARM?=
 =?us-ascii?q?BAQEKCwkIKSMMgjYkAYJiAwMBAhcBDBkBGx0BAwIJAQEFEAMHMQMeAhEBBQEcB?=
 =?us-ascii?q?gEJCQWCUUuBaQEDFQQBmWk8jAkWBQEXgncFhDIKGScNXROBJAIGEodggWuBKIE?=
 =?us-ascii?q?cghaBEYJdgwyBbhULCYVuAokQBRoKgXCEFIFOjzwuBwKOIIMvAhaBXIgKNochi?=
 =?us-ascii?q?SKBBYR8iWYCBAIJAgUPIYE8gXdwgQGCO4IbCQMXg0qKVD8ygQQBAQGKIimCJAE?=
 =?us-ascii?q?B?=
X-IPAS-Result: =?us-ascii?q?A0BXAABnHQ1ch0O0hNFcBxsBAQEBAwEBAQcDAQEBgWWBW4I?=
 =?us-ascii?q?RJ4xyiy+CDRRolmmBYw4BARgTAYddIjgSAQMBAQEBAQECARMBAQEKCwkIKSMMg?=
 =?us-ascii?q?jYkAYJiAwMBAhcBDBkBGx0BAwIJAQEFEAMHMQMeAhEBBQEcBgEJCQWCUUuBaQE?=
 =?us-ascii?q?DFQQBmWk8jAkWBQEXgncFhDIKGScNXROBJAIGEodggWuBKIEcghaBEYJdgwyBb?=
 =?us-ascii?q?hULCYVuAokQBRoKgXCEFIFOjzwuBwKOIIMvAhaBXIgKNochiSKBBYR8iWYCBAI?=
 =?us-ascii?q?JAgUPIYE8gXdwgQGCO4IbCQMXg0qKVD8ygQQBAQGKIimCJAEB?=
X-IronPort-AV: E=Sophos;i="5.56,334,1539673200"; 
   d="scan'208";a="55587487"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 09 Dec 2018 05:54:33 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726273AbeLINy3 (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 9 Dec 2018 08:54:29 -0500
Received: from mail-wm1-f65.google.com ([209.85.128.65]:36664 "EHLO
        mail-wm1-f65.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726179AbeLINy2 (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 9 Dec 2018 08:54:28 -0500
Received: by mail-wm1-f65.google.com with SMTP id a18so8683458wmj.1;
        Sun, 09 Dec 2018 05:54:24 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=IwNTjQaMyH0fXD0fm99sT3TKNWy/kDWgsFmAdYDs9pY=;
        b=qilr0rFSrYrDH1Y/H7q+5N7XF8p/tW8jXAhorOjcmyUslikBOVbleu52AJAEwQBUlM
         JNlTgzuKgtJbw5cQ1IpUpbCEvjn5Z/lFTidyfCx8M2c27tVUR+1OmBTSIEpp0xIwo6vA
         rsq+QFV7p5vYXbr8Zp/lGJKeNfTwLqMZgSPWSYQtfFpVoFKq/JV7RzyjtsT8zBxx9Yip
         ffWxgC/Qme1u149NFuwkdqh0s4QjDSEvzejlsSTkAFmpsCYH0Ug69juYX+GIkdqJo6fm
         ULnkJubAnUDAyAxLk+fqr6Dsmep8xH1HERMJdIM3a4wyFzJgZM7keX1EX+ny4GLn8Ln7
         /1BQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references;
        bh=IwNTjQaMyH0fXD0fm99sT3TKNWy/kDWgsFmAdYDs9pY=;
        b=LL2aen/fhWOwBntRzuT3+S9T7dxzdJ5DdvPKNlgmJqMIykzYirnFyx0s2oK6CsPT5f
         AmR7EA10TMLAu3yHlKTw3Ed8Lmh1gSyYli2OOU26VffDhAWdVsRUjf+r8EFTWZF7bWEv
         GS0a137acu6Nnu5L/bvwhF3HflahRNiyX6Kr/d7B6rOau3OYfWhYYqDByGE0wCh9L/qW
         ALttKkSaaDq+E/SNWpgAsZZlFyX26Lk7duWw4HfFw/iw1X3Wmmx5fKZbTzRnaogOEnzU
         pjB/8uZhyumtFqspn20miI4CE3xvVvOjz92K8xPBHp60XM56RMJDBelm1Rz4MCUTcv/B
         mCFA==
X-Gm-Message-State: AA+aEWYGLVWy6zpC4dHSWEBg2j4CsfY59+bRjj02AJb5OAbdlkhuM17J
        By1VhqBTnch9MHs1q+239D8=
X-Google-Smtp-Source: AFSGD/VMFTlTmowqMmbY/FxOl066KwVkKx2Kdnvhfw9mC4QXX2XBUsDOoCTnpopFT7oTJ3sMysSYBg==
X-Received: by 2002:a1c:c148:: with SMTP id r69mr7647065wmf.147.1544363662890;
        Sun, 09 Dec 2018 05:54:22 -0800 (PST)
Received: from gapa-Lenovo-IdeaPad-Y580.home (dgv239.neoplus.adsl.tpnet.pl. [83.23.177.239])
        by smtp.gmail.com with ESMTPSA id k128sm12271795wmd.37.2018.12.09.05.54.21
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-SHA bits=128/128);
        Sun, 09 Dec 2018 05:54:22 -0800 (PST)
From: cezary.gapinski@gmail.com
To: Mark Brown <broonie@kernel.org>, linux-spi@vger.kernel.org,
        linux-stm32@st-md-mailman.stormreply.com,
        linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org,
        Rob Herring <robh+dt@kernel.org>, devicetree@vger.kernel.org
Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>,
        Alexandre Torgue <alexandre.torgue@st.com>,
        Amelie Delaunay <amelie.delaunay@st.com>,
        Mark Rutland <mark.rutland@arm.com>,
        Cezary Gapinski <cezary.gapinski@gmail.com>
Subject: [PATCH 1/5] spi: stm32: rename STM32 SPI registers and functions to STM32H7
Date: Sun,  9 Dec 2018 14:53:52 +0100
Message-Id: <1544363636-12161-2-git-send-email-cezary.gapinski@gmail.com>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <1544363636-12161-1-git-send-email-cezary.gapinski@gmail.com>
References: <1544363636-12161-1-git-send-email-cezary.gapinski@gmail.com>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: Cezary Gapinski <cezary.gapinski@gmail.com>

Rename STM32 SPI registers and functions to be related to STM32H7 SPI
driver and not STM32 generally.

Signed-off-by: Cezary Gapinski <cezary.gapinski@gmail.com>
---
 drivers/spi/spi-stm32.c | 662 +++++++++++++++++++++++++-----------------------
 1 file changed, 340 insertions(+), 322 deletions(-)

diff --git a/drivers/spi/spi-stm32.c b/drivers/spi/spi-stm32.c
index ad1e55d..eb4d93e 100644
--- a/drivers/spi/spi-stm32.c
+++ b/drivers/spi/spi-stm32.c
@@ -33,97 +33,97 @@
 
 #define DRIVER_NAME "spi_stm32"
 
-/* STM32 SPI registers */
-#define STM32_SPI_CR1		0x00
-#define STM32_SPI_CR2		0x04
-#define STM32_SPI_CFG1		0x08
-#define STM32_SPI_CFG2		0x0C
-#define STM32_SPI_IER		0x10
-#define STM32_SPI_SR		0x14
-#define STM32_SPI_IFCR		0x18
-#define STM32_SPI_TXDR		0x20
-#define STM32_SPI_RXDR		0x30
-#define STM32_SPI_I2SCFGR	0x50
-
-/* STM32_SPI_CR1 bit fields */
-#define SPI_CR1_SPE		BIT(0)
-#define SPI_CR1_MASRX		BIT(8)
-#define SPI_CR1_CSTART		BIT(9)
-#define SPI_CR1_CSUSP		BIT(10)
-#define SPI_CR1_HDDIR		BIT(11)
-#define SPI_CR1_SSI		BIT(12)
-
-/* STM32_SPI_CR2 bit fields */
-#define SPI_CR2_TSIZE_SHIFT	0
-#define SPI_CR2_TSIZE		GENMASK(15, 0)
-
-/* STM32_SPI_CFG1 bit fields */
-#define SPI_CFG1_DSIZE_SHIFT	0
-#define SPI_CFG1_DSIZE		GENMASK(4, 0)
-#define SPI_CFG1_FTHLV_SHIFT	5
-#define SPI_CFG1_FTHLV		GENMASK(8, 5)
-#define SPI_CFG1_RXDMAEN	BIT(14)
-#define SPI_CFG1_TXDMAEN	BIT(15)
-#define SPI_CFG1_MBR_SHIFT	28
-#define SPI_CFG1_MBR		GENMASK(30, 28)
-#define SPI_CFG1_MBR_MIN	0
-#define SPI_CFG1_MBR_MAX	(GENMASK(30, 28) >> 28)
-
-/* STM32_SPI_CFG2 bit fields */
-#define SPI_CFG2_MIDI_SHIFT	4
-#define SPI_CFG2_MIDI		GENMASK(7, 4)
-#define SPI_CFG2_COMM_SHIFT	17
-#define SPI_CFG2_COMM		GENMASK(18, 17)
-#define SPI_CFG2_SP_SHIFT	19
-#define SPI_CFG2_SP		GENMASK(21, 19)
-#define SPI_CFG2_MASTER		BIT(22)
-#define SPI_CFG2_LSBFRST	BIT(23)
-#define SPI_CFG2_CPHA		BIT(24)
-#define SPI_CFG2_CPOL		BIT(25)
-#define SPI_CFG2_SSM		BIT(26)
-#define SPI_CFG2_AFCNTR		BIT(31)
-
-/* STM32_SPI_IER bit fields */
-#define SPI_IER_RXPIE		BIT(0)
-#define SPI_IER_TXPIE		BIT(1)
-#define SPI_IER_DXPIE		BIT(2)
-#define SPI_IER_EOTIE		BIT(3)
-#define SPI_IER_TXTFIE		BIT(4)
-#define SPI_IER_OVRIE		BIT(6)
-#define SPI_IER_MODFIE		BIT(9)
-#define SPI_IER_ALL		GENMASK(10, 0)
-
-/* STM32_SPI_SR bit fields */
-#define SPI_SR_RXP		BIT(0)
-#define SPI_SR_TXP		BIT(1)
-#define SPI_SR_EOT		BIT(3)
-#define SPI_SR_OVR		BIT(6)
-#define SPI_SR_MODF		BIT(9)
-#define SPI_SR_SUSP		BIT(11)
-#define SPI_SR_RXPLVL_SHIFT	13
-#define SPI_SR_RXPLVL		GENMASK(14, 13)
-#define SPI_SR_RXWNE		BIT(15)
-
-/* STM32_SPI_IFCR bit fields */
-#define SPI_IFCR_ALL		GENMASK(11, 3)
-
-/* STM32_SPI_I2SCFGR bit fields */
-#define SPI_I2SCFGR_I2SMOD	BIT(0)
-
-/* SPI Master Baud Rate min/max divisor */
-#define SPI_MBR_DIV_MIN		(2 << SPI_CFG1_MBR_MIN)
-#define SPI_MBR_DIV_MAX		(2 << SPI_CFG1_MBR_MAX)
-
-/* SPI Communication mode */
-#define SPI_FULL_DUPLEX		0
-#define SPI_SIMPLEX_TX		1
-#define SPI_SIMPLEX_RX		2
-#define SPI_HALF_DUPLEX		3
-
-#define SPI_1HZ_NS		1000000000
+/* STM32H7 SPI registers */
+#define STM32H7_SPI_CR1			0x00
+#define STM32H7_SPI_CR2			0x04
+#define STM32H7_SPI_CFG1		0x08
+#define STM32H7_SPI_CFG2		0x0C
+#define STM32H7_SPI_IER			0x10
+#define STM32H7_SPI_SR			0x14
+#define STM32H7_SPI_IFCR		0x18
+#define STM32H7_SPI_TXDR		0x20
+#define STM32H7_SPI_RXDR		0x30
+#define STM32H7_SPI_I2SCFGR		0x50
+
+/* STM32H7_SPI_CR1 bit fields */
+#define STM32H7_SPI_CR1_SPE		BIT(0)
+#define STM32H7_SPI_CR1_MASRX		BIT(8)
+#define STM32H7_SPI_CR1_CSTART		BIT(9)
+#define STM32H7_SPI_CR1_CSUSP		BIT(10)
+#define STM32H7_SPI_CR1_HDDIR		BIT(11)
+#define STM32H7_SPI_CR1_SSI		BIT(12)
+
+/* STM32H7_SPI_CR2 bit fields */
+#define STM32H7_SPI_CR2_TSIZE_SHIFT	0
+#define STM32H7_SPI_CR2_TSIZE		GENMASK(15, 0)
+
+/* STM32H7_SPI_CFG1 bit fields */
+#define STM32H7_SPI_CFG1_DSIZE_SHIFT	0
+#define STM32H7_SPI_CFG1_DSIZE		GENMASK(4, 0)
+#define STM32H7_SPI_CFG1_FTHLV_SHIFT	5
+#define STM32H7_SPI_CFG1_FTHLV		GENMASK(8, 5)
+#define STM32H7_SPI_CFG1_RXDMAEN	BIT(14)
+#define STM32H7_SPI_CFG1_TXDMAEN	BIT(15)
+#define STM32H7_SPI_CFG1_MBR_SHIFT	28
+#define STM32H7_SPI_CFG1_MBR		GENMASK(30, 28)
+#define STM32H7_SPI_CFG1_MBR_MIN	0
+#define STM32H7_SPI_CFG1_MBR_MAX	(GENMASK(30, 28) >> 28)
+
+/* STM32H7_SPI_CFG2 bit fields */
+#define STM32H7_SPI_CFG2_MIDI_SHIFT	4
+#define STM32H7_SPI_CFG2_MIDI		GENMASK(7, 4)
+#define STM32H7_SPI_CFG2_COMM_SHIFT	17
+#define STM32H7_SPI_CFG2_COMM		GENMASK(18, 17)
+#define STM32H7_SPI_CFG2_SP_SHIFT	19
+#define STM32H7_SPI_CFG2_SP		GENMASK(21, 19)
+#define STM32H7_SPI_CFG2_MASTER		BIT(22)
+#define STM32H7_SPI_CFG2_LSBFRST	BIT(23)
+#define STM32H7_SPI_CFG2_CPHA		BIT(24)
+#define STM32H7_SPI_CFG2_CPOL		BIT(25)
+#define STM32H7_SPI_CFG2_SSM		BIT(26)
+#define STM32H7_SPI_CFG2_AFCNTR		BIT(31)
+
+/* STM32H7_SPI_IER bit fields */
+#define STM32H7_SPI_IER_RXPIE		BIT(0)
+#define STM32H7_SPI_IER_TXPIE		BIT(1)
+#define STM32H7_SPI_IER_DXPIE		BIT(2)
+#define STM32H7_SPI_IER_EOTIE		BIT(3)
+#define STM32H7_SPI_IER_TXTFIE		BIT(4)
+#define STM32H7_SPI_IER_OVRIE		BIT(6)
+#define STM32H7_SPI_IER_MODFIE		BIT(9)
+#define STM32H7_SPI_IER_ALL		GENMASK(10, 0)
+
+/* STM32H7_SPI_SR bit fields */
+#define STM32H7_SPI_SR_RXP		BIT(0)
+#define STM32H7_SPI_SR_TXP		BIT(1)
+#define STM32H7_SPI_SR_EOT		BIT(3)
+#define STM32H7_SPI_SR_OVR		BIT(6)
+#define STM32H7_SPI_SR_MODF		BIT(9)
+#define STM32H7_SPI_SR_SUSP		BIT(11)
+#define STM32H7_SPI_SR_RXPLVL_SHIFT	13
+#define STM32H7_SPI_SR_RXPLVL		GENMASK(14, 13)
+#define STM32H7_SPI_SR_RXWNE		BIT(15)
+
+/* STM32H7_SPI_IFCR bit fields */
+#define STM32H7_SPI_IFCR_ALL		GENMASK(11, 3)
+
+/* STM32H7_SPI_I2SCFGR bit fields */
+#define STM32H7_SPI_I2SCFGR_I2SMOD	BIT(0)
+
+/* STM32H7 SPI Master Baud Rate min/max divisor */
+#define STM32H7_SPI_MBR_DIV_MIN		(2 << STM32H7_SPI_CFG1_MBR_MIN)
+#define STM32H7_SPI_MBR_DIV_MAX		(2 << STM32H7_SPI_CFG1_MBR_MAX)
+
+/* STM32H7 SPI Communication mode */
+#define STM32H7_SPI_FULL_DUPLEX		0
+#define STM32H7_SPI_SIMPLEX_TX		1
+#define STM32H7_SPI_SIMPLEX_RX		2
+#define STM32H7_SPI_HALF_DUPLEX		3
+
+#define STM32H7_SPI_1HZ_NS		1000000000
 
 /**
- * struct stm32_spi - private data of the SPI controller
+ * struct stm32h7_spi - private data of the SPI controller
  * @dev: driver model representation of the controller
  * @master: controller master interface
  * @base: virtual memory area
@@ -148,7 +148,7 @@
  * @dma_rx: dma channel for RX transfer
  * @phys_addr: SPI registers physical base address
  */
-struct stm32_spi {
+struct stm32h7_spi {
 	struct device *dev;
 	struct spi_master *master;
 	void __iomem *base;
@@ -176,37 +176,37 @@ struct stm32_spi {
 	dma_addr_t phys_addr;
 };
 
-static inline void stm32_spi_set_bits(struct stm32_spi *spi,
-				      u32 offset, u32 bits)
+static inline void stm32h7_spi_set_bits(struct stm32h7_spi *spi,
+					u32 offset, u32 bits)
 {
 	writel_relaxed(readl_relaxed(spi->base + offset) | bits,
 		       spi->base + offset);
 }
 
-static inline void stm32_spi_clr_bits(struct stm32_spi *spi,
-				      u32 offset, u32 bits)
+static inline void stm32h7_spi_clr_bits(struct stm32h7_spi *spi,
+					u32 offset, u32 bits)
 {
 	writel_relaxed(readl_relaxed(spi->base + offset) & ~bits,
 		       spi->base + offset);
 }
 
 /**
- * stm32_spi_get_fifo_size - Return fifo size
+ * stm32h7_spi_get_fifo_size - Return fifo size
  * @spi: pointer to the spi controller data structure
  */
-static int stm32_spi_get_fifo_size(struct stm32_spi *spi)
+static int stm32h7_spi_get_fifo_size(struct stm32h7_spi *spi)
 {
 	unsigned long flags;
 	u32 count = 0;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
-	stm32_spi_set_bits(spi, STM32_SPI_CR1, SPI_CR1_SPE);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);
 
-	while (readl_relaxed(spi->base + STM32_SPI_SR) & SPI_SR_TXP)
-		writeb_relaxed(++count, spi->base + STM32_SPI_TXDR);
+	while (readl_relaxed(spi->base + STM32H7_SPI_SR) & STM32H7_SPI_SR_TXP)
+		writeb_relaxed(++count, spi->base + STM32H7_SPI_TXDR);
 
-	stm32_spi_clr_bits(spi, STM32_SPI_CR1, SPI_CR1_SPE);
+	stm32h7_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
@@ -216,10 +216,10 @@ static int stm32_spi_get_fifo_size(struct stm32_spi *spi)
 }
 
 /**
- * stm32_spi_get_bpw_mask - Return bits per word mask
+ * stm32h7_spi_get_bpw_mask - Return bits per word mask
  * @spi: pointer to the spi controller data structure
  */
-static int stm32_spi_get_bpw_mask(struct stm32_spi *spi)
+static int stm32h7_spi_get_bpw_mask(struct stm32h7_spi *spi)
 {
 	unsigned long flags;
 	u32 cfg1, max_bpw;
@@ -230,10 +230,11 @@ static int stm32_spi_get_bpw_mask(struct stm32_spi *spi)
 	 * The most significant bit at DSIZE bit field is reserved when the
 	 * maximum data size of periperal instances is limited to 16-bit
 	 */
-	stm32_spi_set_bits(spi, STM32_SPI_CFG1, SPI_CFG1_DSIZE);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_DSIZE);
 
-	cfg1 = readl_relaxed(spi->base + STM32_SPI_CFG1);
-	max_bpw = (cfg1 & SPI_CFG1_DSIZE) >> SPI_CFG1_DSIZE_SHIFT;
+	cfg1 = readl_relaxed(spi->base + STM32H7_SPI_CFG1);
+	max_bpw = (cfg1 & STM32H7_SPI_CFG1_DSIZE) >>
+		  STM32H7_SPI_CFG1_DSIZE_SHIFT;
 	max_bpw += 1;
 
 	spin_unlock_irqrestore(&spi->lock, flags);
@@ -244,13 +245,13 @@ static int stm32_spi_get_bpw_mask(struct stm32_spi *spi)
 }
 
 /**
- * stm32_spi_prepare_mbr - Determine SPI_CFG1.MBR value
+ * stm32h7_spi_prepare_mbr - Determine STM32H7_SPI_CFG1.MBR value
  * @spi: pointer to the spi controller data structure
  * @speed_hz: requested speed
  *
- * Return SPI_CFG1.MBR value in case of success or -EINVAL
+ * Return STM32H7_SPI_CFG1.MBR value in case of success or -EINVAL
  */
-static int stm32_spi_prepare_mbr(struct stm32_spi *spi, u32 speed_hz)
+static int stm32h7_spi_prepare_mbr(struct stm32h7_spi *spi, u32 speed_hz)
 {
 	u32 div, mbrdiv;
 
@@ -263,8 +264,8 @@ static int stm32_spi_prepare_mbr(struct stm32_spi *spi, u32 speed_hz)
 	 * no need to check it there.
 	 * However, we need to ensure the following calculations.
 	 */
-	if (div < SPI_MBR_DIV_MIN ||
-	    div > SPI_MBR_DIV_MAX)
+	if (div < STM32H7_SPI_MBR_DIV_MIN ||
+	    div > STM32H7_SPI_MBR_DIV_MAX)
 		return -EINVAL;
 
 	/* Determine the first power of 2 greater than or equal to div */
@@ -279,10 +280,10 @@ static int stm32_spi_prepare_mbr(struct stm32_spi *spi, u32 speed_hz)
 }
 
 /**
- * stm32_spi_prepare_fthlv - Determine FIFO threshold level
+ * stm32h7_spi_prepare_fthlv - Determine FIFO threshold level
  * @spi: pointer to the spi controller data structure
  */
-static u32 stm32_spi_prepare_fthlv(struct stm32_spi *spi)
+static u32 stm32h7_spi_prepare_fthlv(struct stm32h7_spi *spi)
 {
 	u32 fthlv, half_fifo;
 
@@ -306,32 +307,33 @@ static u32 stm32_spi_prepare_fthlv(struct stm32_spi *spi)
 }
 
 /**
- * stm32_spi_write_txfifo - Write bytes in Transmit Data Register
+ * stm32h7_spi_write_txfifo - Write bytes in Transmit Data Register
  * @spi: pointer to the spi controller data structure
  *
  * Read from tx_buf depends on remaining bytes to avoid to read beyond
  * tx_buf end.
  */
-static void stm32_spi_write_txfifo(struct stm32_spi *spi)
+static void stm32h7_spi_write_txfifo(struct stm32h7_spi *spi)
 {
 	while ((spi->tx_len > 0) &&
-	       (readl_relaxed(spi->base + STM32_SPI_SR) & SPI_SR_TXP)) {
+	       (readl_relaxed(spi->base + STM32H7_SPI_SR) &
+		STM32H7_SPI_SR_TXP)) {
 		u32 offs = spi->cur_xferlen - spi->tx_len;
 
 		if (spi->tx_len >= sizeof(u32)) {
 			const u32 *tx_buf32 = (const u32 *)(spi->tx_buf + offs);
 
-			writel_relaxed(*tx_buf32, spi->base + STM32_SPI_TXDR);
+			writel_relaxed(*tx_buf32, spi->base + STM32H7_SPI_TXDR);
 			spi->tx_len -= sizeof(u32);
 		} else if (spi->tx_len >= sizeof(u16)) {
 			const u16 *tx_buf16 = (const u16 *)(spi->tx_buf + offs);
 
-			writew_relaxed(*tx_buf16, spi->base + STM32_SPI_TXDR);
+			writew_relaxed(*tx_buf16, spi->base + STM32H7_SPI_TXDR);
 			spi->tx_len -= sizeof(u16);
 		} else {
 			const u8 *tx_buf8 = (const u8 *)(spi->tx_buf + offs);
 
-			writeb_relaxed(*tx_buf8, spi->base + STM32_SPI_TXDR);
+			writeb_relaxed(*tx_buf8, spi->base + STM32H7_SPI_TXDR);
 			spi->tx_len -= sizeof(u8);
 		}
 	}
@@ -340,43 +342,45 @@ static void stm32_spi_write_txfifo(struct stm32_spi *spi)
 }
 
 /**
- * stm32_spi_read_rxfifo - Read bytes in Receive Data Register
+ * stm32h7_spi_read_rxfifo - Read bytes in Receive Data Register
  * @spi: pointer to the spi controller data structure
  *
  * Write in rx_buf depends on remaining bytes to avoid to write beyond
  * rx_buf end.
  */
-static void stm32_spi_read_rxfifo(struct stm32_spi *spi, bool flush)
+static void stm32h7_spi_read_rxfifo(struct stm32h7_spi *spi, bool flush)
 {
-	u32 sr = readl_relaxed(spi->base + STM32_SPI_SR);
-	u32 rxplvl = (sr & SPI_SR_RXPLVL) >> SPI_SR_RXPLVL_SHIFT;
+	u32 sr = readl_relaxed(spi->base + STM32H7_SPI_SR);
+	u32 rxplvl = (sr & STM32H7_SPI_SR_RXPLVL) >>
+		     STM32H7_SPI_SR_RXPLVL_SHIFT;
 
 	while ((spi->rx_len > 0) &&
-	       ((sr & SPI_SR_RXP) ||
-		(flush && ((sr & SPI_SR_RXWNE) || (rxplvl > 0))))) {
+	       ((sr & STM32H7_SPI_SR_RXP) ||
+		(flush && ((sr & STM32H7_SPI_SR_RXWNE) || (rxplvl > 0))))) {
 		u32 offs = spi->cur_xferlen - spi->rx_len;
 
 		if ((spi->rx_len >= sizeof(u32)) ||
-		    (flush && (sr & SPI_SR_RXWNE))) {
+		    (flush && (sr & STM32H7_SPI_SR_RXWNE))) {
 			u32 *rx_buf32 = (u32 *)(spi->rx_buf + offs);
 
-			*rx_buf32 = readl_relaxed(spi->base + STM32_SPI_RXDR);
+			*rx_buf32 = readl_relaxed(spi->base + STM32H7_SPI_RXDR);
 			spi->rx_len -= sizeof(u32);
 		} else if ((spi->rx_len >= sizeof(u16)) ||
 			   (flush && (rxplvl >= 2 || spi->cur_bpw > 8))) {
 			u16 *rx_buf16 = (u16 *)(spi->rx_buf + offs);
 
-			*rx_buf16 = readw_relaxed(spi->base + STM32_SPI_RXDR);
+			*rx_buf16 = readw_relaxed(spi->base + STM32H7_SPI_RXDR);
 			spi->rx_len -= sizeof(u16);
 		} else {
 			u8 *rx_buf8 = (u8 *)(spi->rx_buf + offs);
 
-			*rx_buf8 = readb_relaxed(spi->base + STM32_SPI_RXDR);
+			*rx_buf8 = readb_relaxed(spi->base + STM32H7_SPI_RXDR);
 			spi->rx_len -= sizeof(u8);
 		}
 
-		sr = readl_relaxed(spi->base + STM32_SPI_SR);
-		rxplvl = (sr & SPI_SR_RXPLVL) >> SPI_SR_RXPLVL_SHIFT;
+		sr = readl_relaxed(spi->base + STM32H7_SPI_SR);
+		rxplvl = (sr & STM32H7_SPI_SR_RXPLVL) >>
+			 STM32H7_SPI_SR_RXPLVL_SHIFT;
 	}
 
 	dev_dbg(spi->dev, "%s%s: %d bytes left\n", __func__,
@@ -384,28 +388,28 @@ static void stm32_spi_read_rxfifo(struct stm32_spi *spi, bool flush)
 }
 
 /**
- * stm32_spi_enable - Enable SPI controller
+ * stm32h7_spi_enable - Enable SPI controller
  * @spi: pointer to the spi controller data structure
  *
  * SPI data transfer is enabled but spi_ker_ck is idle.
- * SPI_CFG1 and SPI_CFG2 are now write protected.
+ * STM32H7_SPI_CFG1 and STM32H7_SPI_CFG2 are now write protected.
  */
-static void stm32_spi_enable(struct stm32_spi *spi)
+static void stm32h7_spi_enable(struct stm32h7_spi *spi)
 {
 	dev_dbg(spi->dev, "enable controller\n");
 
-	stm32_spi_set_bits(spi, STM32_SPI_CR1, SPI_CR1_SPE);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);
 }
 
 /**
- * stm32_spi_disable - Disable SPI controller
+ * stm32h7_spi_disable - Disable SPI controller
  * @spi: pointer to the spi controller data structure
  *
  * RX-Fifo is flushed when SPI controller is disabled. To prevent any data
- * loss, use stm32_spi_read_rxfifo(flush) to read the remaining bytes in
+ * loss, use stm32h7_spi_read_rxfifo(flush) to read the remaining bytes in
  * RX-Fifo.
  */
-static void stm32_spi_disable(struct stm32_spi *spi)
+static void stm32h7_spi_disable(struct stm32h7_spi *spi)
 {
 	unsigned long flags;
 	u32 cr1, sr;
@@ -414,23 +418,23 @@ static void stm32_spi_disable(struct stm32_spi *spi)
 
 	spin_lock_irqsave(&spi->lock, flags);
 
-	cr1 = readl_relaxed(spi->base + STM32_SPI_CR1);
+	cr1 = readl_relaxed(spi->base + STM32H7_SPI_CR1);
 
-	if (!(cr1 & SPI_CR1_SPE)) {
+	if (!(cr1 & STM32H7_SPI_CR1_SPE)) {
 		spin_unlock_irqrestore(&spi->lock, flags);
 		return;
 	}
 
 	/* Wait on EOT or suspend the flow */
-	if (readl_relaxed_poll_timeout_atomic(spi->base + STM32_SPI_SR,
-					      sr, !(sr & SPI_SR_EOT),
+	if (readl_relaxed_poll_timeout_atomic(spi->base + STM32H7_SPI_SR,
+					      sr, !(sr & STM32H7_SPI_SR_EOT),
 					      10, 100000) < 0) {
-		if (cr1 & SPI_CR1_CSTART) {
-			writel_relaxed(cr1 | SPI_CR1_CSUSP,
-				       spi->base + STM32_SPI_CR1);
+		if (cr1 & STM32H7_SPI_CR1_CSTART) {
+			writel_relaxed(cr1 | STM32H7_SPI_CR1_CSUSP,
+				       spi->base + STM32H7_SPI_CR1);
 			if (readl_relaxed_poll_timeout_atomic(
-						spi->base + STM32_SPI_SR,
-						sr, !(sr & SPI_SR_SUSP),
+						spi->base + STM32H7_SPI_SR,
+						sr, !(sr & STM32H7_SPI_SR_SUSP),
 						10, 100000) < 0)
 				dev_warn(spi->dev,
 					 "Suspend request timeout\n");
@@ -438,35 +442,35 @@ static void stm32_spi_disable(struct stm32_spi *spi)
 	}
 
 	if (!spi->cur_usedma && spi->rx_buf && (spi->rx_len > 0))
-		stm32_spi_read_rxfifo(spi, true);
+		stm32h7_spi_read_rxfifo(spi, true);
 
 	if (spi->cur_usedma && spi->tx_buf)
 		dmaengine_terminate_all(spi->dma_tx);
 	if (spi->cur_usedma && spi->rx_buf)
 		dmaengine_terminate_all(spi->dma_rx);
 
-	stm32_spi_clr_bits(spi, STM32_SPI_CR1, SPI_CR1_SPE);
+	stm32h7_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);
 
-	stm32_spi_clr_bits(spi, STM32_SPI_CFG1, SPI_CFG1_TXDMAEN |
-						SPI_CFG1_RXDMAEN);
+	stm32h7_spi_clr_bits(spi, STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_TXDMAEN |
+						    STM32H7_SPI_CFG1_RXDMAEN);
 
 	/* Disable interrupts and clear status flags */
-	writel_relaxed(0, spi->base + STM32_SPI_IER);
-	writel_relaxed(SPI_IFCR_ALL, spi->base + STM32_SPI_IFCR);
+	writel_relaxed(0, spi->base + STM32H7_SPI_IER);
+	writel_relaxed(STM32H7_SPI_IFCR_ALL, spi->base + STM32H7_SPI_IFCR);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 }
 
 /**
- * stm32_spi_can_dma - Determine if the transfer is eligible for DMA use
+ * stm32h7_spi_can_dma - Determine if the transfer is eligible for DMA use
  *
  * If the current transfer size is greater than fifo size, use DMA.
  */
-static bool stm32_spi_can_dma(struct spi_master *master,
-			      struct spi_device *spi_dev,
-			      struct spi_transfer *transfer)
+static bool stm32h7_spi_can_dma(struct spi_master *master,
+				struct spi_device *spi_dev,
+				struct spi_transfer *transfer)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 
 	dev_dbg(spi->dev, "%s: %s\n", __func__,
 		(transfer->len > spi->fifo_size) ? "true" : "false");
@@ -475,33 +479,33 @@ static bool stm32_spi_can_dma(struct spi_master *master,
 }
 
 /**
- * stm32_spi_irq - Interrupt handler for SPI controller events
+ * stm32h7_spi_irq - Interrupt handler for SPI controller events
  * @irq: interrupt line
  * @dev_id: SPI controller master interface
  */
-static irqreturn_t stm32_spi_irq(int irq, void *dev_id)
+static irqreturn_t stm32h7_spi_irq(int irq, void *dev_id)
 {
 	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 	u32 sr, ier, mask;
 	unsigned long flags;
 	bool end = false;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
-	sr = readl_relaxed(spi->base + STM32_SPI_SR);
-	ier = readl_relaxed(spi->base + STM32_SPI_IER);
+	sr = readl_relaxed(spi->base + STM32H7_SPI_SR);
+	ier = readl_relaxed(spi->base + STM32H7_SPI_IER);
 
 	mask = ier;
 	/* EOTIE is triggered on EOT, SUSP and TXC events. */
-	mask |= SPI_SR_SUSP;
+	mask |= STM32H7_SPI_SR_SUSP;
 	/*
 	 * When TXTF is set, DXPIE and TXPIE are cleared. So in case of
 	 * Full-Duplex, need to poll RXP event to know if there are remaining
 	 * data, before disabling SPI.
 	 */
 	if (spi->rx_buf && !spi->cur_usedma)
-		mask |= SPI_SR_RXP;
+		mask |= STM32H7_SPI_SR_RXP;
 
 	if (!(sr & mask)) {
 		dev_dbg(spi->dev, "spurious IT (sr=0x%08x, ier=0x%08x)\n",
@@ -510,10 +514,10 @@ static irqreturn_t stm32_spi_irq(int irq, void *dev_id)
 		return IRQ_NONE;
 	}
 
-	if (sr & SPI_SR_SUSP) {
+	if (sr & STM32H7_SPI_SR_SUSP) {
 		dev_warn(spi->dev, "Communication suspended\n");
 		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
-			stm32_spi_read_rxfifo(spi, false);
+			stm32h7_spi_read_rxfifo(spi, false);
 		/*
 		 * If communication is suspended while using DMA, it means
 		 * that something went wrong, so stop the current transfer
@@ -522,15 +526,15 @@ static irqreturn_t stm32_spi_irq(int irq, void *dev_id)
 			end = true;
 	}
 
-	if (sr & SPI_SR_MODF) {
+	if (sr & STM32H7_SPI_SR_MODF) {
 		dev_warn(spi->dev, "Mode fault: transfer aborted\n");
 		end = true;
 	}
 
-	if (sr & SPI_SR_OVR) {
+	if (sr & STM32H7_SPI_SR_OVR) {
 		dev_warn(spi->dev, "Overrun: received value discarded\n");
 		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
-			stm32_spi_read_rxfifo(spi, false);
+			stm32h7_spi_read_rxfifo(spi, false);
 		/*
 		 * If overrun is detected while using DMA, it means that
 		 * something went wrong, so stop the current transfer
@@ -539,36 +543,36 @@ static irqreturn_t stm32_spi_irq(int irq, void *dev_id)
 			end = true;
 	}
 
-	if (sr & SPI_SR_EOT) {
+	if (sr & STM32H7_SPI_SR_EOT) {
 		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
-			stm32_spi_read_rxfifo(spi, true);
+			stm32h7_spi_read_rxfifo(spi, true);
 		end = true;
 	}
 
-	if (sr & SPI_SR_TXP)
+	if (sr & STM32H7_SPI_SR_TXP)
 		if (!spi->cur_usedma && (spi->tx_buf && (spi->tx_len > 0)))
-			stm32_spi_write_txfifo(spi);
+			stm32h7_spi_write_txfifo(spi);
 
-	if (sr & SPI_SR_RXP)
+	if (sr & STM32H7_SPI_SR_RXP)
 		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
-			stm32_spi_read_rxfifo(spi, false);
+			stm32h7_spi_read_rxfifo(spi, false);
 
-	writel_relaxed(mask, spi->base + STM32_SPI_IFCR);
+	writel_relaxed(mask, spi->base + STM32H7_SPI_IFCR);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
 	if (end) {
 		spi_finalize_current_transfer(master);
-		stm32_spi_disable(spi);
+		stm32h7_spi_disable(spi);
 	}
 
 	return IRQ_HANDLED;
 }
 
 /**
- * stm32_spi_setup - setup device chip select
+ * stm32h7_spi_setup - setup device chip select
  */
-static int stm32_spi_setup(struct spi_device *spi_dev)
+static int stm32h7_spi_setup(struct spi_device *spi_dev)
 {
 	int ret = 0;
 
@@ -589,12 +593,12 @@ static int stm32_spi_setup(struct spi_device *spi_dev)
 }
 
 /**
- * stm32_spi_prepare_msg - set up the controller to transfer a single message
+ * stm32h7_spi_prepare_msg - set up the controller to transfer a single message
  */
-static int stm32_spi_prepare_msg(struct spi_master *master,
-				 struct spi_message *msg)
+static int stm32h7_spi_prepare_msg(struct spi_master *master,
+				   struct spi_message *msg)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 	struct spi_device *spi_dev = msg->spi;
 	struct device_node *np = spi_dev->dev.of_node;
 	unsigned long flags;
@@ -606,19 +610,19 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 		dev_dbg(spi->dev, "%dns inter-data idleness\n", spi->cur_midi);
 
 	if (spi_dev->mode & SPI_CPOL)
-		cfg2_setb |= SPI_CFG2_CPOL;
+		cfg2_setb |= STM32H7_SPI_CFG2_CPOL;
 	else
-		cfg2_clrb |= SPI_CFG2_CPOL;
+		cfg2_clrb |= STM32H7_SPI_CFG2_CPOL;
 
 	if (spi_dev->mode & SPI_CPHA)
-		cfg2_setb |= SPI_CFG2_CPHA;
+		cfg2_setb |= STM32H7_SPI_CFG2_CPHA;
 	else
-		cfg2_clrb |= SPI_CFG2_CPHA;
+		cfg2_clrb |= STM32H7_SPI_CFG2_CPHA;
 
 	if (spi_dev->mode & SPI_LSB_FIRST)
-		cfg2_setb |= SPI_CFG2_LSBFRST;
+		cfg2_setb |= STM32H7_SPI_CFG2_LSBFRST;
 	else
-		cfg2_clrb |= SPI_CFG2_LSBFRST;
+		cfg2_clrb |= STM32H7_SPI_CFG2_LSBFRST;
 
 	dev_dbg(spi->dev, "cpol=%d cpha=%d lsb_first=%d cs_high=%d\n",
 		spi_dev->mode & SPI_CPOL,
@@ -630,9 +634,9 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 
 	if (cfg2_clrb || cfg2_setb)
 		writel_relaxed(
-			(readl_relaxed(spi->base + STM32_SPI_CFG2) &
+			(readl_relaxed(spi->base + STM32H7_SPI_CFG2) &
 				~cfg2_clrb) | cfg2_setb,
-			       spi->base + STM32_SPI_CFG2);
+			       spi->base + STM32H7_SPI_CFG2);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
@@ -640,36 +644,36 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 }
 
 /**
- * stm32_spi_dma_cb - dma callback
+ * stm32h7_spi_dma_cb - dma callback
  *
  * DMA callback is called when the transfer is complete or when an error
  * occurs. If the transfer is complete, EOT flag is raised.
  */
-static void stm32_spi_dma_cb(void *data)
+static void stm32h7_spi_dma_cb(void *data)
 {
-	struct stm32_spi *spi = data;
+	struct stm32h7_spi *spi = data;
 	unsigned long flags;
 	u32 sr;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
-	sr = readl_relaxed(spi->base + STM32_SPI_SR);
+	sr = readl_relaxed(spi->base + STM32H7_SPI_SR);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
-	if (!(sr & SPI_SR_EOT))
+	if (!(sr & STM32H7_SPI_SR_EOT))
 		dev_warn(spi->dev, "DMA error (sr=0x%08x)\n", sr);
 
 	/* Now wait for EOT, or SUSP or OVR in case of error */
 }
 
 /**
- * stm32_spi_dma_config - configure dma slave channel depending on current
- *			  transfer bits_per_word.
+ * stm32h7_spi_dma_config - configure dma slave channel depending on current
+ *			    transfer bits_per_word.
  */
-static void stm32_spi_dma_config(struct stm32_spi *spi,
-				 struct dma_slave_config *dma_conf,
-				 enum dma_transfer_direction dir)
+static void stm32h7_spi_dma_config(struct stm32h7_spi *spi,
+				   struct dma_slave_config *dma_conf,
+				   enum dma_transfer_direction dir)
 {
 	enum dma_slave_buswidth buswidth;
 	u32 maxburst;
@@ -690,14 +694,14 @@ static void stm32_spi_dma_config(struct stm32_spi *spi,
 	memset(dma_conf, 0, sizeof(struct dma_slave_config));
 	dma_conf->direction = dir;
 	if (dma_conf->direction == DMA_DEV_TO_MEM) { /* RX */
-		dma_conf->src_addr = spi->phys_addr + STM32_SPI_RXDR;
+		dma_conf->src_addr = spi->phys_addr + STM32H7_SPI_RXDR;
 		dma_conf->src_addr_width = buswidth;
 		dma_conf->src_maxburst = maxburst;
 
 		dev_dbg(spi->dev, "Rx DMA config buswidth=%d, maxburst=%d\n",
 			buswidth, maxburst);
 	} else if (dma_conf->direction == DMA_MEM_TO_DEV) { /* TX */
-		dma_conf->dst_addr = spi->phys_addr + STM32_SPI_TXDR;
+		dma_conf->dst_addr = spi->phys_addr + STM32H7_SPI_TXDR;
 		dma_conf->dst_addr_width = buswidth;
 		dma_conf->dst_maxburst = maxburst;
 
@@ -707,39 +711,40 @@ static void stm32_spi_dma_config(struct stm32_spi *spi,
 }
 
 /**
- * stm32_spi_transfer_one_irq - transfer a single spi_transfer using
- *				interrupts
+ * stm32h7_spi_transfer_one_irq - transfer a single spi_transfer using
+ *				  interrupts
  *
  * It must returns 0 if the transfer is finished or 1 if the transfer is still
  * in progress.
  */
-static int stm32_spi_transfer_one_irq(struct stm32_spi *spi)
+static int stm32h7_spi_transfer_one_irq(struct stm32h7_spi *spi)
 {
 	unsigned long flags;
 	u32 ier = 0;
 
 	/* Enable the interrupts relative to the current communication mode */
 	if (spi->tx_buf && spi->rx_buf)	/* Full Duplex */
-		ier |= SPI_IER_DXPIE;
+		ier |= STM32H7_SPI_IER_DXPIE;
 	else if (spi->tx_buf)		/* Half-Duplex TX dir or Simplex TX */
-		ier |= SPI_IER_TXPIE;
+		ier |= STM32H7_SPI_IER_TXPIE;
 	else if (spi->rx_buf)		/* Half-Duplex RX dir or Simplex RX */
-		ier |= SPI_IER_RXPIE;
+		ier |= STM32H7_SPI_IER_RXPIE;
 
 	/* Enable the interrupts relative to the end of transfer */
-	ier |= SPI_IER_EOTIE | SPI_IER_TXTFIE |	SPI_IER_OVRIE |	SPI_IER_MODFIE;
+	ier |= STM32H7_SPI_IER_EOTIE | STM32H7_SPI_IER_TXTFIE |
+	       STM32H7_SPI_IER_OVRIE | STM32H7_SPI_IER_MODFIE;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
-	stm32_spi_enable(spi);
+	stm32h7_spi_enable(spi);
 
 	/* Be sure to have data in fifo before starting data transfer */
 	if (spi->tx_buf)
-		stm32_spi_write_txfifo(spi);
+		stm32h7_spi_write_txfifo(spi);
 
-	stm32_spi_set_bits(spi, STM32_SPI_CR1, SPI_CR1_CSTART);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
 
-	writel_relaxed(ier, spi->base + STM32_SPI_IER);
+	writel_relaxed(ier, spi->base + STM32H7_SPI_IER);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
@@ -747,13 +752,13 @@ static int stm32_spi_transfer_one_irq(struct stm32_spi *spi)
 }
 
 /**
- * stm32_spi_transfer_one_dma - transfer a single spi_transfer using DMA
+ * stm32h7_spi_transfer_one_dma - transfer a single spi_transfer using DMA
  *
  * It must returns 0 if the transfer is finished or 1 if the transfer is still
  * in progress.
  */
-static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
-				      struct spi_transfer *xfer)
+static int stm32h7_spi_transfer_one_dma(struct stm32h7_spi *spi,
+					struct spi_transfer *xfer)
 {
 	struct dma_slave_config tx_dma_conf, rx_dma_conf;
 	struct dma_async_tx_descriptor *tx_dma_desc, *rx_dma_desc;
@@ -764,11 +769,12 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 	rx_dma_desc = NULL;
 	if (spi->rx_buf) {
-		stm32_spi_dma_config(spi, &rx_dma_conf, DMA_DEV_TO_MEM);
+		stm32h7_spi_dma_config(spi, &rx_dma_conf, DMA_DEV_TO_MEM);
 		dmaengine_slave_config(spi->dma_rx, &rx_dma_conf);
 
 		/* Enable Rx DMA request */
-		stm32_spi_set_bits(spi, STM32_SPI_CFG1, SPI_CFG1_RXDMAEN);
+		stm32h7_spi_set_bits(spi, STM32H7_SPI_CFG1,
+				   STM32H7_SPI_CFG1_RXDMAEN);
 
 		rx_dma_desc = dmaengine_prep_slave_sg(
 					spi->dma_rx, xfer->rx_sg.sgl,
@@ -779,7 +785,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 	tx_dma_desc = NULL;
 	if (spi->tx_buf) {
-		stm32_spi_dma_config(spi, &tx_dma_conf, DMA_MEM_TO_DEV);
+		stm32h7_spi_dma_config(spi, &tx_dma_conf, DMA_MEM_TO_DEV);
 		dmaengine_slave_config(spi->dma_tx, &tx_dma_conf);
 
 		tx_dma_desc = dmaengine_prep_slave_sg(
@@ -794,7 +800,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 		goto dma_desc_error;
 
 	if (rx_dma_desc) {
-		rx_dma_desc->callback = stm32_spi_dma_cb;
+		rx_dma_desc->callback = stm32h7_spi_dma_cb;
 		rx_dma_desc->callback_param = spi;
 
 		if (dma_submit_error(dmaengine_submit(rx_dma_desc))) {
@@ -806,8 +812,8 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 	}
 
 	if (tx_dma_desc) {
-		if (spi->cur_comm == SPI_SIMPLEX_TX) {
-			tx_dma_desc->callback = stm32_spi_dma_cb;
+		if (spi->cur_comm == STM32H7_SPI_SIMPLEX_TX) {
+			tx_dma_desc->callback = stm32h7_spi_dma_cb;
 			tx_dma_desc->callback_param = spi;
 		}
 
@@ -819,16 +825,18 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 		dma_async_issue_pending(spi->dma_tx);
 
 		/* Enable Tx DMA request */
-		stm32_spi_set_bits(spi, STM32_SPI_CFG1, SPI_CFG1_TXDMAEN);
+		stm32h7_spi_set_bits(spi, STM32H7_SPI_CFG1,
+				     STM32H7_SPI_CFG1_TXDMAEN);
 	}
 
 	/* Enable the interrupts relative to the end of transfer */
-	ier |= SPI_IER_EOTIE | SPI_IER_TXTFIE |	SPI_IER_OVRIE |	SPI_IER_MODFIE;
-	writel_relaxed(ier, spi->base + STM32_SPI_IER);
+	ier |= STM32H7_SPI_IER_EOTIE | STM32H7_SPI_IER_TXTFIE |
+	       STM32H7_SPI_IER_OVRIE | STM32H7_SPI_IER_MODFIE;
+	writel_relaxed(ier, spi->base + STM32H7_SPI_IER);
 
-	stm32_spi_enable(spi);
+	stm32h7_spi_enable(spi);
 
-	stm32_spi_set_bits(spi, STM32_SPI_CR1, SPI_CR1_CSTART);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
@@ -839,23 +847,23 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 		dmaengine_terminate_all(spi->dma_rx);
 
 dma_desc_error:
-	stm32_spi_clr_bits(spi, STM32_SPI_CFG1, SPI_CFG1_RXDMAEN);
+	stm32h7_spi_clr_bits(spi, STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_RXDMAEN);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
 	dev_info(spi->dev, "DMA issue: fall back to irq transfer\n");
 
-	return stm32_spi_transfer_one_irq(spi);
+	return stm32h7_spi_transfer_one_irq(spi);
 }
 
 /**
- * stm32_spi_transfer_one_setup - common setup to transfer a single
- *				  spi_transfer either using DMA or
- *				  interrupts.
+ * stm32h7_spi_transfer_one_setup - common setup to transfer a single
+ *				    spi_transfer either using DMA or
+ *				    interrupts.
  */
-static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
-					struct spi_device *spi_dev,
-					struct spi_transfer *transfer)
+static int stm32h7_spi_transfer_one_setup(struct stm32h7_spi *spi,
+					  struct spi_device *spi_dev,
+					  struct spi_transfer *transfer)
 {
 	unsigned long flags;
 	u32 cfg1_clrb = 0, cfg1_setb = 0, cfg2_clrb = 0, cfg2_setb = 0;
@@ -870,21 +878,23 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 		spi->cur_bpw = transfer->bits_per_word;
 		bpw = spi->cur_bpw - 1;
 
-		cfg1_clrb |= SPI_CFG1_DSIZE;
-		cfg1_setb |= (bpw << SPI_CFG1_DSIZE_SHIFT) & SPI_CFG1_DSIZE;
+		cfg1_clrb |= STM32H7_SPI_CFG1_DSIZE;
+		cfg1_setb |= (bpw << STM32H7_SPI_CFG1_DSIZE_SHIFT) &
+			     STM32H7_SPI_CFG1_DSIZE;
 
-		spi->cur_fthlv = stm32_spi_prepare_fthlv(spi);
+		spi->cur_fthlv = stm32h7_spi_prepare_fthlv(spi);
 		fthlv = spi->cur_fthlv - 1;
 
-		cfg1_clrb |= SPI_CFG1_FTHLV;
-		cfg1_setb |= (fthlv << SPI_CFG1_FTHLV_SHIFT) & SPI_CFG1_FTHLV;
+		cfg1_clrb |= STM32H7_SPI_CFG1_FTHLV;
+		cfg1_setb |= (fthlv << STM32H7_SPI_CFG1_FTHLV_SHIFT) &
+			     STM32H7_SPI_CFG1_FTHLV;
 	}
 
 	if (spi->cur_speed != transfer->speed_hz) {
 		int mbr;
 
 		/* Update spi->cur_speed with real clock speed */
-		mbr = stm32_spi_prepare_mbr(spi, transfer->speed_hz);
+		mbr = stm32h7_spi_prepare_mbr(spi, transfer->speed_hz);
 		if (mbr < 0) {
 			ret = mbr;
 			goto out;
@@ -892,16 +902,17 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 
 		transfer->speed_hz = spi->cur_speed;
 
-		cfg1_clrb |= SPI_CFG1_MBR;
-		cfg1_setb |= ((u32)mbr << SPI_CFG1_MBR_SHIFT) & SPI_CFG1_MBR;
+		cfg1_clrb |= STM32H7_SPI_CFG1_MBR;
+		cfg1_setb |= ((u32)mbr << STM32H7_SPI_CFG1_MBR_SHIFT) &
+			     STM32H7_SPI_CFG1_MBR;
 	}
 
 	if (cfg1_clrb || cfg1_setb)
-		writel_relaxed((readl_relaxed(spi->base + STM32_SPI_CFG1) &
+		writel_relaxed((readl_relaxed(spi->base + STM32H7_SPI_CFG1) &
 				~cfg1_clrb) | cfg1_setb,
-			       spi->base + STM32_SPI_CFG1);
+			       spi->base + STM32H7_SPI_CFG1);
 
-	mode = SPI_FULL_DUPLEX;
+	mode = STM32H7_SPI_FULL_DUPLEX;
 	if (spi_dev->mode & SPI_3WIRE) { /* MISO/MOSI signals shared */
 		/*
 		 * SPI_3WIRE and xfer->tx_buf != NULL and xfer->rx_buf != NULL
@@ -909,40 +920,46 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 		 * on the valid buffer, we can determine the direction of the
 		 * transfer.
 		 */
-		mode = SPI_HALF_DUPLEX;
+		mode = STM32H7_SPI_HALF_DUPLEX;
 		if (!transfer->tx_buf)
-			stm32_spi_clr_bits(spi, STM32_SPI_CR1, SPI_CR1_HDDIR);
+			stm32h7_spi_clr_bits(spi, STM32H7_SPI_CR1,
+					     STM32H7_SPI_CR1_HDDIR);
 		else if (!transfer->rx_buf)
-			stm32_spi_set_bits(spi, STM32_SPI_CR1, SPI_CR1_HDDIR);
+			stm32h7_spi_set_bits(spi, STM32H7_SPI_CR1,
+					     STM32H7_SPI_CR1_HDDIR);
 	} else {
 		if (!transfer->tx_buf)
-			mode = SPI_SIMPLEX_RX;
+			mode = STM32H7_SPI_SIMPLEX_RX;
 		else if (!transfer->rx_buf)
-			mode = SPI_SIMPLEX_TX;
+			mode = STM32H7_SPI_SIMPLEX_TX;
 	}
 	if (spi->cur_comm != mode) {
 		spi->cur_comm = mode;
 
-		cfg2_clrb |= SPI_CFG2_COMM;
-		cfg2_setb |= (mode << SPI_CFG2_COMM_SHIFT) & SPI_CFG2_COMM;
+		cfg2_clrb |= STM32H7_SPI_CFG2_COMM;
+		cfg2_setb |= (mode << STM32H7_SPI_CFG2_COMM_SHIFT) &
+			     STM32H7_SPI_CFG2_COMM;
 	}
 
-	cfg2_clrb |= SPI_CFG2_MIDI;
+	cfg2_clrb |= STM32H7_SPI_CFG2_MIDI;
 	if ((transfer->len > 1) && (spi->cur_midi > 0)) {
-		u32 sck_period_ns = DIV_ROUND_UP(SPI_1HZ_NS, spi->cur_speed);
+		u32 sck_period_ns = DIV_ROUND_UP(STM32H7_SPI_1HZ_NS,
+						 spi->cur_speed);
 		u32 midi = min((u32)DIV_ROUND_UP(spi->cur_midi, sck_period_ns),
-			       (u32)SPI_CFG2_MIDI >> SPI_CFG2_MIDI_SHIFT);
+			       (u32)STM32H7_SPI_CFG2_MIDI >>
+			       STM32H7_SPI_CFG2_MIDI_SHIFT);
 
 		dev_dbg(spi->dev, "period=%dns, midi=%d(=%dns)\n",
 			sck_period_ns, midi, midi * sck_period_ns);
 
-		cfg2_setb |= (midi << SPI_CFG2_MIDI_SHIFT) & SPI_CFG2_MIDI;
+		cfg2_setb |= (midi << STM32H7_SPI_CFG2_MIDI_SHIFT) &
+			     STM32H7_SPI_CFG2_MIDI;
 	}
 
 	if (cfg2_clrb || cfg2_setb)
-		writel_relaxed((readl_relaxed(spi->base + STM32_SPI_CFG2) &
+		writel_relaxed((readl_relaxed(spi->base + STM32H7_SPI_CFG2) &
 				~cfg2_clrb) | cfg2_setb,
-			       spi->base + STM32_SPI_CFG2);
+			       spi->base + STM32H7_SPI_CFG2);
 
 	if (spi->cur_bpw <= 8)
 		nb_words = transfer->len;
@@ -950,10 +967,10 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 		nb_words = DIV_ROUND_UP(transfer->len * 8, 16);
 	else
 		nb_words = DIV_ROUND_UP(transfer->len * 8, 32);
-	nb_words <<= SPI_CR2_TSIZE_SHIFT;
+	nb_words <<= STM32H7_SPI_CR2_TSIZE_SHIFT;
 
-	if (nb_words <= SPI_CR2_TSIZE) {
-		writel_relaxed(nb_words, spi->base + STM32_SPI_CR2);
+	if (nb_words <= STM32H7_SPI_CR2_TSIZE) {
+		writel_relaxed(nb_words, spi->base + STM32H7_SPI_CR2);
 	} else {
 		ret = -EMSGSIZE;
 		goto out;
@@ -979,16 +996,16 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 }
 
 /**
- * stm32_spi_transfer_one - transfer a single spi_transfer
+ * stm32h7_spi_transfer_one - transfer a single spi_transfer
  *
  * It must return 0 if the transfer is finished or 1 if the transfer is still
  * in progress.
  */
-static int stm32_spi_transfer_one(struct spi_master *master,
-				  struct spi_device *spi_dev,
-				  struct spi_transfer *transfer)
+static int stm32h7_spi_transfer_one(struct spi_master *master,
+				    struct spi_device *spi_dev,
+				    struct spi_transfer *transfer)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 	int ret;
 
 	spi->tx_buf = transfer->tx_buf;
@@ -997,58 +1014,59 @@ static int stm32_spi_transfer_one(struct spi_master *master,
 	spi->rx_len = spi->rx_buf ? transfer->len : 0;
 
 	spi->cur_usedma = (master->can_dma &&
-			   stm32_spi_can_dma(master, spi_dev, transfer));
+			   stm32h7_spi_can_dma(master, spi_dev, transfer));
 
-	ret = stm32_spi_transfer_one_setup(spi, spi_dev, transfer);
+	ret = stm32h7_spi_transfer_one_setup(spi, spi_dev, transfer);
 	if (ret) {
 		dev_err(spi->dev, "SPI transfer setup failed\n");
 		return ret;
 	}
 
 	if (spi->cur_usedma)
-		return stm32_spi_transfer_one_dma(spi, transfer);
+		return stm32h7_spi_transfer_one_dma(spi, transfer);
 	else
-		return stm32_spi_transfer_one_irq(spi);
+		return stm32h7_spi_transfer_one_irq(spi);
 }
 
 /**
- * stm32_spi_unprepare_msg - relax the hardware
+ * stm32h7_spi_unprepare_msg - relax the hardware
  *
  * Normally, if TSIZE has been configured, we should relax the hardware at the
  * reception of the EOT interrupt. But in case of error, EOT will not be
  * raised. So the subsystem unprepare_message call allows us to properly
  * complete the transfer from an hardware point of view.
  */
-static int stm32_spi_unprepare_msg(struct spi_master *master,
-				   struct spi_message *msg)
+static int stm32h7_spi_unprepare_msg(struct spi_master *master,
+				     struct spi_message *msg)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 
-	stm32_spi_disable(spi);
+	stm32h7_spi_disable(spi);
 
 	return 0;
 }
 
 /**
- * stm32_spi_config - Configure SPI controller as SPI master
+ * stm32h7_spi_config - Configure SPI controller as SPI master
  */
-static int stm32_spi_config(struct stm32_spi *spi)
+static int stm32h7_spi_config(struct stm32h7_spi *spi)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
 	/* Ensure I2SMOD bit is kept cleared */
-	stm32_spi_clr_bits(spi, STM32_SPI_I2SCFGR, SPI_I2SCFGR_I2SMOD);
+	stm32h7_spi_clr_bits(spi, STM32H7_SPI_I2SCFGR,
+			     STM32H7_SPI_I2SCFGR_I2SMOD);
 
 	/*
 	 * - SS input value high
 	 * - transmitter half duplex direction
 	 * - automatic communication suspend when RX-Fifo is full
 	 */
-	stm32_spi_set_bits(spi, STM32_SPI_CR1, SPI_CR1_SSI |
-					       SPI_CR1_HDDIR |
-					       SPI_CR1_MASRX);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SSI |
+						   STM32H7_SPI_CR1_HDDIR |
+						   STM32H7_SPI_CR1_MASRX);
 
 	/*
 	 * - Set the master mode (default Motorola mode)
@@ -1056,29 +1074,29 @@ static int stm32_spi_config(struct stm32_spi *spi)
 	 *   SS input value is determined by the SSI bit
 	 * - keep control of all associated GPIOs
 	 */
-	stm32_spi_set_bits(spi, STM32_SPI_CFG2, SPI_CFG2_MASTER |
-						SPI_CFG2_SSM |
-						SPI_CFG2_AFCNTR);
+	stm32h7_spi_set_bits(spi, STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_MASTER |
+						    STM32H7_SPI_CFG2_SSM |
+						    STM32H7_SPI_CFG2_AFCNTR);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
 	return 0;
 }
 
-static const struct of_device_id stm32_spi_of_match[] = {
+static const struct of_device_id stm32h7_spi_of_match[] = {
 	{ .compatible = "st,stm32h7-spi", },
 	{},
 };
-MODULE_DEVICE_TABLE(of, stm32_spi_of_match);
+MODULE_DEVICE_TABLE(of, stm32h7_spi_of_match);
 
-static int stm32_spi_probe(struct platform_device *pdev)
+static int stm32h7_spi_probe(struct platform_device *pdev)
 {
 	struct spi_master *master;
-	struct stm32_spi *spi;
+	struct stm32h7_spi *spi;
 	struct resource *res;
 	int i, ret;
 
-	master = spi_alloc_master(&pdev->dev, sizeof(struct stm32_spi));
+	master = spi_alloc_master(&pdev->dev, sizeof(struct stm32h7_spi));
 	if (!master) {
 		dev_err(&pdev->dev, "spi master allocation failed\n");
 		return -ENOMEM;
@@ -1105,7 +1123,7 @@ static int stm32_spi_probe(struct platform_device *pdev)
 		goto err_master_put;
 	}
 	ret = devm_request_threaded_irq(&pdev->dev, spi->irq, NULL,
-					stm32_spi_irq, IRQF_ONESHOT,
+					stm32h7_spi_irq, IRQF_ONESHOT,
 					pdev->name, master);
 	if (ret) {
 		dev_err(&pdev->dev, "irq%d request failed: %d\n", spi->irq,
@@ -1139,9 +1157,9 @@ static int stm32_spi_probe(struct platform_device *pdev)
 		reset_control_deassert(spi->rst);
 	}
 
-	spi->fifo_size = stm32_spi_get_fifo_size(spi);
+	spi->fifo_size = stm32h7_spi_get_fifo_size(spi);
 
-	ret = stm32_spi_config(spi);
+	ret = stm32h7_spi_config(spi);
 	if (ret) {
 		dev_err(&pdev->dev, "controller configuration failed: %d\n",
 			ret);
@@ -1153,13 +1171,13 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	master->bus_num = pdev->id;
 	master->mode_bits = SPI_MODE_3 | SPI_CS_HIGH | SPI_LSB_FIRST |
 			    SPI_3WIRE | SPI_LOOP;
-	master->bits_per_word_mask = stm32_spi_get_bpw_mask(spi);
-	master->max_speed_hz = spi->clk_rate / SPI_MBR_DIV_MIN;
-	master->min_speed_hz = spi->clk_rate / SPI_MBR_DIV_MAX;
-	master->setup = stm32_spi_setup;
-	master->prepare_message = stm32_spi_prepare_msg;
-	master->transfer_one = stm32_spi_transfer_one;
-	master->unprepare_message = stm32_spi_unprepare_msg;
+	master->bits_per_word_mask = stm32h7_spi_get_bpw_mask(spi);
+	master->max_speed_hz = spi->clk_rate / STM32H7_SPI_MBR_DIV_MIN;
+	master->min_speed_hz = spi->clk_rate / STM32H7_SPI_MBR_DIV_MAX;
+	master->setup = stm32h7_spi_setup;
+	master->prepare_message = stm32h7_spi_prepare_msg;
+	master->transfer_one = stm32h7_spi_transfer_one;
+	master->unprepare_message = stm32h7_spi_unprepare_msg;
 
 	spi->dma_tx = dma_request_slave_channel(spi->dev, "tx");
 	if (!spi->dma_tx)
@@ -1174,7 +1192,7 @@ static int stm32_spi_probe(struct platform_device *pdev)
 		master->dma_rx = spi->dma_rx;
 
 	if (spi->dma_tx || spi->dma_rx)
-		master->can_dma = stm32_spi_can_dma;
+		master->can_dma = stm32h7_spi_can_dma;
 
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
@@ -1228,12 +1246,12 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int stm32_spi_remove(struct platform_device *pdev)
+static int stm32h7_spi_remove(struct platform_device *pdev)
 {
 	struct spi_master *master = platform_get_drvdata(pdev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 
-	stm32_spi_disable(spi);
+	stm32h7_spi_disable(spi);
 
 	if (master->dma_tx)
 		dma_release_channel(master->dma_tx);
@@ -1248,27 +1266,27 @@ static int stm32_spi_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static int stm32_spi_runtime_suspend(struct device *dev)
+static int stm32h7_spi_runtime_suspend(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 
 	clk_disable_unprepare(spi->clk);
 
 	return 0;
 }
 
-static int stm32_spi_runtime_resume(struct device *dev)
+static int stm32h7_spi_runtime_resume(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 
 	return clk_prepare_enable(spi->clk);
 }
 #endif
 
 #ifdef CONFIG_PM_SLEEP
-static int stm32_spi_suspend(struct device *dev)
+static int stm32h7_spi_suspend(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
 	int ret;
@@ -1280,10 +1298,10 @@ static int stm32_spi_suspend(struct device *dev)
 	return pm_runtime_force_suspend(dev);
 }
 
-static int stm32_spi_resume(struct device *dev)
+static int stm32h7_spi_resume(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32h7_spi *spi = spi_master_get_devdata(master);
 	int ret;
 
 	ret = pm_runtime_force_resume(dev);
@@ -1298,23 +1316,23 @@ static int stm32_spi_resume(struct device *dev)
 }
 #endif
 
-static const struct dev_pm_ops stm32_spi_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(stm32_spi_suspend, stm32_spi_resume)
-	SET_RUNTIME_PM_OPS(stm32_spi_runtime_suspend,
-			   stm32_spi_runtime_resume, NULL)
+static const struct dev_pm_ops stm32h7_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32h7_spi_suspend, stm32h7_spi_resume)
+	SET_RUNTIME_PM_OPS(stm32h7_spi_runtime_suspend,
+			   stm32h7_spi_runtime_resume, NULL)
 };
 
-static struct platform_driver stm32_spi_driver = {
-	.probe = stm32_spi_probe,
-	.remove = stm32_spi_remove,
+static struct platform_driver stm32h7_spi_driver = {
+	.probe = stm32h7_spi_probe,
+	.remove = stm32h7_spi_remove,
 	.driver = {
 		.name = DRIVER_NAME,
-		.pm = &stm32_spi_pm_ops,
-		.of_match_table = stm32_spi_of_match,
+		.pm = &stm32h7_spi_pm_ops,
+		.of_match_table = stm32h7_spi_of_match,
 	},
 };
 
-module_platform_driver(stm32_spi_driver);
+module_platform_driver(stm32h7_spi_driver);
 
 MODULE_ALIAS("platform:" DRIVER_NAME);
 MODULE_DESCRIPTION("STMicroelectronics STM32 SPI Controller driver");
-- 
2.7.4

