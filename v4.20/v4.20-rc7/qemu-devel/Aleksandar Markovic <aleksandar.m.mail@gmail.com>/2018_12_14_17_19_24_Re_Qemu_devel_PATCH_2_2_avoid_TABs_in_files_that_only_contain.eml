Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  15 Dec 2018 13:07:52 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga002.fm.intel.com (fmsmga002.fm.intel.com [10.253.24.26])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 356335805FC
	for <like.xu@linux.intel.com>; Fri, 14 Dec 2018 09:21:39 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by fmsmga002-1.fm.intel.com with ESMTP; 14 Dec 2018 09:21:38 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3ApAJb7B2JKT0/kcpTsmDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?sesWKPvxwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfFjfK3SYMkaSHJDUcZfVyJPDICy?=
 =?us-ascii?q?YZUTAOQcJeZVrYvzqlQToRawGQWjGvjvxyRUhnPqx6A2z/gtHR3E0QEmAtkAsG?=
 =?us-ascii?q?7UrNLwNKoKTe21yLfHzTbYb/xM3zfy9ZLHcgo8qv+LR71wa8nRyU4xFwPEklqb?=
 =?us-ascii?q?tIvoMCmR1usTsGib9PBvVeSyhGE9sQF9uD2vyt0piobTh4IVzkvJ9Sp8wIkvJN?=
 =?us-ascii?q?24TFR3bsKjEJtVriyXMZZ9TMA6Q2xwpio21r4LtYSmcCQXy5kr3QDTZvKHfoSS?=
 =?us-ascii?q?/x7uVv6dLSl5iX55er+yghiy/Eu7xeHgU8S531VHoytKn9TJqHwByxne582JR/?=
 =?us-ascii?q?dj4Eis3yuE2RrJ5eFeO080kLLWK54/zb40kZoeqUDDHi7tmEXql6+abEok+u61?=
 =?us-ascii?q?6+j9ZbXmvJCcO5d1igH4LKsuhtSyDfokPgUNRWSX5Pmw2b758UHnTrhHjuc6nr?=
 =?us-ascii?q?TbvZzCIMQUvK+5Awtb0oY57Ba/Ci+r0M0GknkCMVJJYQ+IgJb3O17QJPD0FOyw?=
 =?us-ascii?q?g1OxkDdt2//JIKbhDpLJLnjCk7fuY6xx6kFByAcrydBf5pRUCqwOIf7pW0/xss?=
 =?us-ascii?q?DYAQE9MwCu3+nnD9B925gYWWKIBK+ZP6XSsUKS6uIoOemMa5cZuCzhJPg9+/7u?=
 =?us-ascii?q?kXg5lEcZfamo3psYdmq0H/t7I0iCZXrsg9EBEXoFvwYkTezqjkGCXiBXZ3qoQ6?=
 =?us-ascii?q?084TQ7W8qbC5zeTNWtnKCZx3X8WZlXfXxdTFaLF3juasODQfhLbSuTJspolHsD?=
 =?us-ascii?q?TaSgTIk6kgijsRK/x7d5I+6HxysDqJi20dF04/HUxwg/8CExA8mD3mXIVWxtg2?=
 =?us-ascii?q?4TWxcw26Zwp1E7zU2MhrNlif5VHsAG+vVSTw0hPoTdxeEpN9enYgvGetDBYlGg?=
 =?us-ascii?q?UNSgAHllVtg2xc0PZUdVAdiujhnfmSGtBulGuaaMAckd9q/fxHH3K89ng1PPzq?=
 =?us-ascii?q?omkVgtCp9GMWClnad5+wHJQYuPlkyYk46lcK0d2GjG82LVnjnGh11RTAMlCfaN?=
 =?us-ascii?q?ZnsYfEaD6I2hvk4=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0BfAQAn5hNchxHrdtBkHgEGBwaBVAYLA?=
 =?us-ascii?q?YEwgTmBKYN8iHiLGSmBZHyJF4QwiwsQGAMRgUuFfCI3Bg0BAwEBAQEBAQIBEwE?=
 =?us-ascii?q?BAQoLCQgbDiMMgjYFAgMaAQaCWwEBAQECAQECFwEIBBkBBQoMHQECAQEBAQIGA?=
 =?us-ascii?q?QEFBQsDBAYCAiIEAgIDAR4BEQEFAQ4OBhMFGYMDAYFnAQMNCAEEmk88iw98FgU?=
 =?us-ascii?q?BF4J3BYQ8ChknDV2BNwIGEnmJcYFCeoEcgRABgl01hFsKBgKDGoI1IgKJHhoGB?=
 =?us-ascii?q?IFxA4QWgU+EBIt5BwKCKIRlg0CHDRiBXU2IAIcomVIPIYE7gXhNI1AxgjsJghI?=
 =?us-ascii?q?JAxeDSoJKiApAMYEHimJVgXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0BfAQAn5hNchxHrdtBkHgEGBwaBVAYLAYEwgTmBKYN8iHi?=
 =?us-ascii?q?LGSmBZHyJF4QwiwsQGAMRgUuFfCI3Bg0BAwEBAQEBAQIBEwEBAQoLCQgbDiMMg?=
 =?us-ascii?q?jYFAgMaAQaCWwEBAQECAQECFwEIBBkBBQoMHQECAQEBAQIGAQEFBQsDBAYCAiI?=
 =?us-ascii?q?EAgIDAR4BEQEFAQ4OBhMFGYMDAYFnAQMNCAEEmk88iw98FgUBF4J3BYQ8ChknD?=
 =?us-ascii?q?V2BNwIGEnmJcYFCeoEcgRABgl01hFsKBgKDGoI1IgKJHhoGBIFxA4QWgU+EBIt?=
 =?us-ascii?q?5BwKCKIRlg0CHDRiBXU2IAIcomVIPIYE7gXhNI1AxgjsJghIJAxeDSoJKiApAM?=
 =?us-ascii?q?YEHimJVgXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,353,1539673200"; 
   d="scan'208";a="44095295"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 14 Dec 2018 09:21:35 -0800
Received: from localhost ([::1]:34726 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gXr9X-0004ie-Vj
	for like.xu@linux.intel.com; Fri, 14 Dec 2018 12:21:32 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:37527)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <aleksandar.m.mail@gmail.com>) id 1gXr96-0004iN-0X
	for qemu-devel@nongnu.org; Fri, 14 Dec 2018 12:21:20 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <aleksandar.m.mail@gmail.com>) id 1gXr8o-0002vl-1t
	for qemu-devel@nongnu.org; Fri, 14 Dec 2018 12:21:03 -0500
Received: from mail-ot1-x32e.google.com ([2607:f8b0:4864:20::32e]:41905)
	by eggs.gnu.org with esmtps (TLS1.0:RSA_AES_128_CBC_SHA1:16)
	(Exim 4.71) (envelope-from <aleksandar.m.mail@gmail.com>)
	id 1gXr7e-00021g-DW; Fri, 14 Dec 2018 12:19:36 -0500
Received: by mail-ot1-x32e.google.com with SMTP id u16so6077243otk.8;
	Fri, 14 Dec 2018 09:19:28 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20161025;
	h=mime-version:in-reply-to:references:from:date:message-id:subject:to
	:cc; bh=ojE3hiFdpAgro7h/IgKo0d8Q8ornsjv0Kh/D9TRszrE=;
	b=pPoL8iqYidOHD6PwlfknlugTPhOMIWun/2v8znFMC2odw8oYiFNld7FR+P7GWfR356
	Cl/eSBAEkNayNetmTzZ8BLMGIH4/NSTDDG2pmI+HaXg4V5LW930aA3iy309LFEiJdoYg
	T9vFZhnN2xfigfRoSkJdws8bEof9dO6GnZjDkYhKX8i3EAacqd/31OuIgiucjnPk2TNi
	wwGOB1NTsGZA7j+k/mSsD1lg5/Oa/7+gurxcv6EbKErUOLHePa4qHyGtxGOrLt6csxaY
	0NzMLJk9U5M8++Ke3NsFMHZT8y+Dy4w6h5KGCtgFCmRuS1obSbU6bVH6Ix+G6CyTXMgY
	qw8w==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:mime-version:in-reply-to:references:from:date
	:message-id:subject:to:cc;
	bh=ojE3hiFdpAgro7h/IgKo0d8Q8ornsjv0Kh/D9TRszrE=;
	b=e/rZitOPZLFIOkVm3zpSKdcU7GskaV9SPW/wTIzf0hY1R0jFT0TuJhWzWrcDet8mXc
	I2h5YJO//wYXBzO2ZOfFQ+mJCrQOK7d0bJaNpsJoZ8wwgUCPlxG2Lilq2WPEpODVjhom
	BZ8e+fLkewzkT2sXkxLpwPVrEq0a0tjQq3EAh9gAV8/BwOcvBtuo79BU+vY7V5Z55ZJZ
	kj9gnN3WjNZ1plaxy5unrcqpEWP5LQ+RP2JAZNoSNtnIj4oLLwIkhDnXHv78wQReQPha
	Ty3+mjly9YPoFItsq8T0xtnCV3hKdn2xSnXAd4/yajrdNHix0y6ojBDtgszqcQtMZpz9
	4TfQ==
X-Gm-Message-State: AA+aEWaq64EW3zdHCYSGfZS2vTunte3MdVNfHQS7zkbSqaAVDdkJu3O4
	D5gQIFVAd5/X/yt4JA5Cqrwsq2QLLoCLpIn3HFM=
X-Google-Smtp-Source: AFSGD/XOYRufOunJDYL5QJdjuXUwvigzlTBukpo39GTWC8R2GjPSDRJWLLGrRtd4GmZ3ieRiqEw9bVSjLjSbweJWnTk=
X-Received: by 2002:a9d:6b95:: with SMTP id b21mr2694468otq.303.1544807966432; 
	Fri, 14 Dec 2018 09:19:26 -0800 (PST)
MIME-Version: 1.0
Received: by 2002:a05:6830:1504:0:0:0:0 with HTTP; Fri, 14 Dec 2018 09:19:24
	-0800 (PST)
Received: by 2002:a05:6830:1504:0:0:0:0 with HTTP; Fri, 14 Dec 2018 09:19:24
	-0800 (PST)
In-Reply-To: <20181213223737.11793-3-pbonzini@redhat.com>
References: <20181213223737.11793-1-pbonzini@redhat.com>
	<20181213223737.11793-3-pbonzini@redhat.com>
From: Aleksandar Markovic <aleksandar.m.mail@gmail.com>
Date: Fri, 14 Dec 2018 18:19:24 +0100
Message-ID: <CAL1e-=hh26Z9n9Jy+zwaWtajmB996X-woGhp-8+Vytckn7GZQA@mail.gmail.com>
To: Paolo Bonzini <pbonzini@redhat.com>
X-detected-operating-system: by eggs.gnu.org: Genre and OS details not
	recognized.
X-Received-From: 2607:f8b0:4864:20::32e
Content-Type: text/plain; charset="UTF-8"
X-Content-Filtered-By: Mailman/MimeDel 2.1.21
Subject: Re: [Qemu-devel] [PATCH 2/2] avoid TABs in files that only contain
 a few
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Peter Maydell <peter.maydell@linaro.org>,
	Dmitry Fleytman <dmitry.fleytman@gmail.com>,
	"Michael S. Tsirkin" <mst@redhat.com>,
	Jason Wang <jasowang@redhat.com>, qemu-devel@nongnu.org,
	Gerd Hoffmann <kraxel@redhat.com>,
	"Edgar E. Iglesias" <edgar.iglesias@gmail.com>,
	Fam Zheng <famz@redhat.com>, Stefano Stabellini <sstabellini@kernel.org>,
	"open list:bochs" <qemu-block@nongnu.org>,
	Stefan Markovic <smarkovic@wavecomp.com>,
	=?UTF-8?B?QWxleCBCZW5uw6ll?= <alex.bennee@linaro.org>,
	Magnus Damm <magnus.damm@gmail.com>,
	=?UTF-8?Q?Herv=C3=A9_Poussineau?= <hpoussin@reactos.org>,
	Anthony Perard <anthony.perard@citrix.com>,
	=?UTF-8?B?TWFyYy1BbmRyw6kgTHVyZWF1?= <marcandre.lureau@redhat.com>,
	Richard Henderson <rth@twiddle.net>,
	Thomas Huth <thuth@redhat.com>, Jiri Pirko <jiri@resnulli.us>,
	Eduardo Habkost <ehabkost@redhat.com>,
	Amit Shah <amit@kernel.org>, Stefan Weil <sw@weilnetz.de>,
	Riku Voipio <riku.voipio@iki.fi>,
	"open list:Stellaris" <qemu-arm@nongnu.org>,
	Stefan Hajnoczi <stefanha@redhat.com>,
	"open list:X86" <xen-devel@lists.xenproject.org>,
	John Snow <jsnow@redhat.com>, David Gibson <david@gibson.dropbear.id.au>,
	Kevin Wolf <kwolf@redhat.com>,
	Viktor Prutyanov <viktor.prutyanov@phystech.edu>,
	Laurent Vivier <laurent@vivier.eu>, Max Reitz <mreitz@redhat.com>,
	"open list:ppc4xx" <qemu-ppc@nongnu.org>,
	Aleksandar Markovic <amarkovic@wavecomp.com>,
	Igor Mammedov <imammedo@redhat.com>, Aurelien Jarno <aurelien@aurel32.net>
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On Dec 13, 2018 11:40 PM, "Paolo Bonzini" <pbonzini@redhat.com> wrote:
>
> Most files that have TABs only contain a handful of them.  Change
> them to spaces so that we don't confuse people.
>
> disas, standard-headers, linux-headers and libdecnumber are imported
> from other projects and probably should be exempted from the check.

For MIPS parts, they are all ok and desireable:

Reviewed-by: Aleksandar Markovic <amarkovic@wavecomp.com>

> Outside those, after this patch the following files still contain both
> 8-space and TAB sequences at the beginning of the line.  Many of them
> have a majority of TABs, or were initially committed with all tabs.
>
>     bsd-user/i386/target_syscall.h
>     bsd-user/x86_64/target_syscall.h
>     crypto/aes.c
>     hw/audio/fmopl.c
>     hw/audio/fmopl.h
>     hw/block/tc58128.c
>     hw/display/cirrus_vga.c
>     hw/display/xenfb.c
>     hw/dma/etraxfs_dma.c
>     hw/intc/sh_intc.c
>     hw/misc/mst_fpga.c
>     hw/net/pcnet.c
>     hw/sh4/sh7750.c
>     hw/timer/m48t59.c
>     hw/timer/sh_timer.c
>     include/crypto/aes.h
>     include/disas/bfd.h
>     include/hw/sh4/sh.h
>     libdecnumber/decNumber.c
>     linux-headers/asm-generic/unistd.h
>     linux-headers/linux/kvm.h
>     linux-user/alpha/target_syscall.h
>     linux-user/arm/nwfpe/double_cpdo.c
>     linux-user/arm/nwfpe/fpa11_cpdt.c
>     linux-user/arm/nwfpe/fpa11_cprt.c
>     linux-user/arm/nwfpe/fpa11.h
>     linux-user/flat.h
>     linux-user/flatload.c
>     linux-user/i386/target_syscall.h
>     linux-user/ppc/target_syscall.h
>     linux-user/sparc/target_syscall.h
>     linux-user/syscall.c
>     linux-user/syscall_defs.h
>     linux-user/x86_64/target_syscall.h
>     slirp/cksum.c
>     slirp/if.c
>     slirp/ip.h
>     slirp/ip_icmp.c
>     slirp/ip_icmp.h
>     slirp/ip_input.c
>     slirp/ip_output.c
>     slirp/mbuf.c
>     slirp/misc.c
>     slirp/sbuf.c
>     slirp/socket.c
>     slirp/socket.h
>     slirp/tcp_input.c
>     slirp/tcpip.h
>     slirp/tcp_output.c
>     slirp/tcp_subr.c
>     slirp/tcp_timer.c
>     slirp/tftp.c
>     slirp/udp.c
>     slirp/udp.h
>     target/cris/cpu.h
>     target/cris/mmu.c
>     target/cris/op_helper.c
>     target/sh4/helper.c
>     target/sh4/op_helper.c
>     target/sh4/translate.c
>     tcg/sparc/tcg-target.inc.c
>     tests/tcg/cris/check_addo.c
>     tests/tcg/cris/check_moveq.c
>     tests/tcg/cris/check_swap.c
>     tests/tcg/multiarch/test-mmap.c
>     ui/vnc-enc-hextile-template.h
>     ui/vnc-enc-zywrle.h
>     util/envlist.c
>     util/readline.c
>
> The following have only TABs:
>
>     bsd-user/i386/target_signal.h
>     bsd-user/sparc64/target_signal.h
>     bsd-user/sparc64/target_syscall.h
>     bsd-user/sparc/target_signal.h
>     bsd-user/sparc/target_syscall.h
>     bsd-user/x86_64/target_signal.h
>     crypto/desrfb.c
>     hw/audio/intel-hda-defs.h
>     hw/core/uboot_image.h
>     hw/sh4/sh7750_regnames.c
>     hw/sh4/sh7750_regs.h
>     include/hw/cris/etraxfs_dma.h
>     linux-user/alpha/termbits.h
>     linux-user/arm/nwfpe/fpopcode.h
>     linux-user/arm/nwfpe/fpsr.h
>     linux-user/arm/syscall_nr.h
>     linux-user/arm/target_signal.h
>     linux-user/cris/target_signal.h
>     linux-user/i386/target_signal.h
>     linux-user/linux_loop.h
>     linux-user/m68k/target_signal.h
>     linux-user/microblaze/target_signal.h
>     linux-user/mips64/target_signal.h
>     linux-user/mips/target_signal.h
>     linux-user/mips/target_syscall.h
>     linux-user/mips/termbits.h
>     linux-user/ppc/target_signal.h
>     linux-user/sh4/target_signal.h
>     linux-user/sh4/termbits.h
>     linux-user/sparc64/target_syscall.h
>     linux-user/sparc/target_signal.h
>     linux-user/x86_64/target_signal.h
>     linux-user/x86_64/termbits.h
>     pc-bios/optionrom/optionrom.h
>     slirp/mbuf.h
>     slirp/misc.h
>     slirp/sbuf.h
>     slirp/tcp.h
>     slirp/tcp_timer.h
>     slirp/tcp_var.h
>     target/i386/svm.h
>     target/sparc/asi.h
>     target/xtensa/core-dc232b/xtensa-modules.inc.c
>     target/xtensa/core-dc233c/xtensa-modules.inc.c
>     target/xtensa/core-de212/core-isa.h
>     target/xtensa/core-de212/xtensa-modules.inc.c
>     target/xtensa/core-fsf/xtensa-modules.inc.c
>     target/xtensa/core-sample_controller/core-isa.h
>     target/xtensa/core-sample_controller/xtensa-modules.inc.c
>     target/xtensa/core-test_kc705_be/core-isa.h
>     target/xtensa/core-test_kc705_be/xtensa-modules.inc.c
>     tests/tcg/cris/check_abs.c
>     tests/tcg/cris/check_addc.c
>     tests/tcg/cris/check_addcm.c
>     tests/tcg/cris/check_addoq.c
>     tests/tcg/cris/check_bound.c
>     tests/tcg/cris/check_ftag.c
>     tests/tcg/cris/check_int64.c
>     tests/tcg/cris/check_lz.c
>     tests/tcg/cris/check_openpf5.c
>     tests/tcg/cris/check_sigalrm.c
>     tests/tcg/cris/crisutils.h
>     tests/tcg/cris/sys.c
>     tests/tcg/i386/test-i386-ssse3.c
>     ui/vgafont.h
>
> Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
> ---
>  block/bochs.c                              | 22 ++---
>  block/file-posix.c                         |  2 +-
>  block/file-win32.c                         |  8 +-
>  block/linux-aio.c                          |  4 +-
>  block/qcow2-cluster.c                      |  2 +-
>  block/vpc.c                                |  2 +-
>  bsd-user/elfload.c                         |  2 +-
>  contrib/elf2dmp/main.c                     |  2 +-
>  hw/alpha/typhoon.c                         | 12 +--
>  hw/arm/stellaris.c                         |  2 +-
>  hw/arm/virt.c                              |  2 +-
>  hw/char/sh_serial.c                        | 18 ++---
>  hw/char/virtio-serial-bus.c                |  2 +-
>  hw/char/xen_console.c                      | 58 ++++++-------
>  hw/core/loader.c                           | 28 +++----
>  hw/display/tc6393xb.c                      |  6 +-
>  hw/display/vga.c                           |  8 +-
>  hw/display/virtio-gpu-3d.c                 |  6 +-
>  hw/dma/pxa2xx_dma.c                        |  4 +-
>  hw/dma/soc_dma.c                           |  2 +-
>  hw/gpio/max7310.c                          |  2 +-
>  hw/i386/xen/xen-hvm.c                      |  4 +-
>  hw/ide/core.c                              | 94 +++++++++++-----------
>  hw/input/lm832x.c                          |  2 +-
>  hw/input/pckbd.c                           |  2 +-
>  hw/input/tsc210x.c                         |  2 +-
>  hw/intc/apic.c                             |  2 +-
>  hw/mips/gt64xxx_pci.c                      |  6 +-
>  hw/mips/mips_r4k.c                         |  4 +-
>  hw/misc/max111x.c                          |  6 +-
>  hw/misc/omap_l4.c                          |  4 +-
>  hw/net/mipsnet.c                           | 16 ++--
>  hw/net/ne2000.c                            | 44 +++++-----
>  hw/net/rocker/rocker.c                     |  2 +-
>  hw/net/virtio-net.c                        |  4 +-
>  hw/net/vmxnet3.c                           |  6 +-
>  hw/pci/msix.c                              |  2 +-
>  hw/pci/pci.c                               | 44 +++++-----
>  hw/pci/pci_bridge.c                        |  2 +-
>  hw/ppc/ppc405_uc.c                         |  2 +-
>  hw/ppc/prep.c                              |  4 +-
>  hw/scsi/lsi53c895a.c                       |  6 +-
>  hw/sh4/r2d.c                               | 16 ++--
>  hw/usb/dev-bluetooth.c                     |  2 +-
>  hw/usb/dev-hid.c                           |  6 +-
>  hw/usb/dev-hub.c                           | 14 ++--
>  hw/xen/xen_devconfig.c                     |  2 +-
>  hw/xenpv/xen_domainbuild.c                 |  8 +-
>  include/elf.h                              | 10 +--
>  include/hw/acpi/acpi.h                     | 14 ++--
>  include/hw/elf_ops.h                       |  2 +-
>  include/hw/ide/internal.h                  |  2 +-
>  include/hw/sh4/sh_intc.h                   | 20 ++---
>  include/hw/xen/io/ring.h                   |  4 +-
>  include/qemu/acl.h                         | 14 ++--
>  include/qemu/iov.h                         |  2 +-
>  include/scsi/constants.h                   |  2 +-
>  include/sysemu/balloon.h                   |  2 +-
>  linux-user/linuxload.c                     | 14 ++--
>  linux-user/main.c                          |  4 +-
>  linux-user/mmap.c                          | 10 +--
>  linux-user/qemu.h                          |  4 +-
>  linux-user/signal.c                        | 16 ++--
>  linux-user/strace.c                        |  4 +-
>  linux-user/uaccess.c                       |  2 +-
>  linux-user/vm86.c                          |  2 +-
>  nbd/client.c                               |  2 +-
>  net/checksum.c                             |  2 +-
>  qtest.c                                    |  4 +-
>  target/alpha/translate.c                   |  2 +-
>  target/cris/helper.c                       |  2 +-
>  target/cris/mmu.h                          | 10 +--
>  target/cris/translate_v10.inc.c            |  2 +-
>  target/i386/translate.c                    | 12 +--
>  target/mips/translate.c                    |  2 +-
>  target/tilegx/translate.c                  |  2 +-
>  tcg/i386/tcg-target.inc.c                  |  4 +-
>  tests/tcg/alpha/test-cond.c                |  4 +-
>  tests/tcg/arm/hello-arm.c                  | 20 ++---
>  tests/tcg/cris/check_glibc_kernelversion.c |  8 +-
>  tests/tcg/cris/check_mmap3.c               |  2 +-
>  tests/tcg/cris/check_openpf1.c             |  2 +-
>  tests/tcg/cris/check_settls1.c             |  2 +-
>  tests/tcg/i386/hello-i386.c                | 14 ++--
>  tests/tcg/mips/hello-mips.c                | 10 +--
>  tests/tcg/multiarch/sha1.c                 | 12 +--
>  tests/vhost-user-test.c                    |  4 +-
>  ui/keymaps.h                               |  4 +-
>  ui/qemu-pixman.c                           |  2 +-
>  ui/vnc-enc-zywrle-template.c               |  4 +-
>  ui/vnc.c                                   |  4 +-
>  util/bitops.c                              |  4 +-
>  util/osdep.c                               |  4 +-
>  util/qemu-sockets.c                        |  4 +-
>  94 files changed, 388 insertions(+), 388 deletions(-)
>
> diff --git a/block/bochs.c b/block/bochs.c
> index 22e7d44211..79f95d3b50 100644
> --- a/block/bochs.c
> +++ b/block/bochs.c
> @@ -85,14 +85,14 @@ static int bochs_probe(const uint8_t *buf, int
buf_size, const char *filename)
>      const struct bochs_header *bochs = (const void *)buf;
>
>      if (buf_size < HEADER_SIZE)
> -       return 0;
> +        return 0;
>
>      if (!strcmp(bochs->magic, HEADER_MAGIC) &&
> -       !strcmp(bochs->type, REDOLOG_TYPE) &&
> -       !strcmp(bochs->subtype, GROWING_TYPE) &&
> -       ((le32_to_cpu(bochs->version) == HEADER_VERSION) ||
> -       (le32_to_cpu(bochs->version) == HEADER_V1)))
> -       return 100;
> +        !strcmp(bochs->type, REDOLOG_TYPE) &&
> +        !strcmp(bochs->subtype, GROWING_TYPE) &&
> +        ((le32_to_cpu(bochs->version) == HEADER_VERSION) ||
> +        (le32_to_cpu(bochs->version) == HEADER_V1)))
> +        return 100;
>
>      return 0;
>  }
> @@ -125,8 +125,8 @@ static int bochs_open(BlockDriverState *bs, QDict
*options, int flags,
>      if (strcmp(bochs.magic, HEADER_MAGIC) ||
>          strcmp(bochs.type, REDOLOG_TYPE) ||
>          strcmp(bochs.subtype, GROWING_TYPE) ||
> -       ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&
> -       (le32_to_cpu(bochs.version) != HEADER_V1))) {
> +        ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&
> +        (le32_to_cpu(bochs.version) != HEADER_V1))) {
>          error_setg(errp, "Image not in Bochs format");
>          return -EINVAL;
>      }
> @@ -158,7 +158,7 @@ static int bochs_open(BlockDriverState *bs, QDict
*options, int flags,
>      }
>
>      for (i = 0; i < s->catalog_size; i++)
> -       le32_to_cpus(&s->catalog_bitmap[i]);
> +        le32_to_cpus(&s->catalog_bitmap[i]);
>
>      s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);
>
> @@ -217,7 +217,7 @@ static int64_t seek_to_sector(BlockDriverState *bs,
int64_t sector_num)
>      extent_offset = (offset % s->extent_size) / 512;
>
>      if (s->catalog_bitmap[extent_index] == 0xffffffff) {
> -       return 0; /* not allocated */
> +        return 0; /* not allocated */
>      }
>
>      bitmap_offset = s->data_offset +
> @@ -232,7 +232,7 @@ static int64_t seek_to_sector(BlockDriverState *bs,
int64_t sector_num)
>      }
>
>      if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {
> -       return 0; /* not allocated */
> +        return 0; /* not allocated */
>      }
>
>      return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));
> diff --git a/block/file-posix.c b/block/file-posix.c
> index 07bbdab953..5c66c3b2bc 100644
> --- a/block/file-posix.c
> +++ b/block/file-posix.c
> @@ -2117,7 +2117,7 @@ again:
>  #endif
>      if (!fstat(fd, &sb) && (S_IFCHR & sb.st_mode)) {
>  #ifdef DIOCGMEDIASIZE
> -       if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
> +        if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
>  #elif defined(DIOCGPART)
>          {
>                  struct partinfo pi;
> diff --git a/block/file-win32.c b/block/file-win32.c
> index f1e2187f3b..6b2d67b239 100644
> --- a/block/file-win32.c
> +++ b/block/file-win32.c
> @@ -176,7 +176,7 @@ int qemu_ftruncate64(int fd, int64_t length)
>      BOOL res;
>
>      if ((GetVersion() & 0x80000000UL) && (length >> 32) != 0)
> -       return -1;
> +        return -1;
>
>      h = (HANDLE)_get_osfhandle(fd);
>
> @@ -184,13 +184,13 @@ int qemu_ftruncate64(int fd, int64_t length)
>      li.HighPart = 0;
>      li.LowPart = SetFilePointer (h, 0, &li.HighPart, FILE_CURRENT);
>      if (li.LowPart == INVALID_SET_FILE_POINTER && GetLastError() !=
NO_ERROR) {
> -       return -1;
> +        return -1;
>      }
>
>      high = length >> 32;
>      dw = SetFilePointer(h, (DWORD) length, &high, FILE_BEGIN);
>      if (dw == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR) {
> -       return -1;
> +        return -1;
>      }
>      res = SetEndOfFile(h);
>
> @@ -203,7 +203,7 @@ static int set_sparse(int fd)
>  {
>      DWORD returned;
>      return (int) DeviceIoControl((HANDLE)_get_osfhandle(fd),
FSCTL_SET_SPARSE,
> -                                NULL, 0, NULL, 0, &returned, NULL);
> +                                 NULL, 0, NULL, 0, &returned, NULL);
>  }
>
>  static void raw_detach_aio_context(BlockDriverState *bs)
> diff --git a/block/linux-aio.c b/block/linux-aio.c
> index 217ce60138..d4b61fb251 100644
> --- a/block/linux-aio.c
> +++ b/block/linux-aio.c
> @@ -384,10 +384,10 @@ static int laio_do_submit(int fd, struct
qemu_laiocb *laiocb, off_t offset,
>      switch (type) {
>      case QEMU_AIO_WRITE:
>          io_prep_pwritev(iocbs, fd, qiov->iov, qiov->niov, offset);
> -       break;
> +        break;
>      case QEMU_AIO_READ:
>          io_prep_preadv(iocbs, fd, qiov->iov, qiov->niov, offset);
> -       break;
> +        break;
>      /* Currently Linux kernel does not support other operations */
>      default:
>          fprintf(stderr, "%s: invalid AIO request type 0x%x.\n",
> diff --git a/block/qcow2-cluster.c b/block/qcow2-cluster.c
> index d37fe08b3d..0145ce5218 100644
> --- a/block/qcow2-cluster.c
> +++ b/block/qcow2-cluster.c
> @@ -402,7 +402,7 @@ static int count_contiguous_clusters(int nb_clusters,
int cluster_size,
>          }
>      }
>
> -       return i;
> +        return i;
>  }
>
>  /*
> diff --git a/block/vpc.c b/block/vpc.c
> index 80c5b2b197..d886465b7e 100644
> --- a/block/vpc.c
> +++ b/block/vpc.c
> @@ -187,7 +187,7 @@ static uint32_t vpc_checksum(uint8_t* buf, size_t
size)
>  static int vpc_probe(const uint8_t *buf, int buf_size, const char
*filename)
>  {
>      if (buf_size >= 8 && !strncmp((char *)buf, "conectix", 8))
> -       return 100;
> +        return 100;
>      return 0;
>  }
>
> diff --git a/bsd-user/elfload.c b/bsd-user/elfload.c
> index 7cccf3eb8b..32378af7b2 100644
> --- a/bsd-user/elfload.c
> +++ b/bsd-user/elfload.c
> @@ -1367,7 +1367,7 @@ int load_elf_binary(struct linux_binprm * bprm,
struct target_pt_regs * regs,
>      if (!have_guest_base) {
>          /*
>           * Go through ELF program header table and find out whether
> -        * any of the segments drop below our current mmap_min_addr and
> +         * any of the segments drop below our current mmap_min_addr and
>           * in that case set guest_base to corresponding address.
>           */
>          for (i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum;
> diff --git a/contrib/elf2dmp/main.c b/contrib/elf2dmp/main.c
> index 9b93dab662..7115b0d6d0 100644
> --- a/contrib/elf2dmp/main.c
> +++ b/contrib/elf2dmp/main.c
> @@ -296,7 +296,7 @@ static int fill_header(WinDumpHeader64 *hdr, struct
pa_space *ps,
>  static int fill_context(KDDEBUGGER_DATA64 *kdbg,
>          struct va_space *vs, QEMU_Elf *qe)
>  {
> -       int i;
> +        int i;
>      for (i = 0; i < qe->state_nr; i++) {
>          uint64_t Prcb;
>          uint64_t Context;
> diff --git a/hw/alpha/typhoon.c b/hw/alpha/typhoon.c
> index 8004afe45b..ad79638ffa 100644
> --- a/hw/alpha/typhoon.c
> +++ b/hw/alpha/typhoon.c
> @@ -657,8 +657,8 @@ static bool window_translate(TyphoonWindow *win,
hwaddr addr,
>          pte_addr |= (addr & (wsm | 0xfe000)) >> 10;
>          return pte_translate(pte_addr, ret);
>      } else {
> -       /* Direct-mapped translation.  */
> -       return make_iommu_tlbe(tba & ~wsm_ext, wsm_ext, ret);
> +        /* Direct-mapped translation.  */
> +        return make_iommu_tlbe(tba & ~wsm_ext, wsm_ext, ret);
>      }
>  }
>
> @@ -693,7 +693,7 @@ static IOMMUTLBEntry
typhoon_translate_iommu(IOMMUMemoryRegion *iommu,
>
>          /* Check the fourth window for DAC disable.  */
>          if ((pchip->win[3].wba & 0x80000000000ull) == 0
> -           && window_translate(&pchip->win[3], addr, &ret)) {
> +            && window_translate(&pchip->win[3], addr, &ret)) {
>              goto success;
>          }
>      } else {
> @@ -704,7 +704,7 @@ static IOMMUTLBEntry
typhoon_translate_iommu(IOMMUMemoryRegion *iommu,
>              if (pchip->ctl & 0x40) {
>                  /* See 10.1.4.4; in particular <39:35> is ignored.  */
>                  make_iommu_tlbe(0, 0x007ffffffffull, &ret);
> -               goto success;
> +                goto success;
>              }
>          }
>
> @@ -716,8 +716,8 @@ static IOMMUTLBEntry
typhoon_translate_iommu(IOMMUMemoryRegion *iommu,
>                  pte_addr  = pchip->win[3].tba & 0x7ffc00000ull;
>                  pte_addr |= (addr & 0xffffe000u) >> 10;
>                  if (pte_translate(pte_addr, &ret)) {
> -                       goto success;
> -               }
> +                        goto success;
> +                }
>              }
>          }
>      }
> diff --git a/hw/arm/stellaris.c b/hw/arm/stellaris.c
> index 6c69ce79b2..442529cc65 100644
> --- a/hw/arm/stellaris.c
> +++ b/hw/arm/stellaris.c
> @@ -131,7 +131,7 @@ static void gptm_tick(void *opaque)
>          s->state |= 1;
>          if ((s->control & 0x20)) {
>              /* Output trigger.  */
> -           qemu_irq_pulse(s->trigger);
> +            qemu_irq_pulse(s->trigger);
>          }
>          if (s->mode[0] & 1) {
>              /* One-shot.  */
> diff --git a/hw/arm/virt.c b/hw/arm/virt.c
> index 17f1b49d11..ad6fa8e3c6 100644
> --- a/hw/arm/virt.c
> +++ b/hw/arm/virt.c
> @@ -1854,7 +1854,7 @@ static const TypeInfo virt_machine_info = {
>      .instance_size = sizeof(VirtMachineState),
>      .class_size    = sizeof(VirtMachineClass),
>      .class_init    = virt_machine_class_init,
> -       .instance_init = virt_instance_init,
> +        .instance_init = virt_instance_init,
>      .interfaces = (InterfaceInfo[]) {
>           { TYPE_HOTPLUG_HANDLER },
>           { }
> diff --git a/hw/char/sh_serial.c b/hw/char/sh_serial.c
> index 12831561a6..67740b7ee6 100644
> --- a/hw/char/sh_serial.c
> +++ b/hw/char/sh_serial.c
> @@ -90,7 +90,7 @@ static void sh_serial_write(void *opaque, hwaddr offs,
>
>  #ifdef DEBUG_SERIAL
>      printf("sh_serial: write offs=0x%02x val=0x%02x\n",
> -          offs, val);
> +           offs, val);
>  #endif
>      switch(offs) {
>      case 0x00: /* SMR */
> @@ -98,17 +98,17 @@ static void sh_serial_write(void *opaque, hwaddr offs,
>          return;
>      case 0x04: /* BRR */
>          s->brr = val;
> -       return;
> +        return;
>      case 0x08: /* SCR */
>          /* TODO : For SH7751, SCIF mask should be 0xfb. */
>          s->scr = val & ((s->feat & SH_SERIAL_FEAT_SCIF) ? 0xfa : 0xff);
>          if (!(val & (1 << 5)))
>              s->flags |= SH_SERIAL_FLAG_TEND;
>          if ((s->feat & SH_SERIAL_FEAT_SCIF) && s->txi) {
> -           qemu_set_irq(s->txi, val & (1 << 7));
> +            qemu_set_irq(s->txi, val & (1 << 7));
>          }
>          if (!(val & (1 << 6))) {
> -           qemu_set_irq(s->rxi, 0);
> +            qemu_set_irq(s->rxi, 0);
>          }
>          return;
>      case 0x0c: /* FTDR / TDR */
> @@ -117,9 +117,9 @@ static void sh_serial_write(void *opaque, hwaddr offs,
>              /* XXX this blocks entire thread. Rewrite to use
>               * qemu_chr_fe_write and background I/O callbacks */
>              qemu_chr_fe_write_all(&s->chr, &ch, 1);
> -       }
> -       s->dr = val;
> -       s->flags &= ~SH_SERIAL_FLAG_TDE;
> +        }
> +        s->dr = val;
> +        s->flags &= ~SH_SERIAL_FLAG_TDE;
>          return;
>  #if 0
>      case 0x14: /* FRDR / RDR */
> @@ -210,7 +210,7 @@ static uint64_t sh_serial_read(void *opaque, hwaddr
offs,
>          break;
>      case 0x04:
>          ret = s->brr;
> -       break;
> +        break;
>      case 0x08:
>          ret = s->scr;
>          break;
> @@ -288,7 +288,7 @@ static uint64_t sh_serial_read(void *opaque, hwaddr
offs,
>      }
>  #ifdef DEBUG_SERIAL
>      printf("sh_serial: read offs=0x%02x val=0x%x\n",
> -          offs, ret);
> +           offs, ret);
>  #endif
>
>      if (ret & ~((1 << 16) - 1)) {
> diff --git a/hw/char/virtio-serial-bus.c b/hw/char/virtio-serial-bus.c
> index 04e3ebe352..d76351d748 100644
> --- a/hw/char/virtio-serial-bus.c
> +++ b/hw/char/virtio-serial-bus.c
> @@ -696,7 +696,7 @@ static void virtio_serial_save_device(VirtIODevice
*vdev, QEMUFile *f)
>          qemu_put_byte(f, port->guest_connected);
>          qemu_put_byte(f, port->host_connected);
>
> -       elem_popped = 0;
> +        elem_popped = 0;
>          if (port->elem) {
>              elem_popped = 1;
>          }
> diff --git a/hw/char/xen_console.c b/hw/char/xen_console.c
> index 44f7236382..b1a1e66d5a 100644
> --- a/hw/char/xen_console.c
> +++ b/hw/char/xen_console.c
> @@ -60,34 +60,34 @@ static void buffer_append(struct XenConsole *con)
>
>      size = prod - cons;
>      if ((size == 0) || (size > sizeof(intf->out)))
> -       return;
> +        return;
>
>      if ((buffer->capacity - buffer->size) < size) {
> -       buffer->capacity += (size + 1024);
> -       buffer->data = g_realloc(buffer->data, buffer->capacity);
> +        buffer->capacity += (size + 1024);
> +        buffer->data = g_realloc(buffer->data, buffer->capacity);
>      }
>
>      while (cons != prod)
> -       buffer->data[buffer->size++] = intf->out[
> -           MASK_XENCONS_IDX(cons++, intf->out)];
> +        buffer->data[buffer->size++] = intf->out[
> +            MASK_XENCONS_IDX(cons++, intf->out)];
>
>      xen_mb();
>      intf->out_cons = cons;
>      xen_pv_send_notify(&con->xendev);
>
>      if (buffer->max_capacity &&
> -       buffer->size > buffer->max_capacity) {
> -       /* Discard the middle of the data. */
> +        buffer->size > buffer->max_capacity) {
> +        /* Discard the middle of the data. */
>
> -       size_t over = buffer->size - buffer->max_capacity;
> -       uint8_t *maxpos = buffer->data + buffer->max_capacity;
> +        size_t over = buffer->size - buffer->max_capacity;
> +        uint8_t *maxpos = buffer->data + buffer->max_capacity;
>
> -       memmove(maxpos - over, maxpos, over);
> -       buffer->data = g_realloc(buffer->data, buffer->max_capacity);
> -       buffer->size = buffer->capacity = buffer->max_capacity;
> +        memmove(maxpos - over, maxpos, over);
> +        buffer->data = g_realloc(buffer->data, buffer->max_capacity);
> +        buffer->size = buffer->capacity = buffer->max_capacity;
>
> -       if (buffer->consumed > buffer->max_capacity - over)
> -           buffer->consumed = buffer->max_capacity - over;
> +        if (buffer->consumed > buffer->max_capacity - over)
> +            buffer->consumed = buffer->max_capacity - over;
>      }
>  }
>
> @@ -95,8 +95,8 @@ static void buffer_advance(struct buffer *buffer,
size_t len)
>  {
>      buffer->consumed += len;
>      if (buffer->consumed == buffer->size) {
> -       buffer->consumed = 0;
> -       buffer->size = 0;
> +        buffer->consumed = 0;
> +        buffer->size = 0;
>      }
>  }
>
> @@ -111,7 +111,7 @@ static int ring_free_bytes(struct XenConsole *con)
>
>      space = prod - cons;
>      if (space > sizeof(intf->in))
> -       return 0; /* ring is screwed: ignore it */
> +        return 0; /* ring is screwed: ignore it */
>
>      return (sizeof(intf->in) - space);
>  }
> @@ -132,12 +132,12 @@ static void xencons_receive(void *opaque, const
uint8_t *buf, int len)
>      max = ring_free_bytes(con);
>      /* The can_receive() func limits this, but check again anyway */
>      if (max < len)
> -       len = max;
> +        len = max;
>
>      prod = intf->in_prod;
>      for (i = 0; i < len; i++) {
> -       intf->in[MASK_XENCONS_IDX(prod++, intf->in)] =
> -           buf[i];
> +        intf->in[MASK_XENCONS_IDX(prod++, intf->in)] =
> +            buf[i];
>      }
>      xen_wmb();
>      intf->in_prod = prod;
> @@ -228,11 +228,11 @@ static int con_initialise(struct XenDevice *xendev)
>      int limit;
>
>      if (xenstore_read_int(con->console, "ring-ref", &con->ring_ref) ==
-1)
> -       return -1;
> +        return -1;
>      if (xenstore_read_int(con->console, "port",
&con->xendev.remote_port) == -1)
> -       return -1;
> +        return -1;
>      if (xenstore_read_int(con->console, "limit", &limit) == 0)
> -       con->buffer.max_capacity = limit;
> +        con->buffer.max_capacity = limit;
>
>      if (!xendev->dev) {
>          xen_pfn_t mfn = con->ring_ref;
> @@ -244,7 +244,7 @@ static int con_initialise(struct XenDevice *xendev)
>                                            PROT_READ | PROT_WRITE);
>      }
>      if (!con->sring)
> -       return -1;
> +        return -1;
>
>      xen_be_bind_evtchn(&con->xendev);
>      qemu_chr_fe_set_handlers(&con->chr, xencons_can_receive,
> @@ -252,10 +252,10 @@ static int con_initialise(struct XenDevice *xendev)
>
>      xen_pv_printf(xendev, 1,
>                    "ring mfn %d, remote port %d, local port %d, limit
%zd\n",
> -                 con->ring_ref,
> -                 con->xendev.remote_port,
> -                 con->xendev.local_port,
> -                 con->buffer.max_capacity);
> +                  con->ring_ref,
> +                  con->xendev.remote_port,
> +                  con->xendev.local_port,
> +                  con->buffer.max_capacity);
>      return 0;
>  }
>
> @@ -282,7 +282,7 @@ static void con_event(struct XenDevice *xendev)
>
>      buffer_append(con);
>      if (con->buffer.size - con->buffer.consumed)
> -       xencons_send(con);
> +        xencons_send(con);
>  }
>
>  /* --------------------------------------------------------------------
*/
> diff --git a/hw/core/loader.c b/hw/core/loader.c
> index aa0b3fc867..0b7762a062 100644
> --- a/hw/core/loader.c
> +++ b/hw/core/loader.c
> @@ -269,26 +269,26 @@ int load_aout(const char *filename, hwaddr addr,
int max_sz,
>      case OMAGIC:
>          if (e.a_text + e.a_data > max_sz)
>              goto fail;
> -       lseek(fd, N_TXTOFF(e), SEEK_SET);
> -       size = read_targphys(filename, fd, addr, e.a_text + e.a_data);
> -       if (size < 0)
> -           goto fail;
> -       break;
> +        lseek(fd, N_TXTOFF(e), SEEK_SET);
> +        size = read_targphys(filename, fd, addr, e.a_text + e.a_data);
> +        if (size < 0)
> +            goto fail;
> +        break;
>      case NMAGIC:
>          if (N_DATADDR(e, target_page_size) + e.a_data > max_sz)
>              goto fail;
> -       lseek(fd, N_TXTOFF(e), SEEK_SET);
> -       size = read_targphys(filename, fd, addr, e.a_text);
> -       if (size < 0)
> -           goto fail;
> +        lseek(fd, N_TXTOFF(e), SEEK_SET);
> +        size = read_targphys(filename, fd, addr, e.a_text);
> +        if (size < 0)
> +            goto fail;
>          ret = read_targphys(filename, fd, addr + N_DATADDR(e,
target_page_size),
>                              e.a_data);
> -       if (ret < 0)
> -           goto fail;
> -       size += ret;
> -       break;
> +        if (ret < 0)
> +            goto fail;
> +        size += ret;
> +        break;
>      default:
> -       goto fail;
> +        goto fail;
>      }
>      close(fd);
>      return size;
> diff --git a/hw/display/tc6393xb.c b/hw/display/tc6393xb.c
> index 3360be6f84..e1b1e302f2 100644
> --- a/hw/display/tc6393xb.c
> +++ b/hw/display/tc6393xb.c
> @@ -319,7 +319,7 @@ static void tc6393xb_scr_writeb(TC6393xbState *s,
hwaddr addr, uint32_t value)
>          SCR_REG_B(DEBUG);
>      }
>      fprintf(stderr, "tc6393xb_scr: unhandled write at %08x: %02x\n",
> -                                       (uint32_t) addr, value & 0xff);
> +                                        (uint32_t) addr, value & 0xff);
>  }
>  #undef SCR_REG_B
>  #undef SCR_REG_W
> @@ -358,7 +358,7 @@ static void tc6393xb_nand_cfg_writeb(TC6393xbState
*s, hwaddr addr, uint32_t val
>              return;
>      }
>      fprintf(stderr, "tc6393xb_nand_cfg: unhandled write at %08x: %02x\n",
> -                                       (uint32_t) addr, value & 0xff);
> +                                        (uint32_t) addr, value & 0xff);
>  }
>
>  static uint32_t tc6393xb_nand_readb(TC6393xbState *s, hwaddr addr) {
> @@ -421,7 +421,7 @@ static void tc6393xb_nand_writeb(TC6393xbState *s,
hwaddr addr, uint32_t value)
>              return;
>      }
>      fprintf(stderr, "tc6393xb_nand: unhandled write at %08x: %02x\n",
> -                                       (uint32_t) addr, value & 0xff);
> +                                        (uint32_t) addr, value & 0xff);
>  }
>
>  #define BITS 8
> diff --git a/hw/display/vga.c b/hw/display/vga.c
> index 3ba3f6853c..910a23c12e 100644
> --- a/hw/display/vga.c
> +++ b/hw/display/vga.c
> @@ -85,10 +85,10 @@ const uint8_t gr_mask[16] = {
>
>  #define cbswap_32(__x) \
>  ((uint32_t)( \
> -               (((uint32_t)(__x) & (uint32_t)0x000000ffUL) << 24) | \
> -               (((uint32_t)(__x) & (uint32_t)0x0000ff00UL) <<  8) | \
> -               (((uint32_t)(__x) & (uint32_t)0x00ff0000UL) >>  8) | \
> -               (((uint32_t)(__x) & (uint32_t)0xff000000UL) >> 24) ))
> +                (((uint32_t)(__x) & (uint32_t)0x000000ffUL) << 24) | \
> +                (((uint32_t)(__x) & (uint32_t)0x0000ff00UL) <<  8) | \
> +                (((uint32_t)(__x) & (uint32_t)0x00ff0000UL) >>  8) | \
> +                (((uint32_t)(__x) & (uint32_t)0xff000000UL) >> 24) ))
>
>  #ifdef HOST_WORDS_BIGENDIAN
>  #define PAT(x) cbswap_32(x)
> diff --git a/hw/display/virtio-gpu-3d.c b/hw/display/virtio-gpu-3d.c
> index 55d76405a9..bc6e99c943 100644
> --- a/hw/display/virtio-gpu-3d.c
> +++ b/hw/display/virtio-gpu-3d.c
> @@ -498,9 +498,9 @@ static void virgl_write_fence(void *opaque, uint32_t
fence)
>
>      QTAILQ_FOREACH_SAFE(cmd, &g->fenceq, next, tmp) {
>          /*
> -        * the guest can end up emitting fences out of order
> -        * so we should check all fenced cmds not just the first one.
> -        */
> +         * the guest can end up emitting fences out of order
> +         * so we should check all fenced cmds not just the first one.
> +         */
>          if (cmd->cmd_hdr.fence_id > fence) {
>              continue;
>          }
> diff --git a/hw/dma/pxa2xx_dma.c b/hw/dma/pxa2xx_dma.c
> index f4eb26cf17..d498de8ffe 100644
> --- a/hw/dma/pxa2xx_dma.c
> +++ b/hw/dma/pxa2xx_dma.c
> @@ -228,7 +228,7 @@ static void pxa2xx_dma_run(PXA2xxDMAState *s)
>                                          !(ch->state & DCSR_NODESCFETCH))
>                              pxa2xx_dma_descriptor_fetch(s, c);
>                          break;
> -                   }
> +                    }
>                  }
>
>                  ch->cmd = (ch->cmd & ~DCMD_LEN) | length;
> @@ -283,7 +283,7 @@ static uint64_t pxa2xx_dma_read(void *opaque, hwaddr
offset,
>
>      case DCSR0 ... DCSR31:
>          channel = offset >> 2;
> -       if (s->chan[channel].request)
> +        if (s->chan[channel].request)
>              return s->chan[channel].state | DCSR_REQPEND;
>          return s->chan[channel].state;
>
> diff --git a/hw/dma/soc_dma.c b/hw/dma/soc_dma.c
> index 45516241c6..58502721fa 100644
> --- a/hw/dma/soc_dma.c
> +++ b/hw/dma/soc_dma.c
> @@ -345,7 +345,7 @@ void soc_dma_port_add_mem(struct soc_dma_s *soc,
uint8_t *phys_base,
>              while (entry < dma->memmap + dma->memmap_size &&
>                              entry->addr <= virt_base)
>                  entry ++;
> -       }
> +        }
>
>          memmove(entry + 1, entry,
>                          (uint8_t *) (dma->memmap + dma->memmap_size ++) -
> diff --git a/hw/gpio/max7310.c b/hw/gpio/max7310.c
> index a560e3afd2..1a2478b5a9 100644
> --- a/hw/gpio/max7310.c
> +++ b/hw/gpio/max7310.c
> @@ -118,7 +118,7 @@ static int max7310_tx(I2CSlave *i2c, uint8_t data)
>          break;
>
>      case 0x00: /* Input port - ignore writes */
> -       break;
> +        break;
>      default:
>  #ifdef VERBOSE
>          printf("%s: unknown register %02x\n", __func__, s->command);
> diff --git a/hw/i386/xen/xen-hvm.c b/hw/i386/xen/xen-hvm.c
> index 935a3676c8..bf4812cfc9 100644
> --- a/hw/i386/xen/xen-hvm.c
> +++ b/hw/i386/xen/xen-hvm.c
> @@ -570,7 +570,7 @@ static void xen_io_del(MemoryListener *listener,
>  }
>
>  static void xen_device_realize(DeviceListener *listener,
> -                              DeviceState *dev)
> +                               DeviceState *dev)
>  {
>      XenIOState *state = container_of(listener, XenIOState,
device_listener);
>
> @@ -588,7 +588,7 @@ static void xen_device_realize(DeviceListener
*listener,
>  }
>
>  static void xen_device_unrealize(DeviceListener *listener,
> -                                DeviceState *dev)
> +                                 DeviceState *dev)
>  {
>      XenIOState *state = container_of(listener, XenIOState,
device_listener);
>
> diff --git a/hw/ide/core.c b/hw/ide/core.c
> index 04e22e751d..c3d779db6e 100644
> --- a/hw/ide/core.c
> +++ b/hw/ide/core.c
> @@ -575,16 +575,16 @@ int64_t ide_get_sector(IDEState *s)
>      int64_t sector_num;
>      if (s->select & 0x40) {
>          /* lba */
> -       if (!s->lba48) {
> -           sector_num = ((s->select & 0x0f) << 24) | (s->hcyl << 16) |
> -               (s->lcyl << 8) | s->sector;
> -       } else {
> -           sector_num = ((int64_t)s->hob_hcyl << 40) |
> -               ((int64_t) s->hob_lcyl << 32) |
> -               ((int64_t) s->hob_sector << 24) |
> -               ((int64_t) s->hcyl << 16) |
> -               ((int64_t) s->lcyl << 8) | s->sector;
> -       }
> +        if (!s->lba48) {
> +            sector_num = ((s->select & 0x0f) << 24) | (s->hcyl << 16) |
> +                (s->lcyl << 8) | s->sector;
> +        } else {
> +            sector_num = ((int64_t)s->hob_hcyl << 40) |
> +                ((int64_t) s->hob_lcyl << 32) |
> +                ((int64_t) s->hob_sector << 24) |
> +                ((int64_t) s->hcyl << 16) |
> +                ((int64_t) s->lcyl << 8) | s->sector;
> +        }
>      } else {
>          sector_num = ((s->hcyl << 8) | s->lcyl) * s->heads * s->sectors +
>              (s->select & 0x0f) * s->sectors + (s->sector - 1);
> @@ -596,19 +596,19 @@ void ide_set_sector(IDEState *s, int64_t sector_num)
>  {
>      unsigned int cyl, r;
>      if (s->select & 0x40) {
> -       if (!s->lba48) {
> +        if (!s->lba48) {
>              s->select = (s->select & 0xf0) | (sector_num >> 24);
>              s->hcyl = (sector_num >> 16);
>              s->lcyl = (sector_num >> 8);
>              s->sector = (sector_num);
> -       } else {
> -           s->sector = sector_num;
> -           s->lcyl = sector_num >> 8;
> -           s->hcyl = sector_num >> 16;
> -           s->hob_sector = sector_num >> 24;
> -           s->hob_lcyl = sector_num >> 32;
> -           s->hob_hcyl = sector_num >> 40;
> -       }
> +        } else {
> +            s->sector = sector_num;
> +            s->lcyl = sector_num >> 8;
> +            s->hcyl = sector_num >> 16;
> +            s->hob_sector = sector_num >> 24;
> +            s->hob_lcyl = sector_num >> 32;
> +            s->hob_hcyl = sector_num >> 40;
> +        }
>      } else {
>          cyl = sector_num / (s->heads * s->sectors);
>          r = sector_num % (s->heads * s->sectors);
> @@ -1188,17 +1188,17 @@ static void ide_cmd_lba48_transform(IDEState *s,
int lba48)
>       * full sector count in ->nsector and ignore ->hob_nsector from now
>       */
>      if (!s->lba48) {
> -       if (!s->nsector)
> -           s->nsector = 256;
> +        if (!s->nsector)
> +            s->nsector = 256;
>      } else {
> -       if (!s->nsector && !s->hob_nsector)
> -           s->nsector = 65536;
> -       else {
> -           int lo = s->nsector;
> -           int hi = s->hob_nsector;
> +        if (!s->nsector && !s->hob_nsector)
> +            s->nsector = 65536;
> +        else {
> +            int lo = s->nsector;
> +            int hi = s->hob_nsector;
>
> -           s->nsector = (hi << 8) | lo;
> -       }
> +            s->nsector = (hi << 8) | lo;
> +        }
>      }
>  }
>
> @@ -1258,35 +1258,35 @@ void ide_ioport_write(void *opaque, uint32_t
addr, uint32_t val)
>          bus->ifs[1].feature = val;
>          break;
>      case ATA_IOPORT_WR_SECTOR_COUNT:
> -       ide_clear_hob(bus);
> -       bus->ifs[0].hob_nsector = bus->ifs[0].nsector;
> -       bus->ifs[1].hob_nsector = bus->ifs[1].nsector;
> +        ide_clear_hob(bus);
> +        bus->ifs[0].hob_nsector = bus->ifs[0].nsector;
> +        bus->ifs[1].hob_nsector = bus->ifs[1].nsector;
>          bus->ifs[0].nsector = val;
>          bus->ifs[1].nsector = val;
>          break;
>      case ATA_IOPORT_WR_SECTOR_NUMBER:
> -       ide_clear_hob(bus);
> -       bus->ifs[0].hob_sector = bus->ifs[0].sector;
> -       bus->ifs[1].hob_sector = bus->ifs[1].sector;
> +        ide_clear_hob(bus);
> +        bus->ifs[0].hob_sector = bus->ifs[0].sector;
> +        bus->ifs[1].hob_sector = bus->ifs[1].sector;
>          bus->ifs[0].sector = val;
>          bus->ifs[1].sector = val;
>          break;
>      case ATA_IOPORT_WR_CYLINDER_LOW:
> -       ide_clear_hob(bus);
> -       bus->ifs[0].hob_lcyl = bus->ifs[0].lcyl;
> -       bus->ifs[1].hob_lcyl = bus->ifs[1].lcyl;
> +        ide_clear_hob(bus);
> +        bus->ifs[0].hob_lcyl = bus->ifs[0].lcyl;
> +        bus->ifs[1].hob_lcyl = bus->ifs[1].lcyl;
>          bus->ifs[0].lcyl = val;
>          bus->ifs[1].lcyl = val;
>          break;
>      case ATA_IOPORT_WR_CYLINDER_HIGH:
> -       ide_clear_hob(bus);
> -       bus->ifs[0].hob_hcyl = bus->ifs[0].hcyl;
> -       bus->ifs[1].hob_hcyl = bus->ifs[1].hcyl;
> +        ide_clear_hob(bus);
> +        bus->ifs[0].hob_hcyl = bus->ifs[0].hcyl;
> +        bus->ifs[1].hob_hcyl = bus->ifs[1].hcyl;
>          bus->ifs[0].hcyl = val;
>          bus->ifs[1].hcyl = val;
>          break;
>      case ATA_IOPORT_WR_DEVICE_HEAD:
> -       /* FIXME: HOB readback uses bit 7 */
> +        /* FIXME: HOB readback uses bit 7 */
>          bus->ifs[0].select = (val & ~0x10) | 0xa0;
>          bus->ifs[1].select = (val | 0x10) | 0xa0;
>          /* select drive */
> @@ -2146,7 +2146,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t
addr)
>          } else if (!hob) {
>              ret = s->error;
>          } else {
> -           ret = s->hob_feature;
> +            ret = s->hob_feature;
>          }
>          break;
>      case ATA_IOPORT_RR_SECTOR_COUNT:
> @@ -2155,7 +2155,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t
addr)
>          } else if (!hob) {
>              ret = s->nsector & 0xff;
>          } else {
> -           ret = s->hob_nsector;
> +            ret = s->hob_nsector;
>          }
>          break;
>      case ATA_IOPORT_RR_SECTOR_NUMBER:
> @@ -2164,7 +2164,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t
addr)
>          } else if (!hob) {
>              ret = s->sector;
>          } else {
> -           ret = s->hob_sector;
> +            ret = s->hob_sector;
>          }
>          break;
>      case ATA_IOPORT_RR_CYLINDER_LOW:
> @@ -2173,7 +2173,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t
addr)
>          } else if (!hob) {
>              ret = s->lcyl;
>          } else {
> -           ret = s->hob_lcyl;
> +            ret = s->hob_lcyl;
>          }
>          break;
>      case ATA_IOPORT_RR_CYLINDER_HIGH:
> @@ -2182,7 +2182,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t
addr)
>          } else if (!hob) {
>              ret = s->hcyl;
>          } else {
> -           ret = s->hob_hcyl;
> +            ret = s->hob_hcyl;
>          }
>          break;
>      case ATA_IOPORT_RR_DEVICE_HEAD:
> @@ -2847,7 +2847,7 @@ static const VMStateDescription
vmstate_ide_drive_pio_state = {
>      .fields = (VMStateField[]) {
>          VMSTATE_INT32(req_nb_sectors, IDEState),
>          VMSTATE_VARRAY_INT32(io_buffer, IDEState, io_buffer_total_len, 1,
> -                            vmstate_info_uint8, uint8_t),
> +                             vmstate_info_uint8, uint8_t),
>          VMSTATE_INT32(cur_io_buffer_offset, IDEState),
>          VMSTATE_INT32(cur_io_buffer_len, IDEState),
>          VMSTATE_UINT8(end_transfer_fn_idx, IDEState),
> diff --git a/hw/input/lm832x.c b/hw/input/lm832x.c
> index 74da30d9ca..cffbf586d4 100644
> --- a/hw/input/lm832x.c
> +++ b/hw/input/lm832x.c
> @@ -66,7 +66,7 @@ typedef struct {
>
>      struct {
>          uint16_t file[256];
> -       uint8_t faddr;
> +        uint8_t faddr;
>          uint8_t addr[3];
>          QEMUTimer *tm[3];
>      } pwm;
> diff --git a/hw/input/pckbd.c b/hw/input/pckbd.c
> index 07c8801387..3e66713b47 100644
> --- a/hw/input/pckbd.c
> +++ b/hw/input/pckbd.c
> @@ -55,7 +55,7 @@
>  #define KBD_CCMD_WRITE_OUTPORT 0xD1    /* write output port */
>  #define KBD_CCMD_WRITE_OBUF    0xD2
>  #define KBD_CCMD_WRITE_AUX_OBUF        0xD3    /* Write to output buffer
as if
> -                                          initiated by the auxiliary
device */
> +                                           initiated by the auxiliary
device */
>  #define KBD_CCMD_WRITE_MOUSE   0xD4    /* Write the following byte to
the mouse */
>  #define KBD_CCMD_DISABLE_A20    0xDD    /* HP vectra only ? */
>  #define KBD_CCMD_ENABLE_A20     0xDF    /* HP vectra only ? */
> diff --git a/hw/input/tsc210x.c b/hw/input/tsc210x.c
> index 1cad57f644..ded0db9351 100644
> --- a/hw/input/tsc210x.c
> +++ b/hw/input/tsc210x.c
> @@ -577,7 +577,7 @@ static void tsc2102_control_register_write(
>      case 0x01: /* Status / Keypad Control */
>          if ((s->model & 0xff00) == 0x2100)
>              s->pin_func = value >> 14;
> -       else {
> +        else {
>              s->kb.scan = (value >> 14) & 1;
>              s->kb.debounce = (value >> 11) & 7;
>              if (s->kb.intr && s->kb.scan) {
> diff --git a/hw/intc/apic.c b/hw/intc/apic.c
> index 97ffdd820f..4e8290c4e0 100644
> --- a/hw/intc/apic.c
> +++ b/hw/intc/apic.c
> @@ -441,7 +441,7 @@ static int apic_find_dest(uint8_t dest)
>
>      for (i = 0; i < MAX_APICS; i++) {
>          apic = local_apics[i];
> -       if (apic && apic->id == dest)
> +        if (apic && apic->id == dest)
>              return i;
>          if (!apic)
>              break;
> diff --git a/hw/mips/gt64xxx_pci.c b/hw/mips/gt64xxx_pci.c
> index 1cd8aac658..f707e59c7a 100644
> --- a/hw/mips/gt64xxx_pci.c
> +++ b/hw/mips/gt64xxx_pci.c
> @@ -395,7 +395,7 @@ static void gt64120_writel (void *opaque, hwaddr addr,
>          s->regs[GT_CPU] = val;
>          break;
>      case GT_MULTI:
> -       /* Read-only register as only one GT64xxx is present on the CPU
bus */
> +        /* Read-only register as only one GT64xxx is present on the CPU
bus */
>          break;
>
>      /* CPU Address Decode */
> @@ -457,13 +457,13 @@ static void gt64120_writel (void *opaque, hwaddr
addr,
>      case GT_CPUERR_DATALO:
>      case GT_CPUERR_DATAHI:
>      case GT_CPUERR_PARITY:
> -       /* Read-only registers, do nothing */
> +        /* Read-only registers, do nothing */
>          break;
>
>      /* CPU Sync Barrier */
>      case GT_PCI0SYNC:
>      case GT_PCI1SYNC:
> -       /* Read-only registers, do nothing */
> +        /* Read-only registers, do nothing */
>          break;
>
>      /* SDRAM and Device Address Decode */
> diff --git a/hw/mips/mips_r4k.c b/hw/mips/mips_r4k.c
> index 3e852e98cf..1922407394 100644
> --- a/hw/mips/mips_r4k.c
> +++ b/hw/mips/mips_r4k.c
> @@ -239,7 +239,7 @@ void mips_r4k_init(MachineState *machine)
>                                     sector_len, mips_rom / sector_len,
>                                     4, 0, 0, 0, 0, be)) {
>              fprintf(stderr, "qemu: Error registering flash memory.\n");
> -       }
> +        }
>      } else if (!qtest_enabled()) {
>          /* not fatal */
>          warn_report("could not load MIPS bios '%s'", bios_name);
> @@ -285,7 +285,7 @@ void mips_r4k_init(MachineState *machine)
>      for(i = 0; i < MAX_IDE_BUS; i++)
>          isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],
>                       hd[MAX_IDE_DEVS * i],
> -                    hd[MAX_IDE_DEVS * i + 1]);
> +                     hd[MAX_IDE_DEVS * i + 1]);
>
>      isa_create_simple(isa_bus, TYPE_I8042);
>  }
> diff --git a/hw/misc/max111x.c b/hw/misc/max111x.c
> index 6dbdc03677..ac6d35a81d 100644
> --- a/hw/misc/max111x.c
> +++ b/hw/misc/max111x.c
> @@ -43,9 +43,9 @@ typedef struct {
>  #define CB_START       (1 << 7)
>
>  #define CHANNEL_NUM(v, b0, b1, b2)     \
> -                       ((((v) >> (2 + (b0))) & 4) |    \
> -                        (((v) >> (3 + (b1))) & 2) |    \
> -                        (((v) >> (4 + (b2))) & 1))
> +                        ((((v) >> (2 + (b0))) & 4) |   \
> +                         (((v) >> (3 + (b1))) & 2) |   \
> +                         (((v) >> (4 + (b2))) & 1))
>
>  static uint32_t max111x_read(MAX111xState *s)
>  {
> diff --git a/hw/misc/omap_l4.c b/hw/misc/omap_l4.c
> index 96fc057b4e..c217728c78 100644
> --- a/hw/misc/omap_l4.c
> +++ b/hw/misc/omap_l4.c
> @@ -112,8 +112,8 @@ static const MemoryRegionOps omap_l4ta_ops = {
>
>  struct omap_target_agent_s *omap_l4ta_get(struct omap_l4_s *bus,
>          const struct omap_l4_region_s *regions,
> -       const struct omap_l4_agent_info_s *agents,
> -       int cs)
> +        const struct omap_l4_agent_info_s *agents,
> +        int cs)
>  {
>      int i;
>      struct omap_target_agent_s *ta = NULL;
> diff --git a/hw/net/mipsnet.c b/hw/net/mipsnet.c
> index 03b3104278..5ec13105df 100644
> --- a/hw/net/mipsnet.c
> +++ b/hw/net/mipsnet.c
> @@ -112,27 +112,27 @@ static uint64_t mipsnet_ioport_read(void *opaque,
hwaddr addr,
>      addr &= 0x3f;
>      switch (addr) {
>      case MIPSNET_DEV_ID:
> -       ret = be32_to_cpu(0x4d495053);          /* MIPS */
> +        ret = be32_to_cpu(0x4d495053);         /* MIPS */
>          break;
>      case MIPSNET_DEV_ID + 4:
> -       ret = be32_to_cpu(0x4e455430);          /* NET0 */
> +        ret = be32_to_cpu(0x4e455430);         /* NET0 */
>          break;
>      case MIPSNET_BUSY:
> -       ret = s->busy;
> +        ret = s->busy;
>          break;
>      case MIPSNET_RX_DATA_COUNT:
> -       ret = s->rx_count;
> +        ret = s->rx_count;
>          break;
>      case MIPSNET_TX_DATA_COUNT:
> -       ret = s->tx_count;
> +        ret = s->tx_count;
>          break;
>      case MIPSNET_INT_CTL:
> -       ret = s->intctl;
> +        ret = s->intctl;
>          s->intctl &= ~MIPSNET_INTCTL_TESTBIT;
>          break;
>      case MIPSNET_INTERRUPT_INFO:
>          /* XXX: This seems to be a per-VPE interrupt number. */
> -       ret = 0;
> +        ret = 0;
>          break;
>      case MIPSNET_RX_DATA_BUFFER:
>          if (s->rx_count) {
> @@ -161,7 +161,7 @@ static void mipsnet_ioport_write(void *opaque, hwaddr
addr,
>      trace_mipsnet_write(addr, val);
>      switch (addr) {
>      case MIPSNET_TX_DATA_COUNT:
> -       s->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;
> +        s->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;
>          s->tx_written = 0;
>          break;
>      case MIPSNET_INT_CTL:
> diff --git a/hw/net/ne2000.c b/hw/net/ne2000.c
> index 869518ee06..037afc8052 100644
> --- a/hw/net/ne2000.c
> +++ b/hw/net/ne2000.c
> @@ -145,7 +145,7 @@ static void ne2000_update_irq(NE2000State *s)
>      isr = (s->isr & s->imr) & 0x7f;
>  #if defined(DEBUG_NE2000)
>      printf("NE2000: Set IRQ to %d (%02x %02x)\n",
> -          isr ? 1 : 0, s->isr, s->imr);
> +           isr ? 1 : 0, s->isr, s->imr);
>  #endif
>      qemu_set_irq(s->irq, (isr != 0));
>  }
> @@ -396,12 +396,12 @@ static uint32_t ne2000_ioport_read(void *opaque,
uint32_t addr)
>          case EN0_ISR:
>              ret = s->isr;
>              break;
> -       case EN0_RSARLO:
> -           ret = s->rsar & 0x00ff;
> -           break;
> -       case EN0_RSARHI:
> -           ret = s->rsar >> 8;
> -           break;
> +        case EN0_RSARLO:
> +            ret = s->rsar & 0x00ff;
> +            break;
> +        case EN0_RSARHI:
> +            ret = s->rsar >> 8;
> +            break;
>          case EN1_PHYS ... EN1_PHYS + 5:
>              ret = s->phys[offset - EN1_PHYS];
>              break;
> @@ -420,21 +420,21 @@ static uint32_t ne2000_ioport_read(void *opaque,
uint32_t addr)
>          case EN2_STOPPG:
>              ret = s->stop >> 8;
>              break;
> -       case EN0_RTL8029ID0:
> -           ret = 0x50;
> -           break;
> -       case EN0_RTL8029ID1:
> -           ret = 0x43;
> -           break;
> -       case EN3_CONFIG0:
> -           ret = 0;            /* 10baseT media */
> -           break;
> -       case EN3_CONFIG2:
> -           ret = 0x40;         /* 10baseT active */
> -           break;
> -       case EN3_CONFIG3:
> -           ret = 0x40;         /* Full duplex */
> -           break;
> +        case EN0_RTL8029ID0:
> +            ret = 0x50;
> +            break;
> +        case EN0_RTL8029ID1:
> +            ret = 0x43;
> +            break;
> +        case EN3_CONFIG0:
> +            ret = 0;           /* 10baseT media */
> +            break;
> +        case EN3_CONFIG2:
> +            ret = 0x40;                /* 10baseT active */
> +            break;
> +        case EN3_CONFIG3:
> +            ret = 0x40;                /* Full duplex */
> +            break;
>          default:
>              ret = 0x00;
>              break;
> diff --git a/hw/net/rocker/rocker.c b/hw/net/rocker/rocker.c
> index c02cbefece..5266f9b7dd 100644
> --- a/hw/net/rocker/rocker.c
> +++ b/hw/net/rocker/rocker.c
> @@ -1279,7 +1279,7 @@ static World *rocker_world_type_by_name(Rocker *r,
const char *name)
>      for (i = 0; i < ROCKER_WORLD_TYPE_MAX; i++) {
>          if (strcmp(name, world_name(r->worlds[i])) == 0) {
>              return r->worlds[i];
> -       }
> +        }
>      }
>      return NULL;
>  }
> diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
> index 385b1a03e9..e37fc34839 100644
> --- a/hw/net/virtio-net.c
> +++ b/hw/net/virtio-net.c
> @@ -1375,10 +1375,10 @@ static int32_t virtio_net_flush_tx(VirtIONetQueue
*q)
>                                     n->guest_hdr_len, -1);
>                  if (out_num == VIRTQUEUE_MAX_SIZE) {
>                      goto drop;
> -               }
> +                }
>                  out_num += 1;
>                  out_sg = sg2;
> -           }
> +            }
>          }
>          /*
>           * If host wants to see the guest header as is, we can
> diff --git a/hw/net/vmxnet3.c b/hw/net/vmxnet3.c
> index 3648630386..76f3ed319d 100644
> --- a/hw/net/vmxnet3.c
> +++ b/hw/net/vmxnet3.c
> @@ -149,7 +149,7 @@ typedef struct {
>  } Vmxnet3Ring;
>
>  static inline void vmxnet3_ring_init(PCIDevice *d,
> -                                    Vmxnet3Ring *ring,
> +                                     Vmxnet3Ring *ring,
>                                       hwaddr pa,
>                                       uint32_t size,
>                                       uint32_t cell_size,
> @@ -193,13 +193,13 @@ static inline hwaddr
vmxnet3_ring_curr_cell_pa(Vmxnet3Ring *ring)
>  }
>
>  static inline void vmxnet3_ring_read_curr_cell(PCIDevice *d, Vmxnet3Ring
*ring,
> -                                              void *buff)
> +                                               void *buff)
>  {
>      vmw_shmem_read(d, vmxnet3_ring_curr_cell_pa(ring), buff,
ring->cell_size);
>  }
>
>  static inline void vmxnet3_ring_write_curr_cell(PCIDevice *d,
Vmxnet3Ring *ring,
> -                                               void *buff)
> +                                                void *buff)
>  {
>      vmw_shmem_write(d, vmxnet3_ring_curr_cell_pa(ring), buff,
ring->cell_size);
>  }
> diff --git a/hw/pci/msix.c b/hw/pci/msix.c
> index 702dac4ec7..c7bdbeda9e 100644
> --- a/hw/pci/msix.c
> +++ b/hw/pci/msix.c
> @@ -501,7 +501,7 @@ void msix_reset(PCIDevice *dev)
>      }
>      msix_clear_all_vectors(dev);
>      dev->config[dev->msix_cap + MSIX_CONTROL_OFFSET] &=
> -           ~dev->wmask[dev->msix_cap + MSIX_CONTROL_OFFSET];
> +            ~dev->wmask[dev->msix_cap + MSIX_CONTROL_OFFSET];
>      memset(dev->msix_table, 0, dev->msix_entries_nr *
PCI_MSIX_ENTRY_SIZE);
>      memset(dev->msix_pba, 0, QEMU_ALIGN_UP(dev->msix_entries_nr, 64) /
8);
>      msix_mask_all(dev, dev->msix_entries_nr);
> diff --git a/hw/pci/pci.c b/hw/pci/pci.c
> index 56b13b3320..13328a0827 100644
> --- a/hw/pci/pci.c
> +++ b/hw/pci/pci.c
> @@ -211,13 +211,13 @@ int pci_bar(PCIDevice *d, int reg)
>
>  static inline int pci_irq_state(PCIDevice *d, int irq_num)
>  {
> -       return (d->irq_state >> irq_num) & 0x1;
> +        return (d->irq_state >> irq_num) & 0x1;
>  }
>
>  static inline void pci_set_irq_state(PCIDevice *d, int irq_num, int
level)
>  {
> -       d->irq_state &= ~(0x1 << irq_num);
> -       d->irq_state |= level << irq_num;
> +        d->irq_state &= ~(0x1 << irq_num);
> +        d->irq_state |= level << irq_num;
>  }
>
>  static void pci_change_irq_level(PCIDevice *pci_dev, int irq_num, int
change)
> @@ -571,8 +571,8 @@ const VMStateDescription vmstate_pci_device = {
>                                     0, vmstate_info_pci_config,
>                                     PCIE_CONFIG_SPACE_SIZE),
>          VMSTATE_BUFFER_UNSAFE_INFO(irq_state, PCIDevice, 2,
> -                                  vmstate_info_pci_irq_state,
> -                                  PCI_NUM_PINS * sizeof(int32_t)),
> +                                   vmstate_info_pci_irq_state,
> +                                   PCI_NUM_PINS * sizeof(int32_t)),
>          VMSTATE_END_OF_LIST()
>      }
>  };
> @@ -624,21 +624,21 @@ static int pci_parse_devaddr(const char *addr, int
*domp, int *busp,
>      p = addr;
>      val = strtoul(p, &e, 16);
>      if (e == p)
> -       return -1;
> +        return -1;
>      if (*e == ':') {
> -       bus = val;
> -       p = e + 1;
> -       val = strtoul(p, &e, 16);
> -       if (e == p)
> -           return -1;
> -       if (*e == ':') {
> -           dom = bus;
> -           bus = val;
> -           p = e + 1;
> -           val = strtoul(p, &e, 16);
> -           if (e == p)
> -               return -1;
> -       }
> +        bus = val;
> +        p = e + 1;
> +        val = strtoul(p, &e, 16);
> +        if (e == p)
> +            return -1;
> +        if (*e == ':') {
> +            dom = bus;
> +            bus = val;
> +            p = e + 1;
> +            val = strtoul(p, &e, 16);
> +            if (e == p)
> +                return -1;
> +        }
>      }
>
>      slot = val;
> @@ -657,10 +657,10 @@ static int pci_parse_devaddr(const char *addr, int
*domp, int *busp,
>
>      /* if funcp == NULL func is 0 */
>      if (dom > 0xffff || bus > 0xff || slot > 0x1f || func > 7)
> -       return -1;
> +        return -1;
>
>      if (*e)
> -       return -1;
> +        return -1;
>
>      *domp = dom;
>      *busp = bus;
> @@ -1217,7 +1217,7 @@ pcibus_t pci_get_bar_addr(PCIDevice *pci_dev, int
region_num)
>  }
>
>  static pcibus_t pci_bar_address(PCIDevice *d,
> -                               int reg, uint8_t type, pcibus_t size)
> +                                int reg, uint8_t type, pcibus_t size)
>  {
>      pcibus_t new_addr, last_addr;
>      int bar = pci_bar(d, reg);
> diff --git a/hw/pci/pci_bridge.c b/hw/pci/pci_bridge.c
> index ee9dff2d3a..55d0dacd60 100644
> --- a/hw/pci/pci_bridge.c
> +++ b/hw/pci/pci_bridge.c
> @@ -369,7 +369,7 @@ void pci_bridge_initfn(PCIDevice *dev, const char
*typename)
>       * let users address the bus using the device name.
>       */
>      if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {
> -           br->bus_name = dev->qdev.id;
> +            br->bus_name = dev->qdev.id;
>      }
>
>      qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename,
DEVICE(dev),
> diff --git a/hw/ppc/ppc405_uc.c b/hw/ppc/ppc405_uc.c
> index 5c58415cf1..fbe2e7f857 100644
> --- a/hw/ppc/ppc405_uc.c
> +++ b/hw/ppc/ppc405_uc.c
> @@ -1885,7 +1885,7 @@ CPUPPCState *ppc405ep_init(MemoryRegion
*address_space_mem,
>      pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);
>      *picp = pic;
>      /* SDRAM controller */
> -       /* XXX 405EP has no ECC interrupt */
> +        /* XXX 405EP has no ECC interrupt */
>      ppc4xx_sdram_init(env, pic[17], 2, ram_memories,
>                        ram_bases, ram_sizes, do_init);
>      /* External bus controller */
> diff --git a/hw/ppc/prep.c b/hw/ppc/prep.c
> index 2afb7f437e..7bda86a7d0 100644
> --- a/hw/ppc/prep.c
> +++ b/hw/ppc/prep.c
> @@ -538,7 +538,7 @@ static void ppc_prep_init(MachineState *machine)
>          nb_nics1 = NE2000_NB_MAX;
>      for(i = 0; i < nb_nics1; i++) {
>          if (nd_table[i].model == NULL) {
> -           nd_table[i].model = g_strdup("ne2k_isa");
> +            nd_table[i].model = g_strdup("ne2k_isa");
>          }
>          if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {
>              isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],
> @@ -552,7 +552,7 @@ static void ppc_prep_init(MachineState *machine)
>      for(i = 0; i < MAX_IDE_BUS; i++) {
>          isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],
>                       hd[2 * i],
> -                    hd[2 * i + 1]);
> +                     hd[2 * i + 1]);
>      }
>
>      cpu = POWERPC_CPU(first_cpu);
> diff --git a/hw/scsi/lsi53c895a.c b/hw/scsi/lsi53c895a.c
> index 52a38933b6..89def1421f 100644
> --- a/hw/scsi/lsi53c895a.c
> +++ b/hw/scsi/lsi53c895a.c
> @@ -1850,7 +1850,7 @@ static void lsi_reg_writeb(LSIState *s, int offset,
uint8_t val)
>          break;
>      case 0x0a: case 0x0b:
>          /* Openserver writes to these readonly registers on startup */
> -       return;
> +        return;
>      case 0x0c: case 0x0d: case 0x0e: case 0x0f:
>          /* Linux writes to these readonly registers on startup.  */
>          return;
> @@ -1884,8 +1884,8 @@ static void lsi_reg_writeb(LSIState *s, int offset,
uint8_t val)
>          /* nothing to do */
>          break;
>      case 0x1a: /* CTEST2 */
> -       s->ctest2 = val & LSI_CTEST2_PCICIE;
> -       break;
> +        s->ctest2 = val & LSI_CTEST2_PCICIE;
> +        break;
>      case 0x1b: /* CTEST3 */
>          s->ctest3 = val & 0x0f;
>          break;
> diff --git a/hw/sh4/r2d.c b/hw/sh4/r2d.c
> index 6a5fc46a47..5b399e7161 100644
> --- a/hw/sh4/r2d.c
> +++ b/hw/sh4/r2d.c
> @@ -139,11 +139,11 @@ static uint64_t r2d_fpga_read(void *opaque, hwaddr
addr, unsigned int size)
>      case PA_IRLMSK:
>          return s->irlmsk;
>      case PA_OUTPORT:
> -       return s->outport;
> +        return s->outport;
>      case PA_POWOFF:
> -       return 0x00;
> +        return 0x00;
>      case PA_VERREG:
> -       return 0x10;
> +        return 0x10;
>      }
>
>      return 0;
> @@ -158,18 +158,18 @@ r2d_fpga_write(void *opaque, hwaddr addr, uint64_t
value, unsigned int size)
>      case PA_IRLMSK:
>          s->irlmsk = value;
>          update_irl(s);
> -       break;
> +        break;
>      case PA_OUTPORT:
> -       s->outport = value;
> -       break;
> +        s->outport = value;
> +        break;
>      case PA_POWOFF:
>          if (value & 1) {
>              qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
>          }
>          break;
>      case PA_VERREG:
> -       /* Discard writes */
> -       break;
> +        /* Discard writes */
> +        break;
>      }
>  }
>
> diff --git a/hw/usb/dev-bluetooth.c b/hw/usb/dev-bluetooth.c
> index eac7365b0a..c539a1afc6 100644
> --- a/hw/usb/dev-bluetooth.c
> +++ b/hw/usb/dev-bluetooth.c
> @@ -46,7 +46,7 @@ struct USBBtState {
>
>      struct usb_hci_out_fifo_s {
>          uint8_t data[4096];
> -       int len;
> +        int len;
>      } outcmd, outacl, outsco;
>  };
>
> diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
> index 62d18290dc..90cd745f06 100644
> --- a/hw/usb/dev-hid.c
> +++ b/hw/usb/dev-hid.c
> @@ -592,12 +592,12 @@ static void usb_hid_handle_control(USBDevice *dev,
USBPacket *p,
>          switch (value >> 8) {
>          case 0x22:
>              if (hs->kind == HID_MOUSE) {
> -               memcpy(data, qemu_mouse_hid_report_descriptor,
> -                      sizeof(qemu_mouse_hid_report_descriptor));
> +                memcpy(data, qemu_mouse_hid_report_descriptor,
> +                       sizeof(qemu_mouse_hid_report_descriptor));
>                  p->actual_length =
sizeof(qemu_mouse_hid_report_descriptor);
>              } else if (hs->kind == HID_TABLET) {
>                  memcpy(data, qemu_tablet_hid_report_descriptor,
> -                      sizeof(qemu_tablet_hid_report_descriptor));
> +                       sizeof(qemu_tablet_hid_report_descriptor));
>                  p->actual_length =
sizeof(qemu_tablet_hid_report_descriptor);
>              } else if (hs->kind == HID_KEYBOARD) {
>                  memcpy(data, qemu_keyboard_hid_report_descriptor,
> diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
> index dc368179d1..7e9339b8a8 100644
> --- a/hw/usb/dev-hub.c
> +++ b/hw/usb/dev-hub.c
> @@ -147,13 +147,13 @@ static const USBDesc desc_hub = {
>
>  static const uint8_t qemu_hub_hub_descriptor[] =
>  {
> -       0x00,                   /*  u8  bLength; patched in later */
> -       0x29,                   /*  u8  bDescriptorType; Hub-descriptor */
> -       0x00,                   /*  u8  bNbrPorts; (patched later) */
> -       0x0a,                   /* u16  wHubCharacteristics; */
> -       0x00,                   /*   (per-port OC, no power switching) */
> -       0x01,                   /*  u8  bPwrOn2pwrGood; 2ms */
> -       0x00                    /*  u8  bHubContrCurrent; 0 mA */
> +        0x00,                  /*  u8  bLength; patched in later */
> +        0x29,                  /*  u8  bDescriptorType; Hub-descriptor */
> +        0x00,                  /*  u8  bNbrPorts; (patched later) */
> +        0x0a,                  /* u16  wHubCharacteristics; */
> +        0x00,                  /*   (per-port OC, no power switching) */
> +        0x01,                  /*  u8  bPwrOn2pwrGood; 2ms */
> +        0x00                   /*  u8  bHubContrCurrent; 0 mA */
>
>          /* DeviceRemovable and PortPwrCtrlMask patched in later */
>  };
> diff --git a/hw/xen/xen_devconfig.c b/hw/xen/xen_devconfig.c
> index aebc19bd71..3500d88a3e 100644
> --- a/hw/xen/xen_devconfig.c
> +++ b/hw/xen/xen_devconfig.c
> @@ -6,7 +6,7 @@
>  /* ------------------------------------------------------------- */
>
>  static int xen_config_dev_dirs(const char *ftype, const char *btype, int
vdev,
> -                              char *fe, char *be, int len)
> +                               char *fe, char *be, int len)
>  {
>      char *dom;
>
> diff --git a/hw/xenpv/xen_domainbuild.c b/hw/xenpv/xen_domainbuild.c
> index 188acaca16..2859280a6a 100644
> --- a/hw/xenpv/xen_domainbuild.c
> +++ b/hw/xenpv/xen_domainbuild.c
> @@ -27,11 +27,11 @@ static int xenstore_domain_mkdir(char *path)
>
>      if (!xs_mkdir(xenstore, 0, path)) {
>          fprintf(stderr, "%s: xs_mkdir %s: failed\n", __func__, path);
> -       return -1;
> +        return -1;
>      }
>      if (!xs_set_permissions(xenstore, 0, path, perms_ro, 2)) {
>          fprintf(stderr, "%s: xs_set_permissions failed\n", __func__);
> -       return -1;
> +        return -1;
>      }
>
>      for (i = 0; writable[i]; i++) {
> @@ -82,8 +82,8 @@ int xenstore_domain_init1(const char *kernel, const
char *ramdisk,
>
>      /* cpus */
>      for (i = 0; i < smp_cpus; i++) {
> -       snprintf(path, sizeof(path), "cpu/%d/availability",i);
> -       xenstore_write_str(dom, path, "online");
> +        snprintf(path, sizeof(path), "cpu/%d/availability",i);
> +        xenstore_write_str(dom, path, "online");
>      }
>      xenstore_write_int(vm, "vcpu_avail",  smp_cpus);
>      xenstore_write_int(vm, "vcpus",       smp_cpus);
> diff --git a/include/elf.h b/include/elf.h
> index c151164b63..2a72b282f7 100644
> --- a/include/elf.h
> +++ b/include/elf.h
> @@ -782,11 +782,11 @@ typedef struct {
>  /* ARM-specific values for sh_flags */
>  #define SHF_ARM_ENTRYSECT  0x10000000   /* Section contains an entry
point */
>  #define SHF_ARM_COMDEF     0x80000000   /* Section may be multiply
defined
> -                                          in the input to a link step */
> +                                           in the input to a link step */
>
>  /* ARM-specific program header flags */
>  #define PF_ARM_SB          0x10000000   /* Segment contains the location
> -                                          addressed by the static base */
> +                                           addressed by the static base
*/
>
>  /* ARM relocs.  */
>  #define R_ARM_NONE             0       /* No reloc */
> @@ -1047,7 +1047,7 @@ typedef struct {
>  #define R_X86_64_JUMP_SLOT     7       /* Create PLT entry */
>  #define R_X86_64_RELATIVE      8       /* Adjust by program base */
>  #define R_X86_64_GOTPCREL      9       /* 32 bit signed pc relative
> -                                          offset to GOT */
> +                                           offset to GOT */
>  #define R_X86_64_32            10      /* Direct 32 bit zero extended */
>  #define R_X86_64_32S           11      /* Direct 32 bit sign extended */
>  #define R_X86_64_16            12      /* Direct 16 bit zero extended */
> @@ -1070,7 +1070,7 @@ typedef struct {
>  #define EF_PARISC_LSB          0x00040000 /* Program expects little
endian. */
>  #define EF_PARISC_WIDE         0x00080000 /* Program expects wide mode.
*/
>  #define EF_PARISC_NO_KABP      0x00100000 /* No kernel assisted branch
> -                                             prediction.  */
> +                                              prediction.  */
>  #define EF_PARISC_LAZYSWAP     0x00400000 /* Allow lazy swapping.  */
>  #define EF_PARISC_ARCH         0x0000ffff /* Architecture version.  */
>
> @@ -1083,7 +1083,7 @@ typedef struct {
>  /* Additional section indeces.  */
>
>  #define SHN_PARISC_ANSI_COMMON 0xff00     /* Section for tenatively
declared
> -                                             symbols in ANSI C.  */
> +                                              symbols in ANSI C.  */
>  #define SHN_PARISC_HUGE_COMMON 0xff01     /* Common blocks in huge
model.  */
>
>  /* Legal values for sh_type field of Elf32_Shdr.  */
> diff --git a/include/hw/acpi/acpi.h b/include/hw/acpi/acpi.h
> index c20ace0d0b..bbf541263a 100644
> --- a/include/hw/acpi/acpi.h
> +++ b/include/hw/acpi/acpi.h
> @@ -69,13 +69,13 @@
>  #define ACPI_BITMASK_WAKE_STATUS                0x8000
>
>  #define ACPI_BITMASK_ALL_FIXED_STATUS           (\
> -       ACPI_BITMASK_TIMER_STATUS          | \
> -       ACPI_BITMASK_BUS_MASTER_STATUS     | \
> -       ACPI_BITMASK_GLOBAL_LOCK_STATUS    | \
> -       ACPI_BITMASK_POWER_BUTTON_STATUS   | \
> -       ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
> -       ACPI_BITMASK_RT_CLOCK_STATUS       | \
> -       ACPI_BITMASK_WAKE_STATUS)
> +        ACPI_BITMASK_TIMER_STATUS          | \
> +        ACPI_BITMASK_BUS_MASTER_STATUS     | \
> +        ACPI_BITMASK_GLOBAL_LOCK_STATUS    | \
> +        ACPI_BITMASK_POWER_BUTTON_STATUS   | \
> +        ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
> +        ACPI_BITMASK_RT_CLOCK_STATUS       | \
> +        ACPI_BITMASK_WAKE_STATUS)
>
>  /* PM1x_EN */
>  #define ACPI_BITMASK_TIMER_ENABLE               0x0001
> diff --git a/include/hw/elf_ops.h b/include/hw/elf_ops.h
> index 3b6398cb39..b84ba87e44 100644
> --- a/include/hw/elf_ops.h
> +++ b/include/hw/elf_ops.h
> @@ -343,7 +343,7 @@ static int glue(load_elf, SZ)(const char *name, int
fd,
>      }
>
>      if (pentry)
> -       *pentry = (uint64_t)(elf_sword)ehdr.e_entry;
> +        *pentry = (uint64_t)(elf_sword)ehdr.e_entry;
>
>      glue(load_symbols, SZ)(&ehdr, fd, must_swab, clear_lsb, sym_cb);
>
> diff --git a/include/hw/ide/internal.h b/include/hw/ide/internal.h
> index 594081e57f..880413ddc7 100644
> --- a/include/hw/ide/internal.h
> +++ b/include/hw/ide/internal.h
> @@ -342,7 +342,7 @@ enum ide_dma_cmd {
>  extern const char *IDE_DMA_CMD_lookup[IDE_DMA__COUNT];
>
>  #define ide_cmd_is_read(s) \
> -       ((s)->dma_cmd == IDE_DMA_READ)
> +        ((s)->dma_cmd == IDE_DMA_READ)
>
>  typedef struct IDEBufferedRequest {
>      QLIST_ENTRY(IDEBufferedRequest) list;
> diff --git a/include/hw/sh4/sh_intc.h b/include/hw/sh4/sh_intc.h
> index fbcee94ed7..adfedb2efc 100644
> --- a/include/hw/sh4/sh_intc.h
> +++ b/include/hw/sh4/sh_intc.h
> @@ -61,21 +61,21 @@ struct intc_desc {
>  int sh_intc_get_pending_vector(struct intc_desc *desc, int imask);
>  struct intc_source *sh_intc_source(struct intc_desc *desc, intc_enum id);
>  void sh_intc_toggle_source(struct intc_source *source,
> -                          int enable_adj, int assert_adj);
> +                           int enable_adj, int assert_adj);
>
>  void sh_intc_register_sources(struct intc_desc *desc,
> -                             struct intc_vect *vectors,
> -                             int nr_vectors,
> -                             struct intc_group *groups,
> -                             int nr_groups);
> +                              struct intc_vect *vectors,
> +                              int nr_vectors,
> +                              struct intc_group *groups,
> +                              int nr_groups);
>
>  int sh_intc_init(MemoryRegion *sysmem,
>                   struct intc_desc *desc,
> -                int nr_sources,
> -                struct intc_mask_reg *mask_regs,
> -                int nr_mask_regs,
> -                struct intc_prio_reg *prio_regs,
> -                int nr_prio_regs);
> +                 int nr_sources,
> +                 struct intc_mask_reg *mask_regs,
> +                 int nr_mask_regs,
> +                 struct intc_prio_reg *prio_regs,
> +                 int nr_prio_regs);
>
>  void sh_intc_set_irl(void *opaque, int n, int level);
>
> diff --git a/include/hw/xen/io/ring.h b/include/hw/xen/io/ring.h
> index ffa3ebadc8..1adacf09f9 100644
> --- a/include/hw/xen/io/ring.h
> +++ b/include/hw/xen/io/ring.h
> @@ -235,8 +235,8 @@ typedef struct __name##_back_ring __name##_back_ring_t
>   * to be ineffective where _req is a struct which consists of only
bitfields.
>   */
>  #define RING_COPY_REQUEST(_r, _idx, _req) do {                         \
> -       /* Use volatile to force the copy into _req. */                 \
> -       *(_req) = *(volatile typeof(_req))RING_GET_REQUEST(_r, _idx);   \
> +        /* Use volatile to force the copy into _req. */
      \
> +        *(_req) = *(volatile typeof(_req))RING_GET_REQUEST(_r, _idx);  \
>  } while (0)
>
>  #define RING_GET_RESPONSE(_r, _idx)                                     \
> diff --git a/include/qemu/acl.h b/include/qemu/acl.h
> index 7c44119a47..73d2a71c8d 100644
> --- a/include/qemu/acl.h
> +++ b/include/qemu/acl.h
> @@ -49,18 +49,18 @@ qemu_acl *qemu_acl_init(const char *aclname);
>  qemu_acl *qemu_acl_find(const char *aclname);
>
>  int qemu_acl_party_is_allowed(qemu_acl *acl,
> -                             const char *party);
> +                              const char *party);
>
>  void qemu_acl_reset(qemu_acl *acl);
>
>  int qemu_acl_append(qemu_acl *acl,
> -                   int deny,
> -                   const char *match);
> +                    int deny,
> +                    const char *match);
>  int qemu_acl_insert(qemu_acl *acl,
> -                   int deny,
> -                   const char *match,
> -                   int index);
> +                    int deny,
> +                    const char *match,
> +                    int index);
>  int qemu_acl_remove(qemu_acl *acl,
> -                   const char *match);
> +                    const char *match);
>
>  #endif /* QEMU_ACL_H */
> diff --git a/include/qemu/iov.h b/include/qemu/iov.h
> index 72d4c559b4..5f433c7768 100644
> --- a/include/qemu/iov.h
> +++ b/include/qemu/iov.h
> @@ -35,7 +35,7 @@ size_t iov_size(const struct iovec *iov, const unsigned
int iov_cnt);
>  size_t iov_from_buf_full(const struct iovec *iov, unsigned int iov_cnt,
>                           size_t offset, const void *buf, size_t bytes);
>  size_t iov_to_buf_full(const struct iovec *iov, const unsigned int
iov_cnt,
> -                      size_t offset, void *buf, size_t bytes);
> +                       size_t offset, void *buf, size_t bytes);
>
>  static inline size_t
>  iov_from_buf(const struct iovec *iov, unsigned int iov_cnt,
> diff --git a/include/scsi/constants.h b/include/scsi/constants.h
> index 083a8e887a..0dc550732d 100644
> --- a/include/scsi/constants.h
> +++ b/include/scsi/constants.h
> @@ -212,7 +212,7 @@
>  #define TYPE_ROM            0x05
>  #define TYPE_SCANNER        0x06
>  #define TYPE_MOD            0x07    /* Magneto-optical disk -
> -                                    * - treated as TYPE_DISK */
> +                                     * - treated as TYPE_DISK */
>  #define TYPE_MEDIUM_CHANGER 0x08
>  #define TYPE_STORAGE_ARRAY  0x0c    /* Storage array device */
>  #define TYPE_ENCLOSURE      0x0d    /* Enclosure Services Device */
> diff --git a/include/sysemu/balloon.h b/include/sysemu/balloon.h
> index 66543ae8f4..c8f6145257 100644
> --- a/include/sysemu/balloon.h
> +++ b/include/sysemu/balloon.h
> @@ -20,7 +20,7 @@ typedef void (QEMUBalloonEvent)(void *opaque,
ram_addr_t target);
>  typedef void (QEMUBalloonStatus)(void *opaque, BalloonInfo *info);
>
>  int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
> -                            QEMUBalloonStatus *stat_func, void *opaque);
> +                             QEMUBalloonStatus *stat_func, void *opaque);
>  void qemu_remove_balloon_handler(void *opaque);
>  bool qemu_balloon_is_inhibited(void);
>  void qemu_balloon_inhibit(bool state);
> diff --git a/linux-user/linuxload.c b/linux-user/linuxload.c
> index 6717c9c6f0..a27e1d0d8b 100644
> --- a/linux-user/linuxload.c
> +++ b/linux-user/linuxload.c
> @@ -38,15 +38,15 @@ static int prepare_binprm(struct linux_binprm *bprm)
>      int retval;
>
>      if(fstat(bprm->fd, &st) < 0) {
> -       return(-errno);
> +        return(-errno);
>      }
>
>      mode = st.st_mode;
>      if(!S_ISREG(mode)) {       /* Must be regular file */
> -       return(-EACCES);
> +        return(-EACCES);
>      }
>      if(!(mode & 0111)) {       /* Must have at least one execute bit set
*/
> -       return(-EACCES);
> +        return(-EACCES);
>      }
>
>      bprm->e_uid = geteuid();
> @@ -54,7 +54,7 @@ static int prepare_binprm(struct linux_binprm *bprm)
>
>      /* Set-uid? */
>      if(mode & S_ISUID) {
> -       bprm->e_uid = st.st_uid;
> +        bprm->e_uid = st.st_uid;
>      }
>
>      /* Set-gid? */
> @@ -64,13 +64,13 @@ static int prepare_binprm(struct linux_binprm *bprm)
>       * executable.
>       */
>      if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
> -       bprm->e_gid = st.st_gid;
> +        bprm->e_gid = st.st_gid;
>      }
>
>      retval = read(bprm->fd, bprm->buf, BPRM_BUF_SIZE);
>      if (retval < 0) {
> -       perror("prepare_binprm");
> -       exit(-1);
> +        perror("prepare_binprm");
> +        exit(-1);
>      }
>      if (retval < BPRM_BUF_SIZE) {
>          /* Make sure the rest of the loader won't read garbage.  */
> diff --git a/linux-user/main.c b/linux-user/main.c
> index 923cbb753a..a0aba9cb1e 100644
> --- a/linux-user/main.c
> +++ b/linux-user/main.c
> @@ -740,8 +740,8 @@ int main(int argc, char **argv, char **envp)
>      target_argc = argc - optind;
>      target_argv = calloc(target_argc + 1, sizeof (char *));
>      if (target_argv == NULL) {
> -       (void) fprintf(stderr, "Unable to allocate memory for
target_argv\n");
> -       exit(EXIT_FAILURE);
> +        (void) fprintf(stderr, "Unable to allocate memory for
target_argv\n");
> +        exit(EXIT_FAILURE);
>      }
>
>      /*
> diff --git a/linux-user/mmap.c b/linux-user/mmap.c
> index 41e0983ce8..e0249efe4f 100644
> --- a/linux-user/mmap.c
> +++ b/linux-user/mmap.c
> @@ -485,11 +485,11 @@ abi_long target_mmap(abi_ulong start, abi_ulong
len, int prot,
>          end = start + len;
>          real_end = HOST_PAGE_ALIGN(end);
>
> -       /*
> -        * Test if requested memory area fits target address space
> -        * It can fail only on 64-bit host with 32-bit target.
> -        * On any other target/host host mmap() handles this error
correctly.
> -        */
> +        /*
> +         * Test if requested memory area fits target address space
> +         * It can fail only on 64-bit host with 32-bit target.
> +         * On any other target/host host mmap() handles this error
correctly.
> +         */
>          if (!guest_range_valid(start, len)) {
>              errno = ENOMEM;
>              goto fail;
> diff --git a/linux-user/qemu.h b/linux-user/qemu.h
> index dd5771ce0c..069df8f1f9 100644
> --- a/linux-user/qemu.h
> +++ b/linux-user/qemu.h
> @@ -50,7 +50,7 @@ struct image_info {
>          abi_ulong       env_strings;
>          abi_ulong       file_string;
>          uint32_t        elf_flags;
> -       int             personality;
> +        int            personality;
>          abi_ulong       alignment;
>
>          /* The fields below are used in FDPIC mode.  */
> @@ -174,7 +174,7 @@ extern unsigned long mmap_min_addr;
>  struct linux_binprm {
>          char buf[BPRM_BUF_SIZE] __attribute__((aligned));
>          abi_ulong p;
> -       int fd;
> +        int fd;
>          int e_uid, e_gid;
>          int argc, envc;
>          char **argv;
> diff --git a/linux-user/signal.c b/linux-user/signal.c
> index 602b631b92..e2c0b37173 100644
> --- a/linux-user/signal.c
> +++ b/linux-user/signal.c
> @@ -727,7 +727,7 @@ abi_long do_sigaltstack(abi_ulong uss_addr, abi_ulong
uoss_addr, abi_ulong sp)
>          }
>  #endif
>
> -       ret = -TARGET_EFAULT;
> +        ret = -TARGET_EFAULT;
>          if (!lock_user_struct(VERIFY_READ, uss, uss_addr, 1)) {
>              goto out;
>          }
> @@ -736,25 +736,25 @@ abi_long do_sigaltstack(abi_ulong uss_addr,
abi_ulong uoss_addr, abi_ulong sp)
>          __get_user(ss.ss_flags, &uss->ss_flags);
>          unlock_user_struct(uss, uss_addr, 0);
>
> -       ret = -TARGET_EPERM;
> -       if (on_sig_stack(sp))
> +        ret = -TARGET_EPERM;
> +        if (on_sig_stack(sp))
>              goto out;
>
> -       ret = -TARGET_EINVAL;
> -       if (ss.ss_flags != TARGET_SS_DISABLE
> +        ret = -TARGET_EINVAL;
> +        if (ss.ss_flags != TARGET_SS_DISABLE
>              && ss.ss_flags != TARGET_SS_ONSTACK
>              && ss.ss_flags != 0)
>              goto out;
>
> -       if (ss.ss_flags == TARGET_SS_DISABLE) {
> +        if (ss.ss_flags == TARGET_SS_DISABLE) {
>              ss.ss_size = 0;
>              ss.ss_sp = 0;
> -       } else {
> +        } else {
>              ret = -TARGET_ENOMEM;
>              if (ss.ss_size < minstacksize) {
>                  goto out;
>              }
> -       }
> +        }
>
>          target_sigaltstack_used.ss_sp = ss.ss_sp;
>          target_sigaltstack_used.ss_size = ss.ss_size;
> diff --git a/linux-user/strace.c b/linux-user/strace.c
> index d1d14945f9..7318392e57 100644
> --- a/linux-user/strace.c
> +++ b/linux-user/strace.c
> @@ -647,11 +647,11 @@ print_execve(const struct syscallname *name,
>      for (arg_ptr_addr = arg2; ; arg_ptr_addr += sizeof(abi_ulong)) {
>          abi_ulong *arg_ptr, arg_addr;
>
> -       arg_ptr = lock_user(VERIFY_READ, arg_ptr_addr, sizeof(abi_ulong),
1);
> +        arg_ptr = lock_user(VERIFY_READ, arg_ptr_addr,
sizeof(abi_ulong), 1);
>          if (!arg_ptr)
>              return;
>      arg_addr = tswapal(*arg_ptr);
> -       unlock_user(arg_ptr, arg_ptr_addr, 0);
> +        unlock_user(arg_ptr, arg_ptr_addr, 0);
>          if (!arg_addr)
>              break;
>          if ((s = lock_user_string(arg_addr))) {
> diff --git a/linux-user/uaccess.c b/linux-user/uaccess.c
> index 0a5c0b0b29..e215ecc2a6 100644
> --- a/linux-user/uaccess.c
> +++ b/linux-user/uaccess.c
> @@ -30,7 +30,7 @@ abi_long copy_to_user(abi_ulong gaddr, void *hptr,
size_t len)
>
>      if ((ghptr = lock_user(VERIFY_WRITE, gaddr, len, 0))) {
>          memcpy(ghptr, hptr, len);
> -       unlock_user(ghptr, gaddr, len);
> +        unlock_user(ghptr, gaddr, len);
>      } else
>          ret = -TARGET_EFAULT;
>
> diff --git a/linux-user/vm86.c b/linux-user/vm86.c
> index 3829b9a677..9c393df424 100644
> --- a/linux-user/vm86.c
> +++ b/linux-user/vm86.c
> @@ -257,7 +257,7 @@ void handle_vm86_trap(CPUX86State *env, int trapno)
>  #define CHECK_IF_IN_TRAP() \
>        if ((ts->vm86plus.vm86plus.flags & TARGET_vm86dbg_active) && \
>            (ts->vm86plus.vm86plus.flags & TARGET_vm86dbg_TFpendig)) \
> -               newflags |= TF_MASK
> +                newflags |= TF_MASK
>
>  #define VM86_FAULT_RETURN \
>          if ((ts->vm86plus.vm86plus.flags & TARGET_force_return_for_pic)
&& \
> diff --git a/nbd/client.c b/nbd/client.c
> index b4d457a19a..69f5e1b7d2 100644
> --- a/nbd/client.c
> +++ b/nbd/client.c
> @@ -1028,7 +1028,7 @@ int nbd_disconnect(int fd)
>
>  #else
>  int nbd_init(int fd, QIOChannelSocket *ioc, NBDExportInfo *info,
> -            Error **errp)
> +             Error **errp)
>  {
>      error_setg(errp, "nbd_init is only supported on Linux");
>      return -ENOTSUP;
> diff --git a/net/checksum.c b/net/checksum.c
> index 4da72a6a6c..273bc9c6bc 100644
> --- a/net/checksum.c
> +++ b/net/checksum.c
> @@ -43,7 +43,7 @@ uint32_t net_checksum_add_cont(int len, uint8_t *buf,
int seq)
>  uint16_t net_checksum_finish(uint32_t sum)
>  {
>      while (sum>>16)
> -       sum = (sum & 0xFFFF)+(sum >> 16);
> +        sum = (sum & 0xFFFF)+(sum >> 16);
>      return ~sum;
>  }
>
> diff --git a/qtest.c b/qtest.c
> index 69b9e9962b..55df6c43db 100644
> --- a/qtest.c
> +++ b/qtest.c
> @@ -290,7 +290,7 @@ static void qtest_process_command(CharBackend *chr,
gchar **words)
>          if (!dev) {
>              qtest_send_prefix(chr);
>              qtest_send(chr, "FAIL Unknown device\n");
> -           return;
> +            return;
>          }
>
>          if (irq_intercept_dev) {
> @@ -300,7 +300,7 @@ static void qtest_process_command(CharBackend *chr,
gchar **words)
>              } else {
>                  qtest_send(chr, "OK\n");
>              }
> -           return;
> +            return;
>          }
>
>          QLIST_FOREACH(ngl, &dev->gpios, node) {
> diff --git a/target/alpha/translate.c b/target/alpha/translate.c
> index e5d62850c5..9d8f9b3eea 100644
> --- a/target/alpha/translate.c
> +++ b/target/alpha/translate.c
> @@ -804,7 +804,7 @@ static void gen_cvttq(DisasContext *ctx, int rb, int
rc, int fn11)
>
>  static void gen_ieee_intcvt(DisasContext *ctx,
>                              void (*helper)(TCGv, TCGv_ptr, TCGv),
> -                           int rb, int rc, int fn11)
> +                            int rb, int rc, int fn11)
>  {
>      TCGv vb, vc;
>
> diff --git a/target/cris/helper.c b/target/cris/helper.c
> index d2ec349191..754fa00d06 100644
> --- a/target/cris/helper.c
> +++ b/target/cris/helper.c
> @@ -240,7 +240,7 @@ void cris_cpu_do_interrupt(CPUState *cs)
>          /* Exception starts with dslot cleared.  */
>          env->dslot = 0;
>      }
> -
> +
>      if (env->pregs[PR_CCS] & U_FLAG) {
>          /* Swap stack pointers.  */
>          env->pregs[PR_USP] = env->regs[R_SP];
> diff --git a/target/cris/mmu.h b/target/cris/mmu.h
> index 8e249e812b..0217f476de 100644
> --- a/target/cris/mmu.h
> +++ b/target/cris/mmu.h
> @@ -5,13 +5,13 @@
>
>  struct cris_mmu_result
>  {
> -       uint32_t phy;
> -       int prot;
> -       int bf_vec;
> +        uint32_t phy;
> +        int prot;
> +        int bf_vec;
>  };
>
>  void cris_mmu_init(CPUCRISState *env);
>  void cris_mmu_flush_pid(CPUCRISState *env, uint32_t pid);
>  int cris_mmu_translate(struct cris_mmu_result *res,
> -                      CPUCRISState *env, uint32_t vaddr,
> -                      int rw, int mmu_idx, int debug);
> +                       CPUCRISState *env, uint32_t vaddr,
> +                       int rw, int mmu_idx, int debug);
> diff --git a/target/cris/translate_v10.inc.c
b/target/cris/translate_v10.inc.c
> index fce78825cc..a87b8bb281 100644
> --- a/target/cris/translate_v10.inc.c
> +++ b/target/cris/translate_v10.inc.c
> @@ -384,7 +384,7 @@ static unsigned int dec10_setclrf(DisasContext *dc)
>  }
>
>  static inline void dec10_reg_prep_sext(DisasContext *dc, int size, int
sext,
> -                                      TCGv dd, TCGv ds, TCGv sd, TCGv ss)
> +                                       TCGv dd, TCGv ds, TCGv sd, TCGv
ss)
>  {
>      if (sext) {
>          t_gen_sext(dd, sd, size);
> diff --git a/target/i386/translate.c b/target/i386/translate.c
> index 0dd5fbe45c..49cd298374 100644
> --- a/target/i386/translate.c
> +++ b/target/i386/translate.c
> @@ -3445,7 +3445,7 @@ static void gen_sse(CPUX86State *env, DisasContext
*s, int b,
>          case 0x172:
>          case 0x173:
>              if (b1 >= 2) {
> -               goto unknown_op;
> +                goto unknown_op;
>              }
>              val = x86_ldub_code(env, s);
>              if (is_xmm) {
> @@ -6400,7 +6400,7 @@ static target_ulong disas_insn(DisasContext *s,
CPUState *cpu)
>                       SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
>          if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
>              gen_io_start();
> -       }
> +        }
>          tcg_gen_movi_i32(s->tmp2_i32, val);
>          gen_helper_in_func(ot, s->T1, s->tmp2_i32);
>          gen_op_mov_reg_v(s, ot, R_EAX, s->T1);
> @@ -6421,7 +6421,7 @@ static target_ulong disas_insn(DisasContext *s,
CPUState *cpu)
>
>          if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
>              gen_io_start();
> -       }
> +        }
>          tcg_gen_movi_i32(s->tmp2_i32, val);
>          tcg_gen_trunc_tl_i32(s->tmp3_i32, s->T1);
>          gen_helper_out_func(ot, s->tmp2_i32, s->tmp3_i32);
> @@ -6439,7 +6439,7 @@ static target_ulong disas_insn(DisasContext *s,
CPUState *cpu)
>                       SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
>          if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
>              gen_io_start();
> -       }
> +        }
>          tcg_gen_trunc_tl_i32(s->tmp2_i32, s->T0);
>          gen_helper_in_func(ot, s->T1, s->tmp2_i32);
>          gen_op_mov_reg_v(s, ot, R_EAX, s->T1);
> @@ -6459,7 +6459,7 @@ static target_ulong disas_insn(DisasContext *s,
CPUState *cpu)
>
>          if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
>              gen_io_start();
> -       }
> +        }
>          tcg_gen_trunc_tl_i32(s->tmp2_i32, s->T0);
>          tcg_gen_trunc_tl_i32(s->tmp3_i32, s->T1);
>          gen_helper_out_func(ot, s->tmp2_i32, s->tmp3_i32);
> @@ -7166,7 +7166,7 @@ static target_ulong disas_insn(DisasContext *s,
CPUState *cpu)
>          gen_jmp_im(s, pc_start - s->cs_base);
>          if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
>              gen_io_start();
> -       }
> +        }
>          gen_helper_rdtsc(cpu_env);
>          if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
>              gen_io_end();
> diff --git a/target/mips/translate.c b/target/mips/translate.c
> index e9c23a594b..b8dcab5307 100644
> --- a/target/mips/translate.c
> +++ b/target/mips/translate.c
> @@ -6942,7 +6942,7 @@ static void gen_mfc0(DisasContext *ctx, TCGv arg,
int reg, int sel)
>              /* Mark as an IO operation because we read the time.  */
>              if (tb_cflags(ctx->base.tb) & CF_USE_ICOUNT) {
>                  gen_io_start();
> -           }
> +            }
>              gen_helper_mfc0_count(arg, cpu_env);
>              if (tb_cflags(ctx->base.tb) & CF_USE_ICOUNT) {
>                  gen_io_end();
> diff --git a/target/tilegx/translate.c b/target/tilegx/translate.c
> index f201150fc7..df1e4d0fef 100644
> --- a/target/tilegx/translate.c
> +++ b/target/tilegx/translate.c
> @@ -297,7 +297,7 @@ static TileExcp gen_st_opcode(DisasContext *dc,
unsigned dest, unsigned srca,
>      }
>
>      tcg_gen_qemu_st_tl(load_gr(dc, srcb), load_gr(dc, srca),
> -                      dc->mmuidx, memop);
> +                       dc->mmuidx, memop);
>
>      qemu_log_mask(CPU_LOG_TB_IN_ASM, "%s %s, %s", name,
>                    reg_names[srca], reg_names[srcb]);
> diff --git a/tcg/i386/tcg-target.inc.c b/tcg/i386/tcg-target.inc.c
> index 436195894b..cdca3fe034 100644
> --- a/tcg/i386/tcg-target.inc.c
> +++ b/tcg/i386/tcg-target.inc.c
> @@ -3424,8 +3424,8 @@ static void tcg_target_qemu_prologue(TCGContext *s)
>      tcg_out_addi(s, TCG_REG_ESP, -stack_addend);
>      /* jmp *tb.  */
>      tcg_out_modrm_offset(s, OPC_GRP5, EXT5_JMPN_Ev, TCG_REG_ESP,
> -                        (ARRAY_SIZE(tcg_target_callee_save_regs) + 2) * 4
> -                        + stack_addend);
> +                         (ARRAY_SIZE(tcg_target_callee_save_regs) + 2) *
4
> +                         + stack_addend);
>  #else
>      tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0,
tcg_target_call_iarg_regs[0]);
>      tcg_out_addi(s, TCG_REG_ESP, -stack_addend);
> diff --git a/tests/tcg/alpha/test-cond.c b/tests/tcg/alpha/test-cond.c
> index e625313b3e..3e11c4c105 100644
> --- a/tests/tcg/alpha/test-cond.c
> +++ b/tests/tcg/alpha/test-cond.c
> @@ -6,7 +6,7 @@
>  int test_##N (long a)                          \
>  {                                              \
>    int res = 1;                                 \
> -                                               \
> +                                                \
>    asm ("cmov"#N" %1,$31,%0"                    \
>         : "+r" (res) : "r" (a));                        \
>    return !res;                                 \
> @@ -18,7 +18,7 @@ int test_##N (long a)                         \
>  int test_##N (long a)                          \
>  {                                              \
>    int res = 1;                                 \
> -                                               \
> +                                                \
>    asm ("b"#N" %1,1f\n\t"                       \
>         "addq $31,$31,%0\n\t"                   \
>         "1: unop\n"                             \
> diff --git a/tests/tcg/arm/hello-arm.c b/tests/tcg/arm/hello-arm.c
> index 6e5a93bccf..e33edf949f 100644
> --- a/tests/tcg/arm/hello-arm.c
> +++ b/tests/tcg/arm/hello-arm.c
> @@ -11,7 +11,7 @@
>
>  #define __syscall_return(type, res)                                    \
>  do {                                                                   \
> -       return (type) (res);                                            \
> +        return (type) (res);                                           \
>  } while (0)
>
>  #define _syscall0(type,name)                                           \
> @@ -33,7 +33,7 @@ type name(type1 arg1) {
                       \
>    "mov %0,r0"                                                          \
>          : "=r" (__res)                                                 \
>          : "r" ((long)(arg1))                                           \
> -       : "r0","lr");                                                   \
> +        : "r0","lr");                                                  \
>    __syscall_return(type,__res);
      \
>  }
>
> @@ -47,7 +47,7 @@ type name(type1 arg1,type2 arg2) {
              \
>    "mov\t%0,r0"                                                         \
>          : "=r" (__res)                                                 \
>          : "r" ((long)(arg1)),"r" ((long)(arg2))
      \
> -       : "r0","r1","lr");                                              \
> +        : "r0","r1","lr");                                             \
>    __syscall_return(type,__res);
      \
>  }
>
> @@ -78,9 +78,9 @@ type name(type1 arg1, type2 arg2, type3 arg3, type4
arg4) {                           \
>    "mov\tr3,%4\n\t"
               \
>    __syscall(name)
              \
>    "mov\t%0,r0"
               \
> -       : "=r" (__res)
              \
> -       : "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r"
((long)(arg4))   \
> -       : "r0","r1","r2","r3","lr");
              \
> +        : "=r" (__res)
               \
> +        : "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r"
((long)(arg4))  \
> +        : "r0","r1","r2","r3","lr");
               \
>    __syscall_return(type,__res);
                      \
>  }
>
> @@ -96,10 +96,10 @@ type name(type1 arg1, type2 arg2, type3 arg3, type4
arg4, type5 arg5) {                     \
>    "mov\tr4,%5\n\t"
               \
>    __syscall(name)
              \
>    "mov\t%0,r0"
               \
> -       : "=r" (__res)
              \
> -       : "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r"
((long)(arg4)),  \
> -         "r" ((long)(arg5))
              \
> -       : "r0","r1","r2","r3","r4","lr");
               \
> +        : "=r" (__res)
               \
> +        : "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r"
((long)(arg4)), \
> +          "r" ((long)(arg5))
               \
> +        : "r0","r1","r2","r3","r4","lr");
              \
>    __syscall_return(type,__res);
                      \
>  }
>
> diff --git a/tests/tcg/cris/check_glibc_kernelversion.c
b/tests/tcg/cris/check_glibc_kernelversion.c
> index 07448722c0..7aada89911 100644
> --- a/tests/tcg/cris/check_glibc_kernelversion.c
> +++ b/tests/tcg/cris/check_glibc_kernelversion.c
> @@ -109,8 +109,8 @@ int main(void)
>
>          if (parts < 3)
>            version <<= 8 * (3 - parts);
> -       if (version < __LINUX_KERNEL_VERSION)
> -               err();
> -       pass();
> -       exit(0);
> +        if (version < __LINUX_KERNEL_VERSION)
> +                err();
> +        pass();
> +        exit(0);
>  }
> diff --git a/tests/tcg/cris/check_mmap3.c b/tests/tcg/cris/check_mmap3.c
> index 34401fa0c9..cb890ef120 100644
> --- a/tests/tcg/cris/check_mmap3.c
> +++ b/tests/tcg/cris/check_mmap3.c
> @@ -17,7 +17,7 @@ int main (int argc, char *argv[])
>
>    /* Check that we can map a non-multiple of a page and still get a full
page.  */
>    a = mmap (NULL, 0x4c, PROT_READ | PROT_WRITE | PROT_EXEC,
> -           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
> +            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
>    if (a == NULL || a == (unsigned char *) -1)
>      abort ();
>
> diff --git a/tests/tcg/cris/check_openpf1.c
b/tests/tcg/cris/check_openpf1.c
> index fdcf4c5c3f..251d26eec2 100644
> --- a/tests/tcg/cris/check_openpf1.c
> +++ b/tests/tcg/cris/check_openpf1.c
> @@ -19,7 +19,7 @@ int main (int argc, char *argv[])
>      {
>        fnam = malloc (strlen (argv[0]) + 2);
>        if (fnam == NULL)
> -       abort ();
> +        abort ();
>        strcpy (fnam, "/");
>        strcat (fnam, argv[0]);
>      }
> diff --git a/tests/tcg/cris/check_settls1.c
b/tests/tcg/cris/check_settls1.c
> index 69d202652a..3abc3a9ea8 100644
> --- a/tests/tcg/cris/check_settls1.c
> +++ b/tests/tcg/cris/check_settls1.c
> @@ -35,7 +35,7 @@ int main (void)
>      syscall (SYS_set_thread_area, old_tp);
>
>      if (tp != 0xeddeed00) {
> -       * (volatile int *) 0 = 0;
> +        * (volatile int *) 0 = 0;
>          perror ("tls2");
>          abort ();
>      }
> diff --git a/tests/tcg/i386/hello-i386.c b/tests/tcg/i386/hello-i386.c
> index cfeb24b2f5..59196dd0b7 100644
> --- a/tests/tcg/i386/hello-i386.c
> +++ b/tests/tcg/i386/hello-i386.c
> @@ -4,19 +4,19 @@ static inline void exit(int status)
>  {
>    int __res;
>    __asm__ volatile ("movl %%ecx,%%ebx\n"\
> -                   "int $0x80" \
> -                   :  "=a" (__res) : "0" (__NR_exit),"c"
((long)(status)));
> +                    "int $0x80" \
> +                    :  "=a" (__res) : "0" (__NR_exit),"c"
((long)(status)));
>  }
>
>  static inline int write(int fd, const char * buf, int len)
>  {
>    int status;
>    __asm__ volatile ("pushl %%ebx\n"\
> -                   "movl %%esi,%%ebx\n"\
> -                   "int $0x80\n" \
> -                   "popl %%ebx\n"\
> -                   : "=a" (status) \
> -                   : "0" (__NR_write),"S" ((long)(fd)),"c"
((long)(buf)),"d" ((long)(len)));
> +                    "movl %%esi,%%ebx\n"\
> +                    "int $0x80\n" \
> +                    "popl %%ebx\n"\
> +                    : "=a" (status) \
> +                    : "0" (__NR_write),"S" ((long)(fd)),"c"
((long)(buf)),"d" ((long)(len)));
>    return status;
>  }
>
> diff --git a/tests/tcg/mips/hello-mips.c b/tests/tcg/mips/hello-mips.c
> index f8256730dd..c7052fdf2e 100644
> --- a/tests/tcg/mips/hello-mips.c
> +++ b/tests/tcg/mips/hello-mips.c
> @@ -24,9 +24,9 @@ static inline void exit1(int status)
>          "      syscall         \n"
>          "      .set pop        "
>          :
> -       : "i" (__NR_exit), "r" (__a0)
> -       : "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15",
"$24",
> -         "memory");
> +        : "i" (__NR_exit), "r" (__a0)
> +        : "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15",
"$24",
> +          "memory");
>  }
>
>  static inline int write(int fd, const char *buf, int len)
> @@ -46,8 +46,8 @@ static inline int write(int fd, const char *buf, int
len)
>          "      .set pop        "
>          : "=r" (__v0), "=r" (__a3)
>          : "i" (__NR_write), "r" (__a0), "r" (__a1), "r" (__a2)
> -       : "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15",
"$24",
> -         "memory");
> +        : "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15",
"$24",
> +          "memory");
>
>  /*    if (__a3 == 0) */
>          return (int) __v0;
> diff --git a/tests/tcg/multiarch/sha1.c b/tests/tcg/multiarch/sha1.c
> index 93b7c8e808..87bfbcdf52 100644
> --- a/tests/tcg/multiarch/sha1.c
> +++ b/tests/tcg/multiarch/sha1.c
> @@ -152,7 +152,7 @@ uint32_t j;
>
>      j = context->count[0];
>      if ((context->count[0] += len << 3) < j)
> -       context->count[1]++;
> +        context->count[1]++;
>      context->count[1] += (len>>29);
>      j = (j >> 3) & 63;
>      if ((j + len) > 63) {
> @@ -186,11 +186,11 @@ unsigned char c;
>
>      for (i = 0; i < 2; i++)
>      {
> -       uint32_t t = context->count[i];
> -       int j;
> +        uint32_t t = context->count[i];
> +        int j;
>
> -       for (j = 0; j < 4; t >>= 8, j++)
> -           *--fcp = (unsigned char) t;
> +        for (j = 0; j < 4; t >>= 8, j++)
> +            *--fcp = (unsigned char) t;
>      }
>  #else
>      for (i = 0; i < 8; i++) {
> @@ -201,7 +201,7 @@ unsigned char c;
>      c = 0200;
>      SHA1Update(context, &c, 1);
>      while ((context->count[0] & 504) != 448) {
> -       c = 0000;
> +        c = 0000;
>          SHA1Update(context, &c, 1);
>      }
>      SHA1Update(context, finalcount, 8);  /* Should cause a
SHA1Transform() */
> diff --git a/tests/vhost-user-test.c b/tests/vhost-user-test.c
> index 9d7b0d48a0..4e43d6b96e 100644
> --- a/tests/vhost-user-test.c
> +++ b/tests/vhost-user-test.c
> @@ -369,8 +369,8 @@ static void chr_read(void *opaque, const uint8_t
*buf, int size)
>          break;
>
>      case VHOST_USER_SET_FEATURES:
> -       g_assert_cmpint(msg.payload.u64 & (0x1ULL <<
VHOST_USER_F_PROTOCOL_FEATURES),
> -                       !=, 0ULL);
> +        g_assert_cmpint(msg.payload.u64 & (0x1ULL <<
VHOST_USER_F_PROTOCOL_FEATURES),
> +                        !=, 0ULL);
>          if (s->test_flags == TEST_FLAGS_DISCONNECT) {
>              qemu_chr_fe_disconnect(chr);
>              s->test_flags = TEST_FLAGS_BAD;
> diff --git a/ui/keymaps.h b/ui/keymaps.h
> index 98213a4191..4e9c87fb8f 100644
> --- a/ui/keymaps.h
> +++ b/ui/keymaps.h
> @@ -28,8 +28,8 @@
>  #include "qemu-common.h"
>
>  typedef struct {
> -       const char* name;
> -       int keysym;
> +    const char* name;
> +    int keysym;
>  } name2keysym_t;
>
>  /* scancode without modifiers */
> diff --git a/ui/qemu-pixman.c b/ui/qemu-pixman.c
> index 3e52abd92d..1429cf08d5 100644
> --- a/ui/qemu-pixman.c
> +++ b/ui/qemu-pixman.c
> @@ -36,7 +36,7 @@ PixelFormat
qemu_pixelformat_from_pixman(pixman_format_code_t format)
>          pf.rshift = 0;
>          break;
>      case PIXMAN_TYPE_BGRA:
> -       pf.bshift = bpp - pf.bbits;
> +        pf.bshift = bpp - pf.bbits;
>          pf.gshift = bpp - (pf.bbits + pf.gbits);
>          pf.rshift = bpp - (pf.bbits + pf.gbits + pf.rbits);
>          pf.ashift = 0;
> diff --git a/ui/vnc-enc-zywrle-template.c b/ui/vnc-enc-zywrle-template.c
> index b446380a7a..e9be55966e 100644
> --- a/ui/vnc-enc-zywrle-template.c
> +++ b/ui/vnc-enc-zywrle-template.c
> @@ -44,8 +44,8 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
>
>  /* Change Log:
>       V0.02 : 2008/02/04 : Fix mis encode/decode when width != scanline
> -                            (Thanks Johannes Schindelin, author of LibVNC
> -                                                 Server/Client)
> +                             (Thanks Johannes Schindelin, author of
LibVNC
> +                                                  Server/Client)
>       V0.01 : 2007/02/06 : Initial release
>  */
>
> diff --git a/ui/vnc.c b/ui/vnc.c
> index 0c1b477425..9e4b2beb71 100644
> --- a/ui/vnc.c
> +++ b/ui/vnc.c
> @@ -3097,8 +3097,8 @@ static void vnc_connect(VncDisplay *vd,
QIOChannelSocket *sioc,
>      buffer_init(&vs->zrle.zlib,      "vnc-zrle-zlib/%p", sioc);
>
>      if (skipauth) {
> -       vs->auth = VNC_AUTH_NONE;
> -       vs->subauth = VNC_AUTH_INVALID;
> +        vs->auth = VNC_AUTH_NONE;
> +        vs->subauth = VNC_AUTH_INVALID;
>      } else {
>          if (websocket) {
>              vs->auth = vd->ws_auth;
> diff --git a/util/bitops.c b/util/bitops.c
> index f2364015c4..3fe6b1c4f1 100644
> --- a/util/bitops.c
> +++ b/util/bitops.c
> @@ -18,7 +18,7 @@
>   * Find the next set bit in a memory region.
>   */
>  unsigned long find_next_bit(const unsigned long *addr, unsigned long
size,
> -                           unsigned long offset)
> +                            unsigned long offset)
>  {
>      const unsigned long *p = addr + BIT_WORD(offset);
>      unsigned long result = offset & ~(BITS_PER_LONG-1);
> @@ -83,7 +83,7 @@ found_middle:
>   * Linus' asm-alpha/bitops.h.
>   */
>  unsigned long find_next_zero_bit(const unsigned long *addr, unsigned
long size,
> -                                unsigned long offset)
> +                                 unsigned long offset)
>  {
>      const unsigned long *p = addr + BIT_WORD(offset);
>      unsigned long result = offset & ~(BITS_PER_LONG-1);
> diff --git a/util/osdep.c b/util/osdep.c
> index 1c8d1e2ee0..4b5dc7287d 100644
> --- a/util/osdep.c
> +++ b/util/osdep.c
> @@ -470,8 +470,8 @@ void fips_set_state(bool requested)
>
>  #ifdef _FIPS_DEBUG
>      fprintf(stderr, "FIPS mode %s (requested %s)\n",
> -           (fips_enabled ? "enabled" : "disabled"),
> -           (requested ? "enabled" : "disabled"));
> +            (fips_enabled ? "enabled" : "disabled"),
> +            (requested ? "enabled" : "disabled"));
>  #endif
>  }
>
> diff --git a/util/qemu-sockets.c b/util/qemu-sockets.c
> index 8bd8bb64eb..9705051690 100644
> --- a/util/qemu-sockets.c
> +++ b/util/qemu-sockets.c
> @@ -270,8 +270,8 @@ static int inet_listen_saddr(InetSocketAddress *saddr,
>      /* create socket + bind/listen */
>      for (e = res; e != NULL; e = e->ai_next) {
>          getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,
> -                       uaddr,INET6_ADDRSTRLEN,uport,32,
> -                       NI_NUMERICHOST | NI_NUMERICSERV);
> +                        uaddr,INET6_ADDRSTRLEN,uport,32,
> +                        NI_NUMERICHOST | NI_NUMERICSERV);
>
>          port_min = inet_getport(e);
>          port_max = saddr->has_to ? saddr->to + port_offset : port_min;
> --
> 2.19.2
>
>
