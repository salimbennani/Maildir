Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  12 Dec 2018 09:20:18 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 0CC615803DC;
	Tue, 11 Dec 2018 17:20:30 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by orsmga007-1.jf.intel.com with ESMTP; 11 Dec 2018 17:20:29 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AbvkOqxJjf22gM20n9tmcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgULfz6rarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0vRz+s87lkRwPpiC?=
 =?us-ascii?q?cfNj427mfXitBrjKlGpB6tvgFzz5LIbI2QMvd1Y6HTcs4ARWdZXshfSTFPAp+y?=
 =?us-ascii?q?YYUMAeoOP+dYoJXyqVQBthu+HQuhCfjzyj9RmnP6wbE23/g/HQzAwQcuH8gOsH?=
 =?us-ascii?q?PRrNjtM6kSUPy6zKnSwjrda/NdxDLz55bMchAlv/6NXa97fM3UyUkuFAPKkFGQ?=
 =?us-ascii?q?qYj7MDKVzekNtmmb4PZ6VeKokG4nrA9xoiS1ysgwjYnJg5sYx1bZ/it3x4Y1IM?=
 =?us-ascii?q?e3SE99YdO8FZtQtj2VN5FxQsM5RGFotjo6xqcatp68ZCQKzJcnxxvba/CddIiI?=
 =?us-ascii?q?+B3jWP6eLDtkgXJlea6whwy18Ui7ze38WNW03ExWoSpCl9nArncN1wHP6siDTf?=
 =?us-ascii?q?t9+USh1SyT2ADU7+FIOUU0lavHJJ47xb4wjZ0TsUrfHiPshEr2i6qWe0M58ear?=
 =?us-ascii?q?8+TqeqvqqoOYOoNulw3zPLoiltaiDek7LgQCRWmW9Oak2LH98kD1WqtGguMsnq?=
 =?us-ascii?q?XEsZ3XJ94XqrO9DgJXyooj5QiwAjS63NkdmHQHIlJIdRaFgoXsJV7CPOz0Au26?=
 =?us-ascii?q?jlmskzpmyOvJM7jvAprQLXXMjLHsdqtn5UFG0go819Vf6opUCr4fJPLzXVf8tM?=
 =?us-ascii?q?LXDhAnKQy42eXnB8tn1oMYR22PBrWVMKTIsV+H/u4vIu+Ma5EJuDvlNfQp+/rj?=
 =?us-ascii?q?gWUklVITY6Wlx4YbZXOkEvh8IkiUY2LggtIbHmcLugo+QvbqiFqHUTNLY3ayXq?=
 =?us-ascii?q?Q85iw0CY6/DofMWJqtgLqf0ye/B5FWYW5HClaSHnfybIiERfgMZzyIIsN7kTwL?=
 =?us-ascii?q?S6KhS4k/2hGqrgP6zKBnLuXM9i0CqZ3jzMR15/HUlRwq8Tx0Dsed3H+XQ2B7g2?=
 =?us-ascii?q?MFXDs23KF5oUxgxVaPy6l4g/pEFdNN4/NFSBs1NZnZz+ZiEdD9RhrBfsuVSFah?=
 =?us-ascii?q?WtimASs+TtMtw9AUZEZxAdWijg3Z0CqsDL8YjLiLBJ0y8qLB0Hn9Pcd9y3Da1K?=
 =?us-ascii?q?Y/i1kqWNdANWqjhqRn7QjcG5bJk1mFl6atbakc3inN+3mZwWqNu0FYVghwUaLe?=
 =?us-ascii?q?UHAbZ0vWq8n550zYQ7+vD7QnLhVOycqYJqRWbd3piE1MRO3/N9TGf2Kxh2CwCA?=
 =?us-ascii?q?6SybOXbIrqfGYd0D/HCEcekQAe5nKGNQk4Bie8rGPSFj1uFVTzY0zy9elysm+0?=
 =?us-ascii?q?TkgxzwuSdU1uy6K1+gIJhfybU/4T3agLuCE7pzVwHVayxdTWC9WbqgplfaVcZ8?=
 =?us-ascii?q?494Vhd2WLYsQx9IoKvL6R4ilECdAR3ulvk1w9rBYVYjcgqsHQqwRJvJq2CzlNO?=
 =?us-ascii?q?aSmU3ZDqNb3RMWn94havZ6nS2lHd1daW/rwC6PA5q1XloQGoGVAu83Rh09lJzX?=
 =?us-ascii?q?Sc4o/GAxYVUZL0Skw37QR1p6nGYikh4IPZzWBjPrOqsjDcwd4pBPEqyhC7f9hB?=
 =?us-ascii?q?NqOJDwvyE8wcB8izJ+0mgVmpbhQYPO9M8K44Jd+pd/yD2KSzJuZvgCqmjXhb4I?=
 =?us-ascii?q?B6yk+M6yt8SuvP35YZw/GZ3hGLVyvmgFemqMD3nYFEZTcdHmekzSjkBYhRZrB9?=
 =?us-ascii?q?fIoRCGeuJdG3yct6h5L3R3FY81ujDUsc2MC1YRqSc0D93QpI2EsNpXyohyS5wC?=
 =?us-ascii?q?J0kj0ztaWfwTHBzP7kdBoEPW5LWnJvjVPtIYiyktAbU1KkbwkvlBu5+0n6w7JX?=
 =?us-ascii?q?q7h4L2nWWU1IZTT5L3l+UqussbqPe85O6I4yvSpLSui9YFCaRaT7oxsVyC7jG2?=
 =?us-ascii?q?pexDYmdzCloJn5nhp6iH6DI3Z3tnbWZcZwxRLH7tzGWfFRxiYGRDV/iTTPHFi8?=
 =?us-ascii?q?PsWm8s+Ol5jeteCyTWShWYNJcSnq1I+PqDG05Wl3DhKhhfCzndvnHBM+0S/60d?=
 =?us-ascii?q?lqSCrJoAz9Yonty6S1L+ZnclN0C1/77spwApt+nZcohJEMxXgagY2Y/HoGkWvp?=
 =?us-ascii?q?MdRXw7n+bGcLRTMQx97V4Q7l2FBsL36TxoL5UGmdzdVlZ9WgfmwW3Sc95dhQCK?=
 =?us-ascii?q?iI9LxEgTd1ol2goALTe/d9hDQdyfgp6HIAmOEGogktziacArAUA0ZYOzfhlxCJ?=
 =?us-ascii?q?79C4saVWa3yjcbm21Epig9+hCKuOrR1bWHb8Yp0iBzN/7t1jMFLQ133+8oHld8?=
 =?us-ascii?q?PXbd4JtB2UkhHAgvNRKJIwkPoKmCVmNXj8vX0j1+40kxhu0Yums4iALmVn5Li5?=
 =?us-ascii?q?DQJANj3pe8MT/SngjaVEkcaXxYyvHohhFS8NXJvnVv+oFDMStfL6NweBCjE8q3?=
 =?us-ascii?q?GbGabBEg+b8ktps3XPE5WzPXGNOHYZ1cliRAWaJEFHhQAUXTY6kYQjGgGk2sPh?=
 =?us-ascii?q?a1t56S4L5lHjtBRM0O1oOgL7Umfeogeodzg1RIKeLBpQ8gFN+UPVPdaC4eJ0Gi?=
 =?us-ascii?q?FS5oehoxCVKmyHewRICnkEWlCDB1DmJLWv5MPP8+6FBuqlNPvOYK6DqehfV/eO?=
 =?us-ascii?q?2JKu3ZFq/zeKNsWTIHZiC+c31VZEXXB8A87ZgSkASzQLlyLRaM6WvAyz9Tdwrs?=
 =?us-ascii?q?C77fTnQgbv5ZaUBrtWMNVv/Q22gKiZO+6RgiZ5NShX1pcWyXDUz7gf2UYYizty?=
 =?us-ascii?q?eDm1DbQAqSnNQbrSmqBNCh4UdThzONFU764m3QlNJM3bis7z1rFilf44EFNFVV?=
 =?us-ascii?q?3nmsG0as0GOWC9NFXbBEmVMLSKPyHEw8byYamkU71fkP1UtwGsuTacC0LiPjOD?=
 =?us-ascii?q?lyTwVxCyK+5MijuXPAdZuIG7fRZgEmzjTNPgah2mP957lzw2wbsohnzUMW4QKy?=
 =?us-ascii?q?Rzc0RIrreI9yNXnu1/G3Bd7npiNeSEmziW7+jbKpYVsPtnGCd0l/hd4HQ11bRV?=
 =?us-ascii?q?9jxEROdulSvWr95upUymk+aVxjpmVhpOtihEhIaRsUp+PqXZ84FKWWzY8xIV8W?=
 =?us-ascii?q?WQFxMKqsN/Bd3yoK9Q0MbAlaLpJDdG8tLZ5s8cB8nSKMKaP3stKxvpGDjIDAQb?=
 =?us-ascii?q?ST6nL33Qh0tYkPuK7H2asoA6qoTwmJoJUrJbSF01FvYABkt5BtANPJd3US0ikb?=
 =?us-ascii?q?OAiM4I5Hy+rATeRclAv5DHUO6SDuvrKDqDkbZEYB4Iy6viLYsPLo37x1Bial5i?=
 =?us-ascii?q?kYXKAUXQW9VNoixnbgAsoURN8GJxTms820/+bgOt4XkTFeO7nxIsiwt+Z/gt+y?=
 =?us-ascii?q?no41stOlXKoy4wwwENnoDagDSVOBL8Jay3W8kCFCvwsw49P5rwRABdZBe320dj?=
 =?us-ascii?q?MWGAD5Fgx4B6dGZqlgbHsJ0HTf1NVoVBYRQKwuqQaelu2lNZ/HaJ30hCsM7EAp?=
 =?us-ascii?q?trmQ9iUpOoq39Rk1Zmbd04IajdNYJMz1NKgbmJsDPu3ec0llxNb30R+X+fLXZb?=
 =?us-ascii?q?8HcDMaMrcm/xprRh?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAACKYRBch0O0hNFlGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwGBMFBpcwQLJwqHOAOET4tISoINFGiWVhSBYw8BGA0?=
 =?us-ascii?q?GAYEFRheFTCI0CQ0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmEBAQEBAgEBA?=
 =?us-ascii?q?g4JAQwTBgEBNwEFCQEBAQEIEgMBIBADLxcOAgQBDQUFA4MUBAEBgWkDDQgBAgI?=
 =?us-ascii?q?KkzwBh0cCigYBAQGBajOCdgEBBYEwARNAgwYDgh4IgnaJRReBQD+BEUaBTkk1g?=
 =?us-ascii?q?wUZAQMYgQwIARIBg1SCBCKJKwYaHoFEhWKEaYo/RgmHCYM8hySBXE2ESoMphyS?=
 =?us-ascii?q?JI4EFg26KdgIEAgQFAg0BAQWBRkVYcTMTBwgbFRqDDQkWgXwMF4NEBoUUhT9BM?=
 =?us-ascii?q?QEBAQGBAQEBIYgFgR8BMW0BAQ?=
X-IPAS-Result: =?us-ascii?q?A0ABAACKYRBch0O0hNFlGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwGBMFBpcwQLJwqHOAOET4tISoINFGiWVhSBYw8BGA0GAYEFRheFTCI0C?=
 =?us-ascii?q?Q0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmEBAQEBAgEBAg4JAQwTBgEBNwE?=
 =?us-ascii?q?FCQEBAQEIEgMBIBADLxcOAgQBDQUFA4MUBAEBgWkDDQgBAgIKkzwBh0cCigYBA?=
 =?us-ascii?q?QGBajOCdgEBBYEwARNAgwYDgh4IgnaJRReBQD+BEUaBTkk1gwUZAQMYgQwIARI?=
 =?us-ascii?q?Bg1SCBCKJKwYaHoFEhWKEaYo/RgmHCYM8hySBXE2ESoMphySJI4EFg26KdgIEA?=
 =?us-ascii?q?gQFAg0BAQWBRkVYcTMTBwgbFRqDDQkWgXwMF4NEBoUUhT9BMQEBAQGBAQEBIYg?=
 =?us-ascii?q?FgR8BMW0BAQ?=
X-IronPort-AV: E=Sophos;i="5.56,343,1539673200"; 
   d="scan'208";a="43685782"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 11 Dec 2018 17:20:27 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726285AbeLLBUX (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Tue, 11 Dec 2018 20:20:23 -0500
Received: from mail-eopbgr790137.outbound.protection.outlook.com ([40.107.79.137]:10524
        "EHLO NAM03-CO1-obe.outbound.protection.outlook.com"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1726259AbeLLBUW (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 11 Dec 2018 20:20:22 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=pFWz7/xv6ixsqX7DeGswA6hrKhCAHfxrgnkW7n/nYeo=;
 b=ZHkBOKSSdgmr5RkB5Zg4+L7ImteLVwqCdAoW2kB0t9tGOYqkeUdEjA2IF+oJBt/0+ySEqtc6eKKsF5gtPo4CZwI70IiiouVOIjSXhcgWA6AudnLcYhpSzOJLAUp0Q3iA9YhdyJ/9omHBq1Q8GGYb/oT4zpgDoO8/k6Qy3esq1+8=
Received: from CY4PR21MB0773.namprd21.prod.outlook.com (10.173.192.19) by
 CY4PR21MB0773.namprd21.prod.outlook.com (10.173.192.19) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1446.4; Wed, 12 Dec 2018 01:19:59 +0000
Received: from CY4PR21MB0773.namprd21.prod.outlook.com
 ([fe80::f597:e00a:584b:fd8c]) by CY4PR21MB0773.namprd21.prod.outlook.com
 ([fe80::f597:e00a:584b:fd8c%2]) with mapi id 15.20.1446.006; Wed, 12 Dec 2018
 01:19:59 +0000
From: Michael Kelley <mikelley@microsoft.com>
To: Will Deacon <will.deacon@arm.com>,
        KY Srinivasan <kys@microsoft.com>
CC: "catalin.marinas@arm.com" <catalin.marinas@arm.com>,
        "mark.rutland@arm.com" <mark.rutland@arm.com>,
        "marc.zyngier@arm.com" <marc.zyngier@arm.com>,
        "linux-arm-kernel@lists.infradead.org" 
        <linux-arm-kernel@lists.infradead.org>,
        "gregkh@linuxfoundation.org" <gregkh@linuxfoundation.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
        "devel@linuxdriverproject.org" <devel@linuxdriverproject.org>,
        "olaf@aepfle.de" <olaf@aepfle.de>,
        "apw@canonical.com" <apw@canonical.com>,
        "jasowang@redhat.com" <jasowang@redhat.com>,
        Stephen Hemminger <sthemmin@microsoft.com>,
        vkuznets <vkuznets@redhat.com>
Subject: RE: [PATCH 1/4] arm64: hyperv: Add core Hyper-V include files
Thread-Topic: [PATCH 1/4] arm64: hyperv: Add core Hyper-V include files
Thread-Index: AQHUghEmNHlyvlewGkO1i9U/zSLkoqVzYUmAgAb189A=
Date: Wed, 12 Dec 2018 01:19:59 +0000
Message-ID: <CY4PR21MB0773FAA7E902ADC72AE13CD6D7A70@CY4PR21MB0773.namprd21.prod.outlook.com>
References: <20181122030914.16274-1-kys@linuxonhyperv.com>
 <20181122031059.16338-1-kys@linuxonhyperv.com>
 <20181207134234.GB29076@arm.com>
In-Reply-To: <20181207134234.GB29076@arm.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
msip_labels: MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_Enabled=True;
 MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_SiteId=72f988bf-86f1-41af-91ab-2d7cd011db47;
 MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_Owner=mikelley@ntdev.microsoft.com;
 MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_SetDate=2018-12-12T01:19:56.4912599Z;
 MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_Name=General;
 MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_Application=Microsoft Azure
 Information Protection;
 MSIP_Label_f42aa342-8706-4288-bd11-ebb85995028c_Extended_MSFT_Method=Automatic;
 Sensitivity=General
x-originating-ip: [24.22.167.197]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1;CY4PR21MB0773;6:9jCK9IHQmOS4PbRNyO92a0olOk2J/bZOY+oOzNv0ne0kLEbUUEILHQBwW6pUSUy3rjvHxcK0/gv5ULwcK6bnYt77Je1HkQUCKmCXc5xRRglq8py9bZK/kBYxvn59xJjm45T7vcHvIR3Pd3S8VJunr0grxY/eRd6suoO26lpaIZWxECF40UUHEooUzqsoURwzBplAqhwYUPDIRYrxWkp6yOWIWZiOPWSPHclQ4nZA53sgxxB7b1WJAJjw0soSX2P97guMLv+DS4gYpLeI62k82EmZa+hQHLnwDDQDtL/DKS9+QTBtCgCX3/7AUY9xPQ9Zi2pSWpa3mem+M6CN6bRtKUKOZshcmyncn9KBj7SGqrzR0BiOzXZLWdAEbQDVSj+j8wTiHPOlgoQfB0JTsKRNeK4bK9/9Ci9Mz4EMNAG3u2rLFNaDVDl4+t8R23qnAkFXmam4qQoCGUZT5awu0+ejIQ==;5:pppDqE4X7l/mdho0Ct9+Zz2FsPcDePzzoQdTtxcJmZmHlcJmhtlwPWxg5nD3aB7ppb5PkgtDYZDCd//zrvArFDZmPuImqCTgW90XpbUPseTj44bqqJhYa/KjqlrKgH9C5KYwSK+/XloV/LQnhcM/4yqwBW/I/8jODe4hVd4Gu74=;7:fQqflx+8IOXNnWQa0Dgjs5duqcXf+M9ASToITFlVrD+1iv8NE8i0uC2JtIQVW4qYmIJ+VcSNrKoN8Abm5XWSqbLx2QRCRtkT4BNrmc9ixFmm2uNkyQs/GGxL9ZGm4UD2LxKjwJlAhnp7OX0FSO8mqw==
x-ms-office365-filtering-correlation-id: 5e05b72f-3607-48f4-8724-08d65fcfef5b
x-ms-office365-filtering-ht: Tenant
x-microsoft-antispam: BCL:0;PCL:0;RULEID:(2390098)(7020095)(4652040)(8989299)(5600074)(711020)(4618075)(4534185)(4627221)(201703031133081)(201702281549075)(8990200)(2017052603328)(7193020);SRVR:CY4PR21MB0773;
x-ms-traffictypediagnostic: CY4PR21MB0773:
x-ms-exchange-purlcount: 3
authentication-results: spf=none (sender IP is )
 smtp.mailfrom=mikelley@microsoft.com; 
x-ld-processed: 72f988bf-86f1-41af-91ab-2d7cd011db47,ExtAddr
x-microsoft-antispam-prvs: <CY4PR21MB0773C524E5B3B5D781C46C6CD7A70@CY4PR21MB0773.namprd21.prod.outlook.com>
x-ms-exchange-senderadcheck: 1
x-exchange-antispam-report-cfa-test: BCL:0;PCL:0;RULEID:(8211001083)(3230017)(999002)(6040522)(8220035)(2401047)(8121501046)(5005006)(3231472)(944501520)(2018427008)(93006095)(93001095)(10201501046)(3002001)(6055026)(148016)(149066)(150057)(6041310)(20161123560045)(20161123562045)(20161123558120)(20161123564045)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(201708071742011)(7699051)(76991095);SRVR:CY4PR21MB0773;BCL:0;PCL:0;RULEID:;SRVR:CY4PR21MB0773;
x-forefront-prvs: 0884AAA693
x-forefront-antispam-report: SFV:NSPM;SFS:(10019020)(396003)(39860400002)(376002)(346002)(136003)(366004)(51914003)(199004)(189003)(8676002)(81166006)(81156014)(8936002)(6436002)(966005)(478600001)(86612001)(10290500003)(26005)(6246003)(68736007)(486006)(71200400001)(54906003)(102836004)(476003)(186003)(575784001)(86362001)(6506007)(7696005)(76176011)(11346002)(446003)(4326008)(99286004)(71190400001)(22452003)(316002)(110136005)(4744004)(14454004)(97736004)(105586002)(9686003)(53946003)(6306002)(106356001)(7736002)(7416002)(33656002)(3846002)(5660300001)(256004)(55016002)(14444005)(74316002)(305945005)(6116002)(53936002)(1511001)(66066001)(25786009)(8990500004)(10090500001)(229853002)(2906002)(6636002)(2004002)(579004)(559001)(569006);DIR:OUT;SFP:1102;SCL:1;SRVR:CY4PR21MB0773;H:CY4PR21MB0773.namprd21.prod.outlook.com;FPR:;SPF:None;LANG:en;PTR:InfoNoRecords;A:1;MX:1;
x-microsoft-antispam-message-info: /sfhvjnboim/Vzb3g7r4AGs8gqxaHSwMPnbmhO2k/i1y1KiFO9g84xgIaj4R+JPDEVMGYaMYBvKzhYSp4ZgggRUl8DOGxPYuXYSdfJLPBRmBqsRITqZxgEtCyRh9NrngwbUpctaHoWCm1/tgoPtLHIq1bnUJmPAzwW/02srFMgx606XeX7ZS/4Ew25C0PPdvGTCqvvXl4QK6TlFTuS02DcFB1J6D2LWbZ4e9R+6VNQK4iod9ZOjtDnVIj3E0Kk7+5BdFbGWpMQ3njL58bObcfJuyv28EaiApV+36FdgEf+VON3lOVLU3N9XLZSPCIOSb
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-OriginatorOrg: microsoft.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 5e05b72f-3607-48f4-8724-08d65fcfef5b
X-MS-Exchange-CrossTenant-originalarrivaltime: 12 Dec 2018 01:19:59.6704
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 72f988bf-86f1-41af-91ab-2d7cd011db47
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY4PR21MB0773
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: Will Deacon <will.deacon@arm.com> Sent: Friday, December 7, 2018 5:43=
 AM

> > hyperv-tlfs.h defines Hyper-V interfaces from the Hyper-V Top Level
> > Functional Spec (TLFS). The TLFS is distinctly oriented to x86/x64,
> > and Hyper-V has not separated out the architecture-dependent parts into
> > x86/x64 vs. ARM64. So hyperv-tlfs.h includes information for ARM64
> > that is not yet formally published. The TLFS is available here:
>=20
> When do you plan to publish the spec? It's pretty hard to review this stu=
ff
> without knowing what it's supposed to look like.

I don't have a commitment from the Hyper-V team on when an updated TLFS
that covers ARM64 will be published.  I'm on the Linux side, and Hyper-V is=
 a
separate group, but I'll raise the topic again with them.

>=20
> >   docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/=
tlfs
> >
> > mshyperv.h defines Linux-specific structures and routines for
> > interacting with Hyper-V. It is split into an ARM64 specific file
> > and an architecture independent file in include/asm-generic.
> >
> > Signed-off-by: Michael Kelley <mikelley@microsoft.com>
> > Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
> > ---
> >  MAINTAINERS                          |   3 +
> >  arch/arm64/include/asm/hyperv-tlfs.h | 338 +++++++++++++++++++++++++++
> >  arch/arm64/include/asm/mshyperv.h    | 116 +++++++++
> >  include/asm-generic/mshyperv.h       | 240 +++++++++++++++++++
> >  4 files changed, 697 insertions(+)
> >  create mode 100644 arch/arm64/include/asm/hyperv-tlfs.h
> >  create mode 100644 arch/arm64/include/asm/mshyperv.h
> >  create mode 100644 include/asm-generic/mshyperv.h
> >
> > diff --git a/MAINTAINERS b/MAINTAINERS
> > index f4855974f325..72f19cef4c48 100644
> > --- a/MAINTAINERS
> > +++ b/MAINTAINERS
> > @@ -6835,6 +6835,8 @@ F:	arch/x86/include/asm/trace/hyperv.h
> >  F:	arch/x86/include/asm/hyperv-tlfs.h
> >  F:	arch/x86/kernel/cpu/mshyperv.c
> >  F:	arch/x86/hyperv
> > +F:	arch/arm64/include/asm/hyperv-tlfs.h
> > +F:	arch/arm64/include/asm/mshyperv.h
> >  F:	drivers/hid/hid-hyperv.c
> >  F:	drivers/hv/
> >  F:	drivers/input/serio/hyperv-keyboard.c
> > @@ -6846,6 +6848,7 @@ F:	drivers/video/fbdev/hyperv_fb.c
> >  F:	net/vmw_vsock/hyperv_transport.c
> >  F:	include/linux/hyperv.h
> >  F:	include/uapi/linux/hyperv.h
> > +F:	include/asm-generic/mshyperv.h
> >  F:	tools/hv/
> >  F:	Documentation/ABI/stable/sysfs-bus-vmbus
> >
> > diff --git a/arch/arm64/include/asm/hyperv-tlfs.h b/arch/arm64/include/=
asm/hyperv-
> tlfs.h
> > new file mode 100644
> > index 000000000000..924e37600e92
> > --- /dev/null
> > +++ b/arch/arm64/include/asm/hyperv-tlfs.h
> > @@ -0,0 +1,338 @@
> > +/* SPDX-License-Identifier: GPL-2.0 */
> > +
> > +/*
> > + * This file contains definitions from the Hyper-V Hypervisor Top-Leve=
l
> > + * Functional Specification (TLFS):
> > + *
> https://nam06.safelinks.protection.outlook.com/?url=3Dhttps%3A%2F%2Fdocs.=
microsoft.co
> m%2Fen-us%2Fvirtualization%2Fhyper-v-on-
> windows%2Freference%2Ftlfs&amp;data=3D02%7C01%7Cmikelley%40microsoft.com%=
7Ce1b
> dbb31db064623174f08d65c49cc3b%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%=
7C63
> 6797869386921804&amp;sdata=3DRiD05cDWC%2FPnXnis6U7EcfEfCjvb54uuKHRfifQhME=
M%3D
> &amp;reserved=3D0
>=20
> As mentioned elsewhere, please use a better link here and drop the licens=
e
> boilerplate below.

Agreed.  Will do so here and in other files in the next version of the patc=
h.

>=20
> > + *
> > + * Copyright (C) 2018, Microsoft, Inc.
> > + *
> > + * Author : Michael Kelley <mikelley@microsoft.com>
> > + *
> > + * This program is free software; you can redistribute it and/or modif=
y it
> > + * under the terms of the GNU General Public License version 2 as publ=
ished
> > + * by the Free Software Foundation.
> > + *
> > + * This program is distributed in the hope that it will be useful, but
> > + * WITHOUT ANY WARRANTY; without even the implied warranty of
> > + * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
> > + * NON INFRINGEMENT.  See the GNU General Public License for more
> > + * details.
> > + */
> > +
> > +#ifndef _ASM_ARM64_HYPERV_H
> > +#define _ASM_ARM64_HYPERV_H
>=20
> __ASM_HYPER_V_H please

OK.

>=20
> > +
> > +#include <linux/types.h>
> > +
> > +/*
> > + * These Hyper-V registers provide information equivalent to the CPUID
> > + * instruction on x86/x64.
> > + */
> > +#define HV_REGISTER_HYPERVISOR_VERSION		0x00000100 /*CPUID
> 0x40000002 */
> > +#define	HV_REGISTER_PRIVILEGES_AND_FEATURES	0x00000200 /*CPUID
> 0x40000003 */
> > +#define	HV_REGISTER_FEATURES			0x00000201 /*CPUID
> 0x40000004 */
> > +#define	HV_REGISTER_IMPLEMENTATION_LIMITS	0x00000202 /*CPUID
> 0x40000005 */
> > +#define HV_ARM64_REGISTER_INTERFACE_VERSION	0x00090006 /*CPUID
> 0x40000001 */
> > +
> > +/*
> > + * Feature identification. HvRegisterPrivilegesAndFeaturesInfo returns=
 a
> > + * 128-bit value with flags indicating which features are available to=
 the
> > + * partition based upon the current partition privileges. The 128-bit
> > + * value is broken up with different portions stored in different 32-b=
it
> > + * fields in the ms_hyperv structure.
> > + */
> > +
> > +/* Partition Reference Counter available*/
> > +#define HV_MSR_TIME_REF_COUNT_AVAILABLE		(1 << 1)
> > +
> > +/*
> > + * Synthetic Timers available
> > + */
> > +#define HV_MSR_SYNTIMER_AVAILABLE		(1 << 3)
> > +
> > +/* Frequency MSRs available */
> > +#define HV_FEATURE_FREQUENCY_MSRS_AVAILABLE	(1 << 8)
> > +
> > +/* Reference TSC available */
> > +#define HV_MSR_REFERENCE_TSC_AVAILABLE		(1 << 9)
> > +
> > +/* Crash MSR available */
> > +#define HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE	(1 << 10)
> > +
> > +
> > +/*
> > + * This group of flags is in the high order 64-bits of the returned
> > + * 128-bit value.
> > + */
> > +
> > +/* STIMER direct mode is available */
> > +#define HV_STIMER_DIRECT_MODE_AVAILABLE		(1 << 19)
> > +
> > +/*
> > + * Implementation recommendations in register
> > + * HvRegisterFeaturesInfo. Indicates which behaviors the hypervisor
> > + * recommends the OS implement for optimal performance.
> > + */
> > +
> > +/*
> > + * Recommend not using Auto EOI
> > + */
> > +#define HV_DEPRECATING_AEOI_RECOMMENDED		(1 << 9)
> > +
> > +/*
> > + * Synthetic register definitions equivalent to MSRs on x86/x64
> > + */
> > +#define HV_REGISTER_CRASH_P0		0x00000210
> > +#define HV_REGISTER_CRASH_P1		0x00000211
> > +#define HV_REGISTER_CRASH_P2		0x00000212
> > +#define HV_REGISTER_CRASH_P3		0x00000213
> > +#define HV_REGISTER_CRASH_P4		0x00000214
> > +#define HV_REGISTER_CRASH_CTL		0x00000215
> > +
> > +#define HV_REGISTER_GUEST_OSID		0x00090002
> > +#define HV_REGISTER_VPINDEX		0x00090003
> > +#define HV_REGISTER_TIME_REFCOUNT	0x00090004
> > +#define HV_REGISTER_REFERENCE_TSC	0x00090017
> > +
> > +#define HV_REGISTER_SINT0		0x000A0000
> > +#define HV_REGISTER_SINT1		0x000A0001
> > +#define HV_REGISTER_SINT2		0x000A0002
> > +#define HV_REGISTER_SINT3		0x000A0003
> > +#define HV_REGISTER_SINT4		0x000A0004
> > +#define HV_REGISTER_SINT5		0x000A0005
> > +#define HV_REGISTER_SINT6		0x000A0006
> > +#define HV_REGISTER_SINT7		0x000A0007
> > +#define HV_REGISTER_SINT8		0x000A0008
> > +#define HV_REGISTER_SINT9		0x000A0009
> > +#define HV_REGISTER_SINT10		0x000A000A
> > +#define HV_REGISTER_SINT11		0x000A000B
> > +#define HV_REGISTER_SINT12		0x000A000C
> > +#define HV_REGISTER_SINT13		0x000A000D
> > +#define HV_REGISTER_SINT14		0x000A000E
> > +#define HV_REGISTER_SINT15		0x000A000F
> > +#define HV_REGISTER_SCONTROL		0x000A0010
> > +#define HV_REGISTER_SVERSION		0x000A0011
> > +#define HV_REGISTER_SIFP		0x000A0012
> > +#define HV_REGISTER_SIPP		0x000A0013
> > +#define HV_REGISTER_EOM			0x000A0014
> > +#define HV_REGISTER_SIRBP		0x000A0015
> > +
> > +#define HV_REGISTER_STIMER0_CONFIG	0x000B0000
> > +#define HV_REGISTER_STIMER0_COUNT	0x000B0001
> > +#define HV_REGISTER_STIMER1_CONFIG	0x000B0002
> > +#define HV_REGISTER_STIMER1_COUNT	0x000B0003
> > +#define HV_REGISTER_STIMER2_CONFIG	0x000B0004
> > +#define HV_REGISTER_STIMER2_COUNT	0x000B0005
> > +#define HV_REGISTER_STIMER3_CONFIG	0x000B0006
> > +#define HV_REGISTER_STIMER3_COUNT	0x000B0007
> > +
> > +/*
> > + * Crash notification flags.
> > + */
> > +#define HV_CRASH_CTL_CRASH_NOTIFY_MSG	BIT_ULL(62)
> > +#define HV_CRASH_CTL_CRASH_NOTIFY	BIT_ULL(63)
> > +
> > +/*
> > + * The guest OS needs to register the guest ID with the hypervisor.
> > + * The guest ID is a 64 bit entity and the structure of this ID is
> > + * specified in the Hyper-V specification:
> > + *
> > + * msdn.microsoft.com/en-us/library/windows/hardware/ff542653%28v=3Dvs=
.85%29.aspx
>=20
> Dead link :(

Hmmm.  It looks like that doc is gone and the info is now in the TLFS.  Thi=
s
comment block shouldn't be here anyway.  As you noted later, there's anothe=
r
copy in include/asm-generic/mshyperv.h, which is the right place.  I'll
get this cleaned up in the next version of the patch.

>=20
> > + *
> > + * While the current guideline does not specify how Linux guest ID(s)
> > + * need to be generated, our plan is to publish the guidelines for
> > + * Linux and other guest operating systems that currently are hosted
> > + * on Hyper-V. The implementation here conforms to this yet
> > + * unpublished guidelines.
>=20
> Again, any timeline on publishing this stuff? Right now, this is just a f=
ile
> full of magic numbers and I'm not sure we're in a good position to mainta=
in
> it based on the idea that you have a cunning plan.

Fair point.

>=20
> > + *
> > + *
> > + * Bit(s)
> > + * 63 - Indicates if the OS is Open Source or not; 1 is Open Source
> > + * 62:56 - Os Type; Linux is 0x100
> > + * 55:48 - Distro specific identification
> > + * 47:16 - Linux kernel version number
> > + * 15:0  - Distro specific identification
> > + *
> > + *
> > + */
> > +#define HV_LINUX_VENDOR_ID              0x8100
> > +
> > +/* Declare the various hypercall operations. */
> > +#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE	0x0002
> > +#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST	0x0003
> > +#define HVCALL_NOTIFY_LONG_SPIN_WAIT		0x0008
> > +#define HVCALL_SEND_IPI				0x000b
> > +#define HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX	0x0013
> > +#define HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX	0x0014
> > +#define HVCALL_SEND_IPI_EX			0x0015
> > +#define HVCALL_GET_VP_REGISTERS			0x0050
> > +#define HVCALL_SET_VP_REGISTERS			0x0051
> > +#define HVCALL_POST_MESSAGE			0x005c
> > +#define HVCALL_SIGNAL_EVENT			0x005d
> > +#define HVCALL_RETARGET_INTERRUPT		0x007e
> > +#define HVCALL_START_VIRTUAL_PROCESSOR		0x0099
> > +#define HVCALL_GET_VP_INDEX_FROM_APICID		0x009a
>=20
> This all sounds very x86y...

Indeed it is.  Actually, I can delete this definition as the
GET_VP_INDEX_FROM_APICID hypercall is not used on ARM64.

>=20
> > +/* Declare standard hypercall field values. */
> > +#define HV_PARTITION_ID_SELF                    ((u64)-1)
> > +#define HV_VP_INDEX_SELF                        ((u32)-2)
> > +
> > +#define HV_HYPERCALL_FAST_BIT                   BIT(16)
> > +#define HV_HYPERCALL_REP_COUNT_1                BIT_ULL(32)
> > +#define HV_HYPERCALL_RESULT_MASK                GENMASK_ULL(15, 0)
> > +
> > +/* Define the hypercall status result */
> > +
> > +union hv_hypercall_status {
> > +	u64 as_uint64;
> > +	struct {
> > +		u16 status;
> > +		u16 reserved;
> > +		u16 reps_completed;  /* Low 12 bits */
> > +		u16 reserved2;
> > +	};
> > +};
> > +
> > +/* hypercall status code */
> > +#define HV_STATUS_SUCCESS			0
> > +#define HV_STATUS_INVALID_HYPERCALL_CODE	2
> > +#define HV_STATUS_INVALID_HYPERCALL_INPUT	3
> > +#define HV_STATUS_INVALID_ALIGNMENT		4
> > +#define HV_STATUS_INSUFFICIENT_MEMORY		11
> > +#define HV_STATUS_INVALID_CONNECTION_ID		18
> > +#define HV_STATUS_INSUFFICIENT_BUFFERS		19
> > +
> > +/* Define output layout for Get VP Register hypercall */
> > +struct hv_get_vp_register_output {
> > +	u64 registervaluelow;
> > +	u64 registervaluehigh;
> > +};
> > +
> > +#define HV_FLUSH_ALL_PROCESSORS			BIT(0)
> > +#define HV_FLUSH_ALL_VIRTUAL_ADDRESS_SPACES	BIT(1)
> > +#define HV_FLUSH_NON_GLOBAL_MAPPINGS_ONLY	BIT(2)
> > +#define HV_FLUSH_USE_EXTENDED_RANGE_FORMAT	BIT(3)
> > +
> > +enum HV_GENERIC_SET_FORMAT {
> > +	HV_GENERIC_SET_SPARSE_4K,
> > +	HV_GENERIC_SET_ALL,
> > +};
> > +
> > +/*
> > + * The Hyper-V TimeRefCount register and the TSC
> > + * page provide a guest VM clock with 100ns tick rate
> > + */
> > +#define HV_CLOCK_HZ (NSEC_PER_SEC/100)
> > +
> > +/*
> > + * The fields in this structure are set by Hyper-V and read
> > + * by the Linux guest.  They should be accessed with READ_ONCE()
> > + * so the compiler doesn't optimize in a way that will cause
> > + * problems.
> > + */
> > +struct ms_hyperv_tsc_page {
> > +	u32 tsc_sequence;
> > +	u32 reserved1;
> > +	u64 tsc_scale;
> > +	s64 tsc_offset;
> > +	u64 reserved2[509];
> > +};
>=20
> It might be clearer to express this as a union with the page size:
>=20
> struct ms_hyperv_tsc_page {
> 	union {
> 		struct {
> 			__u32	tsc_sequence;
> 			__u32	reserved1;
> 		};
> 		__u8	reserved2[HV_HYP_PAGE_SIZE];
> 	};
> };
>=20
> What's the required alignment on this structure?
> Also, do you intend for 32-bit guests to use this ABI as well?

The definition for struct ms_hyperv_tsc_page matches what
is written in section 12.6.2 of the Hyper-V TLFS, so I'm a little
reluctant to change it.  Alignment must be to Hyper-V's
4 Kbyte page size and the memory allocation for the structure
ensures that alignment when the guest page size is 4K.  In the
future, in order to work with Hyper-V, there's going to
be a general requirement for ARM64 guests to be able to allocate
4 Kbytes of memory that is 4 Kbyte aligned, even when we add
support for 16K/64K page sizes in the guest.  At the moment these
larger page sizes don't work due to incorrect assumptions about
page size in Hyper-V drivers that are architecture independent.
Fixing those mis-assumptions will be a separate set of patches.

There's no intent to support 32-bit guests running on Hyper-V for ARM64.

>=20
> > +
> > +/* Define the number of synthetic interrupt sources. */
> > +#define HV_SYNIC_SINT_COUNT		(16)
> > +/* Define the expected SynIC version. */
> > +#define HV_SYNIC_VERSION_1		(0x1)
> > +
> > +#define HV_SYNIC_CONTROL_ENABLE		(1ULL << 0)
> > +#define HV_SYNIC_SIMP_ENABLE		(1ULL << 0)
> > +#define HV_SYNIC_SIEFP_ENABLE		(1ULL << 0)
> > +#define HV_SYNIC_SINT_MASKED		(1ULL << 16)
> > +#define HV_SYNIC_SINT_AUTO_EOI		(1ULL << 17)
> > +#define HV_SYNIC_SINT_VECTOR_MASK	(0xFF)
> > +
> > +#define HV_SYNIC_STIMER_COUNT		(4)
> > +
> > +/* Define synthetic interrupt controller message constants. */
> > +#define HV_MESSAGE_SIZE			(256)
> > +#define HV_MESSAGE_PAYLOAD_BYTE_COUNT	(240)
> > +#define HV_MESSAGE_PAYLOAD_QWORD_COUNT	(30)
> > +
> > +/* Define hypervisor message types. */
> > +enum hv_message_type {
> > +	HVMSG_NONE			=3D 0x00000000,
> > +
> > +	/* Memory access messages. */
> > +	HVMSG_UNMAPPED_GPA		=3D 0x80000000,
> > +	HVMSG_GPA_INTERCEPT		=3D 0x80000001,
> > +
> > +	/* Timer notification messages. */
> > +	HVMSG_TIMER_EXPIRED		=3D 0x80000010,
> > +
> > +	/* Error messages. */
> > +	HVMSG_INVALID_VP_REGISTER_VALUE	=3D 0x80000020,
> > +	HVMSG_UNRECOVERABLE_EXCEPTION	=3D 0x80000021,
> > +	HVMSG_UNSUPPORTED_FEATURE	=3D 0x80000022,
> > +
> > +	/* Trace buffer complete messages. */
> > +	HVMSG_EVENTLOG_BUFFERCOMPLETE	=3D 0x80000040,
> > +};
> > +
> > +/* Define synthetic interrupt controller message flags. */
> > +union hv_message_flags {
> > +	__u8 asu8;
> > +	struct {
> > +		__u8 msg_pending:1;
> > +		__u8 reserved:7;
> > +	};
> > +};
> > +
> > +/* Define port identifier type. */
> > +union hv_port_id {
> > +	__u32 asu32;
> > +	struct {
> > +		__u32 id:24;
> > +		__u32 reserved:8;
> > +	} u;
> > +};
>=20
> Hmm, I thought bitfields weren't a good idea for this sort of thing. Isn'=
t
> it up to the compiler how they are laid out in memory?

There's just been a discussion about this on the x86 side.  See
https://lkml.org/lkml/2018/11/27/116 and=20
https://lkml.org/lkml/2018/11/30/848.   The data structures are
also typically defined as bitfields in the Hyper-V TLFS.  The decision was
to keep the bitfields but add __packed.  I'll do the same in the
next version of this patch.

>=20
> > +
> > +/* Define synthetic interrupt controller message header. */
> > +struct hv_message_header {
> > +	__u32 message_type;
> > +	__u8 payload_size;
> > +	union hv_message_flags message_flags;
> > +	__u8 reserved[2];
> > +	union {
> > +		__u64 sender;
> > +		union hv_port_id port;
> > +	};
> > +};
> > +
> > +/* Define synthetic interrupt controller message format. */
> > +struct hv_message {
> > +	struct hv_message_header header;
> > +	union {
> > +		__u64 payload[HV_MESSAGE_PAYLOAD_QWORD_COUNT];
> > +	} u;
> > +};
> > +
> > +/* Define the synthetic interrupt message page layout. */
> > +struct hv_message_page {
> > +	struct hv_message sint_message[HV_SYNIC_SINT_COUNT];
> > +};
> > +
> > +/* Define timer message payload structure. */
> > +struct hv_timer_message_payload {
> > +	__u32 timer_index;
> > +	__u32 reserved;
> > +	__u64 expiration_time;	/* When the timer expired */
> > +	__u64 delivery_time;	/* When the message was delivered */
> > +};
> > +
> > +#define HV_STIMER_ENABLE		(1ULL << 0)
> > +#define HV_STIMER_PERIODIC		(1ULL << 1)
> > +#define HV_STIMER_LAZY			(1ULL << 2)
> > +#define HV_STIMER_AUTOENABLE		(1ULL << 3)
> > +#define HV_STIMER_SINT(config)		(__u8)(((config) >> 16) & 0x0F)
> > +
> > +#endif
> > diff --git a/arch/arm64/include/asm/mshyperv.h b/arch/arm64/include/asm=
/mshyperv.h
> > new file mode 100644
> > index 000000000000..a87c431d58b3
> > --- /dev/null
> > +++ b/arch/arm64/include/asm/mshyperv.h
> > @@ -0,0 +1,116 @@
> > +/* SPDX-License-Identifier: GPL-2.0 */
> > +
> > +/*
> > + * Linux-specific definitions for managing interactions with Microsoft=
's
> > + * Hyper-V hypervisor. The definitions in this file are specific to
> > + * the ARM64 architecture.  See include/asm-generic/mshyperv.h for
> > + * definitions are that architecture independent.
> > + *
> > + * Definitions that are specified in the Hyper-V Top Level Functional
> > + * Spec (TLFS) should not go in this file, but should instead go in
> > + * hyperv-tlfs.h.
> > + *
> > + * Copyright (C) 2018, Microsoft, Inc.
> > + *
> > + * Author : Michael Kelley <mikelley@microsoft.com>
> > + *
> > + * This program is free software; you can redistribute it and/or modif=
y it
> > + * under the terms of the GNU General Public License version 2 as publ=
ished
> > + * by the Free Software Foundation.
> > + *
> > + * This program is distributed in the hope that it will be useful, but
> > + * WITHOUT ANY WARRANTY; without even the implied warranty of
> > + * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
> > + * NON INFRINGEMENT.  See the GNU General Public License for more
> > + * details.
> > + */
> > +
> > +#ifndef _ASM_ARM64_MSHYPERV_H
> > +#define _ASM_ARM64_MSHYPERV_H
> > +
> > +#include <linux/types.h>
> > +#include <linux/interrupt.h>
> > +#include <linux/clocksource.h>
> > +#include <linux/irq.h>
> > +#include <linux/irqdesc.h>
> > +#include <asm/hyperv-tlfs.h>
> > +
> > +/*
> > + * Define the IRQ numbers/vectors used by Hyper-V VMbus interrupts
> > + * and by STIMER0 Direct Mode interrupts. Hyper-V should be supplying
> > + * these values through ACPI, but there are no other interrupting
> > + * devices in a Hyper-V VM on ARM64, so it's OK to hard code for now.
> > + * The "CALLBACK_VECTOR" terminology is a left-over from the x86/x64
> > + * world that is used in architecture independent Hyper-V code.
> > + */
> > +#define HYPERVISOR_CALLBACK_VECTOR 16
> > +#define	HV_STIMER0_IRQNR	   17
> > +
> > +extern u64 hv_do_hvc(u64 control, ...);
> > +extern u64 hv_do_hvc_fast_get(u64 control, u64 input1, u64 input2, u64=
 input3,
> > +		struct hv_get_vp_register_output *output);
> > +
> > +/*
> > + * Declare calls to get and set Hyper-V VP register values on ARM64, w=
hich
> > + * requires a hypercall.
> > + */
> > +extern void hv_set_vpreg(u32 reg, u64 value);
> > +extern u64 hv_get_vpreg(u32 reg);
> > +extern void hv_get_vpreg_128(u32 reg, struct hv_get_vp_register_output=
 *result);
> > +
> > +/*
> > + * Use the Hyper-V provided stimer0 as the timer that is made
> > + * available to the architecture independent Hyper-V drivers.
> > + */
> > +#define hv_init_timer(timer, tick) \
> > +		hv_set_vpreg(HV_REGISTER_STIMER0_COUNT + (2*timer), tick)
> > +#define hv_init_timer_config(timer, val) \
> > +		hv_set_vpreg(HV_REGISTER_STIMER0_CONFIG + (2*timer), val)
> > +#define hv_get_current_tick(tick) \
> > +		(tick =3D hv_get_vpreg(HV_REGISTER_TIME_REFCOUNT))
> > +
> > +#define hv_get_simp(val) (val =3D hv_get_vpreg(HV_REGISTER_SIPP))
> > +#define hv_set_simp(val) hv_set_vpreg(HV_REGISTER_SIPP, val)
> > +
> > +#define hv_get_siefp(val) (val =3D hv_get_vpreg(HV_REGISTER_SIFP))
> > +#define hv_set_siefp(val) hv_set_vpreg(HV_REGISTER_SIFP, val)
> > +
> > +#define hv_get_synic_state(val) (val =3D hv_get_vpreg(HV_REGISTER_SCON=
TROL))
> > +#define hv_set_synic_state(val) hv_set_vpreg(HV_REGISTER_SCONTROL, val=
)
> > +
> > +#define hv_get_vp_index(index) (index =3D hv_get_vpreg(HV_REGISTER_VPI=
NDEX))
> > +
> > +#define hv_signal_eom()	hv_set_vpreg(HV_REGISTER_EOM, 0)
> > +
> > +/*
> > + * Hyper-V SINT registers are numbered sequentially, so we can just
> > + * add the SINT number to the register number of SINT0
> > + */
> > +#define hv_get_synint_state(sint_num, val) \
> > +		(val =3D hv_get_vpreg(HV_REGISTER_SINT0 + sint_num))
> > +#define hv_set_synint_state(sint_num, val) \
> > +		hv_set_vpreg(HV_REGISTER_SINT0 + sint_num, val)
> > +
> > +#define hv_get_crash_ctl(val) \
> > +		(val =3D hv_get_vpreg(HV_REGISTER_CRASH_CTL))
> > +
> > +#if IS_ENABLED(CONFIG_HYPERV)
> > +#define hv_enable_stimer0_percpu_irq(irq)	enable_percpu_irq(irq, 0)
> > +#define hv_disable_stimer0_percpu_irq(irq)	disable_percpu_irq(irq)
> > +#endif
> > +
> > +/* ARM64 specific code to read the hardware clock */
> > +static inline u64 hv_read_hwclock(void)
> > +{
> > +	u64 result;
> > +
> > +	isb();
> > +	result =3D read_sysreg(cntvct_el0);
> > +	isb();
> > +
> > +	return result;
> > +}
>=20
> Shouldn't you use arch_timer_read_counter() or arch_counter_get_cntvct()
> instead?

I don't think so.  Hyper-V provides its own clocksource on ARM64 like it do=
es
x86.  It is not the standard ARM64 arch timer, and the ARM64 arch timer dri=
ver
that implements arch_timer_read_counter() and arch_counter_get_cntvct() is
not used.

>=20
> > +#include <asm-generic/mshyperv.h>
> > +
> > +#endif
> > diff --git a/include/asm-generic/mshyperv.h b/include/asm-generic/mshyp=
erv.h
> > new file mode 100644
> > index 000000000000..fbe1ec89c85a
> > --- /dev/null
> > +++ b/include/asm-generic/mshyperv.h
> > @@ -0,0 +1,240 @@
> > +/* SPDX-License-Identifier: GPL-2.0 */
> > +
> > +/*
> > + * Linux-specific definitions for managing interactions with Microsoft=
's
> > + * Hyper-V hypervisor. The definitions in this file are architecture
> > + * independent. See arch/<arch>/include/asm/mshyperv.h for definitions
> > + * that are specific to architecture <arch>.
> > + *
> > + * Definitions that are specified in the Hyper-V Top Level Functional
> > + * Spec (TLFS) should not go in this file, but should instead go in
> > + * hyperv-tlfs.h.
> > + *
> > + * Copyright (C) 2018, Microsoft, Inc.
> > + *
> > + * Author : Michael Kelley <mikelley@microsoft.com>
> > + *
> > + * This program is free software; you can redistribute it and/or modif=
y it
> > + * under the terms of the GNU General Public License version 2 as publ=
ished
> > + * by the Free Software Foundation.
> > + *
> > + * This program is distributed in the hope that it will be useful, but
> > + * WITHOUT ANY WARRANTY; without even the implied warranty of
> > + * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
> > + * NON INFRINGEMENT.  See the GNU General Public License for more
> > + * details.
> > + */
> > +
> > +#ifndef _ASM_GENERIC_MSHYPERV_H
> > +#define _ASM_GENERIC_MSHYPERV_H
> > +
> > +#include <linux/types.h>
> > +#include <linux/interrupt.h>
> > +#include <linux/clocksource.h>
> > +#include <linux/irq.h>
> > +#include <linux/irqdesc.h>
> > +#include <asm/hyperv-tlfs.h>
> > +
> > +/*
> > + * Hyper-V always runs with a page size of 4096. These definitions
> > + * are used when communicating with Hyper-V using guest physical
> > + * pages and guest physical page addresses, since the guest page
> > + * size may not be 4096 on ARM64.
> > + */
> > +#define HV_HYP_PAGE_SIZE	4096
> > +#define HV_HYP_PAGE_SHIFT	12
>=20
> Maybe define the page size in terms of the shift?

Good idea.  I'll make that change.

>=20
> > +#define HV_HYP_PAGE_MASK	(~(HV_HYP_PAGE_SIZE - 1))
> > +
> > +
> > +struct ms_hyperv_info {
> > +	u32 features;
> > +	u32 misc_features;
> > +	u32 hints;
> > +	u32 max_vp_index;
> > +	u32 max_lp_index;
> > +};
>=20
> What is the define endianness for in-memory structures shared with the
> hypervisor?

It is little endian.  I'll add a comment to that effect as it is effectivel=
y
part of the ABI.

>=20
> > +extern struct ms_hyperv_info ms_hyperv;
> > +
> > +extern u64 hv_do_hypercall(u64 control, void *inputaddr, void *outputa=
ddr);
> > +extern u64 hv_do_fast_hypercall8(u16 control, u64 input8);
> > +
> > +/*
> > + * The guest OS needs to register the guest ID with the hypervisor.
> > + * The guest ID is a 64 bit entity and the structure of this ID is
> > + * specified in the Hyper-V specification:
> > + *
> > + * msdn.microsoft.com/en-us/library/windows/hardware/ff542653%28v=3Dvs=
.85%29.aspx
> > + *
> > + * While the current guideline does not specify how Linux guest ID(s)
> > + * need to be generated, our plan is to publish the guidelines for
> > + * Linux and other guest operating systems that currently are hosted
> > + * on Hyper-V. The implementation here conforms to this yet
> > + * unpublished guidelines.
> > + *
> > + *
> > + * Bit(s)
> > + * 63 - Indicates if the OS is Open Source or not; 1 is Open Source
> > + * 62:56 - Os Type; Linux is 0x100
> > + * 55:48 - Distro specific identification
> > + * 47:16 - Linux kernel version number
> > + * 15:0  - Distro specific identification
>=20
> This looks familiar...

Yes.  I'll remove the duplicate copy in the other file.

>=20
> > + * Generate the guest ID based on the guideline described above.
> > + */
> > +
> > +static inline  __u64 generate_guest_id(__u64 d_info1, __u64 kernel_ver=
sion,
> > +				       __u64 d_info2)
> > +{
> > +	__u64 guest_id =3D 0;
> > +
> > +	guest_id =3D (((__u64)HV_LINUX_VENDOR_ID) << 48);
> > +	guest_id |=3D (d_info1 << 48);
> > +	guest_id |=3D (kernel_version << 16);
> > +	guest_id |=3D d_info2;
> > +
> > +	return guest_id;
> > +}
> > +
> > +
> > +/* Free the message slot and signal end-of-message if required */
> > +static inline void vmbus_signal_eom(struct hv_message *msg, u32 old_ms=
g_type)
> > +{
> > +	/*
> > +	 * On crash we're reading some other CPU's message page and we need
> > +	 * to be careful: this other CPU may already had cleared the header
> > +	 * and the host may already had delivered some other message there.
> > +	 * In case we blindly write msg->header.message_type we're going
> > +	 * to lose it. We can still lose a message of the same type but
> > +	 * we count on the fact that there can only be one
> > +	 * CHANNELMSG_UNLOAD_RESPONSE and we don't care about other messages
> > +	 * on crash.
> > +	 */
> > +	if (cmpxchg(&msg->header.message_type, old_msg_type,
> > +		    HVMSG_NONE) !=3D old_msg_type)
> > +		return;
> > +
> > +	/*
> > +	 * Make sure the write to MessageType (ie set to
> > +	 * HVMSG_NONE) happens before we read the
> > +	 * MessagePending and EOMing. Otherwise, the EOMing
> > +	 * will not deliver any more messages since there is
> > +	 * no empty slot
> > +	 */
> > +	mb();
>=20
> A successful cmpxchg() already implies full barriers, so this isn't neede=
d.
> I also wonder whether cmpxchg_acquire() would be sufficient here.

OK.  I'll investigate the use of cmpxchg_acquire().

>=20
> > +
> > +	if (msg->header.message_flags.msg_pending) {
> > +		/*
> > +		 * This will cause message queue rescan to
> > +		 * possibly deliver another msg from the
> > +		 * hypervisor
> > +		 */
> > +		hv_signal_eom();
> > +	}
> > +}
> > +
> > +void hv_setup_vmbus_irq(void (*handler)(void));
> > +void hv_remove_vmbus_irq(void);
> > +void hv_enable_vmbus_irq(void);
> > +void hv_disable_vmbus_irq(void);
> > +
> > +void hv_setup_kexec_handler(void (*handler)(void));
> > +void hv_remove_kexec_handler(void);
> > +void hv_setup_crash_handler(void (*handler)(struct pt_regs *regs));
> > +void hv_remove_crash_handler(void);
> > +
> > +#if IS_ENABLED(CONFIG_HYPERV)
> > +extern struct clocksource *hyperv_cs;
> > +
> > +/*
> > + * Hypervisor's notion of virtual processor ID is different from
> > + * Linux' notion of CPU ID. This information can only be retrieved
> > + * in the context of the calling CPU. Setup a map for easy access
> > + * to this information.
> > + */
> > +extern u32 *hv_vp_index;
> > +extern u32 hv_max_vp_index;
> > +
> > +/* Sentinel value for an uninitialized entry in hv_vp_index array */
> > +#define VP_INVAL	U32_MAX
> > +
> > +/**
> > + * hv_cpu_number_to_vp_number() - Map CPU to VP.
> > + * @cpu_number: CPU number in Linux terms
> > + *
> > + * This function returns the mapping between the Linux processor
> > + * number and the hypervisor's virtual processor number, useful
> > + * in making hypercalls and such that talk about specific
> > + * processors.
> > + *
> > + * Return: Virtual processor number in Hyper-V terms
> > + */
> > +static inline int hv_cpu_number_to_vp_number(int cpu_number)
> > +{
> > +	return hv_vp_index[cpu_number];
> > +}
> > +
> > +void hyperv_report_panic(struct pt_regs *regs, long err);
> > +void hyperv_report_panic_msg(phys_addr_t pa, size_t size);
> > +bool hv_is_hyperv_initialized(void);
> > +void hyperv_cleanup(void);
> > +#else /* CONFIG_HYPERV */
> > +static inline bool hv_is_hyperv_initialized(void) { return false; }
> > +static inline void hyperv_cleanup(void) {}
> > +#endif /* CONFIG_HYPERV */
> > +
> > +#if IS_ENABLED(CONFIG_HYPERV)
> > +extern int hv_setup_stimer0_irq(int *irq, int *vector, void (*handler)=
(void));
> > +extern void hv_remove_stimer0_irq(int irq);
> > +#endif
> > +
> > +static inline u64 hv_read_tsc_page_tsc(const struct ms_hyperv_tsc_page=
 *tsc_pg,
> > +				       u64 *cur_tsc)
> > +{
> > +	u64	scale, offset;
> > +	u32	sequence;
> > +
> > +	/*
> > +	 * The protocol for reading Hyper-V TSC page is specified in Hypervis=
or
> > +	 * Top-Level Functional Specification.  To get the reference time we
> > +	 * must do the following:
> > +	 * - READ ReferenceTscSequence
> > +	 *   A special '0' value indicates the time source is unreliable and =
we
> > +	 *   need to use something else.
> > +	 * - ReferenceTime =3D
> > +	 *     ((HWclock val) * ReferenceTscScale) >> 64) + ReferenceTscOffse=
t
> > +	 * - READ ReferenceTscSequence again. In case its value has changed
> > +	 *   since our first reading we need to discard ReferenceTime and rep=
eat
> > +	 *   the whole sequence as the hypervisor was updating the page in
> > +	 *   between.
> > +	 */
> > +	do {
> > +		sequence =3D READ_ONCE(tsc_pg->tsc_sequence);
> > +		/*
> > +		 * Make sure we read sequence before we read other values from
> > +		 * TSC page.
> > +		 */
> > +		smp_rmb();
> > +
> > +		scale =3D READ_ONCE(tsc_pg->tsc_scale);
> > +		offset =3D READ_ONCE(tsc_pg->tsc_offset);
> > +		*cur_tsc =3D hv_read_hwclock();
> > +
> > +		/*
> > +		 * Make sure we read sequence after we read all other values
> > +		 * from TSC page.
> > +		 */
> > +		smp_rmb();
> > +
> > +	} while (READ_ONCE(tsc_pg->tsc_sequence) !=3D sequence);
>=20
> Could you explain what the writer side looks like, please? I'm a bit
> confused as to why we're not using the bottom bit of the sequence
> number to detect a concurrent update.

The writer side, of course, is Hyper-V.  The algorithm used follows the
code in Section 12.6.3 of the Hyper-V TLFS, though as pointed out in a
separate email by Vitaly Kuznetsov, I seemed to have dropped the test for
sequence value 0 when moving the code over from the x86 side.  I'll add
that back in.

I'm not clear on your thought about using the bottom bit of the sequence
number.   Is that better than just comparing the full 32-bit value?

Thanks for the review and all the great comments ...

Michael

>=20
> Will
