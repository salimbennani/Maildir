Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 11 Dec 2018 08:40:35 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga002.fm.intel.com (fmsmga002.fm.intel.com [10.253.24.26])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 6A89A5807A2;
	Mon, 10 Dec 2018 09:19:35 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by fmsmga002-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 10 Dec 2018 09:19:35 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Aw/RpHhC42k5DKtg2P3sVUyQJP3N1i/DPJgcQr6Af?=
 =?us-ascii?q?oPdwSP7/o8iwAkXT6L1XgUPTWs2DsrQY07qQ6/iocFdDyK7JiGoFfp1IWk1Nou?=
 =?us-ascii?q?QttCtkPvS4D1bmJuXhdS0wEZcKflZk+3amLRodQ56mNBXdrXKo8DEdBAj0OxZr?=
 =?us-ascii?q?KeTpAI7SiNm82/yv95HJbAhEmDmwbaluIBmqsA7cqtQYjYx+J6gr1xDHuGFIe+?=
 =?us-ascii?q?NYxWNpIVKcgRPx7dqu8ZBg7ipdpesv+9ZPXqvmcas4S6dYDCk9PGAu+MLrrxjD?=
 =?us-ascii?q?QhCR6XYaT24bjwBHAwnB7BH9Q5fxri73vfdz1SWGIcH7S60/VDK/5KlpVRDokj?=
 =?us-ascii?q?8KOT4n/m/KhMJ+j6BUoBy6pxxnwYPZe52ZOOZkc6/BYd8WWXZNU8BMXCJBGIO8?=
 =?us-ascii?q?aI4PAvIOMuZZsYnyuVgOpga/CwmrBOLg0DtIjWLx0K0k3OQhFgHH0xYkH98Vqn?=
 =?us-ascii?q?Tbssj6NKcIXuCp1qXH0TLDb/ZP1Dr79YPGcQghrOmSUb5sdcfd01QjGg3bglmK?=
 =?us-ascii?q?tIDoPC+Z2v4MvmWZ9+ZsS/6jhmo9pw1srDWj2N0ghpTKi48b0FzI6yZ0zYAoLt?=
 =?us-ascii?q?OiUkF7e8SrEJ5IuiGaKYR2RsQiTnl2uCY11LIGo4S3fCsUx5Q9wR7QdfiHf5KP?=
 =?us-ascii?q?4hL5W+adOTZ4hHR7d7Kjnxu+71Ssx+nmWsWp3ltGsDBJnsTPu3wRzRDe68qKRu?=
 =?us-ascii?q?N4/ki72DaP0w7T6vtDIUAxjafbL58hwrgtlpscqEjDHTH5mF/wjKCIckUo4++o?=
 =?us-ascii?q?6urhYrr4vJ+RLJF0ig7gPaQ0gMC/Avo3MhIIX2eF/eSwzrrj/Vf2QLlSlP05jr?=
 =?us-ascii?q?HZsIzGJcQcvqO5Bw5V0oU95BqlADamzc8VnX0GLFJDZRKGgJLlO1DIIPDkE/i/?=
 =?us-ascii?q?h06gnytsx/DDJrfhGInCLmDfkLf9erZw805cxxAyzdBD/Z1UDasNIPLuWkDrst?=
 =?us-ascii?q?zYAQQ0Mwi1w+bhFdV82ZkSWWOJAq+FLqzStUWE6f4oI+mJfIUVoiryK+A55/7y?=
 =?us-ascii?q?in80gV0dfa630pcNa3C4GfJmI0OeYXf3htcBEGEKvhcxTeDwiV2CVyJTaGi2X6?=
 =?us-ascii?q?4m+j47D4emB5/ZRo+xmLyBwDu7HppOa29cEVCMEXDod4aeV/cWci2SINRskjgF?=
 =?us-ascii?q?VbinVo8g2guitA78y7p7MOXU/jcUuo7k1Nhw/+fTjw099SRoD8SB1GGAV2J0kX?=
 =?us-ascii?q?kORzMs2KB/oFZyylGM0aVjh/xYFNpT5+5GUwsgNJ7cyfB6BM72Wg7bYtiJT1Om?=
 =?us-ascii?q?SM28AT4tVtIx38MOY0FlFtq/lB/DwTSlD6UVl7ORApw06bzT3372K8Z5yHbG0a?=
 =?us-ascii?q?0hgkIiQstOM22mm6F++xLSB47Pj0WWiaKqeb4A0y7K8WeJ1XCOs11AUA5sTaXF?=
 =?us-ascii?q?WmgSaVbMotTn+EzOVb+uBq4hMgta18GCLLBHatnojVVAWffiN87SY2O3m2esGx?=
 =?us-ascii?q?mIwqmAY5bte2UYxC/dElQLkxgP/XaaMggzHjuho2PbDDxpCVLvY0Pt/fNiqH+h?=
 =?us-ascii?q?SU801QWKb0xn17q64RMVgf2cS/UO3rMLoishqjN0HEqj0NLSEdaPuw1hfKBEa9?=
 =?us-ascii?q?Mn/FhHzX7ZtxB6PpG4Na9igkARcgtpsELuzRl4EZhAntUwo3MszwpyLryY3UhF?=
 =?us-ascii?q?dzOZ25DwJ7LWJnPz/BCpd67ZxFXe3MyK9acI7fQys0/jsx2xFko+73Vn1MFY0n?=
 =?us-ascii?q?uB5pnQEAUeS5PwUkYt+Bh8qLHXeS0954LS1X1xPqi4qD7C29Q1BOQ7zhasZctQ?=
 =?us-ascii?q?MKSBFAXqCc0VG9CuKPA2m1iudh8EJuFS+7IuMMO8avSG37SnPOB+kzK8jGRL+Z?=
 =?us-ascii?q?xy3ViI9yVhVOHIxZEFw/eD0wuDVjf8ikqhs8/tlYBFYzESAnSwySz+CIFNYa1y?=
 =?us-ascii?q?eJ4BCX2yLM2v2tV+m5ntVmZY9V6iHV8H2NWleQGPb1z7xgBQ0UUXoXq6mSq31T?=
 =?us-ascii?q?B0kjcprraB0yzK2ejtaB0HOmtTTml4kVjsOZS0j8wdXEWwbQgmjgGl5UX5x6hc?=
 =?us-ascii?q?vqh/NHPcQURLfyj3KWFtTK2wu6GGY85O7pMorCpWXP69YVCcVr7yvR8a3zn/EG?=
 =?us-ascii?q?tZwTAxbyuqtYnhnxxmlGKdK25+rXrDdsF33xvf5t3cRfhK0zoCRSl4jyTXB1em?=
 =?us-ascii?q?M9mo+9WUi4nMsuSkW229UZ1TdDHhzZmcuyuj+W1qHRq/kuiwmtL9EAg2yy/718?=
 =?us-ascii?q?RwWiXOoxbxeY3r16W8MeJ6cUhkHl7868xmGo5glos8no0f2X8fhp+N53oIjX/z?=
 =?us-ascii?q?MclH2aL5dHcNQD8Lw93P7wT/1kxsMGmJx57nWXWH2cRuecO6YmwN1yI57sBKDr?=
 =?us-ascii?q?qU7bNekSt0pFq4sRzeYfxnkjgBzvsu7WYQg/sVtwo10iWdHrcSEFFEPSzrkhSE?=
 =?us-ascii?q?9dG/o79RZGayariwz0t+kMulDLGDpAFcRXn4do0jHS928sVwLlbM3Gfv5YHjfd?=
 =?us-ascii?q?nadcgTuQGMkxfck+hVL4o8meEQiipgPWL9oGcpy+omjRF12ZG6vY6HK3hi/a6j?=
 =?us-ascii?q?Ax5YMCH1aN0X+j33kalemcOW1Zi1Hpp9AjULQIfoTfWwHTIQr/vnMhiBECYmpn?=
 =?us-ascii?q?eHA7bfHhKf6ER7r3LJCZ+rLGqaJH0YzdVkWRmcK1ZTgAESXDUmgJE5Ehqmy9Dm?=
 =?us-ascii?q?cEd8/joR/EL3qgNQyuJ0MBnySmfepAC1ajctVZiQNhxW4htZ50fSN8ye4fl+Hy?=
 =?us-ascii?q?VZ/p2nsQyMJXaXZwVODWEVREOEA0rvMaWp5dnF6+KYHPaxL+PSYbWSruxTT/eI?=
 =?us-ascii?q?yoyu0otl/DaMN9+DPnp4D/081UpMQ2p5G9nCmzgUTywXliTNb9OUpRum+y13qN?=
 =?us-ascii?q?y//+rvWA71+YSPDL5SO811+x+qmaeDK/KQhCFhJDlCy5MD3mXIx6Yf3VIIjyFu?=
 =?us-ascii?q?diKgEbABtS7LUaLRlbVbDx8dayNvKsRI67gw0RVKOc7ektn1zKJ3juYpC1dZUl?=
 =?us-ascii?q?zsgt2pZc0PI22nKFzLHlqENLSYKj3N2Mz3ZaK8SbtNjORbrRGwuDCbE1P9MTSH?=
 =?us-ascii?q?jTXmSxevMeRUhiGBIBNeoJ29cgpqCWX7TNPpcBu7MNp2jT0w2bI1h3PKOnQaMT?=
 =?us-ascii?q?hzaE5NqryQ7SVFgvRwAWBB73xlLfWalCad9eXXNpEWsf44ShhzwuZb5mkqjrVO?=
 =?us-ascii?q?4CxaSfhdhiTftJhtrkugn+3JzSBoFFJKqzBWlMeIsF9kNKHx6JZNQzDH8QgL4G?=
 =?us-ascii?q?HWDA4F45NmFNjHpa9d0J7Mmbj1JTME9MjbruUGAM2BFsOZPXlpHh34ETqcWBUK?=
 =?us-ascii?q?Si+iMUnFikBdme3U/XqQ+Mtp4qPwkYYDH+cIHGc+EekXXxxo?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ARAAADnw5ch0O0hNFkHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBg2snjBNfizCCIZc9gXMUGBMBh20iNAkNAQMBAQEBAQECARMBAQE?=
 =?us-ascii?q?IDQkIKS+CNiKCZQMDAQIkUgYJAQFQAykrBxIFgxyCAgWnBzOKIIwhF4FAP4ERg?=
 =?us-ascii?q?hRQhHiGEgKJL4cLUY9qCZFECxiJZodXiFdLkA6BRoIOMxoIGxU7gmyCJxeOOyE?=
 =?us-ascii?q?BATGBBQEBHIkvgk0BAQ?=
X-IPAS-Result: =?us-ascii?q?A0ARAAADnw5ch0O0hNFkHAEBAQQBAQcEAQGBUQcBAQsBg2s?=
 =?us-ascii?q?njBNfizCCIZc9gXMUGBMBh20iNAkNAQMBAQEBAQECARMBAQEIDQkIKS+CNiKCZ?=
 =?us-ascii?q?QMDAQIkUgYJAQFQAykrBxIFgxyCAgWnBzOKIIwhF4FAP4ERghRQhHiGEgKJL4c?=
 =?us-ascii?q?LUY9qCZFECxiJZodXiFdLkA6BRoIOMxoIGxU7gmyCJxeOOyEBATGBBQEBHIkvg?=
 =?us-ascii?q?k0BAQ?=
X-IronPort-AV: E=Sophos;i="5.56,339,1539673200"; 
   d="scan'208";a="55284932"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 10 Dec 2018 09:19:33 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1729055AbeLJRSf (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Mon, 10 Dec 2018 12:18:35 -0500
Received: from mx1.redhat.com ([209.132.183.28]:45586 "EHLO mx1.redhat.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1728375AbeLJRNf (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 10 Dec 2018 12:13:35 -0500
Received: from smtp.corp.redhat.com (int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
        (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
        (No client certificate requested)
        by mx1.redhat.com (Postfix) with ESMTPS id 0B494284B1;
        Mon, 10 Dec 2018 17:13:35 +0000 (UTC)
Received: from horse.redhat.com (unknown [10.18.25.234])
        by smtp.corp.redhat.com (Postfix) with ESMTP id 99D4E60158;
        Mon, 10 Dec 2018 17:13:34 +0000 (UTC)
Received: by horse.redhat.com (Postfix, from userid 10451)
        id 5A9CA224260; Mon, 10 Dec 2018 12:13:30 -0500 (EST)
From: Vivek Goyal <vgoyal@redhat.com>
To: linux-fsdevel@vger.kernel.org, linux-kernel@vger.kernel.org,
        kvm@vger.kernel.org
Cc: vgoyal@redhat.com, miklos@szeredi.hu, stefanha@redhat.com,
        dgilbert@redhat.com, sweil@redhat.com, swhiteho@redhat.com
Subject: [PATCH 22/52] Create a list of free memory ranges
Date: Mon, 10 Dec 2018 12:12:48 -0500
Message-Id: <20181210171318.16998-23-vgoyal@redhat.com>
In-Reply-To: <20181210171318.16998-1-vgoyal@redhat.com>
References: <20181210171318.16998-1-vgoyal@redhat.com>
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.11
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16 (mx1.redhat.com [10.5.110.28]); Mon, 10 Dec 2018 17:13:35 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Divide the dax memory range into fixed size ranges (2MB for now) and put
them in a list. This will track free ranges. Once an inode requires a
free range, we will take one from here and put it in interval-tree
of ranges assigned to inode.

Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
---
 fs/fuse/fuse_i.h    | 14 +++++++++
 fs/fuse/inode.c     | 81 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 fs/fuse/virtio_fs.c |  2 ++
 3 files changed, 96 insertions(+), 1 deletion(-)

diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index b9880be690bd..f0775d76e31f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -46,6 +46,10 @@
 /** Number of page pointers embedded in fuse_req */
 #define FUSE_REQ_INLINE_PAGES 1
 
+/* Default memory range size, 2MB */
+#define FUSE_DAX_MEM_RANGE_SZ	(2*1024*1024)
+#define FUSE_DAX_MEM_RANGE_PAGES	(FUSE_DAX_MEM_RANGE_SZ/PAGE_SIZE)
+
 /** List of active connections */
 extern struct list_head fuse_conn_list;
 
@@ -83,6 +87,9 @@ struct fuse_forget_link {
 
 /** Translation information for file offsets to DAX window offsets */
 struct fuse_dax_mapping {
+	/* Will connect in fc->free_ranges to keep track of free memory */
+	struct list_head list;
+
        /** Position in DAX window */
        u64 window_offset;
 
@@ -816,6 +823,13 @@ struct fuse_conn {
 
 	/** DAX device, non-NULL if DAX is supported */
 	struct dax_device *dax_dev;
+
+	/*
+	 * DAX Window Free Ranges. TODO: This might not be best place to store
+	 * this free list
+	 */
+	unsigned long nr_free_ranges;
+	struct list_head free_ranges;
 };
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index d2afce377fd4..403360e352d8 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -22,6 +22,8 @@
 #include <linux/exportfs.h>
 #include <linux/posix_acl.h>
 #include <linux/pid_namespace.h>
+#include <linux/dax.h>
+#include <linux/pfn_t.h>
 
 MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
 MODULE_DESCRIPTION("Filesystem in Userspace");
@@ -607,6 +609,69 @@ static void fuse_pqueue_init(struct fuse_pqueue *fpq)
 	fpq->connected = 1;
 }
 
+static void fuse_free_dax_mem_ranges(struct list_head *mem_list)
+{
+	struct fuse_dax_mapping *range, *temp;
+
+	/* Free All allocated elements */
+	list_for_each_entry_safe(range, temp, mem_list, list) {
+		list_del(&range->list);
+		kfree(range);
+	}
+}
+
+static int fuse_dax_mem_range_init(struct fuse_conn *fc,
+				   struct dax_device *dax_dev)
+{
+	long nr_pages, nr_ranges;
+	void *kaddr;
+	pfn_t pfn;
+	struct fuse_dax_mapping *range;
+	LIST_HEAD(mem_ranges);
+	phys_addr_t phys_addr;
+	int ret = 0, id;
+	size_t dax_size = -1;
+	unsigned long allocated_ranges = 0, i;
+
+	id = dax_read_lock();
+	nr_pages = dax_direct_access(dax_dev, 0, PHYS_PFN(dax_size), &kaddr,
+					&pfn);
+	dax_read_unlock(id);
+	if (nr_pages < 0) {
+		pr_debug("dax_direct_access() returned %ld\n", nr_pages);
+		return nr_pages;
+	}
+
+	phys_addr = pfn_t_to_phys(pfn);
+	nr_ranges = nr_pages/FUSE_DAX_MEM_RANGE_PAGES;
+	printk("fuse_dax_mem_range_init(): dax mapped %ld pages. nr_ranges=%ld\n", nr_pages, nr_ranges);
+
+	for (i = 0; i < nr_ranges; i++) {
+		range = kzalloc(sizeof(struct fuse_dax_mapping), GFP_KERNEL);
+		if (!range) {
+			pr_debug("memory allocation for mem_range failed.\n");
+			ret = -ENOMEM;
+			goto out_err;
+		}
+		/* TODO: This offset only works if virtio-fs driver is not
+		 * having some memory hidden at the beginning. This needs
+		 * better handling
+		 */
+		range->window_offset = i * FUSE_DAX_MEM_RANGE_SZ;
+		range->length = FUSE_DAX_MEM_RANGE_SZ;
+		list_add_tail(&range->list, &mem_ranges);
+		allocated_ranges++;
+	}
+
+	list_replace_init(&mem_ranges, &fc->free_ranges);
+	fc->nr_free_ranges = allocated_ranges;
+	return 0;
+out_err:
+	/* Free All allocated elements */
+	fuse_free_dax_mem_ranges(&mem_ranges);
+	return ret;
+}
+
 void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns,
 			struct dax_device *dax_dev,
 			const struct fuse_iqueue_ops *fiq_ops, void *fiq_priv)
@@ -636,6 +701,7 @@ void fuse_conn_init(struct fuse_conn *fc, struct user_namespace *user_ns,
 	fc->pid_ns = get_pid_ns(task_active_pid_ns(current));
 	fc->dax_dev = dax_dev;
 	fc->user_ns = get_user_ns(user_ns);
+	INIT_LIST_HEAD(&fc->free_ranges);
 }
 EXPORT_SYMBOL_GPL(fuse_conn_init);
 
@@ -644,6 +710,8 @@ void fuse_conn_put(struct fuse_conn *fc)
 	if (refcount_dec_and_test(&fc->count)) {
 		if (fc->destroy_req)
 			fuse_request_free(fc->destroy_req);
+		if (fc->dax_dev)
+			fuse_free_dax_mem_ranges(&fc->free_ranges);
 		put_pid_ns(fc->pid_ns);
 		put_user_ns(fc->user_ns);
 		fc->release(fc);
@@ -1136,9 +1204,17 @@ int fuse_fill_super_common(struct super_block *sb,
 	fuse_conn_init(fc, sb->s_user_ns, dax_dev, fiq_ops, fiq_priv);
 	fc->release = fuse_free_conn;
 
+	if (dax_dev) {
+		err = fuse_dax_mem_range_init(fc, dax_dev);
+		if (err) {
+			pr_debug("fuse_dax_mem_range_init() returned %d\n", err);
+			goto err_put_conn;
+		}
+	}
+
 	fud = fuse_dev_alloc(fc);
 	if (!fud)
-		goto err_put_conn;
+		goto err_free_ranges;
 
 	fc->dev = sb->s_dev;
 	fc->sb = sb;
@@ -1211,6 +1287,9 @@ int fuse_fill_super_common(struct super_block *sb,
 	dput(root_dentry);
  err_dev_free:
 	fuse_dev_free(fud);
+ err_free_ranges:
+	if (dax_dev)
+		fuse_free_dax_mem_ranges(&fc->free_ranges);
  err_put_conn:
 	fuse_conn_put(fc);
 	sb->s_fs_info = NULL;
diff --git a/fs/fuse/virtio_fs.c b/fs/fuse/virtio_fs.c
index ef1469b38a6d..c79c9a885253 100644
--- a/fs/fuse/virtio_fs.c
+++ b/fs/fuse/virtio_fs.c
@@ -451,6 +451,8 @@ static long virtio_fs_direct_access(struct dax_device *dax_dev, pgoff_t pgoff,
 	phys_addr_t offset = PFN_PHYS(pgoff);
 	size_t max_nr_pages = fs->window_len/PAGE_SIZE - pgoff;
 
+	pr_debug("virtio_fs_direct_access(): called. nr_pages=%ld max_nr_pages=%ld\n", nr_pages, max_nr_pages);
+
 	if (kaddr)
 		*kaddr = fs->window_kaddr + offset;
 	if (pfn)
-- 
2.13.6

