Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  13 Dec 2018 21:17:06 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 8BAE458079C;
	Wed, 12 Dec 2018 18:40:00 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 12 Dec 2018 18:39:58 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ACvCDSRxqwclEzJvXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0e4TKfad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXXdPUNhfVyJBAY2y?=
 =?us-ascii?q?YYUAAOUDMulEoIf9vEMOoBmlCAmwB+7i0CNEimP40KA41ekqDAHI3BYnH9ILqH?=
 =?us-ascii?q?naqM/6NLwVUeCz0aLHzS/Mb/VZ2Tzg74XIcAouoeqLXbN+a8XRz0YvGhjfjlqO?=
 =?us-ascii?q?tIPlPyma1vgXv2eH6OpgUPuihmg6oA9yujii3tkghpXNi44P11zJ+zt1zJwoKd?=
 =?us-ascii?q?C7VEJ3e9+pHZlIuy2EK4d7RtkuT3xmtSok0LEKpJ22cSYQxJg5xBPSbeGMfZKS?=
 =?us-ascii?q?7RL5TumRJC91hHJ7d7K7gBa/6VagyuLiWcmuylpKrTRKksPKtn8T0xzf8M+HSu?=
 =?us-ascii?q?Fy/ku52DaP0R7c6v1cLEwqiabWL4QtzqM+m5YNq0jPAyz7lFnsgKKXdEgo4u2o?=
 =?us-ascii?q?5P7mYrXiqJ+cLYh0igTmP6Qqm8y/B/k4MwcXU2iY5+u8zrvj8lP9QLlTif03nK?=
 =?us-ascii?q?/Zv47AJckAuK65DBFa0pw55xa8ETimytIYkmcDLF5ffxKHlYfpN0nUIP/kFfe/?=
 =?us-ascii?q?n0iskDBzyvDCP73hAYvCImLMkbf8Zrt9709cyAwuzdFQ/Z5UC7cBIO7tVU/1rt?=
 =?us-ascii?q?DXEhg5Mwmsyeb9FNp9zp8eWX6IAqKBMKPdq16I5v41LOmLfoMVuCv9JOIj5/7h?=
 =?us-ascii?q?lnI5nV4dfa+03ZoYcny4H/JmI1mHbnromNsODWAKvg8mRuzwlFKCSSJTZ2q1X6?=
 =?us-ascii?q?8k5DE7D5ypAZ3ARoCqhryB2iC7E4ZSZmBHDFCMDHjpe5+FW/cKdCKdPMthniYY?=
 =?us-ascii?q?WrimTo8rzQuuuxPiy7p7MurU/TUVuoj41Nh14O3Tlgs+9SZuAMSfyGyNS2B0nm?=
 =?us-ascii?q?UVRz45xqx/oEp9ykud3qh8mfBXCdtT5/ZRWAcgKZHc1/B6C8z1Wg/ZfdeGUlCm?=
 =?us-ascii?q?Ts+iATEwVN0xxdAObl15G9WjiBDDwiWrD6UUl7yNGJw77Kbc02LtKMZ6znbMzL?=
 =?us-ascii?q?MhgEU+QstTKW2mgbZy+BXJCI7XjUqVjaaqer4a3C7W6miDy22CvEVbUA51VaXI?=
 =?us-ascii?q?RnQfZkrQrdTk6ULOVb6uCbI7MgRfzc6OMLdFatrsjV9eXvfsJMzeY36tm2e3HR?=
 =?us-ascii?q?uH26mDbJT0dGkH3CXSEk4EkxsN8naALgU+Aiaho2TDDD1hD17vYkXs8fVgp3O/?=
 =?us-ascii?q?VEM70waKb0h53bqv5hEVneCcS+8U3r8cpCchqjB0HFGh39LWC9uMvRZhcL9bYd?=
 =?us-ascii?q?Mn5FdH1GTZtwNmM5ykLqBigEMecgtts0Pv0RV3FptPkcwwoHw2ywpyLLqS0Eld?=
 =?us-ascii?q?eDOAwZDwJrrXJ3Ho8xCrdaHX1U/R0daM9qgU9fQ3tk/svAeqFkol7XVqyN1V03?=
 =?us-ascii?q?qa5pXXAwseS5PxUkAr9xdko7HWeDUy54TR1Xd0K6m7rifC2841BOsi0huhf8pf?=
 =?us-ascii?q?PLmYGwPoEswaB9KhKOolm1WyahIEPeZS9LM7Ps+8dvuG3rKrM/hknD68kWtH54?=
 =?us-ascii?q?V92FqW9yVgUu7Iw4oFw/aA0wudVjfzkE2ustrqloBDfz0SGHSwyTLlBIJIeqJ9?=
 =?us-ascii?q?Z4ILBnqwLM2twdV+gYXgW3pZ9F6lGlMH19WleRuUb1zhwwJQ0V4brmCgmSu91z?=
 =?us-ascii?q?Z0iS0mrrKD3CzSxOTvbBoGOm9RSGhil1vsOpW0j9YBUUisbggpkgal5Engy6ha?=
 =?us-ascii?q?oqR/M3fcQUNScyfqKGFiV7O6tqCebM5X9JMorSJXXfy+YV+AUL79oBga0yT5E2?=
 =?us-ascii?q?tF3j87dDKqupT/nxNkjmKQN3JzrHvfecFtyhbT/t3cRfhN3jUYQCl0kyXYBl+5?=
 =?us-ascii?q?P9Ox59Wbi4/DsvyiV2KmTpBScTPkzYSauCu55G1qBwayn/Symt3hDAg73jX319?=
 =?us-ascii?q?hsVSXUshn8ZpPn2Li9MeJiZkNoHkPz69JmGoFilYs9nJIQ1mIbhpmP/XoHjH38?=
 =?us-ascii?q?MdNU2a/laHoNRDgLw8Pa4QT/2U1jKG6JyJz9VnmH3sRhYNy6aHsM2i0h98BKFL?=
 =?us-ascii?q?uU7LtckCtwo1q4rhjebeJznzgD0vsu9GAVg/sStwUz1CWdDasfHU1ZPSzqihSJ?=
 =?us-ascii?q?4MqyrKRRZGazb7ew0FByksymDLGHugtcQmr2eo8+HS9s6cVyKE7M0Hr26o3+ed?=
 =?us-ascii?q?jfd9QTtgCPkxfbjuhYM5YxlvsMhSp6NmPxp3wly+gnjRNw2ZG2ppSIK2Jo/Kih?=
 =?us-ascii?q?GB5XKiX1Z98P+jHqlatRhdyZ34erHpV8ADkLWIboQOmsEDITs/TnKgmPHCc9qn?=
 =?us-ascii?q?edBbrQAwuf5F16oHLIFpChL2uXK2UBzdV+WBmdI1RSgAIOUzU/gJE5DRqmxND7?=
 =?us-ascii?q?fEd6+zAR5UP4qh1WxeJzLBT/VmbfpAG1ajY7UpSfLRxW7h1c6EfRK8CR8uVzHy?=
 =?us-ascii?q?RA9J27sAONMnCbZxhPDWwRWk2EAE3jPqCz5dba9eiUHPG+L/zIYbWBsuFeU/aI?=
 =?us-ascii?q?xZSy0opp5TqMN8OPPmV8AP0/wEZMQXd5G8HBkTUVVyMXjz7Nb9KcpBqk+i14sM?=
 =?us-ascii?q?G/8PfoWALu/4ePCKFSMdJg+x+om6eDKvWQiT19KTZZ0JMM2HDJxKIe3F4UlyFh?=
 =?us-ascii?q?aT2tHa4cui7KSaLagrVXAAIDayNvKMtI6Lox0RNQOcHAkNP6yL55guQxC1dETl?=
 =?us-ascii?q?HhnsCpZcoXI2CyLl/HBUCLNKiYKj3P2c34faS8SbhIhuVOqxKwoSqbE1PkPjmb?=
 =?us-ascii?q?iznpVhWvPftQgy2BIBNeuJ+ychB2BGjnTdLmbAC7MdBtgT03x700mm3FNWoGPT?=
 =?us-ascii?q?dgdENNq6Wa7TlEjfVnB2xB8n1lIPGEmimD6enYL5cWsf1zDSV1l+JV+nI6y7RO?=
 =?us-ascii?q?4SFARfx1njbSr9F0r1GnlOmP1iRoUB5UpjlXg4KLuBYqBaKMvLxBUnbN8RZF1i?=
 =?us-ascii?q?PYNw8LvdhkDJen76VL1vDVma7zISsE+NXRq5gyHc/RfeCOK30neSXgHjGcWAkM?=
 =?us-ascii?q?Vjm0PGfQr1ZQnPGb6jueqZ1s+cuko4YHVrIODA99LfgdEEkwWYVaeJo=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAAAkxhFch0O0hNFjGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYFaghEUE4N8iBlfizOCDRSXP4FzFBgTAYRAgn4iNAkNAQM?=
 =?us-ascii?q?BAQEBAQECARMBAQEIDQkIKS+CNiQBgmEBAQEBAgEBAiAECwEFQQYJAQEIAhgCA?=
 =?us-ascii?q?iYCAgNUBg0GAgEBAYJRS4F5CAWLN5tQfDOFQIR2gQuLMReBQD+BESeCa4UBgwS?=
 =?us-ascii?q?CVwKGdolMkEoJjWqDZwYYgVyFGoJzEIdNii6PEYFGgg4zGggbFYMngicXjioyA?=
 =?us-ascii?q?QExgQUBARyMPgEB?=
X-IPAS-Result: =?us-ascii?q?A0AEAAAkxhFch0O0hNFjGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYFaghEUE4N8iBlfizOCDRSXP4FzFBgTAYRAgn4iNAkNAQMBAQEBAQECARMBA?=
 =?us-ascii?q?QEIDQkIKS+CNiQBgmEBAQEBAgEBAiAECwEFQQYJAQEIAhgCAiYCAgNUBg0GAgE?=
 =?us-ascii?q?BAYJRS4F5CAWLN5tQfDOFQIR2gQuLMReBQD+BESeCa4UBgwSCVwKGdolMkEoJj?=
 =?us-ascii?q?WqDZwYYgVyFGoJzEIdNii6PEYFGgg4zGggbFYMngicXjioyAQExgQUBARyMPgE?=
 =?us-ascii?q?B?=
X-IronPort-AV: E=Sophos;i="5.56,347,1539673200"; 
   d="scan'208";a="54979175"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 12 Dec 2018 18:39:58 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726633AbeLMCjy (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Wed, 12 Dec 2018 21:39:54 -0500
Received: from mx1.redhat.com ([209.132.183.28]:39062 "EHLO mx1.redhat.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726389AbeLMCjy (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Wed, 12 Dec 2018 21:39:54 -0500
Received: from smtp.corp.redhat.com (int-mx07.intmail.prod.int.phx2.redhat.com [10.5.11.22])
        (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
        (No client certificate requested)
        by mx1.redhat.com (Postfix) with ESMTPS id 0884430013DF;
        Thu, 13 Dec 2018 02:39:53 +0000 (UTC)
Received: from [10.72.12.167] (ovpn-12-167.pek2.redhat.com [10.72.12.167])
        by smtp.corp.redhat.com (Postfix) with ESMTPS id 9AF0E105706E;
        Thu, 13 Dec 2018 02:39:46 +0000 (UTC)
Subject: Re: [PATCH net V2 4/4] vhost: log dirty page correctly
To: "Michael S. Tsirkin" <mst@redhat.com>
Cc: kvm@vger.kernel.org, virtualization@lists.linux-foundation.org,
        netdev@vger.kernel.org, linux-kernel@vger.kernel.org,
        Jintack Lim <jintack@cs.columbia.edu>
References: <20181212100819.21295-1-jasowang@redhat.com>
 <20181212100819.21295-5-jasowang@redhat.com>
 <20181212092435-mutt-send-email-mst@kernel.org>
From: Jason Wang <jasowang@redhat.com>
Message-ID: <0239c220-e7ca-c08f-be26-eb9be63fced3@redhat.com>
Date: Thu, 13 Dec 2018 10:39:41 +0800
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
 Thunderbird/60.2.1
MIME-Version: 1.0
In-Reply-To: <20181212092435-mutt-send-email-mst@kernel.org>
Content-Type: text/plain; charset=utf-8; format=flowed
Content-Transfer-Encoding: 8bit
Content-Language: en-US
X-Scanned-By: MIMEDefang 2.84 on 10.5.11.22
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16 (mx1.redhat.com [10.5.110.44]); Thu, 13 Dec 2018 02:39:53 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org


On 2018/12/12 下午10:32, Michael S. Tsirkin wrote:
> On Wed, Dec 12, 2018 at 06:08:19PM +0800, Jason Wang wrote:
>> Vhost dirty page logging API is designed to sync through GPA. But we
>> try to log GIOVA when device IOTLB is enabled. This is wrong and may
>> lead to missing data after migration.
>>
>> To solve this issue, when logging with device IOTLB enabled, we will:
>>
>> 1) reuse the device IOTLB translation result of GIOVA->HVA mapping to
>>     get HVA, for writable descriptor, get HVA through iovec. For used
>>     ring update, translate its GIOVA to HVA
>> 2) traverse the GPA->HVA mapping to get the possible GPA and log
>>     through GPA. Pay attention this reverse mapping is not guaranteed
>>     to be unique, so we should log each possible GPA in this case.
>>
>> This fix the failure of scp to guest during migration. In -next, we
>> will probably support passing GIOVA->GPA instead of GIOVA->HVA.
>>
>> Fixes: 6b1e6cc7855b ("vhost: new device IOTLB API")
>> Reported-by: Jintack Lim <jintack@cs.columbia.edu>
>> Cc: Jintack Lim <jintack@cs.columbia.edu>
>> Signed-off-by: Jason Wang <jasowang@redhat.com>
> It's a nasty bug for sure but it's been like this for a long
> time so I'm inclined to say let's put it in 4.21,
> and queue for stable.
>
> So please split this out from this series.


Ok.


>
> Also, I'd like to see a feature bit that allows GPA in IOTLBs.


Just to make sure I understand this. It looks to me we should:

- allow passing GIOVA->GPA through UAPI

- cache GIOVA->GPA somewhere but still use GIOVA->HVA in device IOTLB 
for performance

Is this what you suggest?

Thanks


>
>> ---
>>   drivers/vhost/net.c   |  3 +-
>>   drivers/vhost/vhost.c | 79 +++++++++++++++++++++++++++++++++++--------
>>   drivers/vhost/vhost.h |  3 +-
>>   3 files changed, 69 insertions(+), 16 deletions(-)
>>
>> diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
>> index ad7a6f475a44..784df2b49628 100644
>> --- a/drivers/vhost/net.c
>> +++ b/drivers/vhost/net.c
>> @@ -1192,7 +1192,8 @@ static void handle_rx(struct vhost_net *net)
>>   		if (nvq->done_idx > VHOST_NET_BATCH)
>>   			vhost_net_signal_used(nvq);
>>   		if (unlikely(vq_log))
>> -			vhost_log_write(vq, vq_log, log, vhost_len);
>> +			vhost_log_write(vq, vq_log, log, vhost_len,
>> +					vq->iov, in);
>>   		total_len += vhost_len;
>>   		if (unlikely(vhost_exceeds_weight(++recv_pkts, total_len))) {
>>   			vhost_poll_queue(&vq->poll);
>> diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
>> index 55e5aa662ad5..3660310604fd 100644
>> --- a/drivers/vhost/vhost.c
>> +++ b/drivers/vhost/vhost.c
>> @@ -1733,11 +1733,67 @@ static int log_write(void __user *log_base,
>>   	return r;
>>   }
>>   
>> +static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
>> +{
>> +	struct vhost_umem *umem = vq->umem;
>> +	struct vhost_umem_node *u;
>> +	u64 gpa;
>> +	int r;
>> +	bool hit = false;
>> +
>> +	list_for_each_entry(u, &umem->umem_list, link) {
>> +		if (u->userspace_addr < hva &&
>> +		    u->userspace_addr + u->size >=
>> +		    hva + len) {
>> +			gpa = u->start + hva - u->userspace_addr;
>> +			r = log_write(vq->log_base, gpa, len);
>> +			if (r < 0)
>> +				return r;
>> +			hit = true;
>> +		}
>> +	}
>> +
>> +	/* No reverse mapping, should be a bug */
>> +	WARN_ON(!hit);
> Maybe it should but userspace can trigger this easily I think.
> We need to stop the device not warn in kernel log.
>
> Also there's an error fd: VHOST_SET_VRING_ERR, need to wake it up.
>

Ok.


>> +	return 0;
>> +}
>> +
>> +static void log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
>> +{
>> +	struct iovec iov[64];
>> +	int i, ret;
>> +
>> +	if (!vq->iotlb) {
>> +		log_write(vq->log_base, vq->log_addr + used_offset, len);
>> +		return;
>> +	}
> This change seems questionable. used ring writes
> use their own machinery it does not go through iotlb.
> Same should apply to log I think.


The problem is used ring may not be physically contiguous with Device 
IOTLB enabled. So it should go through it.


>
>> +
>> +	ret = translate_desc(vq, (u64)(uintptr_t)vq->used + used_offset,
>> +			     len, iov, 64, VHOST_ACCESS_WO);
>> +	WARN_ON(ret < 0);
>
> Same thing here. translation failures can be triggered from guest.
> warn on is not a good error handling strategy ...


Ok. Let me fix it.


Thanks


>> +
>> +	for (i = 0; i < ret; i++) {
>> +		ret = log_write_hva(vq,	(u64)(uintptr_t)iov[i].iov_base,
>> +				    iov[i].iov_len);
>> +		WARN_ON(ret);
>> +	}
>> +}
>> +
>>   int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
>> -		    unsigned int log_num, u64 len)
>> +		    unsigned int log_num, u64 len, struct iovec *iov, int count)
>>   {
>>   	int i, r;
>>   
>> +	if (vq->iotlb) {
>> +		for (i = 0; i < count; i++) {
>> +			r = log_write_hva(vq, (u64)(uintptr_t)iov[i].iov_base,
>> +					  iov[i].iov_len);
>> +			if (r < 0)
>> +				return r;
>> +		}
>> +		return 0;
>> +	}
>> +
>>   	/* Make sure data written is seen before log. */
>>   	smp_wmb();
>>   	for (i = 0; i < log_num; ++i) {
>> @@ -1769,9 +1825,8 @@ static int vhost_update_used_flags(struct vhost_virtqueue *vq)
>>   		smp_wmb();
>>   		/* Log used flag write. */
>>   		used = &vq->used->flags;
>> -		log_write(vq->log_base, vq->log_addr +
>> -			  (used - (void __user *)vq->used),
>> -			  sizeof vq->used->flags);
>> +		log_used(vq, (used - (void __user *)vq->used),
>> +			 sizeof vq->used->flags);
>>   		if (vq->log_ctx)
>>   			eventfd_signal(vq->log_ctx, 1);
>>   	}
>> @@ -1789,9 +1844,8 @@ static int vhost_update_avail_event(struct vhost_virtqueue *vq, u16 avail_event)
>>   		smp_wmb();
>>   		/* Log avail event write */
>>   		used = vhost_avail_event(vq);
>> -		log_write(vq->log_base, vq->log_addr +
>> -			  (used - (void __user *)vq->used),
>> -			  sizeof *vhost_avail_event(vq));
>> +		log_used(vq, (used - (void __user *)vq->used),
>> +			 sizeof *vhost_avail_event(vq));
>>   		if (vq->log_ctx)
>>   			eventfd_signal(vq->log_ctx, 1);
>>   	}
>> @@ -2191,10 +2245,8 @@ static int __vhost_add_used_n(struct vhost_virtqueue *vq,
>>   		/* Make sure data is seen before log. */
>>   		smp_wmb();
>>   		/* Log used ring entry write. */
>> -		log_write(vq->log_base,
>> -			  vq->log_addr +
>> -			   ((void __user *)used - (void __user *)vq->used),
>> -			  count * sizeof *used);
>> +		log_used(vq, ((void __user *)used - (void __user *)vq->used),
>> +			 count * sizeof *used);
>>   	}
>>   	old = vq->last_used_idx;
>>   	new = (vq->last_used_idx += count);
>> @@ -2236,9 +2288,8 @@ int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
>>   		/* Make sure used idx is seen before log. */
>>   		smp_wmb();
>>   		/* Log used index update. */
>> -		log_write(vq->log_base,
>> -			  vq->log_addr + offsetof(struct vring_used, idx),
>> -			  sizeof vq->used->idx);
>> +		log_used(vq, offsetof(struct vring_used, idx),
>> +			 sizeof vq->used->idx);
>>   		if (vq->log_ctx)
>>   			eventfd_signal(vq->log_ctx, 1);
>>   	}
>> diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
>> index 466ef7542291..1b675dad5e05 100644
>> --- a/drivers/vhost/vhost.h
>> +++ b/drivers/vhost/vhost.h
>> @@ -205,7 +205,8 @@ bool vhost_vq_avail_empty(struct vhost_dev *, struct vhost_virtqueue *);
>>   bool vhost_enable_notify(struct vhost_dev *, struct vhost_virtqueue *);
>>   
>>   int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
>> -		    unsigned int log_num, u64 len);
>> +		    unsigned int log_num, u64 len,
>> +		    struct iovec *iov, int count);
>>   int vq_iotlb_prefetch(struct vhost_virtqueue *vq);
>>   
>>   struct vhost_msg_node *vhost_new_msg(struct vhost_virtqueue *vq, int type);
>> -- 
>> 2.17.1
