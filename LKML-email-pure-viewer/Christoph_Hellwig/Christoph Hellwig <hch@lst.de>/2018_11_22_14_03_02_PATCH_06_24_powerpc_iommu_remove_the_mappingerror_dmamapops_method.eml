Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 22 Nov 2018 22:27:08 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 2391758040F;
	Thu, 22 Nov 2018 06:04:00 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by fmsmga006-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 06:03:59 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AOfj2xhZcZLcI35jCesjQs2r/LSx+4OfEezUN459i?=
 =?us-ascii?q?sYplN5qZpci5bB7h7PlgxGXEQZ/co6odzbaO4+a4ASQp2tWoiDg6aptCVhsI24?=
 =?us-ascii?q?09vjcLJ4q7M3D9N+PgdCcgHc5PBxdP9nC/NlVJSo6lPwWB6nK94iQPFRrhKAF7?=
 =?us-ascii?q?Ovr6GpLIj8Swyuu+54Dfbx9HiTahYr5+Ngm6oRnMvcQKnIVuLbo8xAHUqXVSYe?=
 =?us-ascii?q?RWwm1oJVOXnxni48q74YBu/SdNtf8/7sBMSar1cbg2QrxeFzQmLns65Nb3uhnZ?=
 =?us-ascii?q?TAuA/WUTX2MLmRdVGQfF7RX6XpDssivms+d2xSeXMdHqQb0yRD+v9LlgRgP2hy?=
 =?us-ascii?q?gbNj456GDXhdJ2jKJHuxKquhhzz5fJbI2JKPZye6XQds4YS2VcRMZcTyxPDJ2h?=
 =?us-ascii?q?YYUBDOQPOuRXr4fyqFUBthu+HQuhCfjzxjJLnHL6wbc33/g9HQzAwQcuH8gOsH?=
 =?us-ascii?q?PRrNjtKqoSUfq1zKjTzTXfaPNWwTf945XKfB8/pfGMWbxxccveyUIyEA7Fjkmf?=
 =?us-ascii?q?qYz+MjORzeQNr3KX4Pd+Wu+2jWMstgJ/oiC3y8syloXEgpgZxk3K+Cln2oo5ON?=
 =?us-ascii?q?61RFJhbdOlEpZcryKXOoVsTs8/QWxluDw2x78EtJKhYSQG1IoryhjCYPKdaYeI?=
 =?us-ascii?q?+AjsVOOJLDd4mn1lfLW/ig6s8Uiv1OL8TNO40FVUoSpflNnDqHQN2wbU6sidRf?=
 =?us-ascii?q?tx5kah2TCR2ADP8uxIP1w4mK7BJ5I8zLM8iIAfvVnAEyPqgkn7ja2bel0h+uey?=
 =?us-ascii?q?6uTnZrvmpoWbN49xkgz+NqUumsqiAeU3KwQOXHaU+f661LL9+U31WbJKj/Mwkq?=
 =?us-ascii?q?bHqpDXPtobpqGnDA9PyIoj6AiwDy2g0NsGmXkLNlVFeAiIj4TxIVHBPOj4Deuj?=
 =?us-ascii?q?g1SriDprw/HGPr7/DZnXIXnDjazsfbJ8605a1QoywspT55NSCrEdPv3zXlX9u8?=
 =?us-ascii?q?DfDh88Kwa02froCM1h1oMCXmKCGq+ZP7nTsV+U/O0vJPOAZI8IuDnnLfgl6OXj?=
 =?us-ascii?q?jXs4mV8bYKmo0oEbaHG+HvR6PUqZZWDgjcsGEWcPpgA+VvDliEWeUT5PYHa/R6?=
 =?us-ascii?q?A85jYlB468DofDQYatgLqG3CqgGp1WZ2ZGCk2DEHvydoWEXesMZzyWIsN7jjME?=
 =?us-ascii?q?Ur2hQZc71R6yrA/616ZnLu3M9yICrpLj1N915+7JmREo7zN0Dd+Q02WMT2Fyg2?=
 =?us-ascii?q?MJSCU63KF5oUxh1FiD1bJ0jOBfFdxW//lJSBs1NYbAz+xmDND/QgHBcc2PSFq8?=
 =?us-ascii?q?RtWmACs+TtQ+w9IVZ0Z9GtOijg3M3iawAr8VkaCLC4Iw8q7Gw3fxIMN9wW7c1K?=
 =?us-ascii?q?Y9l1kmXtdPNWq+i6Fi7QfTGZDGn1+Zl6mwc6QcxzDC9GGEwWqKv0FYVQpwXL7B?=
 =?us-ascii?q?XXAeYEvWsNv46lnDT7+oFbQoLA9BxdSeJatNb93jlU9GS+v7ONTCf2KxnH+9Cg?=
 =?us-ascii?q?uSybOScoXmYWUd0z/bCEgfjQ8T+22LNQw/BienvmLfAyZiFVPpY0Pw7+Z+rGm3?=
 =?us-ascii?q?QVMzzwGPd0dhzaa6+gYJhfyATPMexq4EuCYkqzVzAFa939LXB8CcpwZ7e6Vce9?=
 =?us-ascii?q?c94FZB1WLWrAF9Op2gL6Z/hl8RaQh3vkXu1wlpBYVEi8QlsHQqzA9qI6KCzFxB?=
 =?us-ascii?q?by+Y3Yz3OrDPMGby+A6gaqHI1VDeytqZ4boP5+kipFXlvwGpEVQi/m5j09lU1X?=
 =?us-ascii?q?uc+5rLABATUZL3TkY46Rx6q6vGbSk64oPezWdsPrWssj/ex9IpA/Moyxa9f9tF?=
 =?us-ascii?q?LKyIDg7zE80ACMioJ+wngFypbhMCPOBP+684JcKmd/2a2KG1OOZshi6pjWNC4I?=
 =?us-ascii?q?plyEKD6zJ8SvLU35YC2/yYxAqHWCvmg1e7r8/3nppIZTcMEWqlyCjoHZJeabd2?=
 =?us-ascii?q?fYkWF2iuOcq3xtNlip7pWn5Y8kOjBlwc1M+ofxqSc0Ly3QlK2UsLpnynnDOyzy?=
 =?us-ascii?q?ZonDExsqqfwCvOzvzidRoGIGJKRHNujUzxIYiylN0aWEmobw40lBqq/0r6xq5b?=
 =?us-ascii?q?pLhhIGnXW0tHYy/2L2R6WKuqqrWCe9JP6I8vsShPUuSze0qaSr3+oxsdyS/jBH?=
 =?us-ascii?q?FRxDM4dzGrvJX2gRp6hXmZLHZyqnrZZM5xyQ3e5NzaWf5ewD4GSDNkhjnQA1i2?=
 =?us-ascii?q?J8Op8smMl5ffruC+UHqsV51Jfins14+Atiq75WtxDB27nvCznMDnEAcg3S/60d?=
 =?us-ascii?q?lqSTvHrBLmbob30KS6NPptflN0C1/k98p6BoZ+n5MzhJ4K2HgWnJWV/Wcdnmf1?=
 =?us-ascii?q?PtVWwqb+bHsLRT4WzN/Z+gnl2Et/Ln2Xw4L1TGmSwsxkZ9OieGMZxjo979xWCK?=
 =?us-ascii?q?eT9LFEmCp1olmiog7Lb/lygCwdyecw534AmO4GphAtziqGD7AWHElYOzHslhuS?=
 =?us-ascii?q?49C/qqVXeHigcbyq2EVimtChCamIohtAV3bhZpciAShw491jMFLL1X3/8IDld8?=
 =?us-ascii?q?PWbdIOrR2UiBbAgvNRKJIwkPoKmCVmNXj8vX0j1+40kxhu0Yums4iALmVn5Li5?=
 =?us-ascii?q?DQJANj3pe8MT/Snggr1EkcaR24CvA49tGjEWXJbzSfKoETQStenoNgqUET08rG?=
 =?us-ascii?q?ubFqTbHQOF9EhmqHfPGYixN36LPHkZ0cliRB6FKUxdmg8UWSs1noUjGgC23sDh?=
 =?us-ascii?q?c1p55jMM5l7+sBRM0fllNx3+UmfZuQepZS04SJmZLBpK8A5C413ZPtCZ7uJ2By?=
 =?us-ascii?q?tY5IGurBSRKmyHYARFFWEIWkuZB1D6I7mh/9/A//KDBuq5KfvObq6DqehfV/eO?=
 =?us-ascii?q?2JKu3ZFq/zeKNsWTIHZiC+c31VZEXXB8A87ZgSkASzQLlyLRaM6WvBe89TN2rs?=
 =?us-ascii?q?C88/TrWRjj5YiVC7tVPtVg5Qq2gbqYN+OLgCZ5KDBY1o4DxHPSybgf2kIShD9q?=
 =?us-ascii?q?dzW3DbsAsivNRrrKmqBLFx4bdz9zNMxQ4q0mwwlCItTbhc3117Jiiv41CkxIVV?=
 =?us-ascii?q?jgmsGveMwLLHuxNFLBBEaXKruGISfHzN3wYaO5UbdQlvlbtwWsuTaHFE/uJiiD?=
 =?us-ascii?q?lzjsVxy1Le5Alj2UPBxAt4G7aRttDWnjTNT7ahy0KtN3jDs2waEqiXPOL2ITLT?=
 =?us-ascii?q?98c0ZVpL2K8SxYmul/G3BG7nd9LeiLgSCZ7+zZKpYQqfRqAyR0mPhc4HQ10LZV?=
 =?us-ascii?q?6CBERPpomCrdtNJuolemkvWRxTpjShZBtjFLhIfY9XllbKTe85xdcXLF5w4Wq2?=
 =?us-ascii?q?GRDQka4tViF9vjsrxRzd6Jk7j8exlY9NeB1ssGBtPIL9qHeFosNR72GTGcWAsO?=
 =?us-ascii?q?TRavLn2Zi0ELw6LazWGcspVv8suko5EJULIOEQVtTv4=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ATAABdtvZbh0O0hNFiHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBg2snjBBfiyJSBoFJZogejiKBcywTAYhRIjQJDQEDAQEBAQEBAgE?=
 =?us-ascii?q?TAQEBCA0JCCkjDII2JAGCYgMDAQIkCwENAQE3AQUJAQFQA1QZBYMcgXUNBAGpA?=
 =?us-ascii?q?4FsM4J2AQEFhyIIh16EKxd4gQeBEYJdiw6JGwYEgW6FTY8kCYERiRiGeyORCCy?=
 =?us-ascii?q?ZSoINMxoIHBSDJ4IbDBeIXoU/PzKBAgMBASETjHUBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ATAABdtvZbh0O0hNFiHAEBAQQBAQcEAQGBUQcBAQsBg2s?=
 =?us-ascii?q?njBBfiyJSBoFJZogejiKBcywTAYhRIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjD?=
 =?us-ascii?q?II2JAGCYgMDAQIkCwENAQE3AQUJAQFQA1QZBYMcgXUNBAGpA4FsM4J2AQEFhyI?=
 =?us-ascii?q?Ih16EKxd4gQeBEYJdiw6JGwYEgW6FTY8kCYERiRiGeyORCCyZSoINMxoIHBSDJ?=
 =?us-ascii?q?4IbDBeIXoU/PzKBAgMBASETjHUBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="52980925"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 06:03:57 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2395429AbeKWAnY (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 19:43:24 -0500
Received: from bombadil.infradead.org ([198.137.202.133]:56680 "EHLO
        bombadil.infradead.org" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2391646AbeKWAnV (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 19:43:21 -0500
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
        d=infradead.org; s=bombadil.20170209; h=Content-Transfer-Encoding:
        MIME-Version:References:In-Reply-To:Message-Id:Date:Subject:Cc:To:From:Sender
        :Reply-To:Content-Type:Content-ID:Content-Description:Resent-Date:Resent-From
        :Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:List-Id:List-Help:
        List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive;
        bh=P+UvCct1WNWlr7BvnCUjU9cL23hPt3qBaGIteJJVSYQ=; b=dNw2vxuFSv5fXvc/yRTT7kSWLt
        xFiuCR5hXtVvu+t/NarkRa6zpjJ4F2MJf0BJbW9y28/BPgzfEMWPCqHBLs5TB7abJOzTau/nka44F
        qVPtXND++PsQO1COFClUSkikidfaxJ3lGMEShSosHx5gmUBHdEtZQlOP3FWJbIX4oOPRtL5S4UyK+
        aJIftIFgWloMthSLfiaO5TRiFwMEKhnvJRdmMok522hOtoGj2KT46ccxpsPwMd4U4YbSC/fWzrBhO
        VvR8nJ08k8vcfG3pq4llEpNpxkOGpDmUTvLwrowVLmTR4kTP2vTAKpKmX+U6tdopmU1/qzgZGQRoB
        H8ORvWQw==;
Received: from clnet-p19-102.ikbnet.co.at ([83.175.77.102] helo=localhost)
        by bombadil.infradead.org with esmtpsa (Exim 4.90_1 #2 (Red Hat Linux))
        id 1gPpa2-0007rA-79; Thu, 22 Nov 2018 14:03:42 +0000
From: Christoph Hellwig <hch@lst.de>
To: iommu@lists.linux-foundation.org
Cc: Linus Torvalds <torvalds@linux-foundation.org>,
        Jon Mason <jdmason@kudzu.us>, Joerg Roedel <joro@8bytes.org>,
        David Woodhouse <dwmw2@infradead.org>,
        Marek Szyprowski <m.szyprowski@samsung.com>,
        Robin Murphy <robin.murphy@arm.com>, x86@kernel.org,
        linux-alpha@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
        linux-ia64@vger.kernel.org, linux-parisc@vger.kernel.org,
        xen-devel@lists.xenproject.org, linux-arch@vger.kernel.org,
        linux-kernel@vger.kernel.org
Subject: [PATCH 06/24] powerpc/iommu: remove the mapping_error dma_map_ops method
Date: Thu, 22 Nov 2018 15:03:02 +0100
Message-Id: <20181122140320.24080-7-hch@lst.de>
X-Mailer: git-send-email 2.19.1
In-Reply-To: <20181122140320.24080-1-hch@lst.de>
References: <20181122140320.24080-1-hch@lst.de>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-SRS-Rewrite: SMTP reverse-path rewritten from <hch@infradead.org> by bombadil.infradead.org. See http://www.infradead.org/rpr.html
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

The powerpc iommu code already returns (~(dma_addr_t)0x0) on mapping
failures, so we can switch over to returning DMA_MAPPING_ERROR and let
the core dma-mapping code handle the rest.

Signed-off-by: Christoph Hellwig <hch@lst.de>
---
 arch/powerpc/include/asm/iommu.h     |  4 ----
 arch/powerpc/kernel/dma-iommu.c      |  6 ------
 arch/powerpc/kernel/iommu.c          | 28 ++++++++++++++--------------
 arch/powerpc/platforms/cell/iommu.c  |  1 -
 arch/powerpc/platforms/pseries/vio.c |  3 +--
 5 files changed, 15 insertions(+), 27 deletions(-)

diff --git a/arch/powerpc/include/asm/iommu.h b/arch/powerpc/include/asm/iommu.h
index 35db0cbc9222..55312990d1d2 100644
--- a/arch/powerpc/include/asm/iommu.h
+++ b/arch/powerpc/include/asm/iommu.h
@@ -143,8 +143,6 @@ struct scatterlist;
 
 #ifdef CONFIG_PPC64
 
-#define IOMMU_MAPPING_ERROR		(~(dma_addr_t)0x0)
-
 static inline void set_iommu_table_base(struct device *dev,
 					struct iommu_table *base)
 {
@@ -242,8 +240,6 @@ static inline int __init tce_iommu_bus_notifier_init(void)
 }
 #endif /* !CONFIG_IOMMU_API */
 
-int dma_iommu_mapping_error(struct device *dev, dma_addr_t dma_addr);
-
 #else
 
 static inline void *get_iommu_table_base(struct device *dev)
diff --git a/arch/powerpc/kernel/dma-iommu.c b/arch/powerpc/kernel/dma-iommu.c
index f9fe2080ceb9..5ebacf0fe41a 100644
--- a/arch/powerpc/kernel/dma-iommu.c
+++ b/arch/powerpc/kernel/dma-iommu.c
@@ -106,11 +106,6 @@ static u64 dma_iommu_get_required_mask(struct device *dev)
 	return mask;
 }
 
-int dma_iommu_mapping_error(struct device *dev, dma_addr_t dma_addr)
-{
-	return dma_addr == IOMMU_MAPPING_ERROR;
-}
-
 struct dma_map_ops dma_iommu_ops = {
 	.alloc			= dma_iommu_alloc_coherent,
 	.free			= dma_iommu_free_coherent,
@@ -121,6 +116,5 @@ struct dma_map_ops dma_iommu_ops = {
 	.map_page		= dma_iommu_map_page,
 	.unmap_page		= dma_iommu_unmap_page,
 	.get_required_mask	= dma_iommu_get_required_mask,
-	.mapping_error		= dma_iommu_mapping_error,
 };
 EXPORT_SYMBOL(dma_iommu_ops);
diff --git a/arch/powerpc/kernel/iommu.c b/arch/powerpc/kernel/iommu.c
index f0dc680e659a..ca7f73488c62 100644
--- a/arch/powerpc/kernel/iommu.c
+++ b/arch/powerpc/kernel/iommu.c
@@ -197,11 +197,11 @@ static unsigned long iommu_range_alloc(struct device *dev,
 	if (unlikely(npages == 0)) {
 		if (printk_ratelimit())
 			WARN_ON(1);
-		return IOMMU_MAPPING_ERROR;
+		return DMA_MAPPING_ERROR;
 	}
 
 	if (should_fail_iommu(dev))
-		return IOMMU_MAPPING_ERROR;
+		return DMA_MAPPING_ERROR;
 
 	/*
 	 * We don't need to disable preemption here because any CPU can
@@ -277,7 +277,7 @@ static unsigned long iommu_range_alloc(struct device *dev,
 		} else {
 			/* Give up */
 			spin_unlock_irqrestore(&(pool->lock), flags);
-			return IOMMU_MAPPING_ERROR;
+			return DMA_MAPPING_ERROR;
 		}
 	}
 
@@ -309,13 +309,13 @@ static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,
 			      unsigned long attrs)
 {
 	unsigned long entry;
-	dma_addr_t ret = IOMMU_MAPPING_ERROR;
+	dma_addr_t ret = DMA_MAPPING_ERROR;
 	int build_fail;
 
 	entry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);
 
-	if (unlikely(entry == IOMMU_MAPPING_ERROR))
-		return IOMMU_MAPPING_ERROR;
+	if (unlikely(entry == DMA_MAPPING_ERROR))
+		return DMA_MAPPING_ERROR;
 
 	entry += tbl->it_offset;	/* Offset into real TCE table */
 	ret = entry << tbl->it_page_shift;	/* Set the return dma address */
@@ -327,12 +327,12 @@ static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,
 
 	/* tbl->it_ops->set() only returns non-zero for transient errors.
 	 * Clean up the table bitmap in this case and return
-	 * IOMMU_MAPPING_ERROR. For all other errors the functionality is
+	 * DMA_MAPPING_ERROR. For all other errors the functionality is
 	 * not altered.
 	 */
 	if (unlikely(build_fail)) {
 		__iommu_free(tbl, ret, npages);
-		return IOMMU_MAPPING_ERROR;
+		return DMA_MAPPING_ERROR;
 	}
 
 	/* Flush/invalidate TLB caches if necessary */
@@ -477,7 +477,7 @@ int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 		DBG("  - vaddr: %lx, size: %lx\n", vaddr, slen);
 
 		/* Handle failure */
-		if (unlikely(entry == IOMMU_MAPPING_ERROR)) {
+		if (unlikely(entry == DMA_MAPPING_ERROR)) {
 			if (!(attrs & DMA_ATTR_NO_WARN) &&
 			    printk_ratelimit())
 				dev_info(dev, "iommu_alloc failed, tbl %p "
@@ -544,7 +544,7 @@ int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 	 */
 	if (outcount < incount) {
 		outs = sg_next(outs);
-		outs->dma_address = IOMMU_MAPPING_ERROR;
+		outs->dma_address = DMA_MAPPING_ERROR;
 		outs->dma_length = 0;
 	}
 
@@ -562,7 +562,7 @@ int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,
 			npages = iommu_num_pages(s->dma_address, s->dma_length,
 						 IOMMU_PAGE_SIZE(tbl));
 			__iommu_free(tbl, vaddr, npages);
-			s->dma_address = IOMMU_MAPPING_ERROR;
+			s->dma_address = DMA_MAPPING_ERROR;
 			s->dma_length = 0;
 		}
 		if (s == outs)
@@ -776,7 +776,7 @@ dma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,
 			  unsigned long mask, enum dma_data_direction direction,
 			  unsigned long attrs)
 {
-	dma_addr_t dma_handle = IOMMU_MAPPING_ERROR;
+	dma_addr_t dma_handle = DMA_MAPPING_ERROR;
 	void *vaddr;
 	unsigned long uaddr;
 	unsigned int npages, align;
@@ -796,7 +796,7 @@ dma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,
 		dma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,
 					 mask >> tbl->it_page_shift, align,
 					 attrs);
-		if (dma_handle == IOMMU_MAPPING_ERROR) {
+		if (dma_handle == DMA_MAPPING_ERROR) {
 			if (!(attrs & DMA_ATTR_NO_WARN) &&
 			    printk_ratelimit())  {
 				dev_info(dev, "iommu_alloc failed, tbl %p "
@@ -868,7 +868,7 @@ void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,
 	io_order = get_iommu_order(size, tbl);
 	mapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,
 			      mask >> tbl->it_page_shift, io_order, 0);
-	if (mapping == IOMMU_MAPPING_ERROR) {
+	if (mapping == DMA_MAPPING_ERROR) {
 		free_pages((unsigned long)ret, order);
 		return NULL;
 	}
diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c
index 12352a58072a..af2a3c15e0ec 100644
--- a/arch/powerpc/platforms/cell/iommu.c
+++ b/arch/powerpc/platforms/cell/iommu.c
@@ -654,7 +654,6 @@ static const struct dma_map_ops dma_iommu_fixed_ops = {
 	.dma_supported  = dma_suported_and_switch,
 	.map_page       = dma_fixed_map_page,
 	.unmap_page     = dma_fixed_unmap_page,
-	.mapping_error	= dma_iommu_mapping_error,
 };
 
 static void cell_dma_dev_setup(struct device *dev)
diff --git a/arch/powerpc/platforms/pseries/vio.c b/arch/powerpc/platforms/pseries/vio.c
index 88f1ad1d6309..a29ad7db918a 100644
--- a/arch/powerpc/platforms/pseries/vio.c
+++ b/arch/powerpc/platforms/pseries/vio.c
@@ -519,7 +519,7 @@ static dma_addr_t vio_dma_iommu_map_page(struct device *dev, struct page *page,
 {
 	struct vio_dev *viodev = to_vio_dev(dev);
 	struct iommu_table *tbl;
-	dma_addr_t ret = IOMMU_MAPPING_ERROR;
+	dma_addr_t ret = DMA_MAPPING_ERROR;
 
 	tbl = get_iommu_table_base(dev);
 	if (vio_cmo_alloc(viodev, roundup(size, IOMMU_PAGE_SIZE(tbl)))) {
@@ -625,7 +625,6 @@ static const struct dma_map_ops vio_dma_mapping_ops = {
 	.unmap_page        = vio_dma_iommu_unmap_page,
 	.dma_supported     = vio_dma_iommu_dma_supported,
 	.get_required_mask = vio_dma_get_required_mask,
-	.mapping_error	   = dma_iommu_mapping_error,
 };
 
 /**
-- 
2.19.1

