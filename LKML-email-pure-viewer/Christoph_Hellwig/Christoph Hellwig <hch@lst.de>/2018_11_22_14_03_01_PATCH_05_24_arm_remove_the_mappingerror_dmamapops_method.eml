Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 22 Nov 2018 22:27:15 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga006.jf.intel.com (orsmga006.jf.intel.com [10.7.209.51])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 8CD1958037D;
	Thu, 22 Nov 2018 06:04:42 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by orsmga006-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 06:04:42 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AD9bikR2vP7XVnQ1EsmDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?segSKfTxwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfFjfK3SYMkaSHJBUMhPSiJPDICy?=
 =?us-ascii?q?YYwNAOoPMulWoJL9p0MMoBalGQWhB/nixiNSi3PqwaE31fkqHwHc3AwnGtIDqG?=
 =?us-ascii?q?rZrNXvNKcTSuC10K7IzS3Db/hL2zny9ozIchQvoPGNUrJ7bM3cyUkzGAPFlViQ?=
 =?us-ascii?q?rZflPy+P2usQrWeW9uxtXv+shW4/swx9vCSjy8M2hoXUiI8Z1ErI+Th6zYopP9?=
 =?us-ascii?q?G1SUx2bcanHZZerS2WKol7T8M4T2xquis20KAKtYKlcCUM1Z8p3QTQa+adfIiN?=
 =?us-ascii?q?+h/jVPieITN/hH99ZrK/iAi98VK6xu3/SMa0ylBKoTRBktXWsXANzRPT5tCGSv?=
 =?us-ascii?q?t74EihxS6C2x7P5uxAO0w4iKTWJ4A7zrItlZcfrV7PEy70lUnuia+ZbEQk+uym?=
 =?us-ascii?q?6+T9ZbXmo4eRN4t1igH4L6QvldWzAecmPQgUWWiU5+C82KTk/Uz3RrVFkOc2n7?=
 =?us-ascii?q?LHsJDVO8sbvLS1AwxL3YY57RawETOm3M4fnXkdI1JJYAiHgJTxO1HSPPD4Cu+y?=
 =?us-ascii?q?g1CtkDdo2f/KJLLgAojWI3jHkbfhe6t96kFGxAoyy9Bf+4xbCrUbLP3vXU/xsc?=
 =?us-ascii?q?TSDgUlPAys3+bnFNJ925seWW2VA6+ZLLndsViS6uIvPumDfokVuDnmJvgh5v7u?=
 =?us-ascii?q?i2I5mFAHcamo25sXdG63HvB8L0qFZnrsh88LEX0WsQomUOzqlFqCXCZRZ3a1Qa?=
 =?us-ascii?q?0w/DI7CIWgDYfFQYCgm7iB3Ca9Hp1LaWFKEFGMEXH0d4qaX/cAcj6dIshkkjYc?=
 =?us-ascii?q?T7iuV5ch1Q2ytA/907doNPHU+i0ftZLgztR1/ffclRMp+DxwDsSd1XyNTm5ukm?=
 =?us-ascii?q?MJQT82wL5woUhnxlif1qh4huRSFcZP6PNRTgc6KZncwvR5C9/oXALNZNOJSFe8?=
 =?us-ascii?q?TdWgDjE8VdYxw94IY0ZgFNSulBHD3yy2A7ALk7yHHoA78qXZ33LpPcZy127G1L?=
 =?us-ascii?q?U9j1khWsZAKHephrBh+ATJB47GiUOZl720eqQa2yLN8GSDzW+KvExDVA5wUKPF?=
 =?us-ascii?q?XW0QZ0fMrNT54F/CQKGqCbg9LgRBzsuCILNQatL1lVVGWOvjONPGbm2sgWiwGw?=
 =?us-ascii?q?iHyqmMbIXwfWUdxzvSCE4fngAX/HaGMxU+Byi7r2LfCjxuCUzgY0f2/eZir3O7?=
 =?us-ascii?q?S1c+zxuWYE15y7q15hkViOSAS/MS27IEvzshqzV0HVqnw9LaEd2ApxBlfKVdZ9?=
 =?us-ascii?q?M970xK1WbYtwx7I5yhILpuhl8YcwRroUzu0w97BZlHkcgvtHkq1hZ9KbqE0FNd?=
 =?us-ascii?q?cDOVxYr/OrnJJWj94h+ua7Ta1UrD0NmL4KgP7vc4q1L9vAyyEkoi8nNn08Ra0n?=
 =?us-ascii?q?eG55XKChYSXoz1Ukot6xd6oLTaaDEn54zIzX1sLbW0sjja1tMpGesp0Aqvc81e?=
 =?us-ascii?q?MaOEDgDyFcIaCtOqKOwrnVipcx0FMPpT9K4yI8Opaf+G1LS3M+ZnmTKslX5H75?=
 =?us-ascii?q?xl0kKQ6yp8TfbF34wEw/6ExASHTSrzjFC7vsDxh49EfzASEnOjxif+AI5ee7N9?=
 =?us-ascii?q?fZwMCWeoOMC3wtR+h5jwW39X7lKjBlUG2NO3dhqWdVDywQpQ1UEPq3y9hSS41y?=
 =?us-ascii?q?B0ky0urqeH3C3Owv7udRodNm5QWWlii0zhIYy1j9AcQUipYBIllBqj5Ubm2adb?=
 =?us-ascii?q?oL5zIHXUQUdNZyL2NX1tUrOstrqeZM5C8JEovj9NUOS/YlCaTaTxowAA3CPgHG?=
 =?us-ascii?q?texTY7eC+supjimxx6iWSdLGt8rXbDeMFwwwvf68LYRfJLwjUGQyx4gyHNBleg?=
 =?us-ascii?q?J9mp4cmUl5Dbv+G+TW2hUYdfcSvqzYOGrya74WxqARuin/G8gNHnEA460TPl2N?=
 =?us-ascii?q?luTynHsBH8Yozz3aSgLe1nZlVoBEP768diGYFxiIowiIsQ2XgHnJqV+3UHnHz3?=
 =?us-ascii?q?MdVa36L+cXUMSSQKw97T/AjqxkljImiVyIL+U3WX2tFhaMWiYmMKxiI96NhHCK?=
 =?us-ascii?q?KV7LxHhyR5uFS5ohzKYfhhgDgd0+Ah52AAg+EGowctyiSdArYPHUhXJyDslhKI?=
 =?us-ascii?q?78ygo6VTfmqgbb+w1E9ml9C7EL6Cuh1cWGr+epo6AS9w6cB/PEjN0XLp7IHkZc?=
 =?us-ascii?q?LQbckSthCPlxfAju5VKI8+l/YQhCpnP379smMhy+IhkRNu2pS6tpCdK2px5KK5?=
 =?us-ascii?q?HgJYNjrtaswI4D7tiqJentuM04CrA5VsATELXJruTfK1HzMer/XnNwCSEDIirn?=
 =?us-ascii?q?eXA6bQHQia6E1+tXLAD4irN22LJHke1dhiRgOSJElBjwAPRjk6goQ1FgO3xMzi?=
 =?us-ascii?q?bUd54Coe5kXjpxtIy+JoMQT/U2jFqAepbDc0VIaQLB5M4g5e4EfVNNSU7vhvEC?=
 =?us-ascii?q?FA4p2hsAuNJ3SbZgRPEGEJQ1GECErlPrW0/tnA9O6YBuWlIvvKYLWOr/FeVviS?=
 =?us-ascii?q?yZKu1Itm4yiDNsGVMnZ+CP0731JJXWplFMTBhzUPVysXmjrNb8GFpRe8+S53rs?=
 =?us-ascii?q?Gl/PToQgLv4oSPBKVIMdVy4BC7mqODN++WhCZkJjdUzJIMxXnUyLcB2F4ekT1h?=
 =?us-ascii?q?dz6oEb4Yry7CULrQmrNLDx4ccy58LtZI4Lkm3gZTOc/XkNf11r9jg/4xCldFU0?=
 =?us-ascii?q?Hhm86zacwLJWG9KE3IBEKROLuaIj3Lxtn9YbmgRr1IkOVUqxqwtC6HE0/iOzSP?=
 =?us-ascii?q?jSXmWwqzPuFMki6bOgdTuIW8chZrFGjiQ8jqahy9MN9rkzI2xac4iW/NNW4ZKT?=
 =?us-ascii?q?J8aV9CrqWM7SNEhfVyA2xA4WBjLemBmiaZ6fHXK5cWsfRxBCR0mPlX4HA7y7tT?=
 =?us-ascii?q?8SFFS+Z5mCrUrt5yvV6mlvODxSZgUBpL+X53g9eKukBnJI3d94JcQjDA/RQQ/S?=
 =?us-ascii?q?CeDAkMq9J5C9rp/adKxYvhjqX2fRxC6dPP4cwEB4D0JcaDL3sueU7pEz78CBAZ?=
 =?us-ascii?q?CzKmYzKMz3dBme2foyXG5qMxrYLhzd9XEudW?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0BwAQAotvZbh0O0hNFiHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBZYNsJ4xviyJSBoFJZogekBgpEwGIUSI4EgEDAQEBAQEBAgETAQEBCA0JCCk?=
 =?us-ascii?q?jDII2JAGCYgMDAQIkCwENAQE3AQUJAQFQA1QZBYMcgXUNBAGpA4FsM4J2AQEFh?=
 =?us-ascii?q?yIIh16EKxd4gQeBEYJdiw6JIQSBbpRxCYERkBMjkQgsmWGBdjMaCBwUgyeCGww?=
 =?us-ascii?q?XiF6FPz8ygQIDAQEhE4x1AQE?=
X-IPAS-Result: =?us-ascii?q?A0BwAQAotvZbh0O0hNFiHAEBAQQBAQcEAQGBZYNsJ4xviyJ?=
 =?us-ascii?q?SBoFJZogekBgpEwGIUSI4EgEDAQEBAQEBAgETAQEBCA0JCCkjDII2JAGCYgMDA?=
 =?us-ascii?q?QIkCwENAQE3AQUJAQFQA1QZBYMcgXUNBAGpA4FsM4J2AQEFhyIIh16EKxd4gQe?=
 =?us-ascii?q?BEYJdiw6JIQSBbpRxCYERkBMjkQgsmWGBdjMaCBwUgyeCGwwXiF6FPz8ygQIDA?=
 =?us-ascii?q?QEhE4x1AQE?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="41887977"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 06:03:54 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2395413AbeKWAnT (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 19:43:19 -0500
Received: from bombadil.infradead.org ([198.137.202.133]:56354 "EHLO
        bombadil.infradead.org" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2391646AbeKWAnT (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 19:43:19 -0500
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
        d=infradead.org; s=bombadil.20170209; h=Content-Transfer-Encoding:
        MIME-Version:References:In-Reply-To:Message-Id:Date:Subject:Cc:To:From:Sender
        :Reply-To:Content-Type:Content-ID:Content-Description:Resent-Date:Resent-From
        :Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:List-Id:List-Help:
        List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive;
        bh=R3V78J3nd5SsZcfm7IBkeuCZR8LS4DbKrcDQGCivuII=; b=k74N7lKIzbxXpL3Mo7uohxjACw
        aEhzDNIbE+wFx2mjyKqTm3vrPAkg1hzzIL4WZ/14bql1cNjshE432ZgCyy2dR485s8nezROfDGXBq
        Vkec2oM0+TPfgcWO8rwPOMOng5Sf2ekRAopm+eM145UaWWcTredDGILw7m5OWTXjv1C4HBntP23d0
        fKSraR6I3bL8OqlxdfZ6bNHZfmFswF2zncL/WSgaGzJIL7sP+hAdJCcuOB+dMObrSC9pHu5BP6Xg8
        QlgW55wLHlKDze2fCNEO8HK/6K/hHW2OUpW9VoR4nS4eTQaWxQdZ0rYxvg5Two63+dGdsUU/+ZXR1
        +bwtXCNg==;
Received: from clnet-p19-102.ikbnet.co.at ([83.175.77.102] helo=localhost)
        by bombadil.infradead.org with esmtpsa (Exim 4.90_1 #2 (Red Hat Linux))
        id 1gPpZz-0007oE-1A; Thu, 22 Nov 2018 14:03:39 +0000
From: Christoph Hellwig <hch@lst.de>
To: iommu@lists.linux-foundation.org
Cc: Linus Torvalds <torvalds@linux-foundation.org>,
        Jon Mason <jdmason@kudzu.us>, Joerg Roedel <joro@8bytes.org>,
        David Woodhouse <dwmw2@infradead.org>,
        Marek Szyprowski <m.szyprowski@samsung.com>,
        Robin Murphy <robin.murphy@arm.com>, x86@kernel.org,
        linux-alpha@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
        linux-ia64@vger.kernel.org, linux-parisc@vger.kernel.org,
        xen-devel@lists.xenproject.org, linux-arch@vger.kernel.org,
        linux-kernel@vger.kernel.org
Subject: [PATCH 05/24] arm: remove the mapping_error dma_map_ops method
Date: Thu, 22 Nov 2018 15:03:01 +0100
Message-Id: <20181122140320.24080-6-hch@lst.de>
X-Mailer: git-send-email 2.19.1
In-Reply-To: <20181122140320.24080-1-hch@lst.de>
References: <20181122140320.24080-1-hch@lst.de>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-SRS-Rewrite: SMTP reverse-path rewritten from <hch@infradead.org> by bombadil.infradead.org. See http://www.infradead.org/rpr.html
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Arm already returns (~(dma_addr_t)0x0) on mapping failures, so we can
switch over to returning DMA_MAPPING_ERROR and let the core dma-mapping
code handle the rest.

Signed-off-by: Christoph Hellwig <hch@lst.de>
---
 arch/arm/common/dmabounce.c      | 12 +++-------
 arch/arm/include/asm/dma-iommu.h |  2 --
 arch/arm/mm/dma-mapping.c        | 39 ++++++++++++--------------------
 3 files changed, 18 insertions(+), 35 deletions(-)

diff --git a/arch/arm/common/dmabounce.c b/arch/arm/common/dmabounce.c
index 9a92de63426f..5ba4622030ca 100644
--- a/arch/arm/common/dmabounce.c
+++ b/arch/arm/common/dmabounce.c
@@ -257,7 +257,7 @@ static inline dma_addr_t map_single(struct device *dev, void *ptr, size_t size,
 	if (buf == NULL) {
 		dev_err(dev, "%s: unable to map unsafe buffer %p!\n",
 		       __func__, ptr);
-		return ARM_MAPPING_ERROR;
+		return DMA_MAPPING_ERROR;
 	}
 
 	dev_dbg(dev, "%s: unsafe buffer %p (dma=%#x) mapped to %p (dma=%#x)\n",
@@ -327,7 +327,7 @@ static dma_addr_t dmabounce_map_page(struct device *dev, struct page *page,
 
 	ret = needs_bounce(dev, dma_addr, size);
 	if (ret < 0)
-		return ARM_MAPPING_ERROR;
+		return DMA_MAPPING_ERROR;
 
 	if (ret == 0) {
 		arm_dma_ops.sync_single_for_device(dev, dma_addr, size, dir);
@@ -336,7 +336,7 @@ static dma_addr_t dmabounce_map_page(struct device *dev, struct page *page,
 
 	if (PageHighMem(page)) {
 		dev_err(dev, "DMA buffer bouncing of HIGHMEM pages is not supported\n");
-		return ARM_MAPPING_ERROR;
+		return DMA_MAPPING_ERROR;
 	}
 
 	return map_single(dev, page_address(page) + offset, size, dir, attrs);
@@ -453,11 +453,6 @@ static int dmabounce_dma_supported(struct device *dev, u64 dma_mask)
 	return arm_dma_ops.dma_supported(dev, dma_mask);
 }
 
-static int dmabounce_mapping_error(struct device *dev, dma_addr_t dma_addr)
-{
-	return arm_dma_ops.mapping_error(dev, dma_addr);
-}
-
 static const struct dma_map_ops dmabounce_ops = {
 	.alloc			= arm_dma_alloc,
 	.free			= arm_dma_free,
@@ -472,7 +467,6 @@ static const struct dma_map_ops dmabounce_ops = {
 	.sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
 	.sync_sg_for_device	= arm_dma_sync_sg_for_device,
 	.dma_supported		= dmabounce_dma_supported,
-	.mapping_error		= dmabounce_mapping_error,
 };
 
 static int dmabounce_init_pool(struct dmabounce_pool *pool, struct device *dev,
diff --git a/arch/arm/include/asm/dma-iommu.h b/arch/arm/include/asm/dma-iommu.h
index 6821f1249300..772f48ef84b7 100644
--- a/arch/arm/include/asm/dma-iommu.h
+++ b/arch/arm/include/asm/dma-iommu.h
@@ -9,8 +9,6 @@
 #include <linux/dma-debug.h>
 #include <linux/kref.h>
 
-#define ARM_MAPPING_ERROR		(~(dma_addr_t)0x0)
-
 struct dma_iommu_mapping {
 	/* iommu specific data */
 	struct iommu_domain	*domain;
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 661fe48ab78d..2cfb17bad1e6 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -179,11 +179,6 @@ static void arm_dma_sync_single_for_device(struct device *dev,
 	__dma_page_cpu_to_dev(page, offset, size, dir);
 }
 
-static int arm_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
-{
-	return dma_addr == ARM_MAPPING_ERROR;
-}
-
 const struct dma_map_ops arm_dma_ops = {
 	.alloc			= arm_dma_alloc,
 	.free			= arm_dma_free,
@@ -197,7 +192,6 @@ const struct dma_map_ops arm_dma_ops = {
 	.sync_single_for_device	= arm_dma_sync_single_for_device,
 	.sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
 	.sync_sg_for_device	= arm_dma_sync_sg_for_device,
-	.mapping_error		= arm_dma_mapping_error,
 	.dma_supported		= arm_dma_supported,
 };
 EXPORT_SYMBOL(arm_dma_ops);
@@ -217,7 +211,6 @@ const struct dma_map_ops arm_coherent_dma_ops = {
 	.get_sgtable		= arm_dma_get_sgtable,
 	.map_page		= arm_coherent_dma_map_page,
 	.map_sg			= arm_dma_map_sg,
-	.mapping_error		= arm_dma_mapping_error,
 	.dma_supported		= arm_dma_supported,
 };
 EXPORT_SYMBOL(arm_coherent_dma_ops);
@@ -774,7 +767,7 @@ static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 	gfp &= ~(__GFP_COMP);
 	args.gfp = gfp;
 
-	*handle = ARM_MAPPING_ERROR;
+	*handle = DMA_MAPPING_ERROR;
 	allowblock = gfpflags_allow_blocking(gfp);
 	cma = allowblock ? dev_get_cma_area(dev) : false;
 
@@ -1217,7 +1210,7 @@ static inline dma_addr_t __alloc_iova(struct dma_iommu_mapping *mapping,
 	if (i == mapping->nr_bitmaps) {
 		if (extend_iommu_mapping(mapping)) {
 			spin_unlock_irqrestore(&mapping->lock, flags);
-			return ARM_MAPPING_ERROR;
+			return DMA_MAPPING_ERROR;
 		}
 
 		start = bitmap_find_next_zero_area(mapping->bitmaps[i],
@@ -1225,7 +1218,7 @@ static inline dma_addr_t __alloc_iova(struct dma_iommu_mapping *mapping,
 
 		if (start > mapping->bits) {
 			spin_unlock_irqrestore(&mapping->lock, flags);
-			return ARM_MAPPING_ERROR;
+			return DMA_MAPPING_ERROR;
 		}
 
 		bitmap_set(mapping->bitmaps[i], start, count);
@@ -1409,7 +1402,7 @@ __iommu_create_mapping(struct device *dev, struct page **pages, size_t size,
 	int i;
 
 	dma_addr = __alloc_iova(mapping, size);
-	if (dma_addr == ARM_MAPPING_ERROR)
+	if (dma_addr == DMA_MAPPING_ERROR)
 		return dma_addr;
 
 	iova = dma_addr;
@@ -1436,7 +1429,7 @@ __iommu_create_mapping(struct device *dev, struct page **pages, size_t size,
 fail:
 	iommu_unmap(mapping->domain, dma_addr, iova-dma_addr);
 	__free_iova(mapping, dma_addr, size);
-	return ARM_MAPPING_ERROR;
+	return DMA_MAPPING_ERROR;
 }
 
 static int __iommu_remove_mapping(struct device *dev, dma_addr_t iova, size_t size)
@@ -1497,7 +1490,7 @@ static void *__iommu_alloc_simple(struct device *dev, size_t size, gfp_t gfp,
 		return NULL;
 
 	*handle = __iommu_create_mapping(dev, &page, size, attrs);
-	if (*handle == ARM_MAPPING_ERROR)
+	if (*handle == DMA_MAPPING_ERROR)
 		goto err_mapping;
 
 	return addr;
@@ -1525,7 +1518,7 @@ static void *__arm_iommu_alloc_attrs(struct device *dev, size_t size,
 	struct page **pages;
 	void *addr = NULL;
 
-	*handle = ARM_MAPPING_ERROR;
+	*handle = DMA_MAPPING_ERROR;
 	size = PAGE_ALIGN(size);
 
 	if (coherent_flag  == COHERENT || !gfpflags_allow_blocking(gfp))
@@ -1546,7 +1539,7 @@ static void *__arm_iommu_alloc_attrs(struct device *dev, size_t size,
 		return NULL;
 
 	*handle = __iommu_create_mapping(dev, pages, size, attrs);
-	if (*handle == ARM_MAPPING_ERROR)
+	if (*handle == DMA_MAPPING_ERROR)
 		goto err_buffer;
 
 	if (attrs & DMA_ATTR_NO_KERNEL_MAPPING)
@@ -1696,10 +1689,10 @@ static int __map_sg_chunk(struct device *dev, struct scatterlist *sg,
 	int prot;
 
 	size = PAGE_ALIGN(size);
-	*handle = ARM_MAPPING_ERROR;
+	*handle = DMA_MAPPING_ERROR;
 
 	iova_base = iova = __alloc_iova(mapping, size);
-	if (iova == ARM_MAPPING_ERROR)
+	if (iova == DMA_MAPPING_ERROR)
 		return -ENOMEM;
 
 	for (count = 0, s = sg; count < (size >> PAGE_SHIFT); s = sg_next(s)) {
@@ -1739,7 +1732,7 @@ static int __iommu_map_sg(struct device *dev, struct scatterlist *sg, int nents,
 	for (i = 1; i < nents; i++) {
 		s = sg_next(s);
 
-		s->dma_address = ARM_MAPPING_ERROR;
+		s->dma_address = DMA_MAPPING_ERROR;
 		s->dma_length = 0;
 
 		if (s->offset || (size & ~PAGE_MASK) || size + s->length > max) {
@@ -1914,7 +1907,7 @@ static dma_addr_t arm_coherent_iommu_map_page(struct device *dev, struct page *p
 	int ret, prot, len = PAGE_ALIGN(size + offset);
 
 	dma_addr = __alloc_iova(mapping, len);
-	if (dma_addr == ARM_MAPPING_ERROR)
+	if (dma_addr == DMA_MAPPING_ERROR)
 		return dma_addr;
 
 	prot = __dma_info_to_prot(dir, attrs);
@@ -1926,7 +1919,7 @@ static dma_addr_t arm_coherent_iommu_map_page(struct device *dev, struct page *p
 	return dma_addr + offset;
 fail:
 	__free_iova(mapping, dma_addr, len);
-	return ARM_MAPPING_ERROR;
+	return DMA_MAPPING_ERROR;
 }
 
 /**
@@ -2020,7 +2013,7 @@ static dma_addr_t arm_iommu_map_resource(struct device *dev,
 	size_t len = PAGE_ALIGN(size + offset);
 
 	dma_addr = __alloc_iova(mapping, len);
-	if (dma_addr == ARM_MAPPING_ERROR)
+	if (dma_addr == DMA_MAPPING_ERROR)
 		return dma_addr;
 
 	prot = __dma_info_to_prot(dir, attrs) | IOMMU_MMIO;
@@ -2032,7 +2025,7 @@ static dma_addr_t arm_iommu_map_resource(struct device *dev,
 	return dma_addr + offset;
 fail:
 	__free_iova(mapping, dma_addr, len);
-	return ARM_MAPPING_ERROR;
+	return DMA_MAPPING_ERROR;
 }
 
 /**
@@ -2105,7 +2098,6 @@ const struct dma_map_ops iommu_ops = {
 	.map_resource		= arm_iommu_map_resource,
 	.unmap_resource		= arm_iommu_unmap_resource,
 
-	.mapping_error		= arm_dma_mapping_error,
 	.dma_supported		= arm_dma_supported,
 };
 
@@ -2124,7 +2116,6 @@ const struct dma_map_ops iommu_coherent_ops = {
 	.map_resource	= arm_iommu_map_resource,
 	.unmap_resource	= arm_iommu_unmap_resource,
 
-	.mapping_error		= arm_dma_mapping_error,
 	.dma_supported		= arm_dma_supported,
 };
 
-- 
2.19.1

