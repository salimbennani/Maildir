Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 05 Dec 2018 08:45:32 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga008.jf.intel.com (orsmga008.jf.intel.com [10.7.209.65])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 75B5C580375;
	Tue,  4 Dec 2018 15:03:22 -0800 (PST)
Received: from fmsmga101.fm.intel.com ([10.1.193.65])
  by orsmga008-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 04 Dec 2018 15:03:21 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3A7oLjAx3potRRfje0smDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?segTLPrxwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfFjfK3SYMkaSHJBUMhPWSJPH4Gz?=
 =?us-ascii?q?b4UMAeUOIelYtJH9qlkVoBuxGQWhHvnixiNUinPq26AxzuQvERvB3AwlB98AqG?=
 =?us-ascii?q?rbrNTxNKoPS+C1y6fJzTPeZP5R3zfy9onIchQ6rvyXRrJwbNHRxlc1GwzZiVWQ?=
 =?us-ascii?q?rJXoMjWI3eoDtGib6vBvVeOpi2M/qAF+vCKvxsEyhYnNnI4VzUrE9SphzIYpON?=
 =?us-ascii?q?24SFV7bcSjEJtKuCGWL4R2QsY4TGFupik20LoGuYS0fCQSzZQo3RjfZv6df4iP?=
 =?us-ascii?q?+BLjW/6dITN2hXJjYr6/gQi98VS4xu37Tsm7zlBKriVfktnLq3ANzwbf6s+dSv?=
 =?us-ascii?q?ty+EqqxDWB1xjL5+1aPUw5kbDXJ4Mvz7IujJYfrEfOEjPslEj3jqKablgo9+yo?=
 =?us-ascii?q?5uj9f7nrqJ+RO5Vqhg3gLqgigNKzDOQ3PwUIQmOV4/6z1Kf58k38WLhKjuM5kq?=
 =?us-ascii?q?3esJ3CO8QbqbC2AxVP3oYg9Rm/FTGm38ocnXUdK1JFYh2Hg5DoO1HIPv/4Ee+y?=
 =?us-ascii?q?j0qwnDpv3fzKI7PsDovXInTek7rtYaxx5k9exQYryNBQ/ZNUCrUPIPLpXU/xsc?=
 =?us-ascii?q?TVDhs4Mwyy3ubmB8xx1oAAVmKVBK+WLqfSvUaP5uMhJemDepUVtS3jK/gq+fHu?=
 =?us-ascii?q?l2U1mVwDcqmz25sYdnS4Eu5hI0WDbnrgms0BHnsSvgoiUOzqj0WPUTpSZ3axQa?=
 =?us-ascii?q?0w/D46CJ+9AIfHR4CthqGB3SihEp1XYGBGFk6DEXPye4qYXPcMbTqYItV9nTwc?=
 =?us-ascii?q?SbihV4gh2AmutADgyrpnMvDb+ioCuZLjydh6/evTlR4p+DxwDsSd1XyNTm5ukm?=
 =?us-ascii?q?MJQT82wL5woUhnxlif1qh4huRSFcZP6PNRTgc6KZncwvR4C9D1RA3NZNSJSFGg?=
 =?us-ascii?q?QtWgBjE8VdYxw94IY0ZgFNSulBHD3yy2A7ALk7yHHoA78qXZ33LpPcZy127G1L?=
 =?us-ascii?q?U9j1khWsZAL3amhq549wjQHYLJiV+Wl6SxeKQY3S7N8nqDzGWUsEFZVg5wTbvK?=
 =?us-ascii?q?XXQFakTKqtT541vIT6WyBrQ/LgtB1cmCJ7NJatLzi1VKXvPjONXEbGK3lGe9Hh?=
 =?us-ascii?q?KIxrKKbIr3dGQRxiTdCE4Ykw8N+XaKLxQxBiCko2jGFjxhCUrvY1/w8el5sH60?=
 =?us-ascii?q?U1U7zx+UYEF717q64BgVheeCRPMV2b4EvCQhqzBwHFum29LWCtyApxdufalGYN?=
 =?us-ascii?q?M95ktH2nzdtwBnIpOgKKVijEYEcwtrp0Puywl3CoJYnMc3tnwq0hR9JbiY0Fxb?=
 =?us-ascii?q?cTOYxo7/OrvMJ2n2/RCvbbPW217E3NaX/KcP9Oo3q1H5sA61EUoi9m1t08NJ3H?=
 =?us-ascii?q?uE+pXKEA0SXIrtUkY28hh6oK3aYik95o/OyX1gK660siXG29IoAuslxQ2tf9Ne?=
 =?us-ascii?q?MKOCCQ/zHNcWB8moKOw2hVepaggIM/xV9K4xJ8mmbeeJ2La3POZ8mzKrlX5I4I?=
 =?us-ascii?q?Rj3UOD6SV9SvTE0I0Yw/6FxASHUTT8jFC/ss3snYBEZDcSHnewyCT+BY5RYLFy?=
 =?us-ascii?q?cpgPCWu0P8K3wdB+jYb3W3FE7F6jG08G2MixdBuSclzxxxFf2V4WoHyngyS4yT?=
 =?us-ascii?q?N0niotrqqe2izO3uvjeAAGOm5NWGltk1PsLZKogNAdWUiidxIpmwe95Ubm26hb?=
 =?us-ascii?q?o7xyL3PSQUhUZSf2NXxtUqyqurqEfcFP8pIovTxLX+umZVCVV6DyowEd0yPlBG?=
 =?us-ascii?q?ZewDE7dze3upT2hRB6iWSdLGpto3rdY81/2RDf5NnET/5LwjUGXDV4iSXQBlWk?=
 =?us-ascii?q?P9ip/M+YlpfZvuClSmKhUIZecS3qzYOGqSu66ndmARy5n/CvhNLnFRI23jP819?=
 =?us-ascii?q?lvTS/ItgrzYpH316SmNuJqZktoC0Xm68p5GYF+lZE8hIoK1ngZhZWV/HwHnnn1?=
 =?us-ascii?q?MdhA3aL+bXwNRSMEwtLP4Qjl3lFjIWyNx47jSnqdxc5hbcGgYmwKwiI989xKCK?=
 =?us-ascii?q?CM4b1EhyR1pUC0rQDQYfh7hTodzfou6HgHg+AGogYtzyOdAqwMEklcJyDjixOI?=
 =?us-ascii?q?79WmpqVNeGmvaaSw1FZ5nd25D7GNuABcVGz5epc/ByBw6Mp/PUnI0H3y7IHkZd?=
 =?us-ascii?q?bRYcgSth2SjxfPkexVJIgtmfoNgCptIXj9smE9y+4nkRxu2om3vI2GK2Vu5q21?=
 =?us-ascii?q?GBBZOSPuZ8MP5D7tl71RkdiM34CgBZhhHjQLXJ31TfOnCj4StPLnNxqQHz04sH?=
 =?us-ascii?q?uUBb3fHQqH4kd8s33PC4yrN22QJHQB0dViQxydKFZegQ8OWjU6g4U5FhurxMH6?=
 =?us-ascii?q?dEd55zYR5kP3qxdWy+JoMQX/XXnbpAuydjg0T52fJgJM7g5e/0fVLdCe7uVrEi?=
 =?us-ascii?q?5D5JKhqwiNKnGBawRMEGEEQUiEB1HlPrmz6tjM6emYBuyiL/TQZbWCs/BRV/CN?=
 =?us-ascii?q?xZi3yItp4y6MNtmTPnllF/A72FBMXXVnFMTCgTkPVzYblyHQb86YuRe8/Dd4rt?=
 =?us-ascii?q?uk/fTvWQLv45aPCrRIPdVu/RC2nbmMN+qKiCllLjZY04sGxWXUx7gHwF4SlyZu?=
 =?us-ascii?q?eiGtELQHqC7NVb/QlbVRDxIBcCNzM81I760n0wlJOM7bjM7117Figv40DVdFSU?=
 =?us-ascii?q?LumsWzacMWJGG9MUvNBFyXO7SeOT3L38b3bLu8SbJOjeVUtB6wuTeBH0/gJDSD?=
 =?us-ascii?q?kDbpWA61MeFRlyGWJxheuIC7chZwBmnvVtPmahunMNBpiT0626E7hnTPNWQEKz?=
 =?us-ascii?q?hzb1tNrqGM7SNfmvhwAXFB4WF/LeaamyeV9e3YKpcNvPtvAyR0kf9a4Xsgx7tU?=
 =?us-ascii?q?6iFEWOJ6mC/IotFypFGml/GFyiB7XxpWtjZLmIWLsF1+OaXY85lMQ2rL8AgR4m?=
 =?us-ascii?q?WQFRsKocBoCtnuu6BW19jOm7j/KDZE89LI48QcA9LYJ96AMHokKRDpAiLbDBMZ?=
 =?us-ascii?q?TT63MmHSn0xcn+uU9n2Qr5g6rIDjmZsOSrBBUlw1GegXCkBkHNwEPZd2USkokb?=
 =?us-ascii?q?+djM4U+3W+qAPdS9ldvpDCBbquBqDNLzCQkblNYVMjxqnyIJhbYob8wUZvdnF+?=
 =?us-ascii?q?g4KMHUfMC4NjuCpkOyk5oUFn6n9hSCVn3U/kbgmF+2IIGLi/mRtg2Vg2Wvgk6D?=
 =?us-ascii?q?q5uwR/HVHNviZl1RBpwdg=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AfAACiBgdch0O0hNFaBAYcAQEBBAEBB?=
 =?us-ascii?q?wQBAYFTBQEBCwGBVQWBD0s3J5gggiFojUKJCxSBYQILHQ8EAYN6QgKDDiI2Bw0?=
 =?us-ascii?q?BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmIDAwECFwEMUgYJAQErExIDDAFHB?=
 =?us-ascii?q?hMFFgRegiQBgXQNBAEKpiMzhC0BCwGFaQ+CbYkxF4E/QIERghRJg1MBAgEYgQE?=
 =?us-ascii?q?bBQ4CAgaFRyICiQgFCQkOAQMohVmBTYRViiBVCYMNg3aCdzyDIIQDgVsjKoEUh?=
 =?us-ascii?q?iorgSSDAIJxhi2DXCaDP4xWAYIFcBU7gmwJCgyCBQIBFxJtAQIGhkpJCDuFUyw?=
 =?us-ascii?q?yAQEIewEBiBQBAQ0XAQMDgiABAQ?=
X-IPAS-Result: =?us-ascii?q?A0AfAACiBgdch0O0hNFaBAYcAQEBBAEBBwQBAYFTBQEBCwG?=
 =?us-ascii?q?BVQWBD0s3J5gggiFojUKJCxSBYQILHQ8EAYN6QgKDDiI2Bw0BAwEBAQEBAQIBE?=
 =?us-ascii?q?wEBAQgNCQgpIwyCNiQBgmIDAwECFwEMUgYJAQErExIDDAFHBhMFFgRegiQBgXQ?=
 =?us-ascii?q?NBAEKpiMzhC0BCwGFaQ+CbYkxF4E/QIERghRJg1MBAgEYgQEbBQ4CAgaFRyICi?=
 =?us-ascii?q?QgFCQkOAQMohVmBTYRViiBVCYMNg3aCdzyDIIQDgVsjKoEUhiorgSSDAIJxhi2?=
 =?us-ascii?q?DXCaDP4xWAYIFcBU7gmwJCgyCBQIBFxJtAQIGhkpJCDuFUywyAQEIewEBiBQBA?=
 =?us-ascii?q?Q0XAQMDgiABAQ?=
X-IronPort-AV: E=Sophos;i="5.56,316,1539673200"; 
   d="asc'?scan'208,217";a="65334919"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mga01b.intel.com with ESMTP; 04 Dec 2018 15:03:16 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726048AbeLDXDN (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Tue, 4 Dec 2018 18:03:13 -0500
Received: from mx2.suse.de ([195.135.220.15]:52312 "EHLO mx1.suse.de"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1725875AbeLDXDN (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 4 Dec 2018 18:03:13 -0500
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.220.254])
        by mx1.suse.de (Postfix) with ESMTP id 2442CAD7D;
        Tue,  4 Dec 2018 23:03:00 +0000 (UTC)
From: NeilBrown <neilb@suse.com>
To: Jonathan Corbet <corbet@lwn.net>
Date: Wed, 05 Dec 2018 10:02:51 +1100
Cc: linux-doc@vger.kernel.org, LKML <linux-kernel@vger.kernel.org>
Subject: [PATCH 1/2] Documentation: convert path-lookup from markdown to resturctured text
In-Reply-To: <87k1l9dgx9.fsf@notabene.neil.brown.name>
References: <87k1l9dgx9.fsf@notabene.neil.brown.name>
Message-ID: <87sgzc7v50.fsf@notabene.neil.brown.name>
MIME-Version: 1.0
Content-Type: multipart/signed; boundary="=-=-=";
        micalg=pgp-sha256; protocol="application/pgp-signature"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

--=-=-=
Content-Type: text/plain
Content-Transfer-Encoding: quoted-printable


This allows the document to be integrated with the main documentation
tree.
Changes include:
=2D rename from .md to .rst
=2D use `` for code, not single `
=2D use correct sub-section marking
=2D fix indented blocks, both code and non-code
=2D fix external-link markup

Signed-off-by: NeilBrown <neilb@suse.com>
=2D--
 Documentation/filesystems/index.rst                |   2 +
 .../{path-lookup.md =3D> path-lookup.rst}            | 875 +++++++++++----=
------
 2 files changed, 448 insertions(+), 429 deletions(-)
 rename Documentation/filesystems/{path-lookup.md =3D> path-lookup.rst} (59=
%)

diff --git a/Documentation/filesystems/index.rst b/Documentation/filesystem=
s/index.rst
index 46d1b1be3a51..3c0f441a9536 100644
=2D-- a/Documentation/filesystems/index.rst
+++ b/Documentation/filesystems/index.rst
@@ -359,3 +359,5 @@ encryption of files and directories.
     :maxdepth: 2
=20
     fscrypt
+
+.. include::  path-lookup.rst
diff --git a/Documentation/filesystems/path-lookup.md b/Documentation/files=
ystems/path-lookup.rst
similarity index 59%
rename from Documentation/filesystems/path-lookup.md
rename to Documentation/filesystems/path-lookup.rst
index 06151b178f80..bba1fef066a1 100644
=2D-- a/Documentation/filesystems/path-lookup.md
+++ b/Documentation/filesystems/path-lookup.rst
@@ -1,7 +1,4 @@
=2D<head>
=2D<style> p { max-width:50em} ol, ul {max-width: 40em}</style>
=2D</head>
=2D
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
 Pathname lookup in Linux.
 =3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
=20
@@ -17,8 +14,8 @@ including:
=20
 - per-directory parallel name lookup.
=20
=2DIntroduction
=2D------------
+Introduction to pathname lookup.
+=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D
=20
 The most obvious aspect of pathname lookup, which very little
 exploration is needed to discover, is that it is complex.  There are
@@ -36,58 +33,58 @@ distinctions we need to clarify first.
 There are two sorts of ...
 --------------------------
=20
=2D[`openat()`]: http://man7.org/linux/man-pages/man2/openat.2.html
+.. _openat: http://man7.org/linux/man-pages/man2/openat.2.html
=20
 Pathnames (sometimes "file names"), used to identify objects in the
 filesystem, will be familiar to most readers.  They contain two sorts
=2Dof elements: "slashes" that are sequences of one or more "`/`"
+of elements: "slashes" that are sequences of one or more "``/``"
 characters, and "components" that are sequences of one or more
=2Dnon-"`/`" characters.  These form two kinds of paths.  Those that
+non-"``/``" characters.  These form two kinds of paths.  Those that
 start with slashes are "absolute" and start from the filesystem root.
 The others are "relative" and start from the current directory, or
 from some other location specified by a file descriptor given to a
=2D"xxx`at`" system call such as "[`openat()`]".
+"``XXXat``" system call such as `openat() <openat_>`_.
=20
=2D[`execveat()`]: http://man7.org/linux/man-pages/man2/execveat.2.html
+.. _execveat: http://man7.org/linux/man-pages/man2/execveat.2.html
=20
 It is tempting to describe the second kind as starting with a
 component, but that isn't always accurate: a pathname can lack both
 slashes and components, it can be empty, in other words.  This is
=2Dgenerally forbidden in POSIX, but some of those "xxx`at`" system calls
=2Din Linux permit it when the `AT_EMPTY_PATH` flag is given.  For
+generally forbidden in POSIX, but some of those "xxx``at``" system calls
+in Linux permit it when the ``AT_EMPTY_PATH`` flag is given.  For
 example, if you have an open file descriptor on an executable file you
=2Dcan execute it by calling [`execveat()`] passing the file descriptor,
=2Dan empty path, and the `AT_EMPTY_PATH` flag.
+can execute it by calling `execveat() <execveat_>`_ passing
+the file descriptor, an empty path, and the ``AT_EMPTY_PATH`` flag.
=20
 These paths can be divided into two sections: the final component and
 everything else.  The "everything else" is the easy bit.  In all cases
 it must identify a directory that already exists, otherwise an error
=2Dsuch as `ENOENT` or `ENOTDIR` will be reported.
+such as ``ENOENT`` or ``ENOTDIR`` will be reported.
=20
 The final component is not so simple.  Not only do different system
 calls interpret it quite differently (e.g. some create it, some do
 not), but it might not even exist: neither the empty pathname nor the
 pathname that is just slashes have a final component.  If it does
=2Dexist, it could be "`.`" or "`..`" which are handled quite differently
+exist, it could be "``.``" or "``..``" which are handled quite differently
 from other components.
=20
=2D[POSIX]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_cha=
p04.html#tag_04_12
+.. _POSIX: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_cha=
p04.html#tag_04_12
=20
=2DIf a pathname ends with a slash, such as "`/tmp/foo/`" it might be
+If a pathname ends with a slash, such as "``/tmp/foo/``" it might be
 tempting to consider that to have an empty final component.  In many
 ways that would lead to correct results, but not always.  In
=2Dparticular, `mkdir()` and `rmdir()` each create or remove a directory na=
med
+particular, ``mkdir()`` and ``rmdir()`` each create or remove a directory =
named
 by the final component, and they are required to work with pathnames
=2Dending in "`/`".  According to [POSIX]
+ending in "``/``".  According to POSIX_
=20
=2D> A pathname that contains at least one non- &lt;slash> character and
=2D> that ends with one or more trailing &lt;slash> characters shall not
=2D> be resolved successfully unless the last pathname component before
=2D> the trailing <slash> characters names an existing directory or a
=2D> directory entry that is to be created for a directory immediately
=2D> after the pathname is resolved.
+  A pathname that contains at least one non- &lt;slash> character and
+  that ends with one or more trailing &lt;slash> characters shall not
+  be resolved successfully unless the last pathname component before
+  the trailing <slash> characters names an existing directory or a
+  directory entry that is to be created for a directory immediately
+  after the pathname is resolved.
=20
=2DThe Linux pathname walking code (mostly in `fs/namei.c`) deals with
+The Linux pathname walking code (mostly in ``fs/namei.c``) deals with
 all of these issues: breaking the path into components, handling the
 "everything else" quite separately from the final component, and
 checking that the trailing slash is not used where it isn't
@@ -112,7 +109,7 @@ make them quickly available for lookup.  Each entry (kn=
own as a
 "dentry") contains three significant fields: a component name, a
 pointer to a parent dentry, and a pointer to the "inode" which
 contains further information about the object in that parent with
=2Dthe given name.  The inode pointer can be `NULL` indicating that the
+the given name.  The inode pointer can be ``NULL`` indicating that the
 name doesn't exist in the parent.  While there can be linkage in the
 dentry of a directory to the dentries of the children, that linkage is
 not used for pathname lookup, and so will not be considered here.
@@ -139,7 +136,7 @@ whether remote filesystems like NFS and 9P, or cluster =
filesystems
 like ocfs2 or cephfs.  These filesystems allow the VFS to revalidate
 cached information, and must provide their own protection against
 awkward races.  The VFS can detect these filesystems by the
=2D`DCACHE_OP_REVALIDATE` flag being set in the dentry.
+``DCACHE_OP_REVALIDATE`` flag being set in the dentry.
=20
 REF-walk: simple concurrency management with refcounts and spinlocks
 --------------------------------------------------------------------
@@ -148,22 +145,23 @@ With all of those divisions carefully classified, we =
can now start
 looking at the actual process of walking along a path.  In particular
 we will start with the handling of the "everything else" part of a
 pathname, and focus on the "REF-walk" approach to concurrency
=2Dmanagement.  This code is found in the `link_path_walk()` function, if
=2Dyou ignore all the places that only run when "`LOOKUP_RCU`"
+management.  This code is found in the ``link_path_walk()`` function, if
+you ignore all the places that only run when "``LOOKUP_RCU``"
 (indicating the use of RCU-walk) is set.
=20
=2D[Meet the Lockers]: https://lwn.net/Articles/453685/
+.. _Meet the Lockers: https://lwn.net/Articles/453685/
=20
 REF-walk is fairly heavy-handed with locks and reference counts.  Not
 as heavy-handed as in the old "big kernel lock" days, but certainly not
 afraid of taking a lock when one is needed.  It uses a variety of
 different concurrency controls.  A background understanding of the
 various primitives is assumed, or can be gleaned from elsewhere such
=2Das in [Meet the Lockers].
+as in `Meet the Lockers`_.
=20
 The locking mechanisms used by REF-walk include:
=20
=2D### dentry->d_lockref ###
+dentry->d_lockref
+~~~~~~~~~~~~~~~~~
=20
 This uses the lockref primitive to provide both a spinlock and a
 reference count.  The special-sauce of this primitive is that the
@@ -172,49 +170,51 @@ with a single atomic memory operation.
=20
 Holding a reference on a dentry ensures that the dentry won't suddenly
 be freed and used for something else, so the values in various fields
=2Dwill behave as expected.  It also protects the `->d_inode` reference
+will behave as expected.  It also protects the ``->d_inode`` reference
 to the inode to some extent.
=20
 The association between a dentry and its inode is fairly permanent.
 For example, when a file is renamed, the dentry and inode move
 together to the new location.  When a file is created the dentry will
=2Dinitially be negative (i.e. `d_inode` is `NULL`), and will be assigned
+initially be negative (i.e. ``d_inode`` is ``NULL``), and will be assigned
 to the new inode as part of the act of creation.
=20
 When a file is deleted, this can be reflected in the cache either by
=2Dsetting `d_inode` to `NULL`, or by removing it from the hash table
+setting ``d_inode`` to ``NULL``, or by removing it from the hash table
 (described shortly) used to look up the name in the parent directory.
 If the dentry is still in use the second option is used as it is
 perfectly legal to keep using an open file after it has been deleted
 and having the dentry around helps.  If the dentry is not otherwise in
=2Duse (i.e. if the refcount in `d_lockref` is one), only then will
=2D`d_inode` be set to `NULL`.  Doing it this way is more efficient for a
+use (i.e. if the refcount in ``d_lockref`` is one), only then will
+``d_inode`` be set to ``NULL``.  Doing it this way is more efficient for a
 very common case.
=20
=2DSo as long as a counted reference is held to a dentry, a non-`NULL` `->d=
_inode`
+So as long as a counted reference is held to a dentry, a non-``NULL`` ``->=
d_inode``
 value will never be changed.
=20
=2D### dentry->d_lock ###
+dentry->d_lock
+~~~~~~~~~~~~~~
=20
=2D`d_lock` is a synonym for the spinlock that is part of `d_lockref` above.
+``d_lock`` is a synonym for the spinlock that is part of ``d_lockref`` abo=
ve.
 For our purposes, holding this lock protects against the dentry being
=2Drenamed or unlinked.  In particular, its parent (`d_parent`), and its
=2Dname (`d_name`) cannot be changed, and it cannot be removed from the
+renamed or unlinked.  In particular, its parent (``d_parent``), and its
+name (``d_name``) cannot be changed, and it cannot be removed from the
 dentry hash table.
=20
=2DWhen looking for a name in a directory, REF-walk takes `d_lock` on
+When looking for a name in a directory, REF-walk takes ``d_lock`` on
 each candidate dentry that it finds in the hash table and then checks
 that the parent and name are correct.  So it doesn't lock the parent
 while searching in the cache; it only locks children.
=20
=2DWhen looking for the parent for a given name (to handle "`..`"),
=2DREF-walk can take `d_lock` to get a stable reference to `d_parent`,
+When looking for the parent for a given name (to handle "``..``"),
+REF-walk can take ``d_lock`` to get a stable reference to ``d_parent``,
 but it first tries a more lightweight approach.  As seen in
=2D`dget_parent()`, if a reference can be claimed on the parent, and if
=2Dsubsequently `d_parent` can be seen to have not changed, then there is
+``dget_parent()``, if a reference can be claimed on the parent, and if
+subsequently ``d_parent`` can be seen to have not changed, then there is
 no need to actually take the lock on the child.
=20
=2D### rename_lock ###
+rename_lock
+~~~~~~~~~~~
=20
 Looking up a given name in a given directory involves computing a hash
 from the two values (the name and the dentry of the directory),
@@ -228,114 +228,117 @@ happened to be looking at a dentry that was moved i=
n this way,
 it might end up continuing the search down the wrong chain,
 and so miss out on part of the correct chain.
=20
=2DThe name-lookup process (`d_lookup()`) does _not_ try to prevent this
+The name-lookup process (``d_lookup()``) does _not_ try to prevent this
 from happening, but only to detect when it happens.
=2D`rename_lock` is a seqlock that is updated whenever any dentry is
=2Drenamed.  If `d_lookup` finds that a rename happened while it
+``rename_lock`` is a seqlock that is updated whenever any dentry is
+renamed.  If ``d_lookup`` finds that a rename happened while it
 unsuccessfully scanned a chain in the hash table, it simply tries
 again.
=20
=2D### inode->i_rwsem ###
+inode->i_rwsem
+~~~~~~~~~~~~~~
=20
=2D`i_rwsem` is a read/write semaphore that serializes all changes to a par=
ticular
=2Ddirectory.  This ensures that, for example, an `unlink()` and a `rename(=
)`
+``i_rwsem`` is a read/write semaphore that serializes all changes to a par=
ticular
+directory.  This ensures that, for example, an ``unlink()`` and a ``rename=
()``
 cannot both happen at the same time.  It also keeps the directory
 stable while the filesystem is asked to look up a name that is not
 currently in the dcache or, optionally, when the list of entries in a
=2Ddirectory is being retrieved with `readdir()`.
+directory is being retrieved with ``readdir()``.
=20
=2DThis has a complementary role to that of `d_lock`: `i_rwsem` on a
=2Ddirectory protects all of the names in that directory, while `d_lock`
+This has a complementary role to that of ``d_lock``: ``i_rwsem`` on a
+directory protects all of the names in that directory, while ``d_lock``
 on a name protects just one name in a directory.  Most changes to the
=2Ddcache hold `i_rwsem` on the relevant directory inode and briefly take
=2D`d_lock` on one or more the dentries while the change happens.  One
+dcache hold ``i_rwsem`` on the relevant directory inode and briefly take
+``d_lock`` on one or more the dentries while the change happens.  One
 exception is when idle dentries are removed from the dcache due to
=2Dmemory pressure.  This uses `d_lock`, but `i_rwsem` plays no role.
+memory pressure.  This uses ``d_lock``, but ``i_rwsem`` plays no role.
=20
 The semaphore affects pathname lookup in two distinct ways.  Firstly it
=2Dprevents changes during lookup of a name in a directory.  `walk_componen=
t()` uses
=2D`lookup_fast()` first which, in turn, checks to see if the name is in th=
e cache,
=2Dusing only `d_lock` locking.  If the name isn't found, then `walk_compon=
ent()`
=2Dfalls back to `lookup_slow()` which takes a shared lock on `i_rwsem`, ch=
ecks again that
+prevents changes during lookup of a name in a directory.  ``walk_component=
()`` uses
+``lookup_fast()`` first which, in turn, checks to see if the name is in th=
e cache,
+using only ``d_lock`` locking.  If the name isn't found, then ``walk_compo=
nent()``
+falls back to ``lookup_slow()`` which takes a shared lock on ``i_rwsem``, =
checks again that
 the name isn't in the cache, and then calls in to the filesystem to get a
 definitive answer.  A new dentry will be added to the cache regardless of
 the result.
=20
 Secondly, when pathname lookup reaches the final component, it will
=2Dsometimes need to take an exclusive lock on `i_rwsem` before performing =
the last lookup so
+sometimes need to take an exclusive lock on ``i_rwsem`` before performing =
the last lookup so
 that the required exclusion can be achieved.  How path lookup chooses
=2Dto take, or not take, `i_rwsem` is one of the
+to take, or not take, ``i_rwsem`` is one of the
 issues addressed in a subsequent section.
=20
 If two threads attempt to look up the same name at the same time - a
=2Dname that is not yet in the dcache - the shared lock on `i_rwsem` will
+name that is not yet in the dcache - the shared lock on ``i_rwsem`` will
 not prevent them both adding new dentries with the same name.  As this
 would result in confusion an extra level of interlocking is used,
=2Dbased around a secondary hash table (`in_lookup_hashtable`) and a
=2Dper-dentry flag bit (`DCACHE_PAR_LOOKUP`).
+based around a secondary hash table (``in_lookup_hashtable``) and a
+per-dentry flag bit (``DCACHE_PAR_LOOKUP``).
=20
 To add a new dentry to the cache while only holding a shared lock on
=2D`i_rwsem`, a thread must call `d_alloc_parallel()`.  This allocates a
+``i_rwsem``, a thread must call ``d_alloc_parallel()``.  This allocates a
 dentry, stores the required name and parent in it, checks if there
 is already a matching dentry in the primary or secondary hash
 tables, and if not, stores the newly allocated dentry in the secondary
=2Dhash table, with `DCACHE_PAR_LOOKUP` set.
+hash table, with ``DCACHE_PAR_LOOKUP`` set.
=20
 If a matching dentry was found in the primary hash table then that is
 returned and the caller can know that it lost a race with some other
 thread adding the entry.  If no matching dentry is found in either
 cache, the newly allocated dentry is returned and the caller can
=2Ddetect this from the presence of `DCACHE_PAR_LOOKUP`.  In this case it
+detect this from the presence of ``DCACHE_PAR_LOOKUP``.  In this case it
 knows that it has won any race and now is responsible for asking the
 filesystem to perform the lookup and find the matching inode.  When
=2Dthe lookup is complete, it must call `d_lookup_done()` which clears
+the lookup is complete, it must call ``d_lookup_done()`` which clears
 the flag and does some other house keeping, including removing the
 dentry from the secondary hash table - it will normally have been
=2Dadded to the primary hash table already.  Note that a `struct
=2Dwaitqueue_head` is passed to `d_alloc_parallel()`, and
=2D`d_lookup_done()` must be called while this `waitqueue_head` is still
+added to the primary hash table already.  Note that a ``struct
+waitqueue_head`` is passed to ``d_alloc_parallel()``, and
+``d_lookup_done()`` must be called while this ``waitqueue_head`` is still
 in scope.
=20
 If a matching dentry is found in the secondary hash table,
=2D`d_alloc_parallel()` has a little more work to do. It first waits for
=2D`DCACHE_PAR_LOOKUP` to be cleared, using a wait_queue that was passed
=2Dto the instance of `d_alloc_parallel()` that won the race and that
=2Dwill be woken by the call to `d_lookup_done()`.  It then checks to see
+``d_alloc_parallel()`` has a little more work to do. It first waits for
+``DCACHE_PAR_LOOKUP`` to be cleared, using a wait_queue that was passed
+to the instance of ``d_alloc_parallel()`` that won the race and that
+will be woken by the call to ``d_lookup_done()``.  It then checks to see
 if the dentry has now been added to the primary hash table.  If it
 has, the dentry is returned and the caller just sees that it lost any
 race.  If it hasn't been added to the primary hash table, the most
 likely explanation is that some other dentry was added instead using
=2D`d_splice_alias()`.  In any case, `d_alloc_parallel()` repeats all the
+``d_splice_alias()``.  In any case, ``d_alloc_parallel()`` repeats all the
 look ups from the start and will normally return something from the
 primary hash table.
=20
=2D### mnt->mnt_count ###
+mnt->mnt_count
+~~~~~~~~~~~~~~
=20
=2D`mnt_count` is a per-CPU reference counter on "`mount`" structures.
+``mnt_count`` is a per-CPU reference counter on "``mount``" structures.
 Per-CPU here means that incrementing the count is cheap as it only
 uses CPU-local memory, but checking if the count is zero is expensive as
=2Dit needs to check with every CPU.  Taking a `mnt_count` reference
+it needs to check with every CPU.  Taking a ``mnt_count`` reference
 prevents the mount structure from disappearing as the result of regular
 unmount operations, but does not prevent a "lazy" unmount.  So holding
=2D`mnt_count` doesn't ensure that the mount remains in the namespace and,
+``mnt_count`` doesn't ensure that the mount remains in the namespace and,
 in particular, doesn't stabilize the link to the mounted-on dentry.  It
=2Ddoes, however, ensure that the `mount` data structure remains coherent,
+does, however, ensure that the ``mount`` data structure remains coherent,
 and it provides a reference to the root dentry of the mounted
=2Dfilesystem.  So a reference through `->mnt_count` provides a stable
+filesystem.  So a reference through ``->mnt_count`` provides a stable
 reference to the mounted dentry, but not the mounted-on dentry.
=20
=2D### mount_lock ###
+mount_lock
+~~~~~~~~~~
=20
=2D`mount_lock` is a global seqlock, a bit like `rename_lock`.  It can be u=
sed to
+``mount_lock`` is a global seqlock, a bit like ``rename_lock``.  It can be=
 used to
 check if any change has been made to any mount points.
=20
 While walking down the tree (away from the root) this lock is used when
 crossing a mount point to check that the crossing was safe.  That is,
 the value in the seqlock is read, then the code finds the mount that
 is mounted on the current directory, if there is one, and increments
=2Dthe `mnt_count`.  Finally the value in `mount_lock` is checked against
+the ``mnt_count``.  Finally the value in ``mount_lock`` is checked against
 the old value.  If there is no change, then the crossing was safe.  If the=
re
=2Dwas a change, the `mnt_count` is decremented and the whole process is
+was a change, the ``mnt_count`` is decremented and the whole process is
 retried.
=20
 When walking up the tree (towards the root) by following a ".." link,
@@ -345,7 +348,8 @@ any changes to any mount points while stepping up.  Thi=
s locking is
 needed to stabilize the link to the mounted-on dentry, which the
 refcount on the mount itself doesn't ensure.
=20
=2D### RCU ###
+RCU
+~~~
=20
 Finally the global (but extremely lightweight) RCU read lock is held
 from time to time to ensure certain data structures don't get freed
@@ -354,85 +358,89 @@ unexpectedly.
 In particular it is held while scanning chains in the dcache hash
 table, and the mount point hash table.
=20
=2DBringing it together with `struct nameidata`
+Bringing it together with ``struct nameidata``
 --------------------------------------------
=20
=2D[First edition Unix]: http://minnie.tuhs.org/cgi-bin/utree.pl?file=3DV1/=
u2.s
+.. _First edition Unix: http://minnie.tuhs.org/cgi-bin/utree.pl?file=3DV1/=
u2.s
=20
 Throughout the process of walking a path, the current status is stored
=2Din a `struct nameidata`, "namei" being the traditional name - dating
=2Dall the way back to [First Edition Unix] - of the function that
=2Dconverts a "name" to an "inode".  `struct nameidata` contains (among
+in a ``struct nameidata``, "namei" being the traditional name - dating
+all the way back to `First Edition Unix`_ - of the function that
+converts a "name" to an "inode".  ``struct nameidata`` contains (among
 other fields):
=20
=2D### `struct path path` ###
+``struct path path``
+~~~~~~~~~~~~~~~~~~
=20
=2DA `path` contains a `struct vfsmount` (which is
=2Dembedded in a `struct mount`) and a `struct dentry`.  Together these
+A ``path`` contains a ``struct vfsmount`` (which is
+embedded in a ``struct mount``) and a ``struct dentry``.  Together these
 record the current status of the walk.  They start out referring to the
 starting point (the current working directory, the root directory, or some=
 other
 directory identified by a file descriptor), and are updated on each
=2Dstep.  A reference through `d_lockref` and `mnt_count` is always
+step.  A reference through ``d_lockref`` and ``mnt_count`` is always
 held.
=20
=2D### `struct qstr last` ###
+``struct qstr last``
+~~~~~~~~~~~~~~~~~~
=20
=2DThis is a string together with a length (i.e. _not_ `nul` terminated)
+This is a string together with a length (i.e. _not_ ``nul`` terminated)
 that is the "next" component in the pathname.
=20
=2D### `int last_type` ###
+``int last_type``
+~~~~~~~~~~~~~~~
=20
=2DThis is one of `LAST_NORM`, `LAST_ROOT`, `LAST_DOT`, `LAST_DOTDOT`, or
=2D`LAST_BIND`.  The `last` field is only valid if the type is
=2D`LAST_NORM`.  `LAST_BIND` is used when following a symlink and no
+This is one of ``LAST_NORM``, ``LAST_ROOT``, ``LAST_DOT``, ``LAST_DOTDOT``=
, or
+``LAST_BIND``.  The ``last`` field is only valid if the type is
+``LAST_NORM``.  ``LAST_BIND`` is used when following a symlink and no
 components of the symlink have been processed yet.  Others should be
 fairly self-explanatory.
=20
=2D### `struct path root` ###
+``struct path root``
+~~~~~~~~~~~~~~~~~~
=20
 This is used to hold a reference to the effective root of the
 filesystem.  Often that reference won't be needed, so this field is
 only assigned the first time it is used, or when a non-standard root
=2Dis requested.  Keeping a reference in the `nameidata` ensures that
+is requested.  Keeping a reference in the ``nameidata`` ensures that
 only one root is in effect for the entire path walk, even if it races
=2Dwith a `chroot()` system call.
+with a ``chroot()`` system call.
=20
 The root is needed when either of two conditions holds: (1) either the
=2Dpathname or a symbolic link starts with a "'/'", or (2) a "`..`"
=2Dcomponent is being handled, since "`..`" from the root must always stay
+pathname or a symbolic link starts with a "'/'", or (2) a "``..``"
+component is being handled, since "``..``" from the root must always stay
 at the root.  The value used is usually the current root directory of
 the calling process.  An alternate root can be provided as when
=2D`sysctl()` calls `file_open_root()`, and when NFSv4 or Btrfs call
=2D`mount_subtree()`.  In each case a pathname is being looked up in a very
+``sysctl()`` calls ``file_open_root()``, and when NFSv4 or Btrfs call
+``mount_subtree()``.  In each case a pathname is being looked up in a very
 specific part of the filesystem, and the lookup must not be allowed to
=2Descape that subtree.  It works a bit like a local `chroot()`.
+escape that subtree.  It works a bit like a local ``chroot()``.
=20
 Ignoring the handling of symbolic links, we can now describe the
=2D"`link_path_walk()`" function, which handles the lookup of everything
+"``link_path_walk()``" function, which handles the lookup of everything
 except the final component as:
=20
=2D>  Given a path (`name`) and a nameidata structure (`nd`), check that the
=2D>  current directory has execute permission and then advance `name`
=2D>  over one component while updating `last_type` and `last`.  If that
=2D>  was the final component, then return, otherwise call
=2D>  `walk_component()` and repeat from the top.
+   Given a path (``name``) and a nameidata structure (``nd``), check that =
the
+   current directory has execute permission and then advance ``name``
+   over one component while updating ``last_type`` and ``last``.  If that
+   was the final component, then return, otherwise call
+   ``walk_component()`` and repeat from the top.
=20
=2D`walk_component()` is even easier.  If the component is `LAST_DOTS`,
=2Dit calls `handle_dots()` which does the necessary locking as already
=2Ddescribed.  If it finds a `LAST_NORM` component it first calls
=2D"`lookup_fast()`" which only looks in the dcache, but will ask the
+``walk_component()`` is even easier.  If the component is ``LAST_DOTS``,
+it calls ``handle_dots()`` which does the necessary locking as already
+described.  If it finds a ``LAST_NORM`` component it first calls
+"``lookup_fast()``" which only looks in the dcache, but will ask the
 filesystem to revalidate the result if it is that sort of filesystem.
=2DIf that doesn't get a good result, it calls "`lookup_slow()`" which
=2Dtakes `i_rwsem`, rechecks the cache, and then asks the filesystem
+If that doesn't get a good result, it calls "``lookup_slow()``" which
+takes ``i_rwsem``, rechecks the cache, and then asks the filesystem
 to find a definitive answer.  Each of these will call
=2D`follow_managed()` (as described below) to handle any mount points.
+``follow_managed()`` (as described below) to handle any mount points.
=20
=2DIn the absence of symbolic links, `walk_component()` creates a new
=2D`struct path` containing a counted reference to the new dentry and a
=2Dreference to the new `vfsmount` which is only counted if it is
=2Ddifferent from the previous `vfsmount`.  It then calls
=2D`path_to_nameidata()` to install the new `struct path` in the
=2D`struct nameidata` and drop the unneeded references.
+In the absence of symbolic links, ``walk_component()`` creates a new
+``struct path`` containing a counted reference to the new dentry and a
+reference to the new ``vfsmount`` which is only counted if it is
+different from the previous ``vfsmount``.  It then calls
+``path_to_nameidata()`` to install the new ``struct path`` in the
+``struct nameidata`` and drop the unneeded references.
=20
 This "hand-over-hand" sequencing of getting a reference to the new
 dentry before dropping the reference to the previous dentry may
@@ -442,49 +450,49 @@ analogue in the "RCU-walk" version.
 Handling the final component.
 -----------------------------
=20
=2D`link_path_walk()` only walks as far as setting `nd->last` and
=2D`nd->last_type` to refer to the final component of the path.  It does
=2Dnot call `walk_component()` that last time.  Handling that final
+``link_path_walk()`` only walks as far as setting ``nd->last`` and
+``nd->last_type`` to refer to the final component of the path.  It does
+not call ``walk_component()`` that last time.  Handling that final
 component remains for the caller to sort out. Those callers are
=2D`path_lookupat()`, `path_parentat()`, `path_mountpoint()` and
=2D`path_openat()` each of which handles the differing requirements of
+``path_lookupat()``, ``path_parentat()``, ``path_mountpoint()`` and
+``path_openat()`` each of which handles the differing requirements of
 different system calls.
=20
=2D`path_parentat()` is clearly the simplest - it just wraps a little bit
=2Dof housekeeping around `link_path_walk()` and returns the parent
+``path_parentat()`` is clearly the simplest - it just wraps a little bit
+of housekeeping around ``link_path_walk()`` and returns the parent
 directory and final component to the caller.  The caller will be either
=2Daiming to create a name (via `filename_create()`) or remove or rename
=2Da name (in which case `user_path_parent()` is used).  They will use
=2D`i_rwsem` to exclude other changes while they validate and then
+aiming to create a name (via ``filename_create()``) or remove or rename
+a name (in which case ``user_path_parent()`` is used).  They will use
+``i_rwsem`` to exclude other changes while they validate and then
 perform their operation.
=20
=2D`path_lookupat()` is nearly as simple - it is used when an existing
=2Dobject is wanted such as by `stat()` or `chmod()`.  It essentially just
=2Dcalls `walk_component()` on the final component through a call to
=2D`lookup_last()`.  `path_lookupat()` returns just the final dentry.
+``path_lookupat()`` is nearly as simple - it is used when an existing
+object is wanted such as by ``stat()`` or ``chmod()``.  It essentially just
+calls ``walk_component()`` on the final component through a call to
+``lookup_last()``.  ``path_lookupat()`` returns just the final dentry.
=20
=2D`path_mountpoint()` handles the special case of unmounting which must
+``path_mountpoint()`` handles the special case of unmounting which must
 not try to revalidate the mounted filesystem.  It effectively
=2Dcontains, through a call to `mountpoint_last()`, an alternate
=2Dimplementation of `lookup_slow()` which skips that step.  This is
+contains, through a call to ``mountpoint_last()``, an alternate
+implementation of ``lookup_slow()`` which skips that step.  This is
 important when unmounting a filesystem that is inaccessible, such as
 one provided by a dead NFS server.
=20
=2DFinally `path_openat()` is used for the `open()` system call; it
=2Dcontains, in support functions starting with "`do_last()`", all the
+Finally ``path_openat()`` is used for the ``open()`` system call; it
+contains, in support functions starting with "``do_last()``", all the
 complexity needed to handle the different subtleties of O_CREAT (with
=2Dor without O_EXCL), final "`/`" characters, and trailing symbolic
+or without O_EXCL), final "``/``" characters, and trailing symbolic
 links.  We will revisit this in the final part of this series, which
=2Dfocuses on those symbolic links.  "`do_last()`" will sometimes, but
=2Dnot always, take `i_rwsem`, depending on what it finds.
+focuses on those symbolic links.  "``do_last()``" will sometimes, but
+not always, take ``i_rwsem``, depending on what it finds.
=20
 Each of these, or the functions which call them, need to be alert to
=2Dthe possibility that the final component is not `LAST_NORM`.  If the
+the possibility that the final component is not ``LAST_NORM``.  If the
 goal of the lookup is to create something, then any value for
=2D`last_type` other than `LAST_NORM` will result in an error.  For
=2Dexample if `path_parentat()` reports `LAST_DOTDOT`, then the caller
+``last_type`` other than ``LAST_NORM`` will result in an error.  For
+example if ``path_parentat()`` reports ``LAST_DOTDOT``, then the caller
 won't try to create that name.  They also check for trailing slashes
=2Dby testing `last.name[last.len]`.  If there is any character beyond
+by testing ``last.name[last.len]``.  If there is any character beyond
 the final component, it must be a trailing slash.
=20
 Revalidation and automounts
@@ -495,12 +503,12 @@ process not yet covered.  One is the handling of stal=
e cache entries
 and the other is automounts.
=20
 On filesystems that require it, the lookup routines will call the
=2D`->d_revalidate()` dentry method to ensure that the cached information
+``->d_revalidate()`` dentry method to ensure that the cached information
 is current.  This will often confirm validity or update a few details
 from a server.  In some cases it may find that there has been change
 further up the path and that something that was thought to be valid
 previously isn't really.  When this happens the lookup of the whole
=2Dpath is aborted and retried with the "`LOOKUP_REVAL`" flag set.  This
+path is aborted and retried with the "``LOOKUP_REVAL``" flag set.  This
 forces revalidation to be more thorough.  We will see more details of
 this retry process in the next article.
=20
@@ -512,52 +520,55 @@ tree, but a few notes specifically related to path lo=
okup are in order
 here.
=20
 The Linux VFS has a concept of "managed" dentries which is reflected
=2Din function names such as "`follow_managed()`".  There are three
+in function names such as "``follow_managed()``".  There are three
 potentially interesting things about these dentries corresponding
=2Dto three different flags that might be set in `dentry->d_flags`:
+to three different flags that might be set in ``dentry->d_flags``:
=20
=2D### `DCACHE_MANAGE_TRANSIT` ###
+``DCACHE_MANAGE_TRANSIT``
+~~~~~~~~~~~~~~~~~~~~~~~
=20
 If this flag has been set, then the filesystem has requested that the
=2D`d_manage()` dentry operation be called before handling any possible
+``d_manage()`` dentry operation be called before handling any possible
 mount point.  This can perform two particular services:
=20
 It can block to avoid races.  If an automount point is being
=2Dunmounted, the `d_manage()` function will usually wait for that
+unmounted, the ``d_manage()`` function will usually wait for that
 process to complete before letting the new lookup proceed and possibly
 trigger a new automount.
=20
 It can selectively allow only some processes to transit through a
 mount point.  When a server process is managing automounts, it may
 need to access a directory without triggering normal automount
=2Dprocessing.  That server process can identify itself to the `autofs`
+processing.  That server process can identify itself to the ``autofs``
 filesystem, which will then give it a special pass through
=2D`d_manage()` by returning `-EISDIR`.
+``d_manage()`` by returning ``-EISDIR``.
=20
=2D### `DCACHE_MOUNTED` ###
+``DCACHE_MOUNTED``
+~~~~~~~~~~~~~~~~
=20
 This flag is set on every dentry that is mounted on.  As Linux
 supports multiple filesystem namespaces, it is possible that the
 dentry may not be mounted on in *this* namespace, just in some
 other.  So this flag is seen as a hint, not a promise.
=20
=2DIf this flag is set, and `d_manage()` didn't return `-EISDIR`,
=2D`lookup_mnt()` is called to examine the mount hash table (honoring the
=2D`mount_lock` described earlier) and possibly return a new `vfsmount`
=2Dand a new `dentry` (both with counted references).
+If this flag is set, and ``d_manage()`` didn't return ``-EISDIR``,
+``lookup_mnt()`` is called to examine the mount hash table (honoring the
+``mount_lock`` described earlier) and possibly return a new ``vfsmount``
+and a new ``dentry`` (both with counted references).
=20
=2D### `DCACHE_NEED_AUTOMOUNT` ###
+``DCACHE_NEED_AUTOMOUNT``
+~~~~~~~~~~~~~~~~~~~~~~~
=20
=2DIf `d_manage()` allowed us to get this far, and `lookup_mnt()` didn't
=2Dfind a mount point, then this flag causes the `d_automount()` dentry
+If ``d_manage()`` allowed us to get this far, and ``lookup_mnt()`` didn't
+find a mount point, then this flag causes the ``d_automount()`` dentry
 operation to be called.
=20
=2DThe `d_automount()` operation can be arbitrarily complex and may
+The ``d_automount()`` operation can be arbitrarily complex and may
 communicate with server processes etc. but it should ultimately either
 report that there was an error, that there was nothing to mount, or
=2Dshould provide an updated `struct path` with new `dentry` and `vfsmount`.
+should provide an updated ``struct path`` with new ``dentry`` and ``vfsmou=
nt``.
=20
=2DIn the latter case, `finish_automount()` will be called to safely
+In the latter case, ``finish_automount()`` will be called to safely
 install the new mount point into the mount table.
=20
 There is no new locking of import here and it is important that no
@@ -614,7 +625,7 @@ isn't in the cache, then it tries to stop gracefully an=
d switch to
 REF-walk.
=20
 This stopping requires getting a counted reference on the current
=2D`vfsmount` and `dentry`, and ensuring that these are still valid -
+``vfsmount`` and ``dentry``, and ensuring that these are still valid -
 that a path walk with REF-walk would have found the same entries.
 This is an invariant that RCU-walk must guarantee.  It can only make
 decisions, such as selecting the next step, that are decisions which
@@ -625,21 +636,21 @@ RCU-walk finds it cannot stop gracefully, it simply g=
ives up and
 restarts from the top with REF-walk.
=20
 This pattern of "try RCU-walk, if that fails try REF-walk" can be
=2Dclearly seen in functions like `filename_lookup()`,
=2D`filename_parentat()`, `filename_mountpoint()`,
=2D`do_filp_open()`, and `do_file_open_root()`.  These five
=2Dcorrespond roughly to the four `path_`* functions we met earlier,
=2Deach of which calls `link_path_walk()`.  The `path_*` functions are
+clearly seen in functions like ``filename_lookup()``,
+``filename_parentat()``, ``filename_mountpoint()``,
+``do_filp_open()``, and ``do_file_open_root()``.  These five
+correspond roughly to the four ``path_``* functions we met earlier,
+each of which calls ``link_path_walk()``.  The ``path_*`` functions are
 called using different mode flags until a mode is found which works.
=2DThey are first called with `LOOKUP_RCU` set to request "RCU-walk".  If
=2Dthat fails with the error `ECHILD` they are called again with no
+They are first called with ``LOOKUP_RCU`` set to request "RCU-walk".  If
+that fails with the error ``ECHILD`` they are called again with no
 special flag to request "REF-walk".  If either of those report the
=2Derror `ESTALE` a final attempt is made with `LOOKUP_REVAL` set (and no
=2D`LOOKUP_RCU`) to ensure that entries found in the cache are forcibly
+error ``ESTALE`` a final attempt is made with ``LOOKUP_REVAL`` set (and no
+``LOOKUP_RCU``) to ensure that entries found in the cache are forcibly
 revalidated - normally entries are only revalidated if the filesystem
 determines that they are too old to trust.
=20
=2DThe `LOOKUP_RCU` attempt may drop that flag internally and switch to
+The ``LOOKUP_RCU`` attempt may drop that flag internally and switch to
 REF-walk, but will never then try to switch back to RCU-walk.  Places
 that trip up RCU-walk are much more likely to be near the leaves and
 so it is very unlikely that there will be much, if any, benefit from
@@ -649,7 +660,7 @@ RCU and seqlocks: fast and light
 --------------------------------
=20
 RCU is, unsurprisingly, critical to RCU-walk mode.  The
=2D`rcu_read_lock()` is held for the entire time that RCU-walk is walking
+``rcu_read_lock()`` is held for the entire time that RCU-walk is walking
 down a path.  The particular guarantee it provides is that the key
 data structures - dentries, inodes, super_blocks, and mounts - will
 not be freed while the lock is held.  They might be unlinked or
@@ -661,7 +672,7 @@ seqlocks.
 As we saw above, REF-walk holds a counted reference to the current
 dentry and the current vfsmount, and does not release those references
 before taking references to the "next" dentry or vfsmount.  It also
=2Dsometimes takes the `d_lock` spinlock.  These references and locks are
+sometimes takes the ``d_lock`` spinlock.  These references and locks are
 taken to prevent certain changes from happening.  RCU-walk must not
 take those references or locks and so cannot prevent such changes.
 Instead, it checks to see if a change has been made, and aborts or
@@ -671,123 +682,126 @@ To preserve the invariant mentioned above (that RCU=
-walk may only make
 decisions that REF-walk could have made), it must make the checks at
 or near the same places that REF-walk holds the references.  So, when
 REF-walk increments a reference count or takes a spinlock, RCU-walk
=2Dsamples the status of a seqlock using `read_seqcount_begin()` or a
+samples the status of a seqlock using ``read_seqcount_begin()`` or a
 similar function.  When REF-walk decrements the count or drops the
 lock, RCU-walk checks if the sampled status is still valid using
=2D`read_seqcount_retry()` or similar.
+``read_seqcount_retry()`` or similar.
=20
 However, there is a little bit more to seqlocks than that.  If
 RCU-walk accesses two different fields in a seqlock-protected
 structure, or accesses the same field twice, there is no a priori
 guarantee of any consistency between those accesses.  When consistency
 is needed - which it usually is - RCU-walk must take a copy and then
=2Duse `read_seqcount_retry()` to validate that copy.
+use ``read_seqcount_retry()`` to validate that copy.
=20
=2D`read_seqcount_retry()` not only checks the sequence number, but also
+``read_seqcount_retry()`` not only checks the sequence number, but also
 imposes a memory barrier so that no memory-read instruction from
 *before* the call can be delayed until *after* the call, either by the
 CPU or by the compiler.  A simple example of this can be seen in
=2D`slow_dentry_cmp()` which, for filesystems which do not use simple
+``slow_dentry_cmp()`` which, for filesystems which do not use simple
 byte-wise name equality, calls into the filesystem to compare a name
 against a dentry.  The length and name pointer are copied into local
=2Dvariables, then `read_seqcount_retry()` is called to confirm the two
=2Dare consistent, and only then is `->d_compare()` called.  When
=2Dstandard filename comparison is used, `dentry_cmp()` is called
=2Dinstead.  Notably it does _not_ use `read_seqcount_retry()`, but
+variables, then ``read_seqcount_retry()`` is called to confirm the two
+are consistent, and only then is ``->d_compare()`` called.  When
+standard filename comparison is used, ``dentry_cmp()`` is called
+instead.  Notably it does _not_ use ``read_seqcount_retry()``, but
 instead has a large comment explaining why the consistency guarantee
=2Disn't necessary.  A subsequent `read_seqcount_retry()` will be
+isn't necessary.  A subsequent ``read_seqcount_retry()`` will be
 sufficient to catch any problem that could occur at this point.
=20
 With that little refresher on seqlocks out of the way we can look at
 the bigger picture of how RCU-walk uses seqlocks.
=20
=2D### `mount_lock` and `nd->m_seq` ###
+``mount_lock`` and ``nd->m_seq``
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=20
=2DWe already met the `mount_lock` seqlock when REF-walk used it to
+We already met the ``mount_lock`` seqlock when REF-walk used it to
 ensure that crossing a mount point is performed safely.  RCU-walk uses
 it for that too, but for quite a bit more.
=20
=2DInstead of taking a counted reference to each `vfsmount` as it
=2Ddescends the tree, RCU-walk samples the state of `mount_lock` at the
+Instead of taking a counted reference to each ``vfsmount`` as it
+descends the tree, RCU-walk samples the state of ``mount_lock`` at the
 start of the walk and stores this initial sequence number in the
=2D`struct nameidata` in the `m_seq` field.  This one lock and one
=2Dsequence number are used to validate all accesses to all `vfsmounts`,
+``struct nameidata`` in the ``m_seq`` field.  This one lock and one
+sequence number are used to validate all accesses to all ``vfsmounts``,
 and all mount point crossings.  As changes to the mount table are
 relatively rare, it is reasonable to fall back on REF-walk any time
 that any "mount" or "unmount" happens.
=20
=2D`m_seq` is checked (using `read_seqretry()`) at the end of an RCU-walk
+``m_seq`` is checked (using ``read_seqretry()``) at the end of an RCU-walk
 sequence, whether switching to REF-walk for the rest of the path or
 when the end of the path is reached.  It is also checked when stepping
=2Ddown over a mount point (in `__follow_mount_rcu()`) or up (in
=2D`follow_dotdot_rcu()`).  If it is ever found to have changed, the
+down over a mount point (in ``__follow_mount_rcu()``) or up (in
+``follow_dotdot_rcu()``).  If it is ever found to have changed, the
 whole RCU-walk sequence is aborted and the path is processed again by
 REF-walk.
=20
=2DIf RCU-walk finds that `mount_lock` hasn't changed then it can be sure
+If RCU-walk finds that ``mount_lock`` hasn't changed then it can be sure
 that, had REF-walk taken counted references on each vfsmount, the
 results would have been the same.  This ensures the invariant holds,
 at least for vfsmount structures.
=20
=2D### `dentry->d_seq` and `nd->seq`. ###
+``dentry->d_seq`` and ``nd->seq``.
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=20
=2DIn place of taking a count or lock on `d_reflock`, RCU-walk samples
=2Dthe per-dentry `d_seq` seqlock, and stores the sequence number in the
=2D`seq` field of the nameidata structure, so `nd->seq` should always be
=2Dthe current sequence number of `nd->dentry`.  This number needs to be
+In place of taking a count or lock on ``d_reflock``, RCU-walk samples
+the per-dentry ``d_seq`` seqlock, and stores the sequence number in the
+``seq`` field of the nameidata structure, so ``nd->seq`` should always be
+the current sequence number of ``nd->dentry``.  This number needs to be
 revalidated after copying, and before using, the name, parent, or
 inode of the dentry.
=20
 The handling of the name we have already looked at, and the parent is
=2Donly accessed in `follow_dotdot_rcu()` which fairly trivially follows
+only accessed in ``follow_dotdot_rcu()`` which fairly trivially follows
 the required pattern, though it does so for three different cases.
=20
=2DWhen not at a mount point, `d_parent` is followed and its `d_seq` is
+When not at a mount point, ``d_parent`` is followed and its ``d_seq`` is
 collected.  When we are at a mount point, we instead follow the
=2D`mnt->mnt_mountpoint` link to get a new dentry and collect its
=2D`d_seq`.  Then, after finally finding a `d_parent` to follow, we must
+``mnt->mnt_mountpoint`` link to get a new dentry and collect its
+``d_seq``.  Then, after finally finding a ``d_parent`` to follow, we must
 check if we have landed on a mount point and, if so, must find that
=2Dmount point and follow the `mnt->mnt_root` link.  This would imply a
+mount point and follow the ``mnt->mnt_root`` link.  This would imply a
 somewhat unusual, but certainly possible, circumstance where the
 starting point of the path lookup was in part of the filesystem that
 was mounted on, and so not visible from the root.
=20
=2DThe inode pointer, stored in `->d_inode`, is a little more
+The inode pointer, stored in ``->d_inode``, is a little more
 interesting.  The inode will always need to be accessed at least
 twice, once to determine if it is NULL and once to verify access
 permissions.  Symlink handling requires a validated inode pointer too.
 Rather than revalidating on each access, a copy is made on the first
=2Daccess and it is stored in the `inode` field of `nameidata` from where
+access and it is stored in the ``inode`` field of ``nameidata`` from where
 it can be safely accessed without further validation.
=20
=2D`lookup_fast()` is the only lookup routine that is used in RCU-mode,
=2D`lookup_slow()` being too slow and requiring locks.  It is in
=2D`lookup_fast()` that we find the important "hand over hand" tracking
+``lookup_fast()`` is the only lookup routine that is used in RCU-mode,
+``lookup_slow()`` being too slow and requiring locks.  It is in
+``lookup_fast()`` that we find the important "hand over hand" tracking
 of the current dentry.
=20
=2DThe current `dentry` and current `seq` number are passed to
=2D`__d_lookup_rcu()` which, on success, returns a new `dentry` and a
=2Dnew `seq` number.  `lookup_fast()` then copies the inode pointer and
=2Drevalidates the new `seq` number.  It then validates the old `dentry`
=2Dwith the old `seq` number one last time and only then continues.  This
=2Dprocess of getting the `seq` number of the new dentry and then
=2Dchecking the `seq` number of the old exactly mirrors the process of
+The current ``dentry`` and current ``seq`` number are passed to
+``__d_lookup_rcu()`` which, on success, returns a new ``dentry`` and a
+new ``seq`` number.  ``lookup_fast()`` then copies the inode pointer and
+revalidates the new ``seq`` number.  It then validates the old ``dentry``
+with the old ``seq`` number one last time and only then continues.  This
+process of getting the ``seq`` number of the new dentry and then
+checking the ``seq`` number of the old exactly mirrors the process of
 getting a counted reference to the new dentry before dropping that for
 the old dentry which we saw in REF-walk.
=20
=2D### No `inode->i_rwsem` or even `rename_lock` ###
+No ``inode->i_rwsem`` or even ``rename_lock``
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=20
 A semaphore is a fairly heavyweight lock that can only be taken when it is
=2Dpermissible to sleep.  As `rcu_read_lock()` forbids sleeping,
=2D`inode->i_rwsem` plays no role in RCU-walk.  If some other thread does
=2Dtake `i_rwsem` and modifies the directory in a way that RCU-walk needs
+permissible to sleep.  As ``rcu_read_lock()`` forbids sleeping,
+``inode->i_rwsem`` plays no role in RCU-walk.  If some other thread does
+take ``i_rwsem`` and modifies the directory in a way that RCU-walk needs
 to notice, the result will be either that RCU-walk fails to find the
 dentry that it is looking for, or it will find a dentry which
=2D`read_seqretry()` won't validate.  In either case it will drop down to
+``read_seqretry()`` won't validate.  In either case it will drop down to
 REF-walk mode which can take whatever locks are needed.
=20
=2DThough `rename_lock` could be used by RCU-walk as it doesn't require
=2Dany sleeping, RCU-walk doesn't bother.  REF-walk uses `rename_lock` to
+Though ``rename_lock`` could be used by RCU-walk as it doesn't require
+any sleeping, RCU-walk doesn't bother.  REF-walk uses ``rename_lock`` to
 protect against the possibility of hash chains in the dcache changing
 while they are being searched.  This can result in failing to find
 something that actually is there.  When RCU-walk fails to find
@@ -796,52 +810,52 @@ already drops down to REF-walk and tries again with a=
ppropriate
 locking.  This neatly handles all cases, so adding extra checks on
 rename_lock would bring no significant value.
=20
=2D`unlazy walk()` and `complete_walk()`
+``unlazy walk()`` and ``complete_walk()``
 -------------------------------------
=20
 That "dropping down to REF-walk" typically involves a call to
=2D`unlazy_walk()`, so named because "RCU-walk" is also sometimes
=2Dreferred to as "lazy walk".  `unlazy_walk()` is called when
+``unlazy_walk()``, so named because "RCU-walk" is also sometimes
+referred to as "lazy walk".  ``unlazy_walk()`` is called when
 following the path down to the current vfsmount/dentry pair seems to
 have proceeded successfully, but the next step is problematic.  This
 can happen if the next name cannot be found in the dcache, if
 permission checking or name revalidation couldn't be achieved while
=2Dthe `rcu_read_lock()` is held (which forbids sleeping), if an
+the ``rcu_read_lock()`` is held (which forbids sleeping), if an
 automount point is found, or in a couple of cases involving symlinks.
=2DIt is also called from `complete_walk()` when the lookup has reached
+It is also called from ``complete_walk()`` when the lookup has reached
 the final component, or the very end of the path, depending on which
 particular flavor of lookup is used.
=20
 Other reasons for dropping out of RCU-walk that do not trigger a call
=2Dto `unlazy_walk()` are when some inconsistency is found that cannot be
=2Dhandled immediately, such as `mount_lock` or one of the `d_seq`
+to ``unlazy_walk()`` are when some inconsistency is found that cannot be
+handled immediately, such as ``mount_lock`` or one of the ``d_seq``
 seqlocks reporting a change.  In these cases the relevant function
=2Dwill return `-ECHILD` which will percolate up until it triggers a new
+will return ``-ECHILD`` which will percolate up until it triggers a new
 attempt from the top using REF-walk.
=20
=2DFor those cases where `unlazy_walk()` is an option, it essentially
+For those cases where ``unlazy_walk()`` is an option, it essentially
 takes a reference on each of the pointers that it holds (vfsmount,
 dentry, and possibly some symbolic links) and then verifies that the
 relevant seqlocks have not been changed.  If there have been changes,
=2Dit, too, aborts with `-ECHILD`, otherwise the transition to REF-walk
+it, too, aborts with ``-ECHILD``, otherwise the transition to REF-walk
 has been a success and the lookup process continues.
=20
 Taking a reference on those pointers is not quite as simple as just
 incrementing a counter.  That works to take a second reference if you
 already have one (often indirectly through another object), but it
 isn't sufficient if you don't actually have a counted reference at
=2Dall.  For `dentry->d_lockref`, it is safe to increment the reference
+all.  For ``dentry->d_lockref``, it is safe to increment the reference
 counter to get a reference unless it has been explicitly marked as
=2D"dead" which involves setting the counter to `-128`.
=2D`lockref_get_not_dead()` achieves this.
+"dead" which involves setting the counter to ``-128``.
+``lockref_get_not_dead()`` achieves this.
=20
=2DFor `mnt->mnt_count` it is safe to take a reference as long as
=2D`mount_lock` is then used to validate the reference.  If that
+For ``mnt->mnt_count`` it is safe to take a reference as long as
+``mount_lock`` is then used to validate the reference.  If that
 validation fails, it may *not* be safe to just drop that reference in
=2Dthe standard way of calling `mnt_put()` - an unmount may have
=2Dprogressed too far.  So the code in `legitimize_mnt()`, when it
+the standard way of calling ``mnt_put()`` - an unmount may have
+progressed too far.  So the code in ``legitimize_mnt()``, when it
 finds that the reference it got might not be safe, checks the
=2D`MNT_SYNC_UMOUNT` flag to determine if a simple `mnt_put()` is
+``MNT_SYNC_UMOUNT`` flag to determine if a simple ``mnt_put()`` is
 correct, or if it should just decrement the count and pretend none of
 this ever happened.
=20
@@ -856,26 +870,26 @@ careful.
=20
 If the filesystem has non-standard permission-checking requirements -
 such as a networked filesystem which may need to check with the server
=2D- the `i_op->permission` interface might be called during RCU-walk.
=2DIn this case an extra "`MAY_NOT_BLOCK`" flag is passed so that it
=2Dknows not to sleep, but to return `-ECHILD` if it cannot complete
=2Dpromptly.  `i_op->permission` is given the inode pointer, not the
+- the ``i_op->permission`` interface might be called during RCU-walk.
+In this case an extra "``MAY_NOT_BLOCK``" flag is passed so that it
+knows not to sleep, but to return ``-ECHILD`` if it cannot complete
+promptly.  ``i_op->permission`` is given the inode pointer, not the
 dentry, so it doesn't need to worry about further consistency checks.
 However if it accesses any other filesystem data structures, it must
=2Densure they are safe to be accessed with only the `rcu_read_lock()`
=2Dheld.  This typically means they must be freed using `kfree_rcu()` or
+ensure they are safe to be accessed with only the ``rcu_read_lock()``
+held.  This typically means they must be freed using ``kfree_rcu()`` or
 similar.
=20
=2D[`READ_ONCE()`]: https://lwn.net/Articles/624126/
+.. _READ_ONCE: https://lwn.net/Articles/624126/
=20
 If the filesystem may need to revalidate dcache entries, then
=2D`d_op->d_revalidate` may be called in RCU-walk too.  This interface
=2D*is* passed the dentry but does not have access to the `inode` or the
=2D`seq` number from the `nameidata`, so it needs to be extra careful
+``d_op->d_revalidate`` may be called in RCU-walk too.  This interface
+*is* passed the dentry but does not have access to the ``inode`` or the
+``seq`` number from the ``nameidata``, so it needs to be extra careful
 when accessing fields in the dentry.  This "extra care" typically
=2Dinvolves using [`READ_ONCE()`] to access fields, and verifying the
+involves using  `READ_ONCE() <READ_ONCE_>`_ to access fields, and verifyin=
g the
 result is not NULL before using it.  This pattern can be seen in
=2D`nfs_lookup_revalidate()`.
+``nfs_lookup_revalidate()``.
=20
 A pair of patterns
 ------------------
@@ -886,14 +900,14 @@ being aware of.
=20
 The first is "try quickly and check, if that fails try slowly".  We
 can see that in the high-level approach of first trying RCU-walk and
=2Dthen trying REF-walk, and in places where `unlazy_walk()` is used to
+then trying REF-walk, and in places where ``unlazy_walk()`` is used to
 switch to REF-walk for the rest of the path.  We also saw it earlier
=2Din `dget_parent()` when following a "`..`" link.  It tries a quick way
+in ``dget_parent()`` when following a "``..``" link.  It tries a quick way
 to get a reference, then falls back to taking locks if needed.
=20
 The second pattern is "try quickly and check, if that fails try
=2Dagain - repeatedly".  This is seen with the use of `rename_lock` and
=2D`mount_lock` in REF-walk.  RCU-walk doesn't make use of this pattern -
+again - repeatedly".  This is seen with the use of ``rename_lock`` and
+``mount_lock`` in REF-walk.  RCU-walk doesn't make use of this pattern -
 if anything goes wrong it is much safer to just abort and try a more
 sedate approach.
=20
@@ -929,8 +943,8 @@ Conceptually, symbolic links could be handled by editin=
g the path.  If
 a component name refers to a symbolic link, then that component is
 replaced by the body of the link and, if that body starts with a '/',
 then all preceding parts of the path are discarded.  This is what the
=2D"`readlink -f`" command does, though it also edits out "`.`" and
=2D"`..`" components.
+"``readlink -f``" command does, though it also edits out "``.``" and
+"``..``" components.
=20
 Directly editing the path string is not really necessary when looking
 up a path, and discarding early components is pointless as they aren't
@@ -946,19 +960,19 @@ There are two reasons for placing limits on how many =
symlinks can
 occur in a single path lookup.  The most obvious is to avoid loops.
 If a symlink referred to itself either directly or through
 intermediaries, then following the symlink can never complete
=2Dsuccessfully - the error `ELOOP` must be returned.  Loops can be
+successfully - the error ``ELOOP`` must be returned.  Loops can be
 detected without imposing limits, but limits are the simplest solution
 and, given the second reason for restriction, quite sufficient.
=20
=2D[outlined recently]: http://thread.gmane.org/gmane.linux.kernel/1934390/=
focus=3D1934550
+.. _outlined recently: http://thread.gmane.org/gmane.linux.kernel/1934390/=
focus=3D1934550
=20
=2DThe second reason was [outlined recently] by Linus:
+The second reason was `outlined recently`_ by Linus:
=20
=2D>  Because it's a latency and DoS issue too. We need to react well to
=2D>  true loops, but also to "very deep" non-loops. It's not about memory
=2D>  use, it's about users triggering unreasonable CPU resources.
+   Because it's a latency and DoS issue too. We need to react well to
+   true loops, but also to "very deep" non-loops. It's not about memory
+   use, it's about users triggering unreasonable CPU resources.
=20
=2DLinux imposes a limit on the length of any pathname: `PATH_MAX`, which
+Linux imposes a limit on the length of any pathname: ``PATH_MAX``, which
 is 4096.  There are a number of reasons for this limit; not letting the
 kernel spend too much time on just one path is one of them.  With
 symbolic links you can effectively generate much longer paths so some
@@ -968,7 +982,7 @@ further limit of eight on the maximum depth of recursio=
n, but that was
 raised to 40 when a separate stack was implemented, so there is now
 just the one limit.
=20
=2DThe `nameidata` structure that we met in an earlier article contains a
+The ``nameidata`` structure that we met in an earlier article contains a
 small stack that can be used to store the remaining part of up to two
 symlinks.  In many cases this will be sufficient.  If it isn't, a
 separate stack is allocated with room for 40 symlinks.  Pathname
@@ -988,13 +1002,13 @@ to external storage.  It is particularly important f=
or RCU-walk to be
 able to find and temporarily hold onto these cached entries, so that
 it doesn't need to drop down into REF-walk.
=20
=2D[object-oriented design pattern]: https://lwn.net/Articles/446317/
+.. _object-oriented design pattern: https://lwn.net/Articles/446317/
=20
 While each filesystem is free to make its own choice, symlinks are
 typically stored in one of two places.  Short symlinks are often
=2Dstored directly in the inode.  When a filesystem allocates a `struct
=2Dinode` it typically allocates extra space to store private data (a
=2Dcommon [object-oriented design pattern] in the kernel).  This will
+stored directly in the inode.  When a filesystem allocates a ``struct
+inode`` it typically allocates extra space to store private data (a
+common `object-oriented design pattern`_ in the kernel).  This will
 sometimes include space for a symlink.  The other common location is
 in the page cache, which normally stores the content of files.  The
 pathname in a symlink can be seen as the content of that symlink and
@@ -1009,13 +1023,13 @@ the inode which, itself, is protected by RCU or by =
a counted reference
 on the dentry.  This means that the mechanisms that pathname lookup
 uses to access the dcache and icache (inode cache) safely are quite
 sufficient for accessing some cached symlinks safely.  In these cases,
=2Dthe `i_link` pointer in the inode is set to point to wherever the
+the ``i_link`` pointer in the inode is set to point to wherever the
 symlink is stored and it can be accessed directly whenever needed.
=20
 When the symlink is stored in the page cache or elsewhere, the
 situation is not so straightforward.  A reference on a dentry or even
 on an inode does not imply any reference on cached pages of that
=2Dinode, and even an `rcu_read_lock()` is not sufficient to ensure that
+inode, and even an ``rcu_read_lock()`` is not sufficient to ensure that
 a page will not disappear.  So for these symlinks the pathname lookup
 code needs to ask the filesystem to provide a stable reference and,
 significantly, needs to release that reference when it is finished
@@ -1025,48 +1039,48 @@ Taking a reference to a cache page is often possibl=
e even in RCU-walk
 mode.  It does require making changes to memory, which is best avoided,
 but that isn't necessarily a big cost and it is better than dropping
 out of RCU-walk mode completely.  Even filesystems that allocate
=2Dspace to copy the symlink into can use `GFP_ATOMIC` to often successfully
+space to copy the symlink into can use ``GFP_ATOMIC`` to often successfully
 allocate memory without the need to drop out of RCU-walk.  If a
 filesystem cannot successfully get a reference in RCU-walk mode, it
=2Dmust return `-ECHILD` and `unlazy_walk()` will be called to return to
+must return ``-ECHILD`` and ``unlazy_walk()`` will be called to return to
 REF-walk mode in which the filesystem is allowed to sleep.
=20
=2DThe place for all this to happen is the `i_op->follow_link()` inode
+The place for all this to happen is the ``i_op->follow_link()`` inode
 method.  In the present mainline code this is never actually called in
 RCU-walk mode as the rewrite is not quite complete.  It is likely that
=2Din a future release this method will be passed an `inode` pointer when
+in a future release this method will be passed an ``inode`` pointer when
 called in RCU-walk mode so it both (1) knows to be careful, and (2) has the
=2Dvalidated pointer.  Much like the `i_op->permission()` method we
=2Dlooked at previously, `->follow_link()` would need to be careful that
+validated pointer.  Much like the ``i_op->permission()`` method we
+looked at previously, ``->follow_link()`` would need to be careful that
 all the data structures it references are safe to be accessed while
 holding no counted reference, only the RCU lock.  Though getting a
=2Dreference with `->follow_link()` is not yet done in RCU-walk mode, the
+reference with ``->follow_link()`` is not yet done in RCU-walk mode, the
 code is ready to release the reference when that does happen.
=20
 This need to drop the reference to a symlink adds significant
 complexity.  It requires a reference to the inode so that the
=2D`i_op->put_link()` inode operation can be called.  In REF-walk, that
+``i_op->put_link()`` inode operation can be called.  In REF-walk, that
 reference is kept implicitly through a reference to the dentry, so
=2Dkeeping the `struct path` of the symlink is easiest.  For RCU-walk,
+keeping the ``struct path`` of the symlink is easiest.  For RCU-walk,
 the pointer to the inode is kept separately.  To allow switching from
 RCU-walk back to REF-walk in the middle of processing nested symlinks
 we also need the seq number for the dentry so we can confirm that
 switching back was safe.
=20
 Finally, when providing a reference to a symlink, the filesystem also
=2Dprovides an opaque "cookie" that must be passed to `->put_link()` so tha=
t it
+provides an opaque "cookie" that must be passed to ``->put_link()`` so tha=
t it
 knows what to free.  This might be the allocated memory area, or a
=2Dpointer to the `struct page` in the page cache, or something else
+pointer to the ``struct page`` in the page cache, or something else
 completely.  Only the filesystem knows what it is.
=20
 In order for the reference to each symlink to be dropped when the walk com=
pletes,
 whether in RCU-walk or REF-walk, the symlink stack needs to contain,
 along with the path remnants:
=20
=2D- the `struct path` to provide a reference to the inode in REF-walk
=2D- the `struct inode *` to provide a reference to the inode in RCU-walk
=2D- the `seq` to allow the path to be safely switched from RCU-walk to REF=
-walk
=2D- the `cookie` that tells `->put_path()` what to put.
+- the ``struct path`` to provide a reference to the inode in REF-walk
+- the ``struct inode *`` to provide a reference to the inode in RCU-walk
+- the ``seq`` to allow the path to be safely switched from RCU-walk to REF=
-walk
+- the ``cookie`` that tells ``->put_path()`` what to put.
=20
 This means that each entry in the symlink stack needs to hold five
 pointers and an integer instead of just one pointer (the path
@@ -1075,28 +1089,28 @@ with 40 entries it adds up to 1600 bytes total, whi=
ch is less than
 half a page.  So it might seem like a lot, but is by no means
 excessive.
=20
=2DNote that, in a given stack frame, the path remnant (`name`) is not
+Note that, in a given stack frame, the path remnant (``name``) is not
 part of the symlink that the other fields refer to.  It is the remnant
 to be followed once that symlink has been fully parsed.
=20
 Following the symlink
 ---------------------
=20
=2DThe main loop in `link_path_walk()` iterates seamlessly over all
+The main loop in ``link_path_walk()`` iterates seamlessly over all
 components in the path and all of the non-final symlinks.  As symlinks
=2Dare processed, the `name` pointer is adjusted to point to a new
+are processed, the ``name`` pointer is adjusted to point to a new
 symlink, or is restored from the stack, so that much of the loop
=2Ddoesn't need to notice.  Getting this `name` variable on and off the
+doesn't need to notice.  Getting this ``name`` variable on and off the
 stack is very straightforward; pushing and popping the references is
 a little more complex.
=20
=2DWhen a symlink is found, `walk_component()` returns the value `1`
=2D(`0` is returned for any other sort of success, and a negative number
=2Dis, as usual, an error indicator).  This causes `get_link()` to be
+When a symlink is found, ``walk_component()`` returns the value ``1``
+(``0`` is returned for any other sort of success, and a negative number
+is, as usual, an error indicator).  This causes ``get_link()`` to be
 called; it then gets the link from the filesystem.  Providing that
=2Doperation is successful, the old path `name` is placed on the stack,
=2Dand the new value is used as the `name` for a while.  When the end of
=2Dthe path is found (i.e. `*name` is `'\0'`) the old `name` is restored
+operation is successful, the old path ``name`` is placed on the stack,
+and the new value is used as the ``name`` for a while.  When the end of
+the path is found (i.e. ``*name`` is ``'\0'``) the old ``name`` is restored
 off the stack and path walking continues.
=20
 Pushing and popping the reference pointers (inode, cookie, etc.) is more
@@ -1107,113 +1121,114 @@ the symlink-just-found to avoid leaving empty pat=
h remnants that would
 just get in the way.
=20
 It is most convenient to push the new symlink references onto the
=2Dstack in `walk_component()` immediately when the symlink is found;
=2D`walk_component()` is also the last piece of code that needs to look at =
the
+stack in ``walk_component()`` immediately when the symlink is found;
+``walk_component()`` is also the last piece of code that needs to look at =
the
 old symlink as it walks that last component.  So it is quite
=2Dconvenient for `walk_component()` to release the old symlink and pop
+convenient for ``walk_component()`` to release the old symlink and pop
 the references just before pushing the reference information for the
=2Dnew symlink.  It is guided in this by two flags; `WALK_GET`, which
+new symlink.  It is guided in this by two flags; ``WALK_GET``, which
 gives it permission to follow a symlink if it finds one, and
=2D`WALK_PUT`, which tells it to release the current symlink after it has b=
een
=2Dfollowed.  `WALK_PUT` is tested first, leading to a call to
=2D`put_link()`.  `WALK_GET` is tested subsequently (by
=2D`should_follow_link()`) leading to a call to `pick_link()` which sets
+``WALK_PUT``, which tells it to release the current symlink after it has b=
een
+followed.  ``WALK_PUT`` is tested first, leading to a call to
+``put_link()``.  ``WALK_GET`` is tested subsequently (by
+``should_follow_link()``) leading to a call to ``pick_link()`` which sets
 up the stack frame.
=20
=2D### Symlinks with no final component ###
+Symlinks with no final component
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=20
 A pair of special-case symlinks deserve a little further explanation.
=2DBoth result in a new `struct path` (with mount and dentry) being set
=2Dup in the `nameidata`, and result in `get_link()` returning `NULL`.
+Both result in a new ``struct path`` (with mount and dentry) being set
+up in the ``nameidata``, and result in ``get_link()`` returning ``NULL``.
=20
=2DThe more obvious case is a symlink to "`/`".  All symlinks starting
=2Dwith "`/`" are detected in `get_link()` which resets the `nameidata`
+The more obvious case is a symlink to "``/``".  All symlinks starting
+with "``/``" are detected in ``get_link()`` which resets the ``nameidata``
 to point to the effective filesystem root.  If the symlink only
=2Dcontains "`/`" then there is nothing more to do, no components at all,
=2Dso `NULL` is returned to indicate that the symlink can be released and
+contains "``/``" then there is nothing more to do, no components at all,
+so ``NULL`` is returned to indicate that the symlink can be released and
 the stack frame discarded.
=20
=2DThe other case involves things in `/proc` that look like symlinks but
=2Daren't really.
+The other case involves things in ``/proc`` that look like symlinks but
+aren't really::
=20
=2D>     $ ls -l /proc/self/fd/1
=2D>     lrwx------ 1 neilb neilb 64 Jun 13 10:19 /proc/self/fd/1 -> /dev/p=
ts/4
+     $ ls -l /proc/self/fd/1
+     lrwx------ 1 neilb neilb 64 Jun 13 10:19 /proc/self/fd/1 -> /dev/pts/4
=20
=2DEvery open file descriptor in any process is represented in `/proc` by
+Every open file descriptor in any process is represented in ``/proc`` by
 something that looks like a symlink.  It is really a reference to the
=2Dtarget file, not just the name of it.  When you `readlink` these
+target file, not just the name of it.  When you ``readlink`` these
 objects you get a name that might refer to the same file - unless it
=2Dhas been unlinked or mounted over.  When `walk_component()` follows
=2Done of these, the `->follow_link()` method in "procfs" doesn't return
=2Da string name, but instead calls `nd_jump_link()` which updates the
=2D`nameidata` in place to point to that target.  `->follow_link()` then
=2Dreturns `NULL`.  Again there is no final component and `get_link()`
=2Dreports this by leaving the `last_type` field of `nameidata` as
=2D`LAST_BIND`.
+has been unlinked or mounted over.  When ``walk_component()`` follows
+one of these, the ``->follow_link()`` method in "procfs" doesn't return
+a string name, but instead calls ``nd_jump_link()`` which updates the
+``nameidata`` in place to point to that target.  ``->follow_link()`` then
+returns ``NULL``.  Again there is no final component and ``get_link()``
+reports this by leaving the ``last_type`` field of ``nameidata`` as
+``LAST_BIND``.
=20
 Following the symlink in the final component
 --------------------------------------------
=20
=2DAll this leads to `link_path_walk()` walking down every component, and
+All this leads to ``link_path_walk()`` walking down every component, and
 following all symbolic links it finds, until it reaches the final
=2Dcomponent.  This is just returned in the `last` field of `nameidata`.
+component.  This is just returned in the ``last`` field of ``nameidata``.
 For some callers, this is all they need; they want to create that
=2D`last` name if it doesn't exist or give an error if it does.  Other
+``last`` name if it doesn't exist or give an error if it does.  Other
 callers will want to follow a symlink if one is found, and possibly
 apply special handling to the last component of that symlink, rather
 than just the last component of the original file name.  These callers
=2Dpotentially need to call `link_path_walk()` again and again on
+potentially need to call ``link_path_walk()`` again and again on
 successive symlinks until one is found that doesn't point to another
 symlink.
=20
=2DThis case is handled by the relevant caller of `link_path_walk()`, such =
as
=2D`path_lookupat()` using a loop that calls `link_path_walk()`, and then
+This case is handled by the relevant caller of ``link_path_walk()``, such =
as
+``path_lookupat()`` using a loop that calls ``link_path_walk()``, and then
 handles the final component.  If the final component is a symlink
=2Dthat needs to be followed, then `trailing_symlink()` is called to set
=2Dthings up properly and the loop repeats, calling `link_path_walk()`
+that needs to be followed, then ``trailing_symlink()`` is called to set
+things up properly and the loop repeats, calling ``link_path_walk()``
 again.  This could loop as many as 40 times if the last component of
 each symlink is another symlink.
=20
 The various functions that examine the final component and possibly
=2Dreport that it is a symlink are `lookup_last()`, `mountpoint_last()`
=2Dand `do_last()`, each of which use the same convention as
=2D`walk_component()` of returning `1` if a symlink was found that needs
+report that it is a symlink are ``lookup_last()``, ``mountpoint_last()``
+and ``do_last()``, each of which use the same convention as
+``walk_component()`` of returning ``1`` if a symlink was found that needs
 to be followed.
=20
=2DOf these, `do_last()` is the most interesting as it is used for
=2Dopening a file.  Part of `do_last()` runs with `i_rwsem` held and this
=2Dpart is in a separate function: `lookup_open()`.
+Of these, ``do_last()`` is the most interesting as it is used for
+opening a file.  Part of ``do_last()`` runs with ``i_rwsem`` held and this
+part is in a separate function: ``lookup_open()``.
=20
=2DExplaining `do_last()` completely is beyond the scope of this article,
+Explaining ``do_last()`` completely is beyond the scope of this article,
 but a few highlights should help those interested in exploring the
 code.
=20
=2D1. Rather than just finding the target file, `do_last()` needs to open
=2D it.  If the file was found in the dcache, then `vfs_open()` is used for
=2D this.  If not, then `lookup_open()` will either call `atomic_open()` (if
=2D the filesystem provides it) to combine the final lookup with the open, =
or
=2D will perform the separate `lookup_real()` and `vfs_create()` steps
=2D directly.  In the later case the actual "open" of this newly found or
=2D created file will be performed by `vfs_open()`, just as if the name
=2D were found in the dcache.
=2D
=2D2. `vfs_open()` can fail with `-EOPENSTALE` if the cached information
=2D wasn't quite current enough.  Rather than restarting the lookup from
=2D the top with `LOOKUP_REVAL` set, `lookup_open()` is called instead,
=2D giving the filesystem a chance to resolve small inconsistencies.
=2D If that doesn't work, only then is the lookup restarted from the top.
+1. Rather than just finding the target file, ``do_last()`` needs to open
+   it.  If the file was found in the dcache, then ``vfs_open()`` is used f=
or
+   this.  If not, then ``lookup_open()`` will either call ``atomic_open()`=
` (if
+   the filesystem provides it) to combine the final lookup with the open, =
or
+   will perform the separate ``lookup_real()`` and ``vfs_create()`` steps
+   directly.  In the later case the actual "open" of this newly found or
+   created file will be performed by ``vfs_open()``, just as if the name
+   were found in the dcache.
+
+2. ``vfs_open()`` can fail with ``-EOPENSTALE`` if the cached information
+   wasn't quite current enough.  Rather than restarting the lookup from
+   the top with ``LOOKUP_REVAL`` set, ``lookup_open()`` is called instead,
+   giving the filesystem a chance to resolve small inconsistencies.
+   If that doesn't work, only then is the lookup restarted from the top.
=20
 3. An open with O_CREAT **does** follow a symlink in the final component,
=2D     unlike other creation system calls (like `mkdir`).  So the sequence:
+   unlike other creation system calls (like ``mkdir``).  So the sequence::
=20
=2D     >     ln -s bar /tmp/foo
=2D     >     echo hello > /tmp/foo
+          ln -s bar /tmp/foo
+          echo hello > /tmp/foo
=20
=2D     will create a file called `/tmp/bar`.  This is not permitted if
=2D     `O_EXCL` is set but otherwise is handled for an O_CREAT open much
=2D     like for a non-creating open: `should_follow_link()` returns `1`, a=
nd
=2D     so does `do_last()` so that `trailing_symlink()` gets called and the
=2D     open process continues on the symlink that was found.
+   will create a file called ``/tmp/bar``.  This is not permitted if
+   ``O_EXCL`` is set but otherwise is handled for an O_CREAT open much
+   like for a non-creating open: ``should_follow_link()`` returns ``1``, a=
nd
+   so does ``do_last()`` so that ``trailing_symlink()`` gets called and the
+   open process continues on the symlink that was found.
=20
 Updating the access time
 ------------------------
@@ -1227,110 +1242,112 @@ footprints are best kept to a minimum.
 One other place where walking down a symlink can involve leaving
 footprints in a way that doesn't affect directories is in updating access =
times.
 In Unix (and Linux) every filesystem object has a "last accessed
=2Dtime", or "`atime`".  Passing through a directory to access a file
+time", or "``atime``".  Passing through a directory to access a file
 within is not considered to be an access for the purposes of
=2D`atime`; only listing the contents of a directory can update its `atime`.
=2DSymlinks are different it seems.  Both reading a symlink (with `readlink=
()`)
+``atime``; only listing the contents of a directory can update its ``atime=
``.
+Symlinks are different it seems.  Both reading a symlink (with ``readlink(=
)``)
 and looking up a symlink on the way to some other destination can
 update the atime on that symlink.
=20
=2D[clearest statement]: http://pubs.opengroup.org/onlinepubs/9699919799/ba=
sedefs/V1_chap04.html#tag_04_08
+.. _clearest statement: http://pubs.opengroup.org/onlinepubs/9699919799/ba=
sedefs/V1_chap04.html#tag_04_08
=20
 It is not clear why this is the case; POSIX has little to say on the
=2Dsubject.  The [clearest statement] is that, if a particular implementati=
on
+subject.  The `clearest statement`_ is that, if a particular implementation
 updates a timestamp in a place not specified by POSIX, this must be
 documented "except that any changes caused by pathname resolution need
 not be documented".  This seems to imply that POSIX doesn't really
 care about access-time updates during pathname lookup.
=20
=2D[Linux 1.3.87]: https://git.kernel.org/cgit/linux/kernel/git/history/his=
tory.git/diff/fs/ext2/symlink.c?id=3Df806c6db77b8eaa6e00dcfb6b567706feae8db=
b8
+.. _Linux 1.3.87: https://git.kernel.org/cgit/linux/kernel/git/history/his=
tory.git/diff/fs/ext2/symlink.c?id=3Df806c6db77b8eaa6e00dcfb6b567706feae8db=
b8
=20
=2DAn examination of history shows that prior to [Linux 1.3.87], the ext2
+An examination of history shows that prior to `Linux 1.3.87`_, the ext2
 filesystem, at least, didn't update atime when following a link.
 Unfortunately we have no record of why that behavior was changed.
=20
 In any case, access time must now be updated and that operation can be
 quite complex.  Trying to stay in RCU-walk while doing it is best
=2Davoided.  Fortunately it is often permitted to skip the `atime`
=2Dupdate.  Because `atime` updates cause performance problems in various
=2Dareas, Linux supports the `relatime` mount option, which generally
=2Dlimits the updates of `atime` to once per day on files that aren't
+avoided.  Fortunately it is often permitted to skip the ``atime``
+update.  Because ``atime`` updates cause performance problems in various
+areas, Linux supports the ``relatime`` mount option, which generally
+limits the updates of ``atime`` to once per day on files that aren't
 being changed (and symlinks never change once created).  Even without
=2D`relatime`, many filesystems record `atime` with a one-second
+``relatime``, many filesystems record ``atime`` with a one-second
 granularity, so only one update per second is required.
=20
=2DIt is easy to test if an `atime` update is needed while in RCU-walk
+It is easy to test if an ``atime`` update is needed while in RCU-walk
 mode and, if it isn't, the update can be skipped and RCU-walk mode
=2Dcontinues.  Only when an `atime` update is actually required does the
+continues.  Only when an ``atime`` update is actually required does the
 path walk drop down to REF-walk.  All of this is handled in the
=2D`get_link()` function.
+``get_link()`` function.
=20
 A few flags
 -----------
=20
 A suitable way to wrap up this tour of pathname walking is to list
=2Dthe various flags that can be stored in the `nameidata` to guide the
+the various flags that can be stored in the ``nameidata`` to guide the
 lookup process.  Many of these are only meaningful on the final
 component, others reflect the current state of the pathname lookup.
=2DAnd then there is `LOOKUP_EMPTY`, which doesn't fit conceptually with
+And then there is ``LOOKUP_EMPTY``, which doesn't fit conceptually with
 the others.  If this is not set, an empty pathname causes an error
 very early on.  If it is set, empty pathnames are not considered to be
 an error.
=20
=2D### Global state flags ###
+Global state flags
+~~~~~~~~~~~~~~~~~~
=20
=2DWe have already met two global state flags: `LOOKUP_RCU` and
=2D`LOOKUP_REVAL`.  These select between one of three overall approaches
+We have already met two global state flags: ``LOOKUP_RCU`` and
+``LOOKUP_REVAL``.  These select between one of three overall approaches
 to lookup: RCU-walk, REF-walk, and REF-walk with forced revalidation.
=20
=2D`LOOKUP_PARENT` indicates that the final component hasn't been reached
+``LOOKUP_PARENT`` indicates that the final component hasn't been reached
 yet.  This is primarily used to tell the audit subsystem the full
 context of a particular access being audited.
=20
=2D`LOOKUP_ROOT` indicates that the `root` field in the `nameidata` was
+``LOOKUP_ROOT`` indicates that the ``root`` field in the ``nameidata`` was
 provided by the caller, so it shouldn't be released when it is no
 longer needed.
=20
=2D`LOOKUP_JUMPED` means that the current dentry was chosen not because
+``LOOKUP_JUMPED`` means that the current dentry was chosen not because
 it had the right name but for some other reason.  This happens when
=2Dfollowing "`..`", following a symlink to `/`, crossing a mount point
=2Dor accessing a "`/proc/$PID/fd/$FD`" symlink.  In this case the
+following "``..``", following a symlink to ``/``, crossing a mount point
+or accessing a "``/proc/$PID/fd/$FD``" symlink.  In this case the
 filesystem has not been asked to revalidate the name (with
=2D`d_revalidate()`).  In such cases the inode may still need to be
=2Drevalidated, so `d_op->d_weak_revalidate()` is called if
=2D`LOOKUP_JUMPED` is set when the look completes - which may be at the
+``d_revalidate()``).  In such cases the inode may still need to be
+revalidated, so ``d_op->d_weak_revalidate()`` is called if
+``LOOKUP_JUMPED`` is set when the look completes - which may be at the
 final component or, when creating, unlinking, or renaming, at the penultim=
ate component.
=20
=2D### Final-component flags ###
+Final-component flags
+~~~~~~~~~~~~~~~~~~~~~
=20
 Some of these flags are only set when the final component is being
 considered.  Others are only checked for when considering that final
 component.
=20
=2D`LOOKUP_AUTOMOUNT` ensures that, if the final component is an automount
+``LOOKUP_AUTOMOUNT`` ensures that, if the final component is an automount
 point, then the mount is triggered.  Some operations would trigger it
=2Danyway, but operations like `stat()` deliberately don't.  `statfs()`
=2Dneeds to trigger the mount but otherwise behaves a lot like `stat()`, so
=2Dit sets `LOOKUP_AUTOMOUNT`, as does "`quotactl()`" and the handling of
=2D"`mount --bind`".
+anyway, but operations like ``stat()`` deliberately don't.  ``statfs()``
+needs to trigger the mount but otherwise behaves a lot like ``stat()``, so
+it sets ``LOOKUP_AUTOMOUNT``, as does "``quotactl()``" and the handling of
+"``mount --bind``".
=20
=2D`LOOKUP_FOLLOW` has a similar function to `LOOKUP_AUTOMOUNT` but for
+``LOOKUP_FOLLOW`` has a similar function to ``LOOKUP_AUTOMOUNT`` but for
 symlinks.  Some system calls set or clear it implicitly, while
=2Dothers have API flags such as `AT_SYMLINK_FOLLOW` and
=2D`UMOUNT_NOFOLLOW` to control it.  Its effect is similar to
=2D`WALK_GET` that we already met, but it is used in a different way.
+others have API flags such as ``AT_SYMLINK_FOLLOW`` and
+``UMOUNT_NOFOLLOW`` to control it.  Its effect is similar to
+``WALK_GET`` that we already met, but it is used in a different way.
=20
=2D`LOOKUP_DIRECTORY` insists that the final component is a directory.
+``LOOKUP_DIRECTORY`` insists that the final component is a directory.
 Various callers set this and it is also set when the final component
 is found to be followed by a slash.
=20
=2DFinally `LOOKUP_OPEN`, `LOOKUP_CREATE`, `LOOKUP_EXCL`, and
=2D`LOOKUP_RENAME_TARGET` are not used directly by the VFS but are made
=2Davailable to the filesystem and particularly the `->d_revalidate()`
+Finally ``LOOKUP_OPEN``, ``LOOKUP_CREATE``, ``LOOKUP_EXCL``, and
+``LOOKUP_RENAME_TARGET`` are not used directly by the VFS but are made
+available to the filesystem and particularly the ``->d_revalidate()``
 method.  A filesystem can choose not to bother revalidating too hard
 if it knows that it will be asked to open or create the file soon.
=2DThese flags were previously useful for `->lookup()` too but with the
=2Dintroduction of `->atomic_open()` they are less relevant there.
+These flags were previously useful for ``->lookup()`` too but with the
+introduction of ``->atomic_open()`` they are less relevant there.
=20
 End of the road
 ---------------
=2D-=20
2.14.0.rc0.dirty


--=-=-=
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEG8Yp69OQ2HB7X0l6Oeye3VZigbkFAlwHB5wACgkQOeye3VZi
gbn8Hw//UAX37bDLTxfD0hq/jTW1ho2k/K5zT2crbF0m9zZS8ikddaJBcoPnC7PN
imBzR0KJ/7HcioAgP+xqu1zQzeLC4bsQhoGFR1NoDOCSB6w2hvFuzt4UK+21WeID
aSnToIx1zUTJweAt/QDNiGYgnc5tUCbSLzzadJT37unrjbzud7HKERc47MYmzW4i
SDUsn1huE7p0Umhs1HSTuGla+x+lOeL8qPCnNpB3YQNOy67/W11lgxc9DhyoVtJK
RZ/iv/CepzHwQu+osgoLoey3Zd6/QsC/VpnPv1YlWZlBZZM9HckQGjMy046O+OtH
Qskm9U0BxfQfg6yfkQyh+kzraMnhIihceLQyGM9zpvxan55jFW2DlJ065dJu1oR/
O0qmaWTOlMNxOpsKFR1Hp5HxMXW0ssYTVd8rI009vZEARto2bPLgZ3+7wVOa0nG9
PkQhu84P9M6oCzd6qWxZ5ct63ywJC9avjo8eOZDHwSZX56JLzxZDIlthjsYFzRII
qnwWnqxw/M7WllR88N8Xn7p+kOg/RbztSDpO/N08bkeO/kZbTLu3IG2K2kWig4XA
Gd0H5m9wTNU+6bMClcjxhPNBERSQtuOJ/mErfl+S2Z7fGIUv5Wt9YIxEPmbiWDyO
hdKIKxDZ0ymyJzt4EH7ET3PKXQhgIYbewuGSk7JSsKSZWq9lNcQ=
=15vP
-----END PGP SIGNATURE-----
--=-=-=--
