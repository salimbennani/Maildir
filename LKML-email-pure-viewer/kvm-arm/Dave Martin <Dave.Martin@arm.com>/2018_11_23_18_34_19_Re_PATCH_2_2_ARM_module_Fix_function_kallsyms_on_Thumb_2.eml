Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:36:53 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id AA52558037D;
	Fri, 23 Nov 2018 10:34:30 -0800 (PST)
Received: from fmsmga105.fm.intel.com ([10.1.193.10])
  by fmsmga001-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 10:34:30 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3As9/SrxbvpSQdxJTsX1WBeaT/LSx+4OfEezUN459i?=
 =?us-ascii?q?sYplN5qZpci8Yx7h7PlgxGXEQZ/co6odzbaO4+a4ASQp2tWoiDg6aptCVhsI24?=
 =?us-ascii?q?09vjcLJ4q7M3D9N+PgdCcgHc5PBxdP9nC/NlVJSo6lPwWB6nK94iQPFRrhKAF7?=
 =?us-ascii?q?Ovr6GpLIj8Swyuu+54Dfbx9HiTahYr5+Ngm6oRnMvcQKnIVuLbo8xAHUqXVSYe?=
 =?us-ascii?q?RWwm1oJVOXnxni48q74YBu/SdNtf8/7sBMSar1cbg2QrxeFzQmLns65Nb3uhnZ?=
 =?us-ascii?q?TAuA/WUTX2MLmRdVGQfF7RX6XpDssivms+d2xSeXMdHqQb0yRD+v9LlgRgP2hy?=
 =?us-ascii?q?gbNj456GDXhdJ2jKJHuxKquhhzz5fJbI2JKPZye6XQds4YS2VcRMZcTyJPDIOi?=
 =?us-ascii?q?YYUSDOQBM+lXoJXgqFQMoxS+HhGsCeH0xz9UmnP7x7E23/g7HA3Y2gErAtIAsG?=
 =?us-ascii?q?7TrNXwLKocX/q6zLfWwj7eaP1Zwy396JTJchAnvPqBWrx+ftDPyUYxDQ/LiU+f?=
 =?us-ascii?q?qZb5PzOU0OQAqHKU7/BlVe61l2EnrARxryGpy8wxiYfJnpoYxk7Y+Sh92oo5ON?=
 =?us-ascii?q?O1RFBhbdK5E5ZcqzuWOop0T886XW1kpSQ3xqcbtZO0YCQG0okrywLCZ/CdcYWE?=
 =?us-ascii?q?/hTuX/uLLzhinnJqYre/ig6y8Ue+zu38UdG50EhFriVbiNnArHMN2ALJ6siBVP?=
 =?us-ascii?q?R9+l2t2TGV1wDc8u1EIEY0mrTHK5M53LI8ip4evV7eEiL4hkn6lrKae0Y49uSy?=
 =?us-ascii?q?6unqYK3qppqGOI91jgH+PL4umsu6AekgNggOXm6b+fmz1bH6/k32Xq9Kjvsona?=
 =?us-ascii?q?ndqZzaIsoapqinDA9PyYsj9Rm/ACm80NgCnnkIMkhFeBSZgIjtIV3OJ+r4Dfin?=
 =?us-ascii?q?j1S2jDhr3+zGPqHmApjVKnjDkbThcqhn509T1Qo+1tRf55NSCrEcL/P/QE7xtN?=
 =?us-ascii?q?rEDhAnNwy42froCNJ41okGQ2KAHreZML/OsV+P/u8vI/ODZI4JuDnnLPgp/f7u?=
 =?us-ascii?q?jWIjll8bcqmkxp8XaHG+HvR7LESVe3vsgtEdEWgUugoyVvDliFqHUTRLfXa9Q7?=
 =?us-ascii?q?o85i0nCIKhFYrDRIetj6Kb0Ce4GZ1WYGZGCleXHHfsdoWEXeoMaS2ILs9glDwE?=
 =?us-ascii?q?SaauS4s72R6ysw/6zqJtLvDI9S0AqZLjyN916vXJmhEp9Tx0CMed33uXT25unG?=
 =?us-ascii?q?MFXDs23KF5oUxgxVaPy6l4g/pEFdNN4/NFSBs1NZnZz+ZiEdD9RhrBfsuVSFah?=
 =?us-ascii?q?WtimAis+TtQrz98KYkZyAdOijh/Y0iquAr8VkaGLBZMu/qLd2XjxO9hyy3Lc2K?=
 =?us-ascii?q?Y9iFkmR9NFNXe6ia5n6wjTG4nJnl2EmKmwa6QTwjTB9GeZwmqIp0FXTghwXaLB?=
 =?us-ascii?q?XXAcY0vWqc/05kfDT7+oFLQmPRFNyc+EKqtWdNLpiU9KS+vkONTbe2ixgXu/BQ?=
 =?us-ascii?q?6UxrOQa4rnY3gS0z/DCEcaiQwT/WyJNQ4lBii/pWLTFzhuFVPpY0Px/uhysnK7?=
 =?us-ascii?q?Tkkozw6Ua01tzaa6+hkQhfaEUfMcwqoEuDs9qzVzBFu9w9PWC9+Hpwp9fKVdYc?=
 =?us-ascii?q?kx4Etd2WLerQx9Op2gL6ZthlMFdwR3vkXu1wh4C4lakMgqqm8qwxR2Ka6CzFxB?=
 =?us-ascii?q?cDaY14jqOrLLMmny4Ayva6nO117E1NaZ5KgO5+o4qln5pw6pC1ct/G9h09lW1H?=
 =?us-ascii?q?uc+I7HDA4TUZL3T0Y2+AJ2p7DcYikh+YzU0WdgPrWzsj/Hw9gpHvcqyg68f9dD?=
 =?us-ascii?q?N6OJDA/zE9AAC8eyMuArmlipYQgCPOBd76M0O8Kmd/2b2K+kJupgnTSmjXhZ74?=
 =?us-ascii?q?B5yE6D6y18SuvQ1ZYf3/6YxheHVyv7jFq5qMD3mJxLaisIHmWizijoHohRabNo?=
 =?us-ascii?q?fYYKEGuhP9e4xtFjiJHzQX5Y81ijCkgC2M+ofxqSclP80RdR1UQRvXyohy+4wy?=
 =?us-ascii?q?ZonDEuq6qVxDbOzPj6dBobJm5LQ3FvjFftIYSuj9EWRlOobxUvlBa+4Ub6xq5b?=
 =?us-ascii?q?pLlwLmXJQEdIeTT2IH9mUqeqqrWCZMtP4osysSpLSOS8fUyaSrnlrhsYySzjBW?=
 =?us-ascii?q?hexDM8dz2woZX2hR96iGGcLHZ1snXZf9p9xRPe5NzaWP5Q0SAKRCh+iTnLGFe8?=
 =?us-ascii?q?O8Ol8smTl5fGquq+TX6uVoVPcSn3yoONrCu66ndtARGlnfCzm9vnHBM+0S/60d?=
 =?us-ascii?q?lqSCrJoAz9Yonty6S1L+ZnclN0C1/77spwApt+nZcohJEMxXgagY2Y/Xkdnmfy?=
 =?us-ascii?q?K9lb2b/+Y2ALRT4E2NPV5Anl2Et+LnOG3Y75V3Odwtd/aNm+eG8ZxiU978VSAq?=
 =?us-ascii?q?eO8LNEhTd1oka/rQ/JZPh9nzQdxuE05H8Une4JoxYtwTuHAr8JA0ZYJyPsmg+M?=
 =?us-ascii?q?79C/qqVXeWmufaKx1Ep4gdCuErWCrhtAV3b+f5coBTVw4dlnMFLQzH3z7ZnpeM?=
 =?us-ascii?q?XXbdIWrBGVkg3Pj+5IKJIqjfoKhDFqOWb8vX0j1u46ggZi3ZC8vIibNWpt+Li1?=
 =?us-ascii?q?DQJfNj3wf8kT4C3ijb5CnsaK2ICiBo5uFS8MXJvsUPKkCjYSten8OgaKET08rG?=
 =?us-ascii?q?qbGLXFEQ+e7kdms2zAE5SxO36LI3kZyM1oRAOBK0xHnAAUQDI6k4Y7Fg+wwczu?=
 =?us-ascii?q?blx56ioN5lLiqRtM1+FoNwT5UmjFvwelcTM0SJmZLBpL4QBO/UbVMcqC7u1tGy?=
 =?us-ascii?q?FU5IGurAuIKmaDfQRHEXkJWlCYB1DkJrSv5d7A8/WBBuqjNfTOZ6+CqfdZV/eO?=
 =?us-ascii?q?ypKiyY9m/zeKNsWSMXhuFfw72kxfXX9nH8TVgSkASysSlyjVdc6UuA+8+jFrrs?=
 =?us-ascii?q?C46PnrWBzg5YqMC7tRMNVj4RO2gb2EN+6fmil5MytY1ogXyH/Mybgf2kMSii50?=
 =?us-ascii?q?ezmsF7QAqTDCTKbKlqBLCB4bbjt5NNFU4KIkwglNJcnbh8vv2b5llfE1EUlKVF?=
 =?us-ascii?q?z7lsGtZMwHOGW9NFLBBEaWO7WKPzzLw8frYayiTb1clvlbtxq1uTyDCU/sIiyD?=
 =?us-ascii?q?lyX1VxCoKexMkCCbPBlEtI6haBpiFWjjQ8zgahCgNN93jDs2waA7h3/QNG4cNy?=
 =?us-ascii?q?R8fF1JrrGK8SxYhfB/EXRb7nV5NemEhzqZ7+7AJ5cWq/RrBCF0l+Nc4HsiyrpV?=
 =?us-ascii?q?7DtLRPp6mCbJqt5uolemkvSAyzZ9URpOrCpLi5yPvUl4JarZ8ZxACj74+0cz7G?=
 =?us-ascii?q?ObBhIW7+RlC8Hku71KwdiHwLzyLjxP9c6S4ssdG8PUNdiMMFIoIRvyXjXTCV1W?=
 =?us-ascii?q?YySsMDTzjlJQ2NSb7GGUqNBuhpHyldwrQ6VHVVodH+kfTE9iGYpRc99MQjo4nO?=
 =?us-ascii?q?vD34Yz7n2koUyUHZ0Csw=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAADIR/hbh0O0hNFjGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwGDayeMEV+LIYINFGaWQYFzLBMBiFoiNAkNAQMBAQE?=
 =?us-ascii?q?BAQECARMBAQEIDQkIKS+CNiQBgmEBAQEBAgEBAiQTGSYFAQkBAQoYCSUDDAVJE?=
 =?us-ascii?q?wWDHIF6CAQBqAczihqMCYFXP4ERgl01ilkCiH8khXaQFFUHAoIgjwQjgVmPL4l?=
 =?us-ascii?q?tkAmCDTMaI4M8gicXjhw/AQExgQUBAYwhAQE?=
X-IPAS-Result: =?us-ascii?q?A0ABAADIR/hbh0O0hNFjGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwGDayeMEV+LIYINFGaWQYFzLBMBiFoiNAkNAQMBAQEBAQECARMBAQEID?=
 =?us-ascii?q?QkIKS+CNiQBgmEBAQEBAgEBAiQTGSYFAQkBAQoYCSUDDAVJEwWDHIF6CAQBqAc?=
 =?us-ascii?q?zihqMCYFXP4ERgl01ilkCiH8khXaQFFUHAoIgjwQjgVmPL4ltkAmCDTMaI4M8g?=
 =?us-ascii?q?icXjhw/AQExgQUBAYwhAQE?=
X-IronPort-AV: E=Sophos;i="5.56,270,1539673200"; 
   d="scan'208";a="139345924"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 10:34:28 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2395328AbeKXFTt (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sat, 24 Nov 2018 00:19:49 -0500
Received: from foss.arm.com ([217.140.101.70]:51002 "EHLO foss.arm.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S2395280AbeKXFTs (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sat, 24 Nov 2018 00:19:48 -0500
Received: from usa-sjc-imap-foss1.foss.arm.com (unknown [10.72.51.249])
        by usa-sjc-mx-foss1.foss.arm.com (Postfix) with ESMTP id 7FBC33620;
        Fri, 23 Nov 2018 10:34:23 -0800 (PST)
Received: from e103592.cambridge.arm.com (usa-sjc-imap-foss1.foss.arm.com [10.72.51.249])
        by usa-sjc-imap-foss1.foss.arm.com (Postfix) with ESMTPSA id 4C8863F5CF;
        Fri, 23 Nov 2018 10:34:22 -0800 (PST)
Date: Fri, 23 Nov 2018 18:34:19 +0000
From: Dave Martin <Dave.Martin@arm.com>
To: Vincent Whitchurch <vincent.whitchurch@axis.com>
Cc: linux@armlinux.org.uk, jeyu@kernel.org,
        Vincent Whitchurch <rabinv@axis.com>,
        linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH 2/2] ARM: module: Fix function kallsyms on Thumb-2
Message-ID: <20181123183419.GM3505@e103592.cambridge.arm.com>
References: <20181119162513.16562-1-vincent.whitchurch@axis.com>
 <20181119162513.16562-2-vincent.whitchurch@axis.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20181119162513.16562-2-vincent.whitchurch@axis.com>
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Mon, Nov 19, 2018 at 05:25:13PM +0100, Vincent Whitchurch wrote:
> Thumb-2 functions have the lowest bit set in the symbol value in the
> symtab.  When kallsyms are generated for the vmlinux, the kallsyms are
> generated from the output of nm, and nm clears the lowest bit.
> 
>  $ arm-linux-gnueabihf-readelf -a vmlinux | grep show_interrupts
>   95947: 8015dc89   686 FUNC    GLOBAL DEFAULT    2 show_interrupts
>  $ arm-linux-gnueabihf-nm vmlinux | grep show_interrupts
>  8015dc88 T show_interrupts
>  $ cat /proc/kallsyms | grep show_interrupts
>  8015dc88 T show_interrupts
> 
> However, for modules, the kallsyms uses the values in the symbol table
> without modification, so for functions in modules, the lowest bit is set
> in kallsyms.
> 
>  $ arm-linux-gnueabihf-readelf -a drivers/net/tun.ko | grep tun_get_socket
>     333: 00002d4d    36 FUNC    GLOBAL DEFAULT    1 tun_get_socket
>  $ arm-linux-gnueabihf-nm drivers/net/tun.ko | grep tun_get_socket
>  00002d4c T tun_get_socket
>  $ cat /proc/kallsyms | grep tun_get_socket
>  7f802d4d t tun_get_socket      [tun]
> 
> Because of this, the symbol+offset of the crashing instruction shown in
> oopses is incorrect when the crash is in a module.  For example, given a
> tun_get_socket which starts like this,
> 
>  00002d4c <tun_get_socket>:
>      2d4c:       6943            ldr     r3, [r0, #20]
>      2d4e:       4a07            ldr     r2, [pc, #28]
>      2d50:       4293            cmp     r3, r2
> 
> a crash when tun_get_socket is called with NULL results in:
> 
>  PC is at tun_xdp+0xa3/0xa4 [tun]
>  pc : [<7f802d4c>]
> 
> As can be seen, the "PC is at" line reports the wrong symbol name, and
> the symbol+offset will point to the wrong source line if it is passed to
> gdb.
> 
> To solve this, add a way for archs to fixup the reading of these module
> kallsyms values, and use that to clear the lowest bit for function
> symbols on Thumb-2.
> 
> After the fix:
> 
>  # cat /proc/kallsyms | grep tun_get_socket
>  7f802d4c t tun_get_socket       [tun]
> 
>  PC is at tun_get_socket+0x0/0x24 [tun]
>  pc : [<7f802d4c>]
> 
> Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
> ---
> v4: Split out st_value overwrite change.  Add HAVE* macro to avoid function call.
> v3: Do not overwrite st_value
> v2: Fix build warning with !MODULES
> 
>  arch/arm/include/asm/module.h | 11 +++++++++++
>  include/linux/module.h        |  7 +++++++
>  kernel/module.c               | 25 ++++++++++++++-----------
>  3 files changed, 32 insertions(+), 11 deletions(-)
> 
> diff --git a/arch/arm/include/asm/module.h b/arch/arm/include/asm/module.h
> index 9e81b7c498d8..e2ccec651e71 100644
> --- a/arch/arm/include/asm/module.h
> +++ b/arch/arm/include/asm/module.h
> @@ -61,4 +61,15 @@ u32 get_module_plt(struct module *mod, unsigned long loc, Elf32_Addr val);
>  	MODULE_ARCH_VERMAGIC_ARMTHUMB \
>  	MODULE_ARCH_VERMAGIC_P2V
>  
> +#ifdef CONFIG_THUMB2_KERNEL
> +#define HAVE_ARCH_MODULE_KALLSYMS_SYMBOL_VALUE
> +static inline unsigned long module_kallsyms_symbol_value(Elf_Sym *sym)
> +{
> +	if (ELF_ST_TYPE(sym->st_info) == STT_FUNC)
> +		return sym->st_value & ~1;
> +
> +	return sym->st_value;
> +}
> +#endif
> +
>  #endif /* _ASM_ARM_MODULE_H */
> diff --git a/include/linux/module.h b/include/linux/module.h
> index fce6b4335e36..cfc55f358800 100644
> --- a/include/linux/module.h
> +++ b/include/linux/module.h
> @@ -486,6 +486,13 @@ struct module {
>  #define MODULE_ARCH_INIT {}
>  #endif
>  
> +#ifndef HAVE_ARCH_MODULE_KALLSYMS_SYMBOL_VALUE
> +static inline unsigned long module_kallsyms_symbol_value(Elf_Sym *sym)
> +{
> +	return sym->st_value;
> +}
> +#endif
> +
>  extern struct mutex module_mutex;
>  
>  /* FIXME: It'd be nice to isolate modules during init, too, so they
> diff --git a/kernel/module.c b/kernel/module.c
> index 3d86a38b580c..a36d7915ed2b 100644
> --- a/kernel/module.c
> +++ b/kernel/module.c
> @@ -3934,6 +3934,9 @@ static const char *get_ksymbol(struct module *mod,
>  	/* Scan for closest preceding symbol, and next symbol. (ELF
>  	   starts real symbols at 1). */
>  	for (i = 1; i < kallsyms->num_symtab; i++) {
> +		unsigned long thisval = module_kallsyms_symbol_value(&kallsyms->symtab[i]);
> +		unsigned long bestval = module_kallsyms_symbol_value(&kallsyms->symtab[best]);
> +
>  		if (kallsyms->symtab[i].st_shndx == SHN_UNDEF)
>  			continue;
>  
> @@ -3943,21 +3946,21 @@ static const char *get_ksymbol(struct module *mod,
>  		    || is_arm_mapping_symbol(symname(kallsyms, i)))
>  			continue;
>  
> -		if (kallsyms->symtab[i].st_value <= addr
> -		    && kallsyms->symtab[i].st_value > kallsyms->symtab[best].st_value)
> +		if (thisval <= addr
> +		    && thisval > bestval)

Nit: this fits easily on one line now.

>  			best = i;

Can we declare bestval outside the loop and update it here, so that
we always have
bestval == module_kallsyms_symbol_value(&kallsyms->symtab[best]) ?

Then we wouldn't need to call module_kallsyms_symbol_value() again
afterwards at [1], [2] below.

> -		if (kallsyms->symtab[i].st_value > addr
> -		    && kallsyms->symtab[i].st_value < nextval)
> -			nextval = kallsyms->symtab[i].st_value;
> +		if (thisval > addr
> +		    && thisval < nextval)
> +			nextval = thisval;

Nit: same again.

>  	}
>  
>  	if (!best)
>  		return NULL;
>  
>  	if (size)
> -		*size = nextval - kallsyms->symtab[best].st_value;
> +		*size = nextval - module_kallsyms_symbol_value(&kallsyms->symtab[best]);

[1]

>  	if (offset)
> -		*offset = addr - kallsyms->symtab[best].st_value;
> +		*offset = addr - module_kallsyms_symbol_value(&kallsyms->symtab[best]);

[2]

>  	return symname(kallsyms, best);
>  }
>  
> @@ -4060,7 +4063,7 @@ int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
>  			continue;
>  		kallsyms = rcu_dereference_sched(mod->kallsyms);
>  		if (symnum < kallsyms->num_symtab) {
> -			*value = kallsyms->symtab[symnum].st_value;
> +			*value = module_kallsyms_symbol_value(&kallsyms->symtab[symnum]);
>  			*type = kallsyms->symtab[symnum].st_size;
>  			strlcpy(name, symname(kallsyms, symnum), KSYM_NAME_LEN);
>  			strlcpy(module_name, mod->name, MODULE_NAME_LEN);
> @@ -4082,7 +4085,7 @@ static unsigned long mod_find_symname(struct module *mod, const char *name)
>  	for (i = 0; i < kallsyms->num_symtab; i++)
>  		if (strcmp(name, symname(kallsyms, i)) == 0 &&
>  		    kallsyms->symtab[i].st_shndx != SHN_UNDEF)
> -			return kallsyms->symtab[i].st_value;
> +			return module_kallsyms_symbol_value(&kallsyms->symtab[i]);
>  	return 0;
>  }
>  
> @@ -4131,8 +4134,8 @@ int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,
>  			if (kallsyms->symtab[i].st_shndx == SHN_UNDEF)
>  				continue;
>  
> -			ret = fn(data, symname(kallsyms, i),
> -				 mod, kallsyms->symtab[i].st_value);
> +			ret = fn(data, symname(kallsyms, i), mod,
> +				 module_kallsyms_symbol_value(&kallsyms->symtab[i]));

Nit: We have some more overlong lines throughout this file now, which is
mildly annoying (though hardly a big deal).

In may places the expression kallsyms->symtab[foo] appears multiple
times and adds to verbosity.

Is it worth stashing the pointer first?  For example, in this case:

			const Elf_Sym *sym = &kallsyms->symtab[i];

			if (sym->st_shndx == SHN_UNDEF)
				continue;

			ret = fn(data, symname(kallsyms, i), mod,
				module_kallsyms_symbol_value(sym));

This adds two lines in the diffstat of course.  Take your pick!

Cheers
---Dave
