Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  18 Dec 2018 08:51:11 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 4F7B35805CF
	for <like.xu@linux.intel.com>; Mon, 17 Dec 2018 15:17:45 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 17 Dec 2018 15:17:45 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3A3M3alReBJPj2S+oCBO7JaA+tlGMj4u6mDksu8pMi?=
 =?us-ascii?q?zoh2WeGdxcW7Zh7h7PlgxGXEQZ/co6odzbaO4+a4ASQp2tWoiDg6aptCVhsI24?=
 =?us-ascii?q?09vjcLJ4q7M3D9N+PgdCcgHc5PBxdP9nC/NlVJSo6lPwWB6nK94iQPFRrhKAF7?=
 =?us-ascii?q?Ovr6GpLIj8Swyuu+54Dfbx9HiTahYr5+Ngm6oRnMvcQKnIVuLbo8xAHUqXVSYe?=
 =?us-ascii?q?RWwm1oJVOXnxni48q74YBu/SdNtf8/7sBMSar1cbg2QrxeFzQmLns65Nb3uhnZ?=
 =?us-ascii?q?TAuA/WUTX2MLmRdVGQfF7RX6XpDssivms+d2xSeXMdHqQb0yRD+v6bpgRh31hy?=
 =?us-ascii?q?cdLzM38H/ZhMJzgq1UrxyvugR/zozWboyaKfZzcL/Rcs0BRWdaQspRTjZMDp+g?=
 =?us-ascii?q?Y4cTE+YMO/tToYnnp1sJqBuzHROiC/noyj9MgX/9wLA30+MnEQDH3QwgGdMOu2?=
 =?us-ascii?q?nTodXtL6gSVua1zajJzTXFbvNbwi3955bVfRAhu/6MQah8ftbWyUkqDg7IiEib?=
 =?us-ascii?q?p4/9Pz6NyOgBr2uW4/B9We6yiGMrsR99rzavy8s2l4XEhJoZxk7Y+Sh92oo5ON?=
 =?us-ascii?q?O1RFBhbdK5E5ZduTuWO5V1T84kXmpmojw1yqcctp6+ZCUKyIooxxrYa/Gfd4iI?=
 =?us-ascii?q?4wnjVPqKITtii3Jlfq+/iwy18Ui6xe3wTsi00FBUoSpZitTAqGwB2h/J5sSaV/?=
 =?us-ascii?q?dw/V2t1SiB2g3T8O1IPEI5mbLeK5E7w74wkpQTsV7EHi/zgEj2lbGZdkA5+uSx?=
 =?us-ascii?q?9uvofKvmqYGYN4NtkQ7+NbkumsqjDusmKQgCWGyb+eW/1LL950H4T6hKg+Uykq?=
 =?us-ascii?q?nYtpDaOMsaqrS4Aw9TzoYs9RK/Ay2639QfmHkKN1RFeBWBj4jmPVHOPer0DfCl?=
 =?us-ascii?q?g1SjiDtr3ezJPqX9ApXRKXjOiLPhfbd+60FC0gYyws1f6olQCrEAJvLzR0DwuM?=
 =?us-ascii?q?bZDh8/Lwy73eLnBM9h2YMZXGLcSpKfK77Y5F+U+vo0ca7LYI4OpC27Lf8j6Pjz?=
 =?us-ascii?q?y3gjlhgYdKit2JIRL3egAvVhJV7eeHfpn5INHHkHulkDSvf3ggiHWD9Xe3HgRq?=
 =?us-ascii?q?85+3Q3BZyrCcLZS5mwjaed9CG8GJJQeyZBEF/bCmridYiPR6IRbjmPKNRqiD0O?=
 =?us-ascii?q?WOudTNo42BSz8QP31bdjBuzT/CIeqNTkztcmyffUkEQK/DtwCIy31GefTmd11j?=
 =?us-ascii?q?cQTTgwzqF5oGRnx1uD2LQ+iPtdQ48Ar8hVWxs3YMaPh9dxDMr/D1rM?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ArAADuLRhchxHrdtBiAx4BBgcGgVEJC?=
 =?us-ascii?q?wGBMIJijHSkf4F3Aw4YFIdWIjQJDQEDAQEBAQEBAgETAQEBCgsJCBsOL4I2BQI?=
 =?us-ascii?q?DGAmCXQICAgIXAQwfCiwDAQIGAkgIAwFsBYMdgXkIAQSmaIIqM4VAhGyKfIFCF?=
 =?us-ascii?q?4FAP4ERiFqFGAKJQpdXCYpNhwILGIlzh1+ZZIFGgg4zGggbFYMngicXjh5AMYE?=
 =?us-ascii?q?HHIsIKymBdwEB?=
X-IPAS-Result: =?us-ascii?q?A0ArAADuLRhchxHrdtBiAx4BBgcGgVEJCwGBMIJijHSkf4F?=
 =?us-ascii?q?3Aw4YFIdWIjQJDQEDAQEBAQEBAgETAQEBCgsJCBsOL4I2BQIDGAmCXQICAgIXA?=
 =?us-ascii?q?QwfCiwDAQIGAkgIAwFsBYMdgXkIAQSmaIIqM4VAhGyKfIFCF4FAP4ERiFqFGAK?=
 =?us-ascii?q?JQpdXCYpNhwILGIlzh1+ZZIFGgg4zGggbFYMngicXjh5AMYEHHIsIKymBdwEB?=
X-IronPort-AV: E=Sophos;i="5.56,366,1539673200"; 
   d="scan'208";a="55552052"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 17 Dec 2018 15:17:43 -0800
Received: from localhost ([::1]:50442 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gZ28t-0008Qv-4j
	for like.xu@linux.intel.com; Mon, 17 Dec 2018 18:17:43 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:42695)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <pbonzini@redhat.com>) id 1gZ282-0008Ke-Mz
	for qemu-devel@nongnu.org; Mon, 17 Dec 2018 18:16:54 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <pbonzini@redhat.com>) id 1gZ27v-0001t4-No
	for qemu-devel@nongnu.org; Mon, 17 Dec 2018 18:16:48 -0500
Received: from mx1.redhat.com ([209.132.183.28]:38998)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <pbonzini@redhat.com>) id 1gZ27v-0001sj-Ce
	for qemu-devel@nongnu.org; Mon, 17 Dec 2018 18:16:43 -0500
Received: from smtp.corp.redhat.com (int-mx07.intmail.prod.int.phx2.redhat.com
	[10.5.11.22])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id BC461432B9
	for <qemu-devel@nongnu.org>; Mon, 17 Dec 2018 23:16:42 +0000 (UTC)
Received: from donizetti.redhat.com (unknown [10.36.112.10])
	by smtp.corp.redhat.com (Postfix) with ESMTP id 58765105704A;
	Mon, 17 Dec 2018 23:16:40 +0000 (UTC)
From: Paolo Bonzini <pbonzini@redhat.com>
To: qemu-devel@nongnu.org
Date: Tue, 18 Dec 2018 00:16:39 +0100
Message-Id: <20181217231639.24250-1-pbonzini@redhat.com>
MIME-Version: 1.0
X-Scanned-By: MIMEDefang 2.84 on 10.5.11.22
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.30]);
	Mon, 17 Dec 2018 23:16:42 +0000 (UTC)
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 209.132.183.28
Subject: [Qemu-devel] [PATCH] crypto: finish removing TABs
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

Suggested-by: Daniel P. Berrange <berrange@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 crypto/aes.c    | 414 ++++++++++++++++-----------------
 crypto/desrfb.c | 594 ++++++++++++++++++++++++------------------------
 2 files changed, 504 insertions(+), 504 deletions(-)

diff --git a/crypto/aes.c b/crypto/aes.c
index 773d246b00..86b3092324 100644
--- a/crypto/aes.c
+++ b/crypto/aes.c
@@ -1059,109 +1059,109 @@ const uint32_t AES_Td4[256] =3D {
     0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
 };
 static const u32 rcon[] =3D {
-	0x01000000, 0x02000000, 0x04000000, 0x08000000,
-	0x10000000, 0x20000000, 0x40000000, 0x80000000,
-	0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more=
 than 10 rcon values */
+        0x01000000, 0x02000000, 0x04000000, 0x08000000,
+        0x10000000, 0x20000000, 0x40000000, 0x80000000,
+        0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never us=
es more than 10 rcon values */
 };
=20
 /**
  * Expand the cipher key into the encryption key schedule.
  */
 int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
-			AES_KEY *key) {
+                        AES_KEY *key) {
=20
-	u32 *rk;
-	int i =3D 0;
-	u32 temp;
+        u32 *rk;
+        int i =3D 0;
+        u32 temp;
=20
-	if (!userKey || !key)
-		return -1;
-	if (bits !=3D 128 && bits !=3D 192 && bits !=3D 256)
-		return -2;
+        if (!userKey || !key)
+                return -1;
+        if (bits !=3D 128 && bits !=3D 192 && bits !=3D 256)
+                return -2;
=20
-	rk =3D key->rd_key;
+        rk =3D key->rd_key;
=20
-	if (bits=3D=3D128)
-		key->rounds =3D 10;
-	else if (bits=3D=3D192)
-		key->rounds =3D 12;
-	else
-		key->rounds =3D 14;
+        if (bits=3D=3D128)
+                key->rounds =3D 10;
+        else if (bits=3D=3D192)
+                key->rounds =3D 12;
+        else
+                key->rounds =3D 14;
=20
-	rk[0] =3D GETU32(userKey     );
-	rk[1] =3D GETU32(userKey +  4);
-	rk[2] =3D GETU32(userKey +  8);
-	rk[3] =3D GETU32(userKey + 12);
-	if (bits =3D=3D 128) {
-		while (1) {
-			temp  =3D rk[3];
-			rk[4] =3D rk[0] ^
+        rk[0] =3D GETU32(userKey     );
+        rk[1] =3D GETU32(userKey +  4);
+        rk[2] =3D GETU32(userKey +  8);
+        rk[3] =3D GETU32(userKey + 12);
+        if (bits =3D=3D 128) {
+                while (1) {
+                        temp  =3D rk[3];
+                        rk[4] =3D rk[0] ^
                                 (AES_Te4[(temp >> 16) & 0xff] & 0xff0000=
00) ^
                                 (AES_Te4[(temp >>  8) & 0xff] & 0x00ff00=
00) ^
                                 (AES_Te4[(temp      ) & 0xff] & 0x0000ff=
00) ^
                                 (AES_Te4[(temp >> 24)       ] & 0x000000=
ff) ^
-				rcon[i];
-			rk[5] =3D rk[1] ^ rk[4];
-			rk[6] =3D rk[2] ^ rk[5];
-			rk[7] =3D rk[3] ^ rk[6];
-			if (++i =3D=3D 10) {
-				return 0;
-			}
-			rk +=3D 4;
-		}
-	}
-	rk[4] =3D GETU32(userKey + 16);
-	rk[5] =3D GETU32(userKey + 20);
-	if (bits =3D=3D 192) {
-		while (1) {
-			temp =3D rk[ 5];
-			rk[ 6] =3D rk[ 0] ^
+                                rcon[i];
+                        rk[5] =3D rk[1] ^ rk[4];
+                        rk[6] =3D rk[2] ^ rk[5];
+                        rk[7] =3D rk[3] ^ rk[6];
+                        if (++i =3D=3D 10) {
+                                return 0;
+                        }
+                        rk +=3D 4;
+                }
+        }
+        rk[4] =3D GETU32(userKey + 16);
+        rk[5] =3D GETU32(userKey + 20);
+        if (bits =3D=3D 192) {
+                while (1) {
+                        temp =3D rk[ 5];
+                        rk[ 6] =3D rk[ 0] ^
                                 (AES_Te4[(temp >> 16) & 0xff] & 0xff0000=
00) ^
                                 (AES_Te4[(temp >>  8) & 0xff] & 0x00ff00=
00) ^
                                 (AES_Te4[(temp      ) & 0xff] & 0x0000ff=
00) ^
                                 (AES_Te4[(temp >> 24)       ] & 0x000000=
ff) ^
-				rcon[i];
-			rk[ 7] =3D rk[ 1] ^ rk[ 6];
-			rk[ 8] =3D rk[ 2] ^ rk[ 7];
-			rk[ 9] =3D rk[ 3] ^ rk[ 8];
-			if (++i =3D=3D 8) {
-				return 0;
-			}
-			rk[10] =3D rk[ 4] ^ rk[ 9];
-			rk[11] =3D rk[ 5] ^ rk[10];
-			rk +=3D 6;
-		}
-	}
-	rk[6] =3D GETU32(userKey + 24);
-	rk[7] =3D GETU32(userKey + 28);
-	if (bits =3D=3D 256) {
-		while (1) {
-			temp =3D rk[ 7];
-			rk[ 8] =3D rk[ 0] ^
+                                rcon[i];
+                        rk[ 7] =3D rk[ 1] ^ rk[ 6];
+                        rk[ 8] =3D rk[ 2] ^ rk[ 7];
+                        rk[ 9] =3D rk[ 3] ^ rk[ 8];
+                        if (++i =3D=3D 8) {
+                                return 0;
+                        }
+                        rk[10] =3D rk[ 4] ^ rk[ 9];
+                        rk[11] =3D rk[ 5] ^ rk[10];
+                        rk +=3D 6;
+                }
+        }
+        rk[6] =3D GETU32(userKey + 24);
+        rk[7] =3D GETU32(userKey + 28);
+        if (bits =3D=3D 256) {
+                while (1) {
+                        temp =3D rk[ 7];
+                        rk[ 8] =3D rk[ 0] ^
                                 (AES_Te4[(temp >> 16) & 0xff] & 0xff0000=
00) ^
                                 (AES_Te4[(temp >>  8) & 0xff] & 0x00ff00=
00) ^
                                 (AES_Te4[(temp      ) & 0xff] & 0x0000ff=
00) ^
                                 (AES_Te4[(temp >> 24)       ] & 0x000000=
ff) ^
-				rcon[i];
-			rk[ 9] =3D rk[ 1] ^ rk[ 8];
-			rk[10] =3D rk[ 2] ^ rk[ 9];
-			rk[11] =3D rk[ 3] ^ rk[10];
-			if (++i =3D=3D 7) {
-				return 0;
-			}
-			temp =3D rk[11];
-			rk[12] =3D rk[ 4] ^
+                                rcon[i];
+                        rk[ 9] =3D rk[ 1] ^ rk[ 8];
+                        rk[10] =3D rk[ 2] ^ rk[ 9];
+                        rk[11] =3D rk[ 3] ^ rk[10];
+                        if (++i =3D=3D 7) {
+                                return 0;
+                        }
+                        temp =3D rk[11];
+                        rk[12] =3D rk[ 4] ^
                                 (AES_Te4[(temp >> 24)       ] & 0xff0000=
00) ^
                                 (AES_Te4[(temp >> 16) & 0xff] & 0x00ff00=
00) ^
                                 (AES_Te4[(temp >>  8) & 0xff] & 0x0000ff=
00) ^
                                 (AES_Te4[(temp      ) & 0xff] & 0x000000=
ff);
-			rk[13] =3D rk[ 5] ^ rk[12];
-			rk[14] =3D rk[ 6] ^ rk[13];
-			rk[15] =3D rk[ 7] ^ rk[14];
+                        rk[13] =3D rk[ 5] ^ rk[12];
+                        rk[14] =3D rk[ 6] ^ rk[13];
+                        rk[15] =3D rk[ 7] ^ rk[14];
=20
-			rk +=3D 8;
-		}
-	}
+                        rk +=3D 8;
+                }
+        }
         abort();
 }
=20
@@ -1169,51 +1169,51 @@ int AES_set_encrypt_key(const unsigned char *user=
Key, const int bits,
  * Expand the cipher key into the decryption key schedule.
  */
 int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
-			 AES_KEY *key) {
+                         AES_KEY *key) {
=20
         u32 *rk;
-	int i, j, status;
-	u32 temp;
+        int i, j, status;
+        u32 temp;
=20
-	/* first, start with an encryption schedule */
-	status =3D AES_set_encrypt_key(userKey, bits, key);
-	if (status < 0)
-		return status;
+        /* first, start with an encryption schedule */
+        status =3D AES_set_encrypt_key(userKey, bits, key);
+        if (status < 0)
+                return status;
=20
-	rk =3D key->rd_key;
+        rk =3D key->rd_key;
=20
-	/* invert the order of the round keys: */
-	for (i =3D 0, j =3D 4*(key->rounds); i < j; i +=3D 4, j -=3D 4) {
-		temp =3D rk[i    ]; rk[i    ] =3D rk[j    ]; rk[j    ] =3D temp;
-		temp =3D rk[i + 1]; rk[i + 1] =3D rk[j + 1]; rk[j + 1] =3D temp;
-		temp =3D rk[i + 2]; rk[i + 2] =3D rk[j + 2]; rk[j + 2] =3D temp;
-		temp =3D rk[i + 3]; rk[i + 3] =3D rk[j + 3]; rk[j + 3] =3D temp;
-	}
-	/* apply the inverse MixColumn transform to all round keys but the firs=
t and the last: */
-	for (i =3D 1; i < (key->rounds); i++) {
-		rk +=3D 4;
-		rk[0] =3D
+        /* invert the order of the round keys: */
+        for (i =3D 0, j =3D 4*(key->rounds); i < j; i +=3D 4, j -=3D 4) =
{
+                temp =3D rk[i    ]; rk[i    ] =3D rk[j    ]; rk[j    ] =3D=
 temp;
+                temp =3D rk[i + 1]; rk[i + 1] =3D rk[j + 1]; rk[j + 1] =3D=
 temp;
+                temp =3D rk[i + 2]; rk[i + 2] =3D rk[j + 2]; rk[j + 2] =3D=
 temp;
+                temp =3D rk[i + 3]; rk[i + 3] =3D rk[j + 3]; rk[j + 3] =3D=
 temp;
+        }
+        /* apply the inverse MixColumn transform to all round keys but t=
he first and the last: */
+        for (i =3D 1; i < (key->rounds); i++) {
+                rk +=3D 4;
+                rk[0] =3D
                         AES_Td0[AES_Te4[(rk[0] >> 24)       ] & 0xff] ^
                         AES_Td1[AES_Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
                         AES_Td2[AES_Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
                         AES_Td3[AES_Te4[(rk[0]      ) & 0xff] & 0xff];
-		rk[1] =3D
+                rk[1] =3D
                         AES_Td0[AES_Te4[(rk[1] >> 24)       ] & 0xff] ^
                         AES_Td1[AES_Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
                         AES_Td2[AES_Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
                         AES_Td3[AES_Te4[(rk[1]      ) & 0xff] & 0xff];
-		rk[2] =3D
+                rk[2] =3D
                         AES_Td0[AES_Te4[(rk[2] >> 24)       ] & 0xff] ^
                         AES_Td1[AES_Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
                         AES_Td2[AES_Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
                         AES_Td3[AES_Te4[(rk[2]      ) & 0xff] & 0xff];
-		rk[3] =3D
+                rk[3] =3D
                         AES_Td0[AES_Te4[(rk[3] >> 24)       ] & 0xff] ^
                         AES_Td1[AES_Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
                         AES_Td2[AES_Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
                         AES_Td3[AES_Te4[(rk[3]      ) & 0xff] & 0xff];
-	}
-	return 0;
+        }
+        return 0;
 }
=20
 #ifndef AES_ASM
@@ -1222,67 +1222,67 @@ int AES_set_decrypt_key(const unsigned char *user=
Key, const int bits,
  * in and out can overlap
  */
 void AES_encrypt(const unsigned char *in, unsigned char *out,
-		 const AES_KEY *key) {
+                 const AES_KEY *key) {
=20
-	const u32 *rk;
-	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+        const u32 *rk;
+        u32 s0, s1, s2, s3, t0, t1, t2, t3;
 #ifndef FULL_UNROLL
-	int r;
+        int r;
 #endif /* ?FULL_UNROLL */
=20
-	assert(in && out && key);
-	rk =3D key->rd_key;
+        assert(in && out && key);
+        rk =3D key->rd_key;
=20
-	/*
-	 * map byte array block to cipher state
-	 * and add initial round key:
-	 */
-	s0 =3D GETU32(in     ) ^ rk[0];
-	s1 =3D GETU32(in +  4) ^ rk[1];
-	s2 =3D GETU32(in +  8) ^ rk[2];
-	s3 =3D GETU32(in + 12) ^ rk[3];
+        /*
+         * map byte array block to cipher state
+         * and add initial round key:
+         */
+        s0 =3D GETU32(in     ) ^ rk[0];
+        s1 =3D GETU32(in +  4) ^ rk[1];
+        s2 =3D GETU32(in +  8) ^ rk[2];
+        s3 =3D GETU32(in + 12) ^ rk[3];
 #ifdef FULL_UNROLL
-	/* round 1: */
+        /* round 1: */
         t0 =3D AES_Te0[s0 >> 24] ^ AES_Te1[(s1 >> 16) & 0xff] ^ AES_Te2[=
(s2 >>  8) & 0xff] ^ AES_Te3[s3 & 0xff] ^ rk[ 4];
         t1 =3D AES_Te0[s1 >> 24] ^ AES_Te1[(s2 >> 16) & 0xff] ^ AES_Te2[=
(s3 >>  8) & 0xff] ^ AES_Te3[s0 & 0xff] ^ rk[ 5];
         t2 =3D AES_Te0[s2 >> 24] ^ AES_Te1[(s3 >> 16) & 0xff] ^ AES_Te2[=
(s0 >>  8) & 0xff] ^ AES_Te3[s1 & 0xff] ^ rk[ 6];
         t3 =3D AES_Te0[s3 >> 24] ^ AES_Te1[(s0 >> 16) & 0xff] ^ AES_Te2[=
(s1 >>  8) & 0xff] ^ AES_Te3[s2 & 0xff] ^ rk[ 7];
-	/* round 2: */
+        /* round 2: */
         s0 =3D AES_Te0[t0 >> 24] ^ AES_Te1[(t1 >> 16) & 0xff] ^ AES_Te2[=
(t2 >>  8) & 0xff] ^ AES_Te3[t3 & 0xff] ^ rk[ 8];
         s1 =3D AES_Te0[t1 >> 24] ^ AES_Te1[(t2 >> 16) & 0xff] ^ AES_Te2[=
(t3 >>  8) & 0xff] ^ AES_Te3[t0 & 0xff] ^ rk[ 9];
         s2 =3D AES_Te0[t2 >> 24] ^ AES_Te1[(t3 >> 16) & 0xff] ^ AES_Te2[=
(t0 >>  8) & 0xff] ^ AES_Te3[t1 & 0xff] ^ rk[10];
         s3 =3D AES_Te0[t3 >> 24] ^ AES_Te1[(t0 >> 16) & 0xff] ^ AES_Te2[=
(t1 >>  8) & 0xff] ^ AES_Te3[t2 & 0xff] ^ rk[11];
-	/* round 3: */
+        /* round 3: */
         t0 =3D AES_Te0[s0 >> 24] ^ AES_Te1[(s1 >> 16) & 0xff] ^ AES_Te2[=
(s2 >>  8) & 0xff] ^ AES_Te3[s3 & 0xff] ^ rk[12];
         t1 =3D AES_Te0[s1 >> 24] ^ AES_Te1[(s2 >> 16) & 0xff] ^ AES_Te2[=
(s3 >>  8) & 0xff] ^ AES_Te3[s0 & 0xff] ^ rk[13];
         t2 =3D AES_Te0[s2 >> 24] ^ AES_Te1[(s3 >> 16) & 0xff] ^ AES_Te2[=
(s0 >>  8) & 0xff] ^ AES_Te3[s1 & 0xff] ^ rk[14];
         t3 =3D AES_Te0[s3 >> 24] ^ AES_Te1[(s0 >> 16) & 0xff] ^ AES_Te2[=
(s1 >>  8) & 0xff] ^ AES_Te3[s2 & 0xff] ^ rk[15];
-	/* round 4: */
+        /* round 4: */
         s0 =3D AES_Te0[t0 >> 24] ^ AES_Te1[(t1 >> 16) & 0xff] ^ AES_Te2[=
(t2 >>  8) & 0xff] ^ AES_Te3[t3 & 0xff] ^ rk[16];
         s1 =3D AES_Te0[t1 >> 24] ^ AES_Te1[(t2 >> 16) & 0xff] ^ AES_Te2[=
(t3 >>  8) & 0xff] ^ AES_Te3[t0 & 0xff] ^ rk[17];
         s2 =3D AES_Te0[t2 >> 24] ^ AES_Te1[(t3 >> 16) & 0xff] ^ AES_Te2[=
(t0 >>  8) & 0xff] ^ AES_Te3[t1 & 0xff] ^ rk[18];
         s3 =3D AES_Te0[t3 >> 24] ^ AES_Te1[(t0 >> 16) & 0xff] ^ AES_Te2[=
(t1 >>  8) & 0xff] ^ AES_Te3[t2 & 0xff] ^ rk[19];
-	/* round 5: */
+        /* round 5: */
         t0 =3D AES_Te0[s0 >> 24] ^ AES_Te1[(s1 >> 16) & 0xff] ^ AES_Te2[=
(s2 >>  8) & 0xff] ^ AES_Te3[s3 & 0xff] ^ rk[20];
         t1 =3D AES_Te0[s1 >> 24] ^ AES_Te1[(s2 >> 16) & 0xff] ^ AES_Te2[=
(s3 >>  8) & 0xff] ^ AES_Te3[s0 & 0xff] ^ rk[21];
         t2 =3D AES_Te0[s2 >> 24] ^ AES_Te1[(s3 >> 16) & 0xff] ^ AES_Te2[=
(s0 >>  8) & 0xff] ^ AES_Te3[s1 & 0xff] ^ rk[22];
         t3 =3D AES_Te0[s3 >> 24] ^ AES_Te1[(s0 >> 16) & 0xff] ^ AES_Te2[=
(s1 >>  8) & 0xff] ^ AES_Te3[s2 & 0xff] ^ rk[23];
-	/* round 6: */
+        /* round 6: */
         s0 =3D AES_Te0[t0 >> 24] ^ AES_Te1[(t1 >> 16) & 0xff] ^ AES_Te2[=
(t2 >>  8) & 0xff] ^ AES_Te3[t3 & 0xff] ^ rk[24];
         s1 =3D AES_Te0[t1 >> 24] ^ AES_Te1[(t2 >> 16) & 0xff] ^ AES_Te2[=
(t3 >>  8) & 0xff] ^ AES_Te3[t0 & 0xff] ^ rk[25];
         s2 =3D AES_Te0[t2 >> 24] ^ AES_Te1[(t3 >> 16) & 0xff] ^ AES_Te2[=
(t0 >>  8) & 0xff] ^ AES_Te3[t1 & 0xff] ^ rk[26];
         s3 =3D AES_Te0[t3 >> 24] ^ AES_Te1[(t0 >> 16) & 0xff] ^ AES_Te2[=
(t1 >>  8) & 0xff] ^ AES_Te3[t2 & 0xff] ^ rk[27];
-	/* round 7: */
+        /* round 7: */
         t0 =3D AES_Te0[s0 >> 24] ^ AES_Te1[(s1 >> 16) & 0xff] ^ AES_Te2[=
(s2 >>  8) & 0xff] ^ AES_Te3[s3 & 0xff] ^ rk[28];
         t1 =3D AES_Te0[s1 >> 24] ^ AES_Te1[(s2 >> 16) & 0xff] ^ AES_Te2[=
(s3 >>  8) & 0xff] ^ AES_Te3[s0 & 0xff] ^ rk[29];
         t2 =3D AES_Te0[s2 >> 24] ^ AES_Te1[(s3 >> 16) & 0xff] ^ AES_Te2[=
(s0 >>  8) & 0xff] ^ AES_Te3[s1 & 0xff] ^ rk[30];
         t3 =3D AES_Te0[s3 >> 24] ^ AES_Te1[(s0 >> 16) & 0xff] ^ AES_Te2[=
(s1 >>  8) & 0xff] ^ AES_Te3[s2 & 0xff] ^ rk[31];
-	/* round 8: */
+        /* round 8: */
         s0 =3D AES_Te0[t0 >> 24] ^ AES_Te1[(t1 >> 16) & 0xff] ^ AES_Te2[=
(t2 >>  8) & 0xff] ^ AES_Te3[t3 & 0xff] ^ rk[32];
         s1 =3D AES_Te0[t1 >> 24] ^ AES_Te1[(t2 >> 16) & 0xff] ^ AES_Te2[=
(t3 >>  8) & 0xff] ^ AES_Te3[t0 & 0xff] ^ rk[33];
         s2 =3D AES_Te0[t2 >> 24] ^ AES_Te1[(t3 >> 16) & 0xff] ^ AES_Te2[=
(t0 >>  8) & 0xff] ^ AES_Te3[t1 & 0xff] ^ rk[34];
         s3 =3D AES_Te0[t3 >> 24] ^ AES_Te1[(t0 >> 16) & 0xff] ^ AES_Te2[=
(t1 >>  8) & 0xff] ^ AES_Te3[t2 & 0xff] ^ rk[35];
-	/* round 9: */
+        /* round 9: */
         t0 =3D AES_Te0[s0 >> 24] ^ AES_Te1[(s1 >> 16) & 0xff] ^ AES_Te2[=
(s2 >>  8) & 0xff] ^ AES_Te3[s3 & 0xff] ^ rk[36];
         t1 =3D AES_Te0[s1 >> 24] ^ AES_Te1[(s2 >> 16) & 0xff] ^ AES_Te2[=
(s3 >>  8) & 0xff] ^ AES_Te3[s0 & 0xff] ^ rk[37];
         t2 =3D AES_Te0[s2 >> 24] ^ AES_Te1[(s3 >> 16) & 0xff] ^ AES_Te2[=
(s0 >>  8) & 0xff] ^ AES_Te3[s1 & 0xff] ^ rk[38];
@@ -1375,37 +1375,37 @@ void AES_encrypt(const unsigned char *in, unsigne=
d char *out,
     }
 #endif /* ?FULL_UNROLL */
     /*
-	 * apply last round and
-	 * map cipher state to byte array block:
-	 */
-	s0 =3D
+         * apply last round and
+         * map cipher state to byte array block:
+         */
+        s0 =3D
                 (AES_Te4[(t0 >> 24)       ] & 0xff000000) ^
                 (AES_Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Te4[(t3      ) & 0xff] & 0x000000ff) ^
-		rk[0];
-	PUTU32(out     , s0);
-	s1 =3D
+                rk[0];
+        PUTU32(out     , s0);
+        s1 =3D
                 (AES_Te4[(t1 >> 24)       ] & 0xff000000) ^
                 (AES_Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Te4[(t0      ) & 0xff] & 0x000000ff) ^
-		rk[1];
-	PUTU32(out +  4, s1);
-	s2 =3D
+                rk[1];
+        PUTU32(out +  4, s1);
+        s2 =3D
                 (AES_Te4[(t2 >> 24)       ] & 0xff000000) ^
                 (AES_Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Te4[(t1      ) & 0xff] & 0x000000ff) ^
-		rk[2];
-	PUTU32(out +  8, s2);
-	s3 =3D
+                rk[2];
+        PUTU32(out +  8, s2);
+        s3 =3D
                 (AES_Te4[(t3 >> 24)       ] & 0xff000000) ^
                 (AES_Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Te4[(t2      ) & 0xff] & 0x000000ff) ^
-		rk[3];
-	PUTU32(out + 12, s3);
+                rk[3];
+        PUTU32(out + 12, s3);
 }
=20
 /*
@@ -1413,21 +1413,21 @@ void AES_encrypt(const unsigned char *in, unsigne=
d char *out,
  * in and out can overlap
  */
 void AES_decrypt(const unsigned char *in, unsigned char *out,
-		 const AES_KEY *key) {
+                 const AES_KEY *key) {
=20
-	const u32 *rk;
-	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+        const u32 *rk;
+        u32 s0, s1, s2, s3, t0, t1, t2, t3;
 #ifndef FULL_UNROLL
-	int r;
+        int r;
 #endif /* ?FULL_UNROLL */
=20
-	assert(in && out && key);
-	rk =3D key->rd_key;
+        assert(in && out && key);
+        rk =3D key->rd_key;
=20
-	/*
-	 * map byte array block to cipher state
-	 * and add initial round key:
-	 */
+        /*
+         * map byte array block to cipher state
+         * and add initial round key:
+         */
     s0 =3D GETU32(in     ) ^ rk[0];
     s1 =3D GETU32(in +  4) ^ rk[1];
     s2 =3D GETU32(in +  8) ^ rk[2];
@@ -1502,7 +1502,7 @@ void AES_decrypt(const unsigned char *in, unsigned =
char *out,
             t3 =3D AES_Td0[s3 >> 24] ^ AES_Td1[(s2 >> 16) & 0xff] ^ AES_=
Td2[(s1 >>  8) & 0xff] ^ AES_Td3[s0 & 0xff] ^ rk[55];
         }
     }
-	rk +=3D key->rounds << 2;
+        rk +=3D key->rounds << 2;
 #else  /* !FULL_UNROLL */
     /*
      * Nr - 1 full rounds:
@@ -1566,88 +1566,88 @@ void AES_decrypt(const unsigned char *in, unsigne=
d char *out,
     }
 #endif /* ?FULL_UNROLL */
     /*
-	 * apply last round and
-	 * map cipher state to byte array block:
-	 */
-	s0 =3D
+         * apply last round and
+         * map cipher state to byte array block:
+         */
+        s0 =3D
                 (AES_Td4[(t0 >> 24)       ] & 0xff000000) ^
                 (AES_Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Td4[(t1      ) & 0xff] & 0x000000ff) ^
-		rk[0];
-	PUTU32(out     , s0);
-	s1 =3D
+                rk[0];
+        PUTU32(out     , s0);
+        s1 =3D
                 (AES_Td4[(t1 >> 24)       ] & 0xff000000) ^
                 (AES_Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Td4[(t2      ) & 0xff] & 0x000000ff) ^
-		rk[1];
-	PUTU32(out +  4, s1);
-	s2 =3D
+                rk[1];
+        PUTU32(out +  4, s1);
+        s2 =3D
                 (AES_Td4[(t2 >> 24)       ] & 0xff000000) ^
                 (AES_Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Td4[(t3      ) & 0xff] & 0x000000ff) ^
-		rk[2];
-	PUTU32(out +  8, s2);
-	s3 =3D
+                rk[2];
+        PUTU32(out +  8, s2);
+        s3 =3D
                 (AES_Td4[(t3 >> 24)       ] & 0xff000000) ^
                 (AES_Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
                 (AES_Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
                 (AES_Td4[(t0      ) & 0xff] & 0x000000ff) ^
-		rk[3];
-	PUTU32(out + 12, s3);
+                rk[3];
+        PUTU32(out + 12, s3);
 }
=20
 #endif /* AES_ASM */
=20
 void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
-		     const unsigned long length, const AES_KEY *key,
-		     unsigned char *ivec, const int enc)
+                     const unsigned long length, const AES_KEY *key,
+                     unsigned char *ivec, const int enc)
 {
=20
-	unsigned long n;
-	unsigned long len =3D length;
-	unsigned char tmp[AES_BLOCK_SIZE];
+        unsigned long n;
+        unsigned long len =3D length;
+        unsigned char tmp[AES_BLOCK_SIZE];
=20
-	assert(in && out && key && ivec);
+        assert(in && out && key && ivec);
=20
-	if (enc) {
-		while (len >=3D AES_BLOCK_SIZE) {
-			for(n=3D0; n < AES_BLOCK_SIZE; ++n)
-				tmp[n] =3D in[n] ^ ivec[n];
-			AES_encrypt(tmp, out, key);
-			memcpy(ivec, out, AES_BLOCK_SIZE);
-			len -=3D AES_BLOCK_SIZE;
-			in +=3D AES_BLOCK_SIZE;
-			out +=3D AES_BLOCK_SIZE;
-		}
-		if (len) {
-			for(n=3D0; n < len; ++n)
-				tmp[n] =3D in[n] ^ ivec[n];
-			for(n=3Dlen; n < AES_BLOCK_SIZE; ++n)
-				tmp[n] =3D ivec[n];
-			AES_encrypt(tmp, tmp, key);
-			memcpy(out, tmp, AES_BLOCK_SIZE);
-			memcpy(ivec, tmp, AES_BLOCK_SIZE);
-		}
-	} else {
-		while (len >=3D AES_BLOCK_SIZE) {
-			memcpy(tmp, in, AES_BLOCK_SIZE);
-			AES_decrypt(in, out, key);
-			for(n=3D0; n < AES_BLOCK_SIZE; ++n)
-				out[n] ^=3D ivec[n];
-			memcpy(ivec, tmp, AES_BLOCK_SIZE);
-			len -=3D AES_BLOCK_SIZE;
-			in +=3D AES_BLOCK_SIZE;
-			out +=3D AES_BLOCK_SIZE;
-		}
-		if (len) {
-			memcpy(tmp, in, AES_BLOCK_SIZE);
-			AES_decrypt(tmp, tmp, key);
-			for(n=3D0; n < len; ++n)
-				out[n] =3D tmp[n] ^ ivec[n];
-			memcpy(ivec, tmp, AES_BLOCK_SIZE);
-		}
-	}
+        if (enc) {
+                while (len >=3D AES_BLOCK_SIZE) {
+                        for(n=3D0; n < AES_BLOCK_SIZE; ++n)
+                                tmp[n] =3D in[n] ^ ivec[n];
+                        AES_encrypt(tmp, out, key);
+                        memcpy(ivec, out, AES_BLOCK_SIZE);
+                        len -=3D AES_BLOCK_SIZE;
+                        in +=3D AES_BLOCK_SIZE;
+                        out +=3D AES_BLOCK_SIZE;
+                }
+                if (len) {
+                        for(n=3D0; n < len; ++n)
+                                tmp[n] =3D in[n] ^ ivec[n];
+                        for(n=3Dlen; n < AES_BLOCK_SIZE; ++n)
+                                tmp[n] =3D ivec[n];
+                        AES_encrypt(tmp, tmp, key);
+                        memcpy(out, tmp, AES_BLOCK_SIZE);
+                        memcpy(ivec, tmp, AES_BLOCK_SIZE);
+                }
+        } else {
+                while (len >=3D AES_BLOCK_SIZE) {
+                        memcpy(tmp, in, AES_BLOCK_SIZE);
+                        AES_decrypt(in, out, key);
+                        for(n=3D0; n < AES_BLOCK_SIZE; ++n)
+                                out[n] ^=3D ivec[n];
+                        memcpy(ivec, tmp, AES_BLOCK_SIZE);
+                        len -=3D AES_BLOCK_SIZE;
+                        in +=3D AES_BLOCK_SIZE;
+                        out +=3D AES_BLOCK_SIZE;
+                }
+                if (len) {
+                        memcpy(tmp, in, AES_BLOCK_SIZE);
+                        AES_decrypt(tmp, tmp, key);
+                        for(n=3D0; n < len; ++n)
+                                out[n] =3D tmp[n] ^ ivec[n];
+                        memcpy(ivec, tmp, AES_BLOCK_SIZE);
+                }
+        }
 }
diff --git a/crypto/desrfb.c b/crypto/desrfb.c
index ec47dea3bb..3274c36510 100644
--- a/crypto/desrfb.c
+++ b/crypto/desrfb.c
@@ -37,353 +37,353 @@ static void cookey(unsigned long *);
 static unsigned long KnL[32] =3D { 0L };
=20
 static const unsigned short bytebit[8]	=3D {
-	01, 02, 04, 010, 020, 040, 0100, 0200 };
+        01, 02, 04, 010, 020, 040, 0100, 0200 };
=20
 static const unsigned long bigbyte[24] =3D {
-	0x800000L,	0x400000L,	0x200000L,	0x100000L,
-	0x80000L,	0x40000L,	0x20000L,	0x10000L,
-	0x8000L,	0x4000L,	0x2000L,	0x1000L,
-	0x800L, 	0x400L, 	0x200L, 	0x100L,
-	0x80L,		0x40L,		0x20L,		0x10L,
-	0x8L,		0x4L,		0x2L,		0x1L	};
+        0x800000L,	0x400000L,	0x200000L,	0x100000L,
+        0x80000L,	0x40000L,	0x20000L,	0x10000L,
+        0x8000L,	0x4000L,	0x2000L,	0x1000L,
+        0x800L, 	0x400L, 	0x200L, 	0x100L,
+        0x80L,		0x40L,		0x20L,		0x10L,
+        0x8L,		0x4L,		0x2L,		0x1L	};
=20
 /* Use the key schedule specified in the Standard (ANSI X3.92-1981). */
=20
 static const unsigned char pc1[56] =3D {
-	56, 48, 40, 32, 24, 16,  8,	 0, 57, 49, 41, 33, 25, 17,
-	 9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
-	62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
-	13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3 };
+        56, 48, 40, 32, 24, 16,  8,	 0, 57, 49, 41, 33, 25, 17,
+         9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
+        62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
+        13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3 };
=20
 static const unsigned char totrot[16] =3D {
-	1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28 };
+        1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28 };
=20
 static const unsigned char pc2[48] =3D {
-	13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
-	22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
-	40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
-	43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
+        13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
+        22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
+        40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
+        43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
=20
 /* Thanks to James Gillogly & Phil Karn! */
 void deskey(unsigned char *key, int edf)
 {
-	register int i, j, l, m, n;
-	unsigned char pc1m[56], pcr[56];
-	unsigned long kn[32];
-
-	for ( j =3D 0; j < 56; j++ ) {
-		l =3D pc1[j];
-		m =3D l & 07;
-		pc1m[j] =3D (key[l >> 3] & bytebit[m]) ? 1 : 0;
-		}
-	for( i =3D 0; i < 16; i++ ) {
-		if( edf =3D=3D DE1 ) m =3D (15 - i) << 1;
-		else m =3D i << 1;
-		n =3D m + 1;
-		kn[m] =3D kn[n] =3D 0L;
-		for( j =3D 0; j < 28; j++ ) {
-			l =3D j + totrot[i];
-			if( l < 28 ) pcr[j] =3D pc1m[l];
-			else pcr[j] =3D pc1m[l - 28];
-			}
-		for( j =3D 28; j < 56; j++ ) {
-		    l =3D j + totrot[i];
-		    if( l < 56 ) pcr[j] =3D pc1m[l];
-		    else pcr[j] =3D pc1m[l - 28];
-		    }
-		for( j =3D 0; j < 24; j++ ) {
-			if( pcr[pc2[j]] ) kn[m] |=3D bigbyte[j];
-			if( pcr[pc2[j+24]] ) kn[n] |=3D bigbyte[j];
-			}
-		}
-	cookey(kn);
-	return;
-	}
+        register int i, j, l, m, n;
+        unsigned char pc1m[56], pcr[56];
+        unsigned long kn[32];
+
+        for ( j =3D 0; j < 56; j++ ) {
+                l =3D pc1[j];
+                m =3D l & 07;
+                pc1m[j] =3D (key[l >> 3] & bytebit[m]) ? 1 : 0;
+                }
+        for( i =3D 0; i < 16; i++ ) {
+                if( edf =3D=3D DE1 ) m =3D (15 - i) << 1;
+                else m =3D i << 1;
+                n =3D m + 1;
+                kn[m] =3D kn[n] =3D 0L;
+                for( j =3D 0; j < 28; j++ ) {
+                        l =3D j + totrot[i];
+                        if( l < 28 ) pcr[j] =3D pc1m[l];
+                        else pcr[j] =3D pc1m[l - 28];
+                        }
+                for( j =3D 28; j < 56; j++ ) {
+                    l =3D j + totrot[i];
+                    if( l < 56 ) pcr[j] =3D pc1m[l];
+                    else pcr[j] =3D pc1m[l - 28];
+                    }
+                for( j =3D 0; j < 24; j++ ) {
+                        if( pcr[pc2[j]] ) kn[m] |=3D bigbyte[j];
+                        if( pcr[pc2[j+24]] ) kn[n] |=3D bigbyte[j];
+                        }
+                }
+        cookey(kn);
+        return;
+        }
=20
 static void cookey(register unsigned long *raw1)
 {
-	register unsigned long *cook, *raw0;
-	unsigned long dough[32];
-	register int i;
-
-	cook =3D dough;
-	for( i =3D 0; i < 16; i++, raw1++ ) {
-		raw0 =3D raw1++;
-		*cook	 =3D (*raw0 & 0x00fc0000L) << 6;
-		*cook	|=3D (*raw0 & 0x00000fc0L) << 10;
-		*cook	|=3D (*raw1 & 0x00fc0000L) >> 10;
-		*cook++ |=3D (*raw1 & 0x00000fc0L) >> 6;
-		*cook	 =3D (*raw0 & 0x0003f000L) << 12;
-		*cook	|=3D (*raw0 & 0x0000003fL) << 16;
-		*cook	|=3D (*raw1 & 0x0003f000L) >> 4;
-		*cook++ |=3D (*raw1 & 0x0000003fL);
-		}
-	usekey(dough);
-	return;
-	}
+        register unsigned long *cook, *raw0;
+        unsigned long dough[32];
+        register int i;
+
+        cook =3D dough;
+        for( i =3D 0; i < 16; i++, raw1++ ) {
+                raw0 =3D raw1++;
+                *cook	 =3D (*raw0 & 0x00fc0000L) << 6;
+                *cook	|=3D (*raw0 & 0x00000fc0L) << 10;
+                *cook	|=3D (*raw1 & 0x00fc0000L) >> 10;
+                *cook++ |=3D (*raw1 & 0x00000fc0L) >> 6;
+                *cook	 =3D (*raw0 & 0x0003f000L) << 12;
+                *cook	|=3D (*raw0 & 0x0000003fL) << 16;
+                *cook	|=3D (*raw1 & 0x0003f000L) >> 4;
+                *cook++ |=3D (*raw1 & 0x0000003fL);
+                }
+        usekey(dough);
+        return;
+        }
=20
 void usekey(register unsigned long *from)
 {
-	register unsigned long *to, *endp;
+        register unsigned long *to, *endp;
=20
-	to =3D KnL, endp =3D &KnL[32];
-	while( to < endp ) *to++ =3D *from++;
-	return;
-	}
+        to =3D KnL, endp =3D &KnL[32];
+        while( to < endp ) *to++ =3D *from++;
+        return;
+        }
=20
 void des(unsigned char *inblock, unsigned char *outblock)
 {
-	unsigned long work[2];
+        unsigned long work[2];
=20
-	scrunch(inblock, work);
-	desfunc(work, KnL);
-	unscrun(work, outblock);
-	return;
-	}
+        scrunch(inblock, work);
+        desfunc(work, KnL);
+        unscrun(work, outblock);
+        return;
+        }
=20
 static void scrunch(register unsigned char *outof, register unsigned lon=
g *into)
 {
-	*into	 =3D (*outof++ & 0xffL) << 24;
-	*into	|=3D (*outof++ & 0xffL) << 16;
-	*into	|=3D (*outof++ & 0xffL) << 8;
-	*into++ |=3D (*outof++ & 0xffL);
-	*into	 =3D (*outof++ & 0xffL) << 24;
-	*into	|=3D (*outof++ & 0xffL) << 16;
-	*into	|=3D (*outof++ & 0xffL) << 8;
-	*into	|=3D (*outof   & 0xffL);
-	return;
-	}
+        *into	 =3D (*outof++ & 0xffL) << 24;
+        *into	|=3D (*outof++ & 0xffL) << 16;
+        *into	|=3D (*outof++ & 0xffL) << 8;
+        *into++ |=3D (*outof++ & 0xffL);
+        *into	 =3D (*outof++ & 0xffL) << 24;
+        *into	|=3D (*outof++ & 0xffL) << 16;
+        *into	|=3D (*outof++ & 0xffL) << 8;
+        *into	|=3D (*outof   & 0xffL);
+        return;
+        }
=20
 static void unscrun(register unsigned long *outof, register unsigned cha=
r *into)
 {
-	*into++ =3D (unsigned char)((*outof >> 24) & 0xffL);
-	*into++ =3D (unsigned char)((*outof >> 16) & 0xffL);
-	*into++ =3D (unsigned char)((*outof >>  8) & 0xffL);
-	*into++ =3D (unsigned char)(*outof++	 & 0xffL);
-	*into++ =3D (unsigned char)((*outof >> 24) & 0xffL);
-	*into++ =3D (unsigned char)((*outof >> 16) & 0xffL);
-	*into++ =3D (unsigned char)((*outof >>  8) & 0xffL);
-	*into	=3D  (unsigned char)(*outof	 & 0xffL);
-	return;
-	}
+        *into++ =3D (unsigned char)((*outof >> 24) & 0xffL);
+        *into++ =3D (unsigned char)((*outof >> 16) & 0xffL);
+        *into++ =3D (unsigned char)((*outof >>  8) & 0xffL);
+        *into++ =3D (unsigned char)(*outof++	 & 0xffL);
+        *into++ =3D (unsigned char)((*outof >> 24) & 0xffL);
+        *into++ =3D (unsigned char)((*outof >> 16) & 0xffL);
+        *into++ =3D (unsigned char)((*outof >>  8) & 0xffL);
+        *into	=3D  (unsigned char)(*outof	 & 0xffL);
+        return;
+        }
=20
 static const unsigned long SP1[64] =3D {
-	0x01010400L, 0x00000000L, 0x00010000L, 0x01010404L,
-	0x01010004L, 0x00010404L, 0x00000004L, 0x00010000L,
-	0x00000400L, 0x01010400L, 0x01010404L, 0x00000400L,
-	0x01000404L, 0x01010004L, 0x01000000L, 0x00000004L,
-	0x00000404L, 0x01000400L, 0x01000400L, 0x00010400L,
-	0x00010400L, 0x01010000L, 0x01010000L, 0x01000404L,
-	0x00010004L, 0x01000004L, 0x01000004L, 0x00010004L,
-	0x00000000L, 0x00000404L, 0x00010404L, 0x01000000L,
-	0x00010000L, 0x01010404L, 0x00000004L, 0x01010000L,
-	0x01010400L, 0x01000000L, 0x01000000L, 0x00000400L,
-	0x01010004L, 0x00010000L, 0x00010400L, 0x01000004L,
-	0x00000400L, 0x00000004L, 0x01000404L, 0x00010404L,
-	0x01010404L, 0x00010004L, 0x01010000L, 0x01000404L,
-	0x01000004L, 0x00000404L, 0x00010404L, 0x01010400L,
-	0x00000404L, 0x01000400L, 0x01000400L, 0x00000000L,
-	0x00010004L, 0x00010400L, 0x00000000L, 0x01010004L };
+        0x01010400L, 0x00000000L, 0x00010000L, 0x01010404L,
+        0x01010004L, 0x00010404L, 0x00000004L, 0x00010000L,
+        0x00000400L, 0x01010400L, 0x01010404L, 0x00000400L,
+        0x01000404L, 0x01010004L, 0x01000000L, 0x00000004L,
+        0x00000404L, 0x01000400L, 0x01000400L, 0x00010400L,
+        0x00010400L, 0x01010000L, 0x01010000L, 0x01000404L,
+        0x00010004L, 0x01000004L, 0x01000004L, 0x00010004L,
+        0x00000000L, 0x00000404L, 0x00010404L, 0x01000000L,
+        0x00010000L, 0x01010404L, 0x00000004L, 0x01010000L,
+        0x01010400L, 0x01000000L, 0x01000000L, 0x00000400L,
+        0x01010004L, 0x00010000L, 0x00010400L, 0x01000004L,
+        0x00000400L, 0x00000004L, 0x01000404L, 0x00010404L,
+        0x01010404L, 0x00010004L, 0x01010000L, 0x01000404L,
+        0x01000004L, 0x00000404L, 0x00010404L, 0x01010400L,
+        0x00000404L, 0x01000400L, 0x01000400L, 0x00000000L,
+        0x00010004L, 0x00010400L, 0x00000000L, 0x01010004L };
=20
 static const unsigned long SP2[64] =3D {
-	0x80108020L, 0x80008000L, 0x00008000L, 0x00108020L,
-	0x00100000L, 0x00000020L, 0x80100020L, 0x80008020L,
-	0x80000020L, 0x80108020L, 0x80108000L, 0x80000000L,
-	0x80008000L, 0x00100000L, 0x00000020L, 0x80100020L,
-	0x00108000L, 0x00100020L, 0x80008020L, 0x00000000L,
-	0x80000000L, 0x00008000L, 0x00108020L, 0x80100000L,
-	0x00100020L, 0x80000020L, 0x00000000L, 0x00108000L,
-	0x00008020L, 0x80108000L, 0x80100000L, 0x00008020L,
-	0x00000000L, 0x00108020L, 0x80100020L, 0x00100000L,
-	0x80008020L, 0x80100000L, 0x80108000L, 0x00008000L,
-	0x80100000L, 0x80008000L, 0x00000020L, 0x80108020L,
-	0x00108020L, 0x00000020L, 0x00008000L, 0x80000000L,
-	0x00008020L, 0x80108000L, 0x00100000L, 0x80000020L,
-	0x00100020L, 0x80008020L, 0x80000020L, 0x00100020L,
-	0x00108000L, 0x00000000L, 0x80008000L, 0x00008020L,
-	0x80000000L, 0x80100020L, 0x80108020L, 0x00108000L };
+        0x80108020L, 0x80008000L, 0x00008000L, 0x00108020L,
+        0x00100000L, 0x00000020L, 0x80100020L, 0x80008020L,
+        0x80000020L, 0x80108020L, 0x80108000L, 0x80000000L,
+        0x80008000L, 0x00100000L, 0x00000020L, 0x80100020L,
+        0x00108000L, 0x00100020L, 0x80008020L, 0x00000000L,
+        0x80000000L, 0x00008000L, 0x00108020L, 0x80100000L,
+        0x00100020L, 0x80000020L, 0x00000000L, 0x00108000L,
+        0x00008020L, 0x80108000L, 0x80100000L, 0x00008020L,
+        0x00000000L, 0x00108020L, 0x80100020L, 0x00100000L,
+        0x80008020L, 0x80100000L, 0x80108000L, 0x00008000L,
+        0x80100000L, 0x80008000L, 0x00000020L, 0x80108020L,
+        0x00108020L, 0x00000020L, 0x00008000L, 0x80000000L,
+        0x00008020L, 0x80108000L, 0x00100000L, 0x80000020L,
+        0x00100020L, 0x80008020L, 0x80000020L, 0x00100020L,
+        0x00108000L, 0x00000000L, 0x80008000L, 0x00008020L,
+        0x80000000L, 0x80100020L, 0x80108020L, 0x00108000L };
=20
 static const unsigned long SP3[64] =3D {
-	0x00000208L, 0x08020200L, 0x00000000L, 0x08020008L,
-	0x08000200L, 0x00000000L, 0x00020208L, 0x08000200L,
-	0x00020008L, 0x08000008L, 0x08000008L, 0x00020000L,
-	0x08020208L, 0x00020008L, 0x08020000L, 0x00000208L,
-	0x08000000L, 0x00000008L, 0x08020200L, 0x00000200L,
-	0x00020200L, 0x08020000L, 0x08020008L, 0x00020208L,
-	0x08000208L, 0x00020200L, 0x00020000L, 0x08000208L,
-	0x00000008L, 0x08020208L, 0x00000200L, 0x08000000L,
-	0x08020200L, 0x08000000L, 0x00020008L, 0x00000208L,
-	0x00020000L, 0x08020200L, 0x08000200L, 0x00000000L,
-	0x00000200L, 0x00020008L, 0x08020208L, 0x08000200L,
-	0x08000008L, 0x00000200L, 0x00000000L, 0x08020008L,
-	0x08000208L, 0x00020000L, 0x08000000L, 0x08020208L,
-	0x00000008L, 0x00020208L, 0x00020200L, 0x08000008L,
-	0x08020000L, 0x08000208L, 0x00000208L, 0x08020000L,
-	0x00020208L, 0x00000008L, 0x08020008L, 0x00020200L };
+        0x00000208L, 0x08020200L, 0x00000000L, 0x08020008L,
+        0x08000200L, 0x00000000L, 0x00020208L, 0x08000200L,
+        0x00020008L, 0x08000008L, 0x08000008L, 0x00020000L,
+        0x08020208L, 0x00020008L, 0x08020000L, 0x00000208L,
+        0x08000000L, 0x00000008L, 0x08020200L, 0x00000200L,
+        0x00020200L, 0x08020000L, 0x08020008L, 0x00020208L,
+        0x08000208L, 0x00020200L, 0x00020000L, 0x08000208L,
+        0x00000008L, 0x08020208L, 0x00000200L, 0x08000000L,
+        0x08020200L, 0x08000000L, 0x00020008L, 0x00000208L,
+        0x00020000L, 0x08020200L, 0x08000200L, 0x00000000L,
+        0x00000200L, 0x00020008L, 0x08020208L, 0x08000200L,
+        0x08000008L, 0x00000200L, 0x00000000L, 0x08020008L,
+        0x08000208L, 0x00020000L, 0x08000000L, 0x08020208L,
+        0x00000008L, 0x00020208L, 0x00020200L, 0x08000008L,
+        0x08020000L, 0x08000208L, 0x00000208L, 0x08020000L,
+        0x00020208L, 0x00000008L, 0x08020008L, 0x00020200L };
=20
 static const unsigned long SP4[64] =3D {
-	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
-	0x00802080L, 0x00800081L, 0x00800001L, 0x00002001L,
-	0x00000000L, 0x00802000L, 0x00802000L, 0x00802081L,
-	0x00000081L, 0x00000000L, 0x00800080L, 0x00800001L,
-	0x00000001L, 0x00002000L, 0x00800000L, 0x00802001L,
-	0x00000080L, 0x00800000L, 0x00002001L, 0x00002080L,
-	0x00800081L, 0x00000001L, 0x00002080L, 0x00800080L,
-	0x00002000L, 0x00802080L, 0x00802081L, 0x00000081L,
-	0x00800080L, 0x00800001L, 0x00802000L, 0x00802081L,
-	0x00000081L, 0x00000000L, 0x00000000L, 0x00802000L,
-	0x00002080L, 0x00800080L, 0x00800081L, 0x00000001L,
-	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
-	0x00802081L, 0x00000081L, 0x00000001L, 0x00002000L,
-	0x00800001L, 0x00002001L, 0x00802080L, 0x00800081L,
-	0x00002001L, 0x00002080L, 0x00800000L, 0x00802001L,
-	0x00000080L, 0x00800000L, 0x00002000L, 0x00802080L };
+        0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
+        0x00802080L, 0x00800081L, 0x00800001L, 0x00002001L,
+        0x00000000L, 0x00802000L, 0x00802000L, 0x00802081L,
+        0x00000081L, 0x00000000L, 0x00800080L, 0x00800001L,
+        0x00000001L, 0x00002000L, 0x00800000L, 0x00802001L,
+        0x00000080L, 0x00800000L, 0x00002001L, 0x00002080L,
+        0x00800081L, 0x00000001L, 0x00002080L, 0x00800080L,
+        0x00002000L, 0x00802080L, 0x00802081L, 0x00000081L,
+        0x00800080L, 0x00800001L, 0x00802000L, 0x00802081L,
+        0x00000081L, 0x00000000L, 0x00000000L, 0x00802000L,
+        0x00002080L, 0x00800080L, 0x00800081L, 0x00000001L,
+        0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
+        0x00802081L, 0x00000081L, 0x00000001L, 0x00002000L,
+        0x00800001L, 0x00002001L, 0x00802080L, 0x00800081L,
+        0x00002001L, 0x00002080L, 0x00800000L, 0x00802001L,
+        0x00000080L, 0x00800000L, 0x00002000L, 0x00802080L };
=20
 static const unsigned long SP5[64] =3D {
-	0x00000100L, 0x02080100L, 0x02080000L, 0x42000100L,
-	0x00080000L, 0x00000100L, 0x40000000L, 0x02080000L,
-	0x40080100L, 0x00080000L, 0x02000100L, 0x40080100L,
-	0x42000100L, 0x42080000L, 0x00080100L, 0x40000000L,
-	0x02000000L, 0x40080000L, 0x40080000L, 0x00000000L,
-	0x40000100L, 0x42080100L, 0x42080100L, 0x02000100L,
-	0x42080000L, 0x40000100L, 0x00000000L, 0x42000000L,
-	0x02080100L, 0x02000000L, 0x42000000L, 0x00080100L,
-	0x00080000L, 0x42000100L, 0x00000100L, 0x02000000L,
-	0x40000000L, 0x02080000L, 0x42000100L, 0x40080100L,
-	0x02000100L, 0x40000000L, 0x42080000L, 0x02080100L,
-	0x40080100L, 0x00000100L, 0x02000000L, 0x42080000L,
-	0x42080100L, 0x00080100L, 0x42000000L, 0x42080100L,
-	0x02080000L, 0x00000000L, 0x40080000L, 0x42000000L,
-	0x00080100L, 0x02000100L, 0x40000100L, 0x00080000L,
-	0x00000000L, 0x40080000L, 0x02080100L, 0x40000100L };
+        0x00000100L, 0x02080100L, 0x02080000L, 0x42000100L,
+        0x00080000L, 0x00000100L, 0x40000000L, 0x02080000L,
+        0x40080100L, 0x00080000L, 0x02000100L, 0x40080100L,
+        0x42000100L, 0x42080000L, 0x00080100L, 0x40000000L,
+        0x02000000L, 0x40080000L, 0x40080000L, 0x00000000L,
+        0x40000100L, 0x42080100L, 0x42080100L, 0x02000100L,
+        0x42080000L, 0x40000100L, 0x00000000L, 0x42000000L,
+        0x02080100L, 0x02000000L, 0x42000000L, 0x00080100L,
+        0x00080000L, 0x42000100L, 0x00000100L, 0x02000000L,
+        0x40000000L, 0x02080000L, 0x42000100L, 0x40080100L,
+        0x02000100L, 0x40000000L, 0x42080000L, 0x02080100L,
+        0x40080100L, 0x00000100L, 0x02000000L, 0x42080000L,
+        0x42080100L, 0x00080100L, 0x42000000L, 0x42080100L,
+        0x02080000L, 0x00000000L, 0x40080000L, 0x42000000L,
+        0x00080100L, 0x02000100L, 0x40000100L, 0x00080000L,
+        0x00000000L, 0x40080000L, 0x02080100L, 0x40000100L };
=20
 static const unsigned long SP6[64] =3D {
-	0x20000010L, 0x20400000L, 0x00004000L, 0x20404010L,
-	0x20400000L, 0x00000010L, 0x20404010L, 0x00400000L,
-	0x20004000L, 0x00404010L, 0x00400000L, 0x20000010L,
-	0x00400010L, 0x20004000L, 0x20000000L, 0x00004010L,
-	0x00000000L, 0x00400010L, 0x20004010L, 0x00004000L,
-	0x00404000L, 0x20004010L, 0x00000010L, 0x20400010L,
-	0x20400010L, 0x00000000L, 0x00404010L, 0x20404000L,
-	0x00004010L, 0x00404000L, 0x20404000L, 0x20000000L,
-	0x20004000L, 0x00000010L, 0x20400010L, 0x00404000L,
-	0x20404010L, 0x00400000L, 0x00004010L, 0x20000010L,
-	0x00400000L, 0x20004000L, 0x20000000L, 0x00004010L,
-	0x20000010L, 0x20404010L, 0x00404000L, 0x20400000L,
-	0x00404010L, 0x20404000L, 0x00000000L, 0x20400010L,
-	0x00000010L, 0x00004000L, 0x20400000L, 0x00404010L,
-	0x00004000L, 0x00400010L, 0x20004010L, 0x00000000L,
-	0x20404000L, 0x20000000L, 0x00400010L, 0x20004010L };
+        0x20000010L, 0x20400000L, 0x00004000L, 0x20404010L,
+        0x20400000L, 0x00000010L, 0x20404010L, 0x00400000L,
+        0x20004000L, 0x00404010L, 0x00400000L, 0x20000010L,
+        0x00400010L, 0x20004000L, 0x20000000L, 0x00004010L,
+        0x00000000L, 0x00400010L, 0x20004010L, 0x00004000L,
+        0x00404000L, 0x20004010L, 0x00000010L, 0x20400010L,
+        0x20400010L, 0x00000000L, 0x00404010L, 0x20404000L,
+        0x00004010L, 0x00404000L, 0x20404000L, 0x20000000L,
+        0x20004000L, 0x00000010L, 0x20400010L, 0x00404000L,
+        0x20404010L, 0x00400000L, 0x00004010L, 0x20000010L,
+        0x00400000L, 0x20004000L, 0x20000000L, 0x00004010L,
+        0x20000010L, 0x20404010L, 0x00404000L, 0x20400000L,
+        0x00404010L, 0x20404000L, 0x00000000L, 0x20400010L,
+        0x00000010L, 0x00004000L, 0x20400000L, 0x00404010L,
+        0x00004000L, 0x00400010L, 0x20004010L, 0x00000000L,
+        0x20404000L, 0x20000000L, 0x00400010L, 0x20004010L };
=20
 static const unsigned long SP7[64] =3D {
-	0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,
-	0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,
-	0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,
-	0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,
-	0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,
-	0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,
-	0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,
-	0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,
-	0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,
-	0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,
-	0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,
-	0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,
-	0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,
-	0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,
-	0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,
-	0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L };
+        0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,
+        0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,
+        0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,
+        0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,
+        0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,
+        0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,
+        0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,
+        0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,
+        0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,
+        0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,
+        0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,
+        0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,
+        0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,
+        0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,
+        0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,
+        0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L };
=20
 static const unsigned long SP8[64] =3D {
-	0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,
-	0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,
-	0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,
-	0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,
-	0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,
-	0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,
-	0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,
-	0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,
-	0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,
-	0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,
-	0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,
-	0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,
-	0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,
-	0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,
-	0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,
-	0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L };
+        0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,
+        0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,
+        0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,
+        0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,
+        0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,
+        0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,
+        0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,
+        0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,
+        0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,
+        0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,
+        0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,
+        0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,
+        0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,
+        0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,
+        0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,
+        0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L };
=20
 static void desfunc(register unsigned long *block, register unsigned lon=
g *keys)
 {
-	register unsigned long fval, work, right, leftt;
-	register int round;
-
-	leftt =3D block[0];
-	right =3D block[1];
-	work =3D ((leftt >> 4) ^ right) & 0x0f0f0f0fL;
-	right ^=3D work;
-	leftt ^=3D (work << 4);
-	work =3D ((leftt >> 16) ^ right) & 0x0000ffffL;
-	right ^=3D work;
-	leftt ^=3D (work << 16);
-	work =3D ((right >> 2) ^ leftt) & 0x33333333L;
-	leftt ^=3D work;
-	right ^=3D (work << 2);
-	work =3D ((right >> 8) ^ leftt) & 0x00ff00ffL;
-	leftt ^=3D work;
-	right ^=3D (work << 8);
-	right =3D ((right << 1) | ((right >> 31) & 1L)) & 0xffffffffL;
-	work =3D (leftt ^ right) & 0xaaaaaaaaL;
-	leftt ^=3D work;
-	right ^=3D work;
-	leftt =3D ((leftt << 1) | ((leftt >> 31) & 1L)) & 0xffffffffL;
-
-	for( round =3D 0; round < 8; round++ ) {
-		work  =3D (right << 28) | (right >> 4);
-		work ^=3D *keys++;
-		fval  =3D SP7[ work		 & 0x3fL];
-		fval |=3D SP5[(work >>  8) & 0x3fL];
-		fval |=3D SP3[(work >> 16) & 0x3fL];
-		fval |=3D SP1[(work >> 24) & 0x3fL];
-		work  =3D right ^ *keys++;
-		fval |=3D SP8[ work		 & 0x3fL];
-		fval |=3D SP6[(work >>  8) & 0x3fL];
-		fval |=3D SP4[(work >> 16) & 0x3fL];
-		fval |=3D SP2[(work >> 24) & 0x3fL];
-		leftt ^=3D fval;
-		work  =3D (leftt << 28) | (leftt >> 4);
-		work ^=3D *keys++;
-		fval  =3D SP7[ work		 & 0x3fL];
-		fval |=3D SP5[(work >>  8) & 0x3fL];
-		fval |=3D SP3[(work >> 16) & 0x3fL];
-		fval |=3D SP1[(work >> 24) & 0x3fL];
-		work  =3D leftt ^ *keys++;
-		fval |=3D SP8[ work		 & 0x3fL];
-		fval |=3D SP6[(work >>  8) & 0x3fL];
-		fval |=3D SP4[(work >> 16) & 0x3fL];
-		fval |=3D SP2[(work >> 24) & 0x3fL];
-		right ^=3D fval;
-		}
-
-	right =3D (right << 31) | (right >> 1);
-	work =3D (leftt ^ right) & 0xaaaaaaaaL;
-	leftt ^=3D work;
-	right ^=3D work;
-	leftt =3D (leftt << 31) | (leftt >> 1);
-	work =3D ((leftt >> 8) ^ right) & 0x00ff00ffL;
-	right ^=3D work;
-	leftt ^=3D (work << 8);
-	work =3D ((leftt >> 2) ^ right) & 0x33333333L;
-	right ^=3D work;
-	leftt ^=3D (work << 2);
-	work =3D ((right >> 16) ^ leftt) & 0x0000ffffL;
-	leftt ^=3D work;
-	right ^=3D (work << 16);
-	work =3D ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
-	leftt ^=3D work;
-	right ^=3D (work << 4);
-	*block++ =3D right;
-	*block =3D leftt;
-	return;
-	}
+        register unsigned long fval, work, right, leftt;
+        register int round;
+
+        leftt =3D block[0];
+        right =3D block[1];
+        work =3D ((leftt >> 4) ^ right) & 0x0f0f0f0fL;
+        right ^=3D work;
+        leftt ^=3D (work << 4);
+        work =3D ((leftt >> 16) ^ right) & 0x0000ffffL;
+        right ^=3D work;
+        leftt ^=3D (work << 16);
+        work =3D ((right >> 2) ^ leftt) & 0x33333333L;
+        leftt ^=3D work;
+        right ^=3D (work << 2);
+        work =3D ((right >> 8) ^ leftt) & 0x00ff00ffL;
+        leftt ^=3D work;
+        right ^=3D (work << 8);
+        right =3D ((right << 1) | ((right >> 31) & 1L)) & 0xffffffffL;
+        work =3D (leftt ^ right) & 0xaaaaaaaaL;
+        leftt ^=3D work;
+        right ^=3D work;
+        leftt =3D ((leftt << 1) | ((leftt >> 31) & 1L)) & 0xffffffffL;
+
+        for( round =3D 0; round < 8; round++ ) {
+                work  =3D (right << 28) | (right >> 4);
+                work ^=3D *keys++;
+                fval  =3D SP7[ work		 & 0x3fL];
+                fval |=3D SP5[(work >>  8) & 0x3fL];
+                fval |=3D SP3[(work >> 16) & 0x3fL];
+                fval |=3D SP1[(work >> 24) & 0x3fL];
+                work  =3D right ^ *keys++;
+                fval |=3D SP8[ work		 & 0x3fL];
+                fval |=3D SP6[(work >>  8) & 0x3fL];
+                fval |=3D SP4[(work >> 16) & 0x3fL];
+                fval |=3D SP2[(work >> 24) & 0x3fL];
+                leftt ^=3D fval;
+                work  =3D (leftt << 28) | (leftt >> 4);
+                work ^=3D *keys++;
+                fval  =3D SP7[ work		 & 0x3fL];
+                fval |=3D SP5[(work >>  8) & 0x3fL];
+                fval |=3D SP3[(work >> 16) & 0x3fL];
+                fval |=3D SP1[(work >> 24) & 0x3fL];
+                work  =3D leftt ^ *keys++;
+                fval |=3D SP8[ work		 & 0x3fL];
+                fval |=3D SP6[(work >>  8) & 0x3fL];
+                fval |=3D SP4[(work >> 16) & 0x3fL];
+                fval |=3D SP2[(work >> 24) & 0x3fL];
+                right ^=3D fval;
+                }
+
+        right =3D (right << 31) | (right >> 1);
+        work =3D (leftt ^ right) & 0xaaaaaaaaL;
+        leftt ^=3D work;
+        right ^=3D work;
+        leftt =3D (leftt << 31) | (leftt >> 1);
+        work =3D ((leftt >> 8) ^ right) & 0x00ff00ffL;
+        right ^=3D work;
+        leftt ^=3D (work << 8);
+        work =3D ((leftt >> 2) ^ right) & 0x33333333L;
+        right ^=3D work;
+        leftt ^=3D (work << 2);
+        work =3D ((right >> 16) ^ leftt) & 0x0000ffffL;
+        leftt ^=3D work;
+        right ^=3D (work << 16);
+        work =3D ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
+        leftt ^=3D work;
+        right ^=3D (work << 4);
+        *block++ =3D right;
+        *block =3D leftt;
+        return;
+        }
=20
 /* Validation sets:
  *
--=20
2.20.1


