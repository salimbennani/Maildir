Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  20 Dec 2018 08:40:09 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga003.jf.intel.com (orsmga003.jf.intel.com [10.7.209.27])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 1D08E580522
	for <like.xu@linux.intel.com>; Wed, 19 Dec 2018 07:55:55 -0800 (PST)
Received: from orsmga102-1.jf.intel.com (HELO mga09.intel.com) ([10.7.208.27])
  by orsmga003-1.jf.intel.com with ESMTP; 19 Dec 2018 07:55:54 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AqqRZlRCFsWvmXLm+YmaWUyQJP3N1i/DPJgcQr6Af?=
 =?us-ascii?q?oPdwSPX+rsbcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Qiqp4bt1RxD0iS?=
 =?us-ascii?q?cHLz85/3/Risxsl6JQvRatqwViz4LIfI2ZMfxzdb7fc9wHX2pMRsZfWTJPDI2/?=
 =?us-ascii?q?bYQPAeUOMvpXoYfgv1sDrxmwCAaxCO7h1jNHmGT20LYm0+Q4CwzKwBAsE84MvX?=
 =?us-ascii?q?nSsd77NL0SUeewzKTQ1zvMdfRW2TP66IPVbx0hpveMXLNxccrXyEkkCgTIjk2L?=
 =?us-ascii?q?poziOTOU1+UNs26a7+d7T+KglXMoqwFrrTiz3Msjlo7JhocMx13C6C53w541KM?=
 =?us-ascii?q?WmREJnYtOoCoZcuzyZOodsXM8vTWFltDwnxrAEoZK3YjQGxZA9yxLCZfGLbZKE?=
 =?us-ascii?q?7g/gWeufOzt0mnFodbSijBio60eg0PfzVsys3VZKsCVFlt7Mu2gJ1xzS8ciHVu?=
 =?us-ascii?q?B98l2u2TaJygDf8OZEIVo7labDKp4hxKA/loYLvEjdAiP7m1/6gLKLekgn4OSk?=
 =?us-ascii?q?9erqb7X8qpOBNYJ4kgT+Pb4vmsy7D+Q4KA8OX22D9OSlyrLj+FD5TKxXgfIojK?=
 =?us-ascii?q?nWrpTaKd0Aqa6+Hg9V1Jos5AikDzuh1NQYnHoHI0xfdBOIkojkI1XOIPH+Dfei?=
 =?us-ascii?q?jFWgijZrx/baPrL/BpXBNGTMkLDkfbtm7U5czwwzzd9Z55JJEL0BJ+jzWkDpuN?=
 =?us-ascii?q?zCEhA5KxC0w/rgCNhl0oMeWGGPDbGDPKLdrF+F/eYvI+iKZI8ItzfxMfkl5/jy?=
 =?us-ascii?q?jXAnnV8RZ7Wm3ZwSaCPwI/J9Pk/MYWbwmsxTViAOvxEiV6rsj1uNVyMVYGy9GK?=
 =?us-ascii?q?c15zU+AYThCp/fR4erm/uY0SKmW5FbeG1CWW2KCmriIoCNWvMQb3CLL8p81zAJ?=
 =?us-ascii?q?S7WlDpUszAyjrxPSzb1hIezJvCoCusX4ydJ36ubPwAw07iF+FM+H0muAHF1zy3?=
 =?us-ascii?q?oFQiJz0K1hrEhVzFCF3q5lxftCGo99/fRMBz8zMprbh8Z9DcLzXAOJKs+DT1C0?=
 =?us-ascii?q?Q9OnKSs8QtI435kFZEMrSIbqtQzKwyf/W+xdrLeMHpFht/uEh3U=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0DSAgCfaRpchxHrdtBkHgEGBwaBZYExg?=
 =?us-ascii?q?TmBKYN9iHiLHYMJjUmLDxEYAxGBS4ViIjgSAQMBAQEBAQECARMBAQEKCwkIGw4?=
 =?us-ascii?q?jDII2BQIDGgEGglwDAwECFwEIBB8KKQMDAQIGAQEcCAIiBAICAwFFDhkFGYMEA?=
 =?us-ascii?q?YIBAQSoOHwzhUCEboELiXKBQheBQD+BEAGCXYUQCgYCgxyCNSICiSUaBgSBcwO?=
 =?us-ascii?q?EGYFPkA0JhxCDRIcCDBiBXk2HTDeHK5oCgV2BdzMaCBsVO4JsCQqCEQMXhhSIC?=
 =?us-ascii?q?kAxgQccinhVgXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0DSAgCfaRpchxHrdtBkHgEGBwaBZYExgTmBKYN9iHiLHYM?=
 =?us-ascii?q?JjUmLDxEYAxGBS4ViIjgSAQMBAQEBAQECARMBAQEKCwkIGw4jDII2BQIDGgEGg?=
 =?us-ascii?q?lwDAwECFwEIBB8KKQMDAQIGAQEcCAIiBAICAwFFDhkFGYMEAYIBAQSoOHwzhUC?=
 =?us-ascii?q?EboELiXKBQheBQD+BEAGCXYUQCgYCgxyCNSICiSUaBgSBcwOEGYFPkA0JhxCDR?=
 =?us-ascii?q?IcCDBiBXk2HTDeHK5oCgV2BdzMaCBsVO4JsCQqCEQMXhhSICkAxgQccinhVgXc?=
 =?us-ascii?q?BAQ?=
X-IronPort-AV: E=Sophos;i="5.56,373,1539673200"; 
   d="scan'208";a="58147743"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 19 Dec 2018 07:55:52 -0800
Received: from localhost ([::1]:60950 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gZeCO-0001xV-7D
	for like.xu@linux.intel.com; Wed, 19 Dec 2018 10:55:52 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:56315)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <pbonzini@redhat.com>) id 1gZden-00079x-It
	for qemu-devel@nongnu.org; Wed, 19 Dec 2018 10:21:17 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <pbonzini@redhat.com>) id 1gZdef-00054P-Cw
	for qemu-devel@nongnu.org; Wed, 19 Dec 2018 10:21:09 -0500
Received: from mx1.redhat.com ([209.132.183.28]:4696)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <pbonzini@redhat.com>) id 1gZded-00052c-AJ
	for qemu-devel@nongnu.org; Wed, 19 Dec 2018 10:21:01 -0500
Received: from smtp.corp.redhat.com (int-mx06.intmail.prod.int.phx2.redhat.com
	[10.5.11.16])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id 59BFAC0AE08F;
	Wed, 19 Dec 2018 15:20:57 +0000 (UTC)
Received: from donizetti.redhat.com (ovpn-112-76.ams2.redhat.com
	[10.36.112.76])
	by smtp.corp.redhat.com (Postfix) with ESMTP id 8A1B817197;
	Wed, 19 Dec 2018 15:20:53 +0000 (UTC)
From: Paolo Bonzini <pbonzini@redhat.com>
To: qemu-devel@nongnu.org
Date: Wed, 19 Dec 2018 16:19:17 +0100
Message-Id: <20181219151917.3874-36-pbonzini@redhat.com>
In-Reply-To: <20181219151917.3874-1-pbonzini@redhat.com>
References: <20181219151917.3874-1-pbonzini@redhat.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.16
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.31]);
	Wed, 19 Dec 2018 15:20:57 +0000 (UTC)
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 209.132.183.28
Subject: [Qemu-devel] [PULL 35/35] avoid TABs in files that only contain a
 few
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Aleksandar Markovic <amarkovic@wavecomp.com>,
	"Michael S . Tsirkin" <mst@redhat.com>,
	Stefan Markovic <smarkovic@wavecomp.com>,
	=?UTF-8?q?Alex=20Benn=C3=A9e?= <alex.bennee@linaro.org>,
	Richard Henderson <richard.henderson@linaro.org>,
	Wainer dos Santos Moschetta <wainersm@redhat.com>,
	Stefan Hajnoczi <stefanha@redhat.com>,
	David Gibson <david@gibson.dropbear.id.au>
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

Most files that have TABs only contain a handful of them.  Change
them to spaces so that we don't confuse people.

disas, standard-headers, linux-headers and libdecnumber are imported
from other projects and probably should be exempted from the check.
Outside those, after this patch the following files still contain both
8-space and TAB sequences at the beginning of the line.  Many of them
have a majority of TABs, or were initially committed with all tabs.

    bsd-user/i386/target_syscall.h
    bsd-user/x86_64/target_syscall.h
    crypto/aes.c
    hw/audio/fmopl.c
    hw/audio/fmopl.h
    hw/block/tc58128.c
    hw/display/cirrus_vga.c
    hw/display/xenfb.c
    hw/dma/etraxfs_dma.c
    hw/intc/sh_intc.c
    hw/misc/mst_fpga.c
    hw/net/pcnet.c
    hw/sh4/sh7750.c
    hw/timer/m48t59.c
    hw/timer/sh_timer.c
    include/crypto/aes.h
    include/disas/bfd.h
    include/hw/sh4/sh.h
    libdecnumber/decNumber.c
    linux-headers/asm-generic/unistd.h
    linux-headers/linux/kvm.h
    linux-user/alpha/target_syscall.h
    linux-user/arm/nwfpe/double_cpdo.c
    linux-user/arm/nwfpe/fpa11_cpdt.c
    linux-user/arm/nwfpe/fpa11_cprt.c
    linux-user/arm/nwfpe/fpa11.h
    linux-user/flat.h
    linux-user/flatload.c
    linux-user/i386/target_syscall.h
    linux-user/ppc/target_syscall.h
    linux-user/sparc/target_syscall.h
    linux-user/syscall.c
    linux-user/syscall_defs.h
    linux-user/x86_64/target_syscall.h
    slirp/cksum.c
    slirp/if.c
    slirp/ip.h
    slirp/ip_icmp.c
    slirp/ip_icmp.h
    slirp/ip_input.c
    slirp/ip_output.c
    slirp/mbuf.c
    slirp/misc.c
    slirp/sbuf.c
    slirp/socket.c
    slirp/socket.h
    slirp/tcp_input.c
    slirp/tcpip.h
    slirp/tcp_output.c
    slirp/tcp_subr.c
    slirp/tcp_timer.c
    slirp/tftp.c
    slirp/udp.c
    slirp/udp.h
    target/cris/cpu.h
    target/cris/mmu.c
    target/cris/op_helper.c
    target/sh4/helper.c
    target/sh4/op_helper.c
    target/sh4/translate.c
    tcg/sparc/tcg-target.inc.c
    tests/tcg/cris/check_addo.c
    tests/tcg/cris/check_moveq.c
    tests/tcg/cris/check_swap.c
    tests/tcg/multiarch/test-mmap.c
    ui/vnc-enc-hextile-template.h
    ui/vnc-enc-zywrle.h
    util/envlist.c
    util/readline.c

The following have only TABs:

    bsd-user/i386/target_signal.h
    bsd-user/sparc64/target_signal.h
    bsd-user/sparc64/target_syscall.h
    bsd-user/sparc/target_signal.h
    bsd-user/sparc/target_syscall.h
    bsd-user/x86_64/target_signal.h
    crypto/desrfb.c
    hw/audio/intel-hda-defs.h
    hw/core/uboot_image.h
    hw/sh4/sh7750_regnames.c
    hw/sh4/sh7750_regs.h
    include/hw/cris/etraxfs_dma.h
    linux-user/alpha/termbits.h
    linux-user/arm/nwfpe/fpopcode.h
    linux-user/arm/nwfpe/fpsr.h
    linux-user/arm/syscall_nr.h
    linux-user/arm/target_signal.h
    linux-user/cris/target_signal.h
    linux-user/i386/target_signal.h
    linux-user/linux_loop.h
    linux-user/m68k/target_signal.h
    linux-user/microblaze/target_signal.h
    linux-user/mips64/target_signal.h
    linux-user/mips/target_signal.h
    linux-user/mips/target_syscall.h
    linux-user/mips/termbits.h
    linux-user/ppc/target_signal.h
    linux-user/sh4/target_signal.h
    linux-user/sh4/termbits.h
    linux-user/sparc64/target_syscall.h
    linux-user/sparc/target_signal.h
    linux-user/x86_64/target_signal.h
    linux-user/x86_64/termbits.h
    pc-bios/optionrom/optionrom.h
    slirp/mbuf.h
    slirp/misc.h
    slirp/sbuf.h
    slirp/tcp.h
    slirp/tcp_timer.h
    slirp/tcp_var.h
    target/i386/svm.h
    target/sparc/asi.h
    target/xtensa/core-dc232b/xtensa-modules.inc.c
    target/xtensa/core-dc233c/xtensa-modules.inc.c
    target/xtensa/core-de212/core-isa.h
    target/xtensa/core-de212/xtensa-modules.inc.c
    target/xtensa/core-fsf/xtensa-modules.inc.c
    target/xtensa/core-sample_controller/core-isa.h
    target/xtensa/core-sample_controller/xtensa-modules.inc.c
    target/xtensa/core-test_kc705_be/core-isa.h
    target/xtensa/core-test_kc705_be/xtensa-modules.inc.c
    tests/tcg/cris/check_abs.c
    tests/tcg/cris/check_addc.c
    tests/tcg/cris/check_addcm.c
    tests/tcg/cris/check_addoq.c
    tests/tcg/cris/check_bound.c
    tests/tcg/cris/check_ftag.c
    tests/tcg/cris/check_int64.c
    tests/tcg/cris/check_lz.c
    tests/tcg/cris/check_openpf5.c
    tests/tcg/cris/check_sigalrm.c
    tests/tcg/cris/crisutils.h
    tests/tcg/cris/sys.c
    tests/tcg/i386/test-i386-ssse3.c
    ui/vgafont.h

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20181213223737.11793-3-pbonzini@redhat.com>
Reviewed-by: Aleksandar Markovic <amarkovic@wavecomp.com>
Reviewed-by: Stefan Hajnoczi <stefanha@redhat.com>
Reviewed-by: Wainer dos Santos Moschetta <wainersm@redhat.com>
Acked-by: Richard Henderson <richard.henderson@linaro.org>
Acked-by: Eric Blake <eblake@redhat.com>
Acked-by: David Gibson <david@gibson.dropbear.id.au>
Reviewed-by: Stefan Markovic <smarkovic@wavecomp.com>
Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
Reviewed-by: Alex Benn=C3=A9e <alex.bennee@linaro.org>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
---
 block/bochs.c                              | 22 ++---
 block/file-posix.c                         |  2 +-
 block/file-win32.c                         |  8 +-
 block/linux-aio.c                          |  4 +-
 block/qcow2-cluster.c                      |  2 +-
 block/vpc.c                                |  2 +-
 bsd-user/elfload.c                         |  2 +-
 contrib/elf2dmp/main.c                     |  2 +-
 hw/alpha/typhoon.c                         | 12 +--
 hw/arm/stellaris.c                         |  2 +-
 hw/char/sh_serial.c                        | 18 ++---
 hw/char/virtio-serial-bus.c                |  2 +-
 hw/char/xen_console.c                      | 58 ++++++-------
 hw/core/loader.c                           | 28 +++----
 hw/display/tc6393xb.c                      |  6 +-
 hw/display/vga.c                           |  8 +-
 hw/display/virtio-gpu-3d.c                 |  6 +-
 hw/dma/pxa2xx_dma.c                        |  4 +-
 hw/dma/soc_dma.c                           |  2 +-
 hw/gpio/max7310.c                          |  2 +-
 hw/i386/xen/xen-hvm.c                      |  4 +-
 hw/ide/core.c                              | 94 +++++++++++-----------
 hw/input/lm832x.c                          |  2 +-
 hw/input/pckbd.c                           |  2 +-
 hw/input/tsc210x.c                         |  2 +-
 hw/intc/apic.c                             |  2 +-
 hw/mips/gt64xxx_pci.c                      |  6 +-
 hw/mips/mips_r4k.c                         |  4 +-
 hw/misc/max111x.c                          |  6 +-
 hw/misc/omap_l4.c                          |  4 +-
 hw/net/mipsnet.c                           | 16 ++--
 hw/net/ne2000.c                            | 44 +++++-----
 hw/net/rocker/rocker.c                     |  2 +-
 hw/net/virtio-net.c                        |  4 +-
 hw/net/vmxnet3.c                           |  6 +-
 hw/pci/msix.c                              |  2 +-
 hw/pci/pci.c                               | 44 +++++-----
 hw/pci/pci_bridge.c                        |  2 +-
 hw/ppc/ppc405_uc.c                         |  2 +-
 hw/ppc/prep.c                              |  4 +-
 hw/scsi/lsi53c895a.c                       |  6 +-
 hw/sh4/r2d.c                               | 16 ++--
 hw/usb/dev-bluetooth.c                     |  2 +-
 hw/usb/dev-hid.c                           |  6 +-
 hw/usb/dev-hub.c                           | 14 ++--
 hw/xen/xen_devconfig.c                     |  2 +-
 hw/xenpv/xen_domainbuild.c                 |  8 +-
 include/elf.h                              | 10 +--
 include/hw/acpi/acpi.h                     | 14 ++--
 include/hw/elf_ops.h                       |  2 +-
 include/hw/ide/internal.h                  |  2 +-
 include/hw/sh4/sh_intc.h                   | 20 ++---
 include/hw/xen/io/ring.h                   |  4 +-
 include/qemu/acl.h                         | 14 ++--
 include/qemu/iov.h                         |  2 +-
 include/scsi/constants.h                   |  2 +-
 include/sysemu/balloon.h                   |  2 +-
 linux-user/linuxload.c                     | 14 ++--
 linux-user/main.c                          |  4 +-
 linux-user/mmap.c                          | 10 +--
 linux-user/qemu.h                          |  4 +-
 linux-user/signal.c                        | 16 ++--
 linux-user/strace.c                        |  4 +-
 linux-user/uaccess.c                       |  2 +-
 linux-user/vm86.c                          |  2 +-
 nbd/client.c                               |  2 +-
 net/checksum.c                             |  2 +-
 qtest.c                                    |  4 +-
 target/alpha/translate.c                   |  2 +-
 target/cris/helper.c                       |  2 +-
 target/cris/mmu.h                          | 10 +--
 target/cris/translate_v10.inc.c            |  2 +-
 target/i386/translate.c                    | 12 +--
 target/mips/translate.c                    |  2 +-
 target/tilegx/translate.c                  |  2 +-
 tcg/i386/tcg-target.inc.c                  |  4 +-
 tests/tcg/alpha/test-cond.c                |  4 +-
 tests/tcg/arm/hello-arm.c                  | 20 ++---
 tests/tcg/cris/check_glibc_kernelversion.c |  8 +-
 tests/tcg/cris/check_mmap3.c               |  2 +-
 tests/tcg/cris/check_openpf1.c             |  2 +-
 tests/tcg/cris/check_settls1.c             |  2 +-
 tests/tcg/i386/hello-i386.c                | 14 ++--
 tests/tcg/mips/hello-mips.c                | 10 +--
 tests/tcg/multiarch/sha1.c                 | 12 +--
 tests/vhost-user-test.c                    |  4 +-
 ui/keymaps.h                               |  4 +-
 ui/qemu-pixman.c                           |  2 +-
 ui/vnc-enc-zywrle-template.c               |  4 +-
 ui/vnc.c                                   |  4 +-
 util/bitops.c                              |  4 +-
 util/osdep.c                               |  4 +-
 util/qemu-sockets.c                        |  4 +-
 93 files changed, 387 insertions(+), 387 deletions(-)

diff --git a/block/bochs.c b/block/bochs.c
index 22e7d44211..79f95d3b50 100644
--- a/block/bochs.c
+++ b/block/bochs.c
@@ -85,14 +85,14 @@ static int bochs_probe(const uint8_t *buf, int buf_si=
ze, const char *filename)
     const struct bochs_header *bochs =3D (const void *)buf;
=20
     if (buf_size < HEADER_SIZE)
-	return 0;
+        return 0;
=20
     if (!strcmp(bochs->magic, HEADER_MAGIC) &&
-	!strcmp(bochs->type, REDOLOG_TYPE) &&
-	!strcmp(bochs->subtype, GROWING_TYPE) &&
-	((le32_to_cpu(bochs->version) =3D=3D HEADER_VERSION) ||
-	(le32_to_cpu(bochs->version) =3D=3D HEADER_V1)))
-	return 100;
+        !strcmp(bochs->type, REDOLOG_TYPE) &&
+        !strcmp(bochs->subtype, GROWING_TYPE) &&
+        ((le32_to_cpu(bochs->version) =3D=3D HEADER_VERSION) ||
+        (le32_to_cpu(bochs->version) =3D=3D HEADER_V1)))
+        return 100;
=20
     return 0;
 }
@@ -125,8 +125,8 @@ static int bochs_open(BlockDriverState *bs, QDict *op=
tions, int flags,
     if (strcmp(bochs.magic, HEADER_MAGIC) ||
         strcmp(bochs.type, REDOLOG_TYPE) ||
         strcmp(bochs.subtype, GROWING_TYPE) ||
-	((le32_to_cpu(bochs.version) !=3D HEADER_VERSION) &&
-	(le32_to_cpu(bochs.version) !=3D HEADER_V1))) {
+        ((le32_to_cpu(bochs.version) !=3D HEADER_VERSION) &&
+        (le32_to_cpu(bochs.version) !=3D HEADER_V1))) {
         error_setg(errp, "Image not in Bochs format");
         return -EINVAL;
     }
@@ -158,7 +158,7 @@ static int bochs_open(BlockDriverState *bs, QDict *op=
tions, int flags,
     }
=20
     for (i =3D 0; i < s->catalog_size; i++)
-	le32_to_cpus(&s->catalog_bitmap[i]);
+        le32_to_cpus(&s->catalog_bitmap[i]);
=20
     s->data_offset =3D le32_to_cpu(bochs.header) + (s->catalog_size * 4)=
;
=20
@@ -217,7 +217,7 @@ static int64_t seek_to_sector(BlockDriverState *bs, i=
nt64_t sector_num)
     extent_offset =3D (offset % s->extent_size) / 512;
=20
     if (s->catalog_bitmap[extent_index] =3D=3D 0xffffffff) {
-	return 0; /* not allocated */
+        return 0; /* not allocated */
     }
=20
     bitmap_offset =3D s->data_offset +
@@ -232,7 +232,7 @@ static int64_t seek_to_sector(BlockDriverState *bs, i=
nt64_t sector_num)
     }
=20
     if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {
-	return 0; /* not allocated */
+        return 0; /* not allocated */
     }
=20
     return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));
diff --git a/block/file-posix.c b/block/file-posix.c
index d8f0b93752..8aee7a3fb8 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -2083,7 +2083,7 @@ again:
 #endif
     if (!fstat(fd, &sb) && (S_IFCHR & sb.st_mode)) {
 #ifdef DIOCGMEDIASIZE
-	if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
+        if (ioctl(fd, DIOCGMEDIASIZE, (off_t *)&size))
 #elif defined(DIOCGPART)
         {
                 struct partinfo pi;
diff --git a/block/file-win32.c b/block/file-win32.c
index f1e2187f3b..6b2d67b239 100644
--- a/block/file-win32.c
+++ b/block/file-win32.c
@@ -176,7 +176,7 @@ int qemu_ftruncate64(int fd, int64_t length)
     BOOL res;
=20
     if ((GetVersion() & 0x80000000UL) && (length >> 32) !=3D 0)
-	return -1;
+        return -1;
=20
     h =3D (HANDLE)_get_osfhandle(fd);
=20
@@ -184,13 +184,13 @@ int qemu_ftruncate64(int fd, int64_t length)
     li.HighPart =3D 0;
     li.LowPart =3D SetFilePointer (h, 0, &li.HighPart, FILE_CURRENT);
     if (li.LowPart =3D=3D INVALID_SET_FILE_POINTER && GetLastError() !=3D=
 NO_ERROR) {
-	return -1;
+        return -1;
     }
=20
     high =3D length >> 32;
     dw =3D SetFilePointer(h, (DWORD) length, &high, FILE_BEGIN);
     if (dw =3D=3D INVALID_SET_FILE_POINTER && GetLastError() !=3D NO_ERR=
OR) {
-	return -1;
+        return -1;
     }
     res =3D SetEndOfFile(h);
=20
@@ -203,7 +203,7 @@ static int set_sparse(int fd)
 {
     DWORD returned;
     return (int) DeviceIoControl((HANDLE)_get_osfhandle(fd), FSCTL_SET_S=
PARSE,
-				 NULL, 0, NULL, 0, &returned, NULL);
+                                 NULL, 0, NULL, 0, &returned, NULL);
 }
=20
 static void raw_detach_aio_context(BlockDriverState *bs)
diff --git a/block/linux-aio.c b/block/linux-aio.c
index 217ce60138..d4b61fb251 100644
--- a/block/linux-aio.c
+++ b/block/linux-aio.c
@@ -384,10 +384,10 @@ static int laio_do_submit(int fd, struct qemu_laioc=
b *laiocb, off_t offset,
     switch (type) {
     case QEMU_AIO_WRITE:
         io_prep_pwritev(iocbs, fd, qiov->iov, qiov->niov, offset);
-	break;
+        break;
     case QEMU_AIO_READ:
         io_prep_preadv(iocbs, fd, qiov->iov, qiov->niov, offset);
-	break;
+        break;
     /* Currently Linux kernel does not support other operations */
     default:
         fprintf(stderr, "%s: invalid AIO request type 0x%x.\n",
diff --git a/block/qcow2-cluster.c b/block/qcow2-cluster.c
index e2737429f5..30eca26c47 100644
--- a/block/qcow2-cluster.c
+++ b/block/qcow2-cluster.c
@@ -402,7 +402,7 @@ static int count_contiguous_clusters(int nb_clusters,=
 int cluster_size,
         }
     }
=20
-	return i;
+        return i;
 }
=20
 /*
diff --git a/block/vpc.c b/block/vpc.c
index 80c5b2b197..d886465b7e 100644
--- a/block/vpc.c
+++ b/block/vpc.c
@@ -187,7 +187,7 @@ static uint32_t vpc_checksum(uint8_t* buf, size_t siz=
e)
 static int vpc_probe(const uint8_t *buf, int buf_size, const char *filen=
ame)
 {
     if (buf_size >=3D 8 && !strncmp((char *)buf, "conectix", 8))
-	return 100;
+        return 100;
     return 0;
 }
=20
diff --git a/bsd-user/elfload.c b/bsd-user/elfload.c
index 7cccf3eb8b..32378af7b2 100644
--- a/bsd-user/elfload.c
+++ b/bsd-user/elfload.c
@@ -1367,7 +1367,7 @@ int load_elf_binary(struct linux_binprm * bprm, str=
uct target_pt_regs * regs,
     if (!have_guest_base) {
         /*
          * Go through ELF program header table and find out whether
-	 * any of the segments drop below our current mmap_min_addr and
+         * any of the segments drop below our current mmap_min_addr and
          * in that case set guest_base to corresponding address.
          */
         for (i =3D 0, elf_ppnt =3D elf_phdata; i < elf_ex.e_phnum;
diff --git a/contrib/elf2dmp/main.c b/contrib/elf2dmp/main.c
index 9b93dab662..7115b0d6d0 100644
--- a/contrib/elf2dmp/main.c
+++ b/contrib/elf2dmp/main.c
@@ -296,7 +296,7 @@ static int fill_header(WinDumpHeader64 *hdr, struct p=
a_space *ps,
 static int fill_context(KDDEBUGGER_DATA64 *kdbg,
         struct va_space *vs, QEMU_Elf *qe)
 {
-	int i;
+        int i;
     for (i =3D 0; i < qe->state_nr; i++) {
         uint64_t Prcb;
         uint64_t Context;
diff --git a/hw/alpha/typhoon.c b/hw/alpha/typhoon.c
index 8004afe45b..ad79638ffa 100644
--- a/hw/alpha/typhoon.c
+++ b/hw/alpha/typhoon.c
@@ -657,8 +657,8 @@ static bool window_translate(TyphoonWindow *win, hwad=
dr addr,
         pte_addr |=3D (addr & (wsm | 0xfe000)) >> 10;
         return pte_translate(pte_addr, ret);
     } else {
-	/* Direct-mapped translation.  */
-	return make_iommu_tlbe(tba & ~wsm_ext, wsm_ext, ret);
+        /* Direct-mapped translation.  */
+        return make_iommu_tlbe(tba & ~wsm_ext, wsm_ext, ret);
     }
 }
=20
@@ -693,7 +693,7 @@ static IOMMUTLBEntry typhoon_translate_iommu(IOMMUMem=
oryRegion *iommu,
=20
         /* Check the fourth window for DAC disable.  */
         if ((pchip->win[3].wba & 0x80000000000ull) =3D=3D 0
-	    && window_translate(&pchip->win[3], addr, &ret)) {
+            && window_translate(&pchip->win[3], addr, &ret)) {
             goto success;
         }
     } else {
@@ -704,7 +704,7 @@ static IOMMUTLBEntry typhoon_translate_iommu(IOMMUMem=
oryRegion *iommu,
             if (pchip->ctl & 0x40) {
                 /* See 10.1.4.4; in particular <39:35> is ignored.  */
                 make_iommu_tlbe(0, 0x007ffffffffull, &ret);
-		goto success;
+                goto success;
             }
         }
=20
@@ -716,8 +716,8 @@ static IOMMUTLBEntry typhoon_translate_iommu(IOMMUMem=
oryRegion *iommu,
                 pte_addr  =3D pchip->win[3].tba & 0x7ffc00000ull;
                 pte_addr |=3D (addr & 0xffffe000u) >> 10;
                 if (pte_translate(pte_addr, &ret)) {
-			goto success;
-		}
+                        goto success;
+                }
             }
         }
     }
diff --git a/hw/arm/stellaris.c b/hw/arm/stellaris.c
index 6c69ce79b2..442529cc65 100644
--- a/hw/arm/stellaris.c
+++ b/hw/arm/stellaris.c
@@ -131,7 +131,7 @@ static void gptm_tick(void *opaque)
         s->state |=3D 1;
         if ((s->control & 0x20)) {
             /* Output trigger.  */
-	    qemu_irq_pulse(s->trigger);
+            qemu_irq_pulse(s->trigger);
         }
         if (s->mode[0] & 1) {
             /* One-shot.  */
diff --git a/hw/char/sh_serial.c b/hw/char/sh_serial.c
index 12831561a6..67740b7ee6 100644
--- a/hw/char/sh_serial.c
+++ b/hw/char/sh_serial.c
@@ -90,7 +90,7 @@ static void sh_serial_write(void *opaque, hwaddr offs,
=20
 #ifdef DEBUG_SERIAL
     printf("sh_serial: write offs=3D0x%02x val=3D0x%02x\n",
-	   offs, val);
+           offs, val);
 #endif
     switch(offs) {
     case 0x00: /* SMR */
@@ -98,17 +98,17 @@ static void sh_serial_write(void *opaque, hwaddr offs=
,
         return;
     case 0x04: /* BRR */
         s->brr =3D val;
-	return;
+        return;
     case 0x08: /* SCR */
         /* TODO : For SH7751, SCIF mask should be 0xfb. */
         s->scr =3D val & ((s->feat & SH_SERIAL_FEAT_SCIF) ? 0xfa : 0xff)=
;
         if (!(val & (1 << 5)))
             s->flags |=3D SH_SERIAL_FLAG_TEND;
         if ((s->feat & SH_SERIAL_FEAT_SCIF) && s->txi) {
-	    qemu_set_irq(s->txi, val & (1 << 7));
+            qemu_set_irq(s->txi, val & (1 << 7));
         }
         if (!(val & (1 << 6))) {
-	    qemu_set_irq(s->rxi, 0);
+            qemu_set_irq(s->rxi, 0);
         }
         return;
     case 0x0c: /* FTDR / TDR */
@@ -117,9 +117,9 @@ static void sh_serial_write(void *opaque, hwaddr offs=
,
             /* XXX this blocks entire thread. Rewrite to use
              * qemu_chr_fe_write and background I/O callbacks */
             qemu_chr_fe_write_all(&s->chr, &ch, 1);
-	}
-	s->dr =3D val;
-	s->flags &=3D ~SH_SERIAL_FLAG_TDE;
+        }
+        s->dr =3D val;
+        s->flags &=3D ~SH_SERIAL_FLAG_TDE;
         return;
 #if 0
     case 0x14: /* FRDR / RDR */
@@ -210,7 +210,7 @@ static uint64_t sh_serial_read(void *opaque, hwaddr o=
ffs,
         break;
     case 0x04:
         ret =3D s->brr;
-	break;
+        break;
     case 0x08:
         ret =3D s->scr;
         break;
@@ -288,7 +288,7 @@ static uint64_t sh_serial_read(void *opaque, hwaddr o=
ffs,
     }
 #ifdef DEBUG_SERIAL
     printf("sh_serial: read offs=3D0x%02x val=3D0x%x\n",
-	   offs, ret);
+           offs, ret);
 #endif
=20
     if (ret & ~((1 << 16) - 1)) {
diff --git a/hw/char/virtio-serial-bus.c b/hw/char/virtio-serial-bus.c
index 04e3ebe352..d76351d748 100644
--- a/hw/char/virtio-serial-bus.c
+++ b/hw/char/virtio-serial-bus.c
@@ -696,7 +696,7 @@ static void virtio_serial_save_device(VirtIODevice *v=
dev, QEMUFile *f)
         qemu_put_byte(f, port->guest_connected);
         qemu_put_byte(f, port->host_connected);
=20
-	elem_popped =3D 0;
+        elem_popped =3D 0;
         if (port->elem) {
             elem_popped =3D 1;
         }
diff --git a/hw/char/xen_console.c b/hw/char/xen_console.c
index 44f7236382..b1a1e66d5a 100644
--- a/hw/char/xen_console.c
+++ b/hw/char/xen_console.c
@@ -60,34 +60,34 @@ static void buffer_append(struct XenConsole *con)
=20
     size =3D prod - cons;
     if ((size =3D=3D 0) || (size > sizeof(intf->out)))
-	return;
+        return;
=20
     if ((buffer->capacity - buffer->size) < size) {
-	buffer->capacity +=3D (size + 1024);
-	buffer->data =3D g_realloc(buffer->data, buffer->capacity);
+        buffer->capacity +=3D (size + 1024);
+        buffer->data =3D g_realloc(buffer->data, buffer->capacity);
     }
=20
     while (cons !=3D prod)
-	buffer->data[buffer->size++] =3D intf->out[
-	    MASK_XENCONS_IDX(cons++, intf->out)];
+        buffer->data[buffer->size++] =3D intf->out[
+            MASK_XENCONS_IDX(cons++, intf->out)];
=20
     xen_mb();
     intf->out_cons =3D cons;
     xen_pv_send_notify(&con->xendev);
=20
     if (buffer->max_capacity &&
-	buffer->size > buffer->max_capacity) {
-	/* Discard the middle of the data. */
+        buffer->size > buffer->max_capacity) {
+        /* Discard the middle of the data. */
=20
-	size_t over =3D buffer->size - buffer->max_capacity;
-	uint8_t *maxpos =3D buffer->data + buffer->max_capacity;
+        size_t over =3D buffer->size - buffer->max_capacity;
+        uint8_t *maxpos =3D buffer->data + buffer->max_capacity;
=20
-	memmove(maxpos - over, maxpos, over);
-	buffer->data =3D g_realloc(buffer->data, buffer->max_capacity);
-	buffer->size =3D buffer->capacity =3D buffer->max_capacity;
+        memmove(maxpos - over, maxpos, over);
+        buffer->data =3D g_realloc(buffer->data, buffer->max_capacity);
+        buffer->size =3D buffer->capacity =3D buffer->max_capacity;
=20
-	if (buffer->consumed > buffer->max_capacity - over)
-	    buffer->consumed =3D buffer->max_capacity - over;
+        if (buffer->consumed > buffer->max_capacity - over)
+            buffer->consumed =3D buffer->max_capacity - over;
     }
 }
=20
@@ -95,8 +95,8 @@ static void buffer_advance(struct buffer *buffer, size_=
t len)
 {
     buffer->consumed +=3D len;
     if (buffer->consumed =3D=3D buffer->size) {
-	buffer->consumed =3D 0;
-	buffer->size =3D 0;
+        buffer->consumed =3D 0;
+        buffer->size =3D 0;
     }
 }
=20
@@ -111,7 +111,7 @@ static int ring_free_bytes(struct XenConsole *con)
=20
     space =3D prod - cons;
     if (space > sizeof(intf->in))
-	return 0; /* ring is screwed: ignore it */
+        return 0; /* ring is screwed: ignore it */
=20
     return (sizeof(intf->in) - space);
 }
@@ -132,12 +132,12 @@ static void xencons_receive(void *opaque, const uin=
t8_t *buf, int len)
     max =3D ring_free_bytes(con);
     /* The can_receive() func limits this, but check again anyway */
     if (max < len)
-	len =3D max;
+        len =3D max;
=20
     prod =3D intf->in_prod;
     for (i =3D 0; i < len; i++) {
-	intf->in[MASK_XENCONS_IDX(prod++, intf->in)] =3D
-	    buf[i];
+        intf->in[MASK_XENCONS_IDX(prod++, intf->in)] =3D
+            buf[i];
     }
     xen_wmb();
     intf->in_prod =3D prod;
@@ -228,11 +228,11 @@ static int con_initialise(struct XenDevice *xendev)
     int limit;
=20
     if (xenstore_read_int(con->console, "ring-ref", &con->ring_ref) =3D=3D=
 -1)
-	return -1;
+        return -1;
     if (xenstore_read_int(con->console, "port", &con->xendev.remote_port=
) =3D=3D -1)
-	return -1;
+        return -1;
     if (xenstore_read_int(con->console, "limit", &limit) =3D=3D 0)
-	con->buffer.max_capacity =3D limit;
+        con->buffer.max_capacity =3D limit;
=20
     if (!xendev->dev) {
         xen_pfn_t mfn =3D con->ring_ref;
@@ -244,7 +244,7 @@ static int con_initialise(struct XenDevice *xendev)
                                           PROT_READ | PROT_WRITE);
     }
     if (!con->sring)
-	return -1;
+        return -1;
=20
     xen_be_bind_evtchn(&con->xendev);
     qemu_chr_fe_set_handlers(&con->chr, xencons_can_receive,
@@ -252,10 +252,10 @@ static int con_initialise(struct XenDevice *xendev)
=20
     xen_pv_printf(xendev, 1,
                   "ring mfn %d, remote port %d, local port %d, limit %zd=
\n",
-		  con->ring_ref,
-		  con->xendev.remote_port,
-		  con->xendev.local_port,
-		  con->buffer.max_capacity);
+                  con->ring_ref,
+                  con->xendev.remote_port,
+                  con->xendev.local_port,
+                  con->buffer.max_capacity);
     return 0;
 }
=20
@@ -282,7 +282,7 @@ static void con_event(struct XenDevice *xendev)
=20
     buffer_append(con);
     if (con->buffer.size - con->buffer.consumed)
-	xencons_send(con);
+        xencons_send(con);
 }
=20
 /* -------------------------------------------------------------------- =
*/
diff --git a/hw/core/loader.c b/hw/core/loader.c
index fa41842280..b8bc5f1833 100644
--- a/hw/core/loader.c
+++ b/hw/core/loader.c
@@ -244,26 +244,26 @@ int load_aout(const char *filename, hwaddr addr, in=
t max_sz,
     case OMAGIC:
         if (e.a_text + e.a_data > max_sz)
             goto fail;
-	lseek(fd, N_TXTOFF(e), SEEK_SET);
-	size =3D read_targphys(filename, fd, addr, e.a_text + e.a_data);
-	if (size < 0)
-	    goto fail;
-	break;
+        lseek(fd, N_TXTOFF(e), SEEK_SET);
+        size =3D read_targphys(filename, fd, addr, e.a_text + e.a_data);
+        if (size < 0)
+            goto fail;
+        break;
     case NMAGIC:
         if (N_DATADDR(e, target_page_size) + e.a_data > max_sz)
             goto fail;
-	lseek(fd, N_TXTOFF(e), SEEK_SET);
-	size =3D read_targphys(filename, fd, addr, e.a_text);
-	if (size < 0)
-	    goto fail;
+        lseek(fd, N_TXTOFF(e), SEEK_SET);
+        size =3D read_targphys(filename, fd, addr, e.a_text);
+        if (size < 0)
+            goto fail;
         ret =3D read_targphys(filename, fd, addr + N_DATADDR(e, target_p=
age_size),
                             e.a_data);
-	if (ret < 0)
-	    goto fail;
-	size +=3D ret;
-	break;
+        if (ret < 0)
+            goto fail;
+        size +=3D ret;
+        break;
     default:
-	goto fail;
+        goto fail;
     }
     close(fd);
     return size;
diff --git a/hw/display/tc6393xb.c b/hw/display/tc6393xb.c
index 3360be6f84..e1b1e302f2 100644
--- a/hw/display/tc6393xb.c
+++ b/hw/display/tc6393xb.c
@@ -319,7 +319,7 @@ static void tc6393xb_scr_writeb(TC6393xbState *s, hwa=
ddr addr, uint32_t value)
         SCR_REG_B(DEBUG);
     }
     fprintf(stderr, "tc6393xb_scr: unhandled write at %08x: %02x\n",
-					(uint32_t) addr, value & 0xff);
+                                        (uint32_t) addr, value & 0xff);
 }
 #undef SCR_REG_B
 #undef SCR_REG_W
@@ -358,7 +358,7 @@ static void tc6393xb_nand_cfg_writeb(TC6393xbState *s=
, hwaddr addr, uint32_t val
             return;
     }
     fprintf(stderr, "tc6393xb_nand_cfg: unhandled write at %08x: %02x\n"=
,
-					(uint32_t) addr, value & 0xff);
+                                        (uint32_t) addr, value & 0xff);
 }
=20
 static uint32_t tc6393xb_nand_readb(TC6393xbState *s, hwaddr addr) {
@@ -421,7 +421,7 @@ static void tc6393xb_nand_writeb(TC6393xbState *s, hw=
addr addr, uint32_t value)
             return;
     }
     fprintf(stderr, "tc6393xb_nand: unhandled write at %08x: %02x\n",
-					(uint32_t) addr, value & 0xff);
+                                        (uint32_t) addr, value & 0xff);
 }
=20
 #define BITS 8
diff --git a/hw/display/vga.c b/hw/display/vga.c
index 3ba3f6853c..910a23c12e 100644
--- a/hw/display/vga.c
+++ b/hw/display/vga.c
@@ -85,10 +85,10 @@ const uint8_t gr_mask[16] =3D {
=20
 #define cbswap_32(__x) \
 ((uint32_t)( \
-		(((uint32_t)(__x) & (uint32_t)0x000000ffUL) << 24) | \
-		(((uint32_t)(__x) & (uint32_t)0x0000ff00UL) <<  8) | \
-		(((uint32_t)(__x) & (uint32_t)0x00ff0000UL) >>  8) | \
-		(((uint32_t)(__x) & (uint32_t)0xff000000UL) >> 24) ))
+                (((uint32_t)(__x) & (uint32_t)0x000000ffUL) << 24) | \
+                (((uint32_t)(__x) & (uint32_t)0x0000ff00UL) <<  8) | \
+                (((uint32_t)(__x) & (uint32_t)0x00ff0000UL) >>  8) | \
+                (((uint32_t)(__x) & (uint32_t)0xff000000UL) >> 24) ))
=20
 #ifdef HOST_WORDS_BIGENDIAN
 #define PAT(x) cbswap_32(x)
diff --git a/hw/display/virtio-gpu-3d.c b/hw/display/virtio-gpu-3d.c
index 55d76405a9..bc6e99c943 100644
--- a/hw/display/virtio-gpu-3d.c
+++ b/hw/display/virtio-gpu-3d.c
@@ -498,9 +498,9 @@ static void virgl_write_fence(void *opaque, uint32_t =
fence)
=20
     QTAILQ_FOREACH_SAFE(cmd, &g->fenceq, next, tmp) {
         /*
-	 * the guest can end up emitting fences out of order
-	 * so we should check all fenced cmds not just the first one.
-	 */
+         * the guest can end up emitting fences out of order
+         * so we should check all fenced cmds not just the first one.
+         */
         if (cmd->cmd_hdr.fence_id > fence) {
             continue;
         }
diff --git a/hw/dma/pxa2xx_dma.c b/hw/dma/pxa2xx_dma.c
index f4eb26cf17..d498de8ffe 100644
--- a/hw/dma/pxa2xx_dma.c
+++ b/hw/dma/pxa2xx_dma.c
@@ -228,7 +228,7 @@ static void pxa2xx_dma_run(PXA2xxDMAState *s)
                                         !(ch->state & DCSR_NODESCFETCH))
                             pxa2xx_dma_descriptor_fetch(s, c);
                         break;
-		    }
+                    }
                 }
=20
                 ch->cmd =3D (ch->cmd & ~DCMD_LEN) | length;
@@ -283,7 +283,7 @@ static uint64_t pxa2xx_dma_read(void *opaque, hwaddr =
offset,
=20
     case DCSR0 ... DCSR31:
         channel =3D offset >> 2;
-	if (s->chan[channel].request)
+        if (s->chan[channel].request)
             return s->chan[channel].state | DCSR_REQPEND;
         return s->chan[channel].state;
=20
diff --git a/hw/dma/soc_dma.c b/hw/dma/soc_dma.c
index 45516241c6..58502721fa 100644
--- a/hw/dma/soc_dma.c
+++ b/hw/dma/soc_dma.c
@@ -345,7 +345,7 @@ void soc_dma_port_add_mem(struct soc_dma_s *soc, uint=
8_t *phys_base,
             while (entry < dma->memmap + dma->memmap_size &&
                             entry->addr <=3D virt_base)
                 entry ++;
-	}
+        }
=20
         memmove(entry + 1, entry,
                         (uint8_t *) (dma->memmap + dma->memmap_size ++) =
-
diff --git a/hw/gpio/max7310.c b/hw/gpio/max7310.c
index a560e3afd2..1a2478b5a9 100644
--- a/hw/gpio/max7310.c
+++ b/hw/gpio/max7310.c
@@ -118,7 +118,7 @@ static int max7310_tx(I2CSlave *i2c, uint8_t data)
         break;
=20
     case 0x00:	/* Input port - ignore writes */
-	break;
+        break;
     default:
 #ifdef VERBOSE
         printf("%s: unknown register %02x\n", __func__, s->command);
diff --git a/hw/i386/xen/xen-hvm.c b/hw/i386/xen/xen-hvm.c
index 935a3676c8..bf4812cfc9 100644
--- a/hw/i386/xen/xen-hvm.c
+++ b/hw/i386/xen/xen-hvm.c
@@ -570,7 +570,7 @@ static void xen_io_del(MemoryListener *listener,
 }
=20
 static void xen_device_realize(DeviceListener *listener,
-			       DeviceState *dev)
+                               DeviceState *dev)
 {
     XenIOState *state =3D container_of(listener, XenIOState, device_list=
ener);
=20
@@ -588,7 +588,7 @@ static void xen_device_realize(DeviceListener *listen=
er,
 }
=20
 static void xen_device_unrealize(DeviceListener *listener,
-				 DeviceState *dev)
+                                 DeviceState *dev)
 {
     XenIOState *state =3D container_of(listener, XenIOState, device_list=
ener);
=20
diff --git a/hw/ide/core.c b/hw/ide/core.c
index 04e22e751d..c3d779db6e 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -575,16 +575,16 @@ int64_t ide_get_sector(IDEState *s)
     int64_t sector_num;
     if (s->select & 0x40) {
         /* lba */
-	if (!s->lba48) {
-	    sector_num =3D ((s->select & 0x0f) << 24) | (s->hcyl << 16) |
-		(s->lcyl << 8) | s->sector;
-	} else {
-	    sector_num =3D ((int64_t)s->hob_hcyl << 40) |
-		((int64_t) s->hob_lcyl << 32) |
-		((int64_t) s->hob_sector << 24) |
-		((int64_t) s->hcyl << 16) |
-		((int64_t) s->lcyl << 8) | s->sector;
-	}
+        if (!s->lba48) {
+            sector_num =3D ((s->select & 0x0f) << 24) | (s->hcyl << 16) =
|
+                (s->lcyl << 8) | s->sector;
+        } else {
+            sector_num =3D ((int64_t)s->hob_hcyl << 40) |
+                ((int64_t) s->hob_lcyl << 32) |
+                ((int64_t) s->hob_sector << 24) |
+                ((int64_t) s->hcyl << 16) |
+                ((int64_t) s->lcyl << 8) | s->sector;
+        }
     } else {
         sector_num =3D ((s->hcyl << 8) | s->lcyl) * s->heads * s->sector=
s +
             (s->select & 0x0f) * s->sectors + (s->sector - 1);
@@ -596,19 +596,19 @@ void ide_set_sector(IDEState *s, int64_t sector_num=
)
 {
     unsigned int cyl, r;
     if (s->select & 0x40) {
-	if (!s->lba48) {
+        if (!s->lba48) {
             s->select =3D (s->select & 0xf0) | (sector_num >> 24);
             s->hcyl =3D (sector_num >> 16);
             s->lcyl =3D (sector_num >> 8);
             s->sector =3D (sector_num);
-	} else {
-	    s->sector =3D sector_num;
-	    s->lcyl =3D sector_num >> 8;
-	    s->hcyl =3D sector_num >> 16;
-	    s->hob_sector =3D sector_num >> 24;
-	    s->hob_lcyl =3D sector_num >> 32;
-	    s->hob_hcyl =3D sector_num >> 40;
-	}
+        } else {
+            s->sector =3D sector_num;
+            s->lcyl =3D sector_num >> 8;
+            s->hcyl =3D sector_num >> 16;
+            s->hob_sector =3D sector_num >> 24;
+            s->hob_lcyl =3D sector_num >> 32;
+            s->hob_hcyl =3D sector_num >> 40;
+        }
     } else {
         cyl =3D sector_num / (s->heads * s->sectors);
         r =3D sector_num % (s->heads * s->sectors);
@@ -1188,17 +1188,17 @@ static void ide_cmd_lba48_transform(IDEState *s, =
int lba48)
      * full sector count in ->nsector and ignore ->hob_nsector from now
      */
     if (!s->lba48) {
-	if (!s->nsector)
-	    s->nsector =3D 256;
+        if (!s->nsector)
+            s->nsector =3D 256;
     } else {
-	if (!s->nsector && !s->hob_nsector)
-	    s->nsector =3D 65536;
-	else {
-	    int lo =3D s->nsector;
-	    int hi =3D s->hob_nsector;
+        if (!s->nsector && !s->hob_nsector)
+            s->nsector =3D 65536;
+        else {
+            int lo =3D s->nsector;
+            int hi =3D s->hob_nsector;
=20
-	    s->nsector =3D (hi << 8) | lo;
-	}
+            s->nsector =3D (hi << 8) | lo;
+        }
     }
 }
=20
@@ -1258,35 +1258,35 @@ void ide_ioport_write(void *opaque, uint32_t addr=
, uint32_t val)
         bus->ifs[1].feature =3D val;
         break;
     case ATA_IOPORT_WR_SECTOR_COUNT:
-	ide_clear_hob(bus);
-	bus->ifs[0].hob_nsector =3D bus->ifs[0].nsector;
-	bus->ifs[1].hob_nsector =3D bus->ifs[1].nsector;
+        ide_clear_hob(bus);
+        bus->ifs[0].hob_nsector =3D bus->ifs[0].nsector;
+        bus->ifs[1].hob_nsector =3D bus->ifs[1].nsector;
         bus->ifs[0].nsector =3D val;
         bus->ifs[1].nsector =3D val;
         break;
     case ATA_IOPORT_WR_SECTOR_NUMBER:
-	ide_clear_hob(bus);
-	bus->ifs[0].hob_sector =3D bus->ifs[0].sector;
-	bus->ifs[1].hob_sector =3D bus->ifs[1].sector;
+        ide_clear_hob(bus);
+        bus->ifs[0].hob_sector =3D bus->ifs[0].sector;
+        bus->ifs[1].hob_sector =3D bus->ifs[1].sector;
         bus->ifs[0].sector =3D val;
         bus->ifs[1].sector =3D val;
         break;
     case ATA_IOPORT_WR_CYLINDER_LOW:
-	ide_clear_hob(bus);
-	bus->ifs[0].hob_lcyl =3D bus->ifs[0].lcyl;
-	bus->ifs[1].hob_lcyl =3D bus->ifs[1].lcyl;
+        ide_clear_hob(bus);
+        bus->ifs[0].hob_lcyl =3D bus->ifs[0].lcyl;
+        bus->ifs[1].hob_lcyl =3D bus->ifs[1].lcyl;
         bus->ifs[0].lcyl =3D val;
         bus->ifs[1].lcyl =3D val;
         break;
     case ATA_IOPORT_WR_CYLINDER_HIGH:
-	ide_clear_hob(bus);
-	bus->ifs[0].hob_hcyl =3D bus->ifs[0].hcyl;
-	bus->ifs[1].hob_hcyl =3D bus->ifs[1].hcyl;
+        ide_clear_hob(bus);
+        bus->ifs[0].hob_hcyl =3D bus->ifs[0].hcyl;
+        bus->ifs[1].hob_hcyl =3D bus->ifs[1].hcyl;
         bus->ifs[0].hcyl =3D val;
         bus->ifs[1].hcyl =3D val;
         break;
     case ATA_IOPORT_WR_DEVICE_HEAD:
-	/* FIXME: HOB readback uses bit 7 */
+        /* FIXME: HOB readback uses bit 7 */
         bus->ifs[0].select =3D (val & ~0x10) | 0xa0;
         bus->ifs[1].select =3D (val | 0x10) | 0xa0;
         /* select drive */
@@ -2146,7 +2146,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t add=
r)
         } else if (!hob) {
             ret =3D s->error;
         } else {
-	    ret =3D s->hob_feature;
+            ret =3D s->hob_feature;
         }
         break;
     case ATA_IOPORT_RR_SECTOR_COUNT:
@@ -2155,7 +2155,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t add=
r)
         } else if (!hob) {
             ret =3D s->nsector & 0xff;
         } else {
-	    ret =3D s->hob_nsector;
+            ret =3D s->hob_nsector;
         }
         break;
     case ATA_IOPORT_RR_SECTOR_NUMBER:
@@ -2164,7 +2164,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t add=
r)
         } else if (!hob) {
             ret =3D s->sector;
         } else {
-	    ret =3D s->hob_sector;
+            ret =3D s->hob_sector;
         }
         break;
     case ATA_IOPORT_RR_CYLINDER_LOW:
@@ -2173,7 +2173,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t add=
r)
         } else if (!hob) {
             ret =3D s->lcyl;
         } else {
-	    ret =3D s->hob_lcyl;
+            ret =3D s->hob_lcyl;
         }
         break;
     case ATA_IOPORT_RR_CYLINDER_HIGH:
@@ -2182,7 +2182,7 @@ uint32_t ide_ioport_read(void *opaque, uint32_t add=
r)
         } else if (!hob) {
             ret =3D s->hcyl;
         } else {
-	    ret =3D s->hob_hcyl;
+            ret =3D s->hob_hcyl;
         }
         break;
     case ATA_IOPORT_RR_DEVICE_HEAD:
@@ -2847,7 +2847,7 @@ static const VMStateDescription vmstate_ide_drive_p=
io_state =3D {
     .fields =3D (VMStateField[]) {
         VMSTATE_INT32(req_nb_sectors, IDEState),
         VMSTATE_VARRAY_INT32(io_buffer, IDEState, io_buffer_total_len, 1=
,
-			     vmstate_info_uint8, uint8_t),
+                             vmstate_info_uint8, uint8_t),
         VMSTATE_INT32(cur_io_buffer_offset, IDEState),
         VMSTATE_INT32(cur_io_buffer_len, IDEState),
         VMSTATE_UINT8(end_transfer_fn_idx, IDEState),
diff --git a/hw/input/lm832x.c b/hw/input/lm832x.c
index 74da30d9ca..cffbf586d4 100644
--- a/hw/input/lm832x.c
+++ b/hw/input/lm832x.c
@@ -66,7 +66,7 @@ typedef struct {
=20
     struct {
         uint16_t file[256];
-	uint8_t faddr;
+        uint8_t faddr;
         uint8_t addr[3];
         QEMUTimer *tm[3];
     } pwm;
diff --git a/hw/input/pckbd.c b/hw/input/pckbd.c
index 07c8801387..3e66713b47 100644
--- a/hw/input/pckbd.c
+++ b/hw/input/pckbd.c
@@ -55,7 +55,7 @@
 #define KBD_CCMD_WRITE_OUTPORT	0xD1    /* write output port */
 #define KBD_CCMD_WRITE_OBUF	0xD2
 #define KBD_CCMD_WRITE_AUX_OBUF	0xD3    /* Write to output buffer as if
-					   initiated by the auxiliary device */
+                                           initiated by the auxiliary de=
vice */
 #define KBD_CCMD_WRITE_MOUSE	0xD4	/* Write the following byte to the mou=
se */
 #define KBD_CCMD_DISABLE_A20    0xDD    /* HP vectra only ? */
 #define KBD_CCMD_ENABLE_A20     0xDF    /* HP vectra only ? */
diff --git a/hw/input/tsc210x.c b/hw/input/tsc210x.c
index 1cad57f644..ded0db9351 100644
--- a/hw/input/tsc210x.c
+++ b/hw/input/tsc210x.c
@@ -577,7 +577,7 @@ static void tsc2102_control_register_write(
     case 0x01:	/* Status / Keypad Control */
         if ((s->model & 0xff00) =3D=3D 0x2100)
             s->pin_func =3D value >> 14;
-	else {
+        else {
             s->kb.scan =3D (value >> 14) & 1;
             s->kb.debounce =3D (value >> 11) & 7;
             if (s->kb.intr && s->kb.scan) {
diff --git a/hw/intc/apic.c b/hw/intc/apic.c
index c9dd65b3a0..6ea619c360 100644
--- a/hw/intc/apic.c
+++ b/hw/intc/apic.c
@@ -442,7 +442,7 @@ static int apic_find_dest(uint8_t dest)
=20
     for (i =3D 0; i < MAX_APICS; i++) {
         apic =3D local_apics[i];
-	if (apic && apic->id =3D=3D dest)
+        if (apic && apic->id =3D=3D dest)
             return i;
         if (!apic)
             break;
diff --git a/hw/mips/gt64xxx_pci.c b/hw/mips/gt64xxx_pci.c
index 1cd8aac658..f707e59c7a 100644
--- a/hw/mips/gt64xxx_pci.c
+++ b/hw/mips/gt64xxx_pci.c
@@ -395,7 +395,7 @@ static void gt64120_writel (void *opaque, hwaddr addr=
,
         s->regs[GT_CPU] =3D val;
         break;
     case GT_MULTI:
-	/* Read-only register as only one GT64xxx is present on the CPU bus */
+        /* Read-only register as only one GT64xxx is present on the CPU =
bus */
         break;
=20
     /* CPU Address Decode */
@@ -457,13 +457,13 @@ static void gt64120_writel (void *opaque, hwaddr ad=
dr,
     case GT_CPUERR_DATALO:
     case GT_CPUERR_DATAHI:
     case GT_CPUERR_PARITY:
-	/* Read-only registers, do nothing */
+        /* Read-only registers, do nothing */
         break;
=20
     /* CPU Sync Barrier */
     case GT_PCI0SYNC:
     case GT_PCI1SYNC:
-	/* Read-only registers, do nothing */
+        /* Read-only registers, do nothing */
         break;
=20
     /* SDRAM and Device Address Decode */
diff --git a/hw/mips/mips_r4k.c b/hw/mips/mips_r4k.c
index 3e852e98cf..1922407394 100644
--- a/hw/mips/mips_r4k.c
+++ b/hw/mips/mips_r4k.c
@@ -239,7 +239,7 @@ void mips_r4k_init(MachineState *machine)
                                    sector_len, mips_rom / sector_len,
                                    4, 0, 0, 0, 0, be)) {
             fprintf(stderr, "qemu: Error registering flash memory.\n");
-	}
+        }
     } else if (!qtest_enabled()) {
         /* not fatal */
         warn_report("could not load MIPS bios '%s'", bios_name);
@@ -285,7 +285,7 @@ void mips_r4k_init(MachineState *machine)
     for(i =3D 0; i < MAX_IDE_BUS; i++)
         isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],
                      hd[MAX_IDE_DEVS * i],
-		     hd[MAX_IDE_DEVS * i + 1]);
+                     hd[MAX_IDE_DEVS * i + 1]);
=20
     isa_create_simple(isa_bus, TYPE_I8042);
 }
diff --git a/hw/misc/max111x.c b/hw/misc/max111x.c
index 6dbdc03677..ac6d35a81d 100644
--- a/hw/misc/max111x.c
+++ b/hw/misc/max111x.c
@@ -43,9 +43,9 @@ typedef struct {
 #define CB_START	(1 << 7)
=20
 #define CHANNEL_NUM(v, b0, b1, b2)	\
-			((((v) >> (2 + (b0))) & 4) |	\
-			 (((v) >> (3 + (b1))) & 2) |	\
-			 (((v) >> (4 + (b2))) & 1))
+                        ((((v) >> (2 + (b0))) & 4) |	\
+                         (((v) >> (3 + (b1))) & 2) |	\
+                         (((v) >> (4 + (b2))) & 1))
=20
 static uint32_t max111x_read(MAX111xState *s)
 {
diff --git a/hw/misc/omap_l4.c b/hw/misc/omap_l4.c
index 96fc057b4e..c217728c78 100644
--- a/hw/misc/omap_l4.c
+++ b/hw/misc/omap_l4.c
@@ -112,8 +112,8 @@ static const MemoryRegionOps omap_l4ta_ops =3D {
=20
 struct omap_target_agent_s *omap_l4ta_get(struct omap_l4_s *bus,
         const struct omap_l4_region_s *regions,
-	const struct omap_l4_agent_info_s *agents,
-	int cs)
+        const struct omap_l4_agent_info_s *agents,
+        int cs)
 {
     int i;
     struct omap_target_agent_s *ta =3D NULL;
diff --git a/hw/net/mipsnet.c b/hw/net/mipsnet.c
index 03b3104278..5ec13105df 100644
--- a/hw/net/mipsnet.c
+++ b/hw/net/mipsnet.c
@@ -112,27 +112,27 @@ static uint64_t mipsnet_ioport_read(void *opaque, h=
waddr addr,
     addr &=3D 0x3f;
     switch (addr) {
     case MIPSNET_DEV_ID:
-	ret =3D be32_to_cpu(0x4d495053);		/* MIPS */
+        ret =3D be32_to_cpu(0x4d495053);		/* MIPS */
         break;
     case MIPSNET_DEV_ID + 4:
-	ret =3D be32_to_cpu(0x4e455430);		/* NET0 */
+        ret =3D be32_to_cpu(0x4e455430);		/* NET0 */
         break;
     case MIPSNET_BUSY:
-	ret =3D s->busy;
+        ret =3D s->busy;
         break;
     case MIPSNET_RX_DATA_COUNT:
-	ret =3D s->rx_count;
+        ret =3D s->rx_count;
         break;
     case MIPSNET_TX_DATA_COUNT:
-	ret =3D s->tx_count;
+        ret =3D s->tx_count;
         break;
     case MIPSNET_INT_CTL:
-	ret =3D s->intctl;
+        ret =3D s->intctl;
         s->intctl &=3D ~MIPSNET_INTCTL_TESTBIT;
         break;
     case MIPSNET_INTERRUPT_INFO:
         /* XXX: This seems to be a per-VPE interrupt number. */
-	ret =3D 0;
+        ret =3D 0;
         break;
     case MIPSNET_RX_DATA_BUFFER:
         if (s->rx_count) {
@@ -161,7 +161,7 @@ static void mipsnet_ioport_write(void *opaque, hwaddr=
 addr,
     trace_mipsnet_write(addr, val);
     switch (addr) {
     case MIPSNET_TX_DATA_COUNT:
-	s->tx_count =3D (val <=3D MAX_ETH_FRAME_SIZE) ? val : 0;
+        s->tx_count =3D (val <=3D MAX_ETH_FRAME_SIZE) ? val : 0;
         s->tx_written =3D 0;
         break;
     case MIPSNET_INT_CTL:
diff --git a/hw/net/ne2000.c b/hw/net/ne2000.c
index 869518ee06..037afc8052 100644
--- a/hw/net/ne2000.c
+++ b/hw/net/ne2000.c
@@ -145,7 +145,7 @@ static void ne2000_update_irq(NE2000State *s)
     isr =3D (s->isr & s->imr) & 0x7f;
 #if defined(DEBUG_NE2000)
     printf("NE2000: Set IRQ to %d (%02x %02x)\n",
-	   isr ? 1 : 0, s->isr, s->imr);
+           isr ? 1 : 0, s->isr, s->imr);
 #endif
     qemu_set_irq(s->irq, (isr !=3D 0));
 }
@@ -396,12 +396,12 @@ static uint32_t ne2000_ioport_read(void *opaque, ui=
nt32_t addr)
         case EN0_ISR:
             ret =3D s->isr;
             break;
-	case EN0_RSARLO:
-	    ret =3D s->rsar & 0x00ff;
-	    break;
-	case EN0_RSARHI:
-	    ret =3D s->rsar >> 8;
-	    break;
+        case EN0_RSARLO:
+            ret =3D s->rsar & 0x00ff;
+            break;
+        case EN0_RSARHI:
+            ret =3D s->rsar >> 8;
+            break;
         case EN1_PHYS ... EN1_PHYS + 5:
             ret =3D s->phys[offset - EN1_PHYS];
             break;
@@ -420,21 +420,21 @@ static uint32_t ne2000_ioport_read(void *opaque, ui=
nt32_t addr)
         case EN2_STOPPG:
             ret =3D s->stop >> 8;
             break;
-	case EN0_RTL8029ID0:
-	    ret =3D 0x50;
-	    break;
-	case EN0_RTL8029ID1:
-	    ret =3D 0x43;
-	    break;
-	case EN3_CONFIG0:
-	    ret =3D 0;		/* 10baseT media */
-	    break;
-	case EN3_CONFIG2:
-	    ret =3D 0x40;		/* 10baseT active */
-	    break;
-	case EN3_CONFIG3:
-	    ret =3D 0x40;		/* Full duplex */
-	    break;
+        case EN0_RTL8029ID0:
+            ret =3D 0x50;
+            break;
+        case EN0_RTL8029ID1:
+            ret =3D 0x43;
+            break;
+        case EN3_CONFIG0:
+            ret =3D 0;		/* 10baseT media */
+            break;
+        case EN3_CONFIG2:
+            ret =3D 0x40;		/* 10baseT active */
+            break;
+        case EN3_CONFIG3:
+            ret =3D 0x40;		/* Full duplex */
+            break;
         default:
             ret =3D 0x00;
             break;
diff --git a/hw/net/rocker/rocker.c b/hw/net/rocker/rocker.c
index c02cbefece..5266f9b7dd 100644
--- a/hw/net/rocker/rocker.c
+++ b/hw/net/rocker/rocker.c
@@ -1279,7 +1279,7 @@ static World *rocker_world_type_by_name(Rocker *r, =
const char *name)
     for (i =3D 0; i < ROCKER_WORLD_TYPE_MAX; i++) {
         if (strcmp(name, world_name(r->worlds[i])) =3D=3D 0) {
             return r->worlds[i];
-	}
+        }
     }
     return NULL;
 }
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 385b1a03e9..e37fc34839 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -1375,10 +1375,10 @@ static int32_t virtio_net_flush_tx(VirtIONetQueue=
 *q)
                                    n->guest_hdr_len, -1);
                 if (out_num =3D=3D VIRTQUEUE_MAX_SIZE) {
                     goto drop;
-		}
+                }
                 out_num +=3D 1;
                 out_sg =3D sg2;
-	    }
+            }
         }
         /*
          * If host wants to see the guest header as is, we can
diff --git a/hw/net/vmxnet3.c b/hw/net/vmxnet3.c
index 3648630386..76f3ed319d 100644
--- a/hw/net/vmxnet3.c
+++ b/hw/net/vmxnet3.c
@@ -149,7 +149,7 @@ typedef struct {
 } Vmxnet3Ring;
=20
 static inline void vmxnet3_ring_init(PCIDevice *d,
-				     Vmxnet3Ring *ring,
+                                     Vmxnet3Ring *ring,
                                      hwaddr pa,
                                      uint32_t size,
                                      uint32_t cell_size,
@@ -193,13 +193,13 @@ static inline hwaddr vmxnet3_ring_curr_cell_pa(Vmxn=
et3Ring *ring)
 }
=20
 static inline void vmxnet3_ring_read_curr_cell(PCIDevice *d, Vmxnet3Ring=
 *ring,
-					       void *buff)
+                                               void *buff)
 {
     vmw_shmem_read(d, vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_=
size);
 }
=20
 static inline void vmxnet3_ring_write_curr_cell(PCIDevice *d, Vmxnet3Rin=
g *ring,
-						void *buff)
+                                                void *buff)
 {
     vmw_shmem_write(d, vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell=
_size);
 }
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index 702dac4ec7..c7bdbeda9e 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -501,7 +501,7 @@ void msix_reset(PCIDevice *dev)
     }
     msix_clear_all_vectors(dev);
     dev->config[dev->msix_cap + MSIX_CONTROL_OFFSET] &=3D
-	    ~dev->wmask[dev->msix_cap + MSIX_CONTROL_OFFSET];
+            ~dev->wmask[dev->msix_cap + MSIX_CONTROL_OFFSET];
     memset(dev->msix_table, 0, dev->msix_entries_nr * PCI_MSIX_ENTRY_SIZ=
E);
     memset(dev->msix_pba, 0, QEMU_ALIGN_UP(dev->msix_entries_nr, 64) / 8=
);
     msix_mask_all(dev, dev->msix_entries_nr);
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index efb5ce196f..3e2df9446d 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -211,13 +211,13 @@ int pci_bar(PCIDevice *d, int reg)
=20
 static inline int pci_irq_state(PCIDevice *d, int irq_num)
 {
-	return (d->irq_state >> irq_num) & 0x1;
+        return (d->irq_state >> irq_num) & 0x1;
 }
=20
 static inline void pci_set_irq_state(PCIDevice *d, int irq_num, int leve=
l)
 {
-	d->irq_state &=3D ~(0x1 << irq_num);
-	d->irq_state |=3D level << irq_num;
+        d->irq_state &=3D ~(0x1 << irq_num);
+        d->irq_state |=3D level << irq_num;
 }
=20
 static void pci_change_irq_level(PCIDevice *pci_dev, int irq_num, int ch=
ange)
@@ -571,8 +571,8 @@ const VMStateDescription vmstate_pci_device =3D {
                                    0, vmstate_info_pci_config,
                                    PCIE_CONFIG_SPACE_SIZE),
         VMSTATE_BUFFER_UNSAFE_INFO(irq_state, PCIDevice, 2,
-				   vmstate_info_pci_irq_state,
-				   PCI_NUM_PINS * sizeof(int32_t)),
+                                   vmstate_info_pci_irq_state,
+                                   PCI_NUM_PINS * sizeof(int32_t)),
         VMSTATE_END_OF_LIST()
     }
 };
@@ -624,21 +624,21 @@ static int pci_parse_devaddr(const char *addr, int =
*domp, int *busp,
     p =3D addr;
     val =3D strtoul(p, &e, 16);
     if (e =3D=3D p)
-	return -1;
+        return -1;
     if (*e =3D=3D ':') {
-	bus =3D val;
-	p =3D e + 1;
-	val =3D strtoul(p, &e, 16);
-	if (e =3D=3D p)
-	    return -1;
-	if (*e =3D=3D ':') {
-	    dom =3D bus;
-	    bus =3D val;
-	    p =3D e + 1;
-	    val =3D strtoul(p, &e, 16);
-	    if (e =3D=3D p)
-		return -1;
-	}
+        bus =3D val;
+        p =3D e + 1;
+        val =3D strtoul(p, &e, 16);
+        if (e =3D=3D p)
+            return -1;
+        if (*e =3D=3D ':') {
+            dom =3D bus;
+            bus =3D val;
+            p =3D e + 1;
+            val =3D strtoul(p, &e, 16);
+            if (e =3D=3D p)
+                return -1;
+        }
     }
=20
     slot =3D val;
@@ -657,10 +657,10 @@ static int pci_parse_devaddr(const char *addr, int =
*domp, int *busp,
=20
     /* if funcp =3D=3D NULL func is 0 */
     if (dom > 0xffff || bus > 0xff || slot > 0x1f || func > 7)
-	return -1;
+        return -1;
=20
     if (*e)
-	return -1;
+        return -1;
=20
     *domp =3D dom;
     *busp =3D bus;
@@ -1217,7 +1217,7 @@ pcibus_t pci_get_bar_addr(PCIDevice *pci_dev, int r=
egion_num)
 }
=20
 static pcibus_t pci_bar_address(PCIDevice *d,
-				int reg, uint8_t type, pcibus_t size)
+                                int reg, uint8_t type, pcibus_t size)
 {
     pcibus_t new_addr, last_addr;
     int bar =3D pci_bar(d, reg);
diff --git a/hw/pci/pci_bridge.c b/hw/pci/pci_bridge.c
index ee9dff2d3a..55d0dacd60 100644
--- a/hw/pci/pci_bridge.c
+++ b/hw/pci/pci_bridge.c
@@ -369,7 +369,7 @@ void pci_bridge_initfn(PCIDevice *dev, const char *ty=
pename)
      * let users address the bus using the device name.
      */
     if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {
-	    br->bus_name =3D dev->qdev.id;
+            br->bus_name =3D dev->qdev.id;
     }
=20
     qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(d=
ev),
diff --git a/hw/ppc/ppc405_uc.c b/hw/ppc/ppc405_uc.c
index 5c58415cf1..fbe2e7f857 100644
--- a/hw/ppc/ppc405_uc.c
+++ b/hw/ppc/ppc405_uc.c
@@ -1885,7 +1885,7 @@ CPUPPCState *ppc405ep_init(MemoryRegion *address_sp=
ace_mem,
     pic =3D ppcuic_init(env, irqs, 0x0C0, 0, 1);
     *picp =3D pic;
     /* SDRAM controller */
-	/* XXX 405EP has no ECC interrupt */
+        /* XXX 405EP has no ECC interrupt */
     ppc4xx_sdram_init(env, pic[17], 2, ram_memories,
                       ram_bases, ram_sizes, do_init);
     /* External bus controller */
diff --git a/hw/ppc/prep.c b/hw/ppc/prep.c
index 2afb7f437e..7bda86a7d0 100644
--- a/hw/ppc/prep.c
+++ b/hw/ppc/prep.c
@@ -538,7 +538,7 @@ static void ppc_prep_init(MachineState *machine)
         nb_nics1 =3D NE2000_NB_MAX;
     for(i =3D 0; i < nb_nics1; i++) {
         if (nd_table[i].model =3D=3D NULL) {
-	    nd_table[i].model =3D g_strdup("ne2k_isa");
+            nd_table[i].model =3D g_strdup("ne2k_isa");
         }
         if (strcmp(nd_table[i].model, "ne2k_isa") =3D=3D 0) {
             isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],
@@ -552,7 +552,7 @@ static void ppc_prep_init(MachineState *machine)
     for(i =3D 0; i < MAX_IDE_BUS; i++) {
         isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i],
                      hd[2 * i],
-		     hd[2 * i + 1]);
+                     hd[2 * i + 1]);
     }
=20
     cpu =3D POWERPC_CPU(first_cpu);
diff --git a/hw/scsi/lsi53c895a.c b/hw/scsi/lsi53c895a.c
index 52a38933b6..89def1421f 100644
--- a/hw/scsi/lsi53c895a.c
+++ b/hw/scsi/lsi53c895a.c
@@ -1850,7 +1850,7 @@ static void lsi_reg_writeb(LSIState *s, int offset,=
 uint8_t val)
         break;
     case 0x0a: case 0x0b:
         /* Openserver writes to these readonly registers on startup */
-	return;
+        return;
     case 0x0c: case 0x0d: case 0x0e: case 0x0f:
         /* Linux writes to these readonly registers on startup.  */
         return;
@@ -1884,8 +1884,8 @@ static void lsi_reg_writeb(LSIState *s, int offset,=
 uint8_t val)
         /* nothing to do */
         break;
     case 0x1a: /* CTEST2 */
-	s->ctest2 =3D val & LSI_CTEST2_PCICIE;
-	break;
+        s->ctest2 =3D val & LSI_CTEST2_PCICIE;
+        break;
     case 0x1b: /* CTEST3 */
         s->ctest3 =3D val & 0x0f;
         break;
diff --git a/hw/sh4/r2d.c b/hw/sh4/r2d.c
index 6a5fc46a47..5b399e7161 100644
--- a/hw/sh4/r2d.c
+++ b/hw/sh4/r2d.c
@@ -139,11 +139,11 @@ static uint64_t r2d_fpga_read(void *opaque, hwaddr =
addr, unsigned int size)
     case PA_IRLMSK:
         return s->irlmsk;
     case PA_OUTPORT:
-	return s->outport;
+        return s->outport;
     case PA_POWOFF:
-	return 0x00;
+        return 0x00;
     case PA_VERREG:
-	return 0x10;
+        return 0x10;
     }
=20
     return 0;
@@ -158,18 +158,18 @@ r2d_fpga_write(void *opaque, hwaddr addr, uint64_t =
value, unsigned int size)
     case PA_IRLMSK:
         s->irlmsk =3D value;
         update_irl(s);
-	break;
+        break;
     case PA_OUTPORT:
-	s->outport =3D value;
-	break;
+        s->outport =3D value;
+        break;
     case PA_POWOFF:
         if (value & 1) {
             qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
         }
         break;
     case PA_VERREG:
-	/* Discard writes */
-	break;
+        /* Discard writes */
+        break;
     }
 }
=20
diff --git a/hw/usb/dev-bluetooth.c b/hw/usb/dev-bluetooth.c
index eac7365b0a..c539a1afc6 100644
--- a/hw/usb/dev-bluetooth.c
+++ b/hw/usb/dev-bluetooth.c
@@ -46,7 +46,7 @@ struct USBBtState {
=20
     struct usb_hci_out_fifo_s {
         uint8_t data[4096];
-	int len;
+        int len;
     } outcmd, outacl, outsco;
 };
=20
diff --git a/hw/usb/dev-hid.c b/hw/usb/dev-hid.c
index 62d18290dc..90cd745f06 100644
--- a/hw/usb/dev-hid.c
+++ b/hw/usb/dev-hid.c
@@ -592,12 +592,12 @@ static void usb_hid_handle_control(USBDevice *dev, =
USBPacket *p,
         switch (value >> 8) {
         case 0x22:
             if (hs->kind =3D=3D HID_MOUSE) {
-		memcpy(data, qemu_mouse_hid_report_descriptor,
-		       sizeof(qemu_mouse_hid_report_descriptor));
+                memcpy(data, qemu_mouse_hid_report_descriptor,
+                       sizeof(qemu_mouse_hid_report_descriptor));
                 p->actual_length =3D sizeof(qemu_mouse_hid_report_descri=
ptor);
             } else if (hs->kind =3D=3D HID_TABLET) {
                 memcpy(data, qemu_tablet_hid_report_descriptor,
-		       sizeof(qemu_tablet_hid_report_descriptor));
+                       sizeof(qemu_tablet_hid_report_descriptor));
                 p->actual_length =3D sizeof(qemu_tablet_hid_report_descr=
iptor);
             } else if (hs->kind =3D=3D HID_KEYBOARD) {
                 memcpy(data, qemu_keyboard_hid_report_descriptor,
diff --git a/hw/usb/dev-hub.c b/hw/usb/dev-hub.c
index dc368179d1..7e9339b8a8 100644
--- a/hw/usb/dev-hub.c
+++ b/hw/usb/dev-hub.c
@@ -147,13 +147,13 @@ static const USBDesc desc_hub =3D {
=20
 static const uint8_t qemu_hub_hub_descriptor[] =3D
 {
-	0x00,			/*  u8  bLength; patched in later */
-	0x29,			/*  u8  bDescriptorType; Hub-descriptor */
-	0x00,			/*  u8  bNbrPorts; (patched later) */
-	0x0a,			/* u16  wHubCharacteristics; */
-	0x00,			/*   (per-port OC, no power switching) */
-	0x01,			/*  u8  bPwrOn2pwrGood; 2ms */
-	0x00			/*  u8  bHubContrCurrent; 0 mA */
+        0x00,			/*  u8  bLength; patched in later */
+        0x29,			/*  u8  bDescriptorType; Hub-descriptor */
+        0x00,			/*  u8  bNbrPorts; (patched later) */
+        0x0a,			/* u16  wHubCharacteristics; */
+        0x00,			/*   (per-port OC, no power switching) */
+        0x01,			/*  u8  bPwrOn2pwrGood; 2ms */
+        0x00			/*  u8  bHubContrCurrent; 0 mA */
=20
         /* DeviceRemovable and PortPwrCtrlMask patched in later */
 };
diff --git a/hw/xen/xen_devconfig.c b/hw/xen/xen_devconfig.c
index aebc19bd71..3500d88a3e 100644
--- a/hw/xen/xen_devconfig.c
+++ b/hw/xen/xen_devconfig.c
@@ -6,7 +6,7 @@
 /* ------------------------------------------------------------- */
=20
 static int xen_config_dev_dirs(const char *ftype, const char *btype, int=
 vdev,
-			       char *fe, char *be, int len)
+                               char *fe, char *be, int len)
 {
     char *dom;
=20
diff --git a/hw/xenpv/xen_domainbuild.c b/hw/xenpv/xen_domainbuild.c
index 188acaca16..2859280a6a 100644
--- a/hw/xenpv/xen_domainbuild.c
+++ b/hw/xenpv/xen_domainbuild.c
@@ -27,11 +27,11 @@ static int xenstore_domain_mkdir(char *path)
=20
     if (!xs_mkdir(xenstore, 0, path)) {
         fprintf(stderr, "%s: xs_mkdir %s: failed\n", __func__, path);
-	return -1;
+        return -1;
     }
     if (!xs_set_permissions(xenstore, 0, path, perms_ro, 2)) {
         fprintf(stderr, "%s: xs_set_permissions failed\n", __func__);
-	return -1;
+        return -1;
     }
=20
     for (i =3D 0; writable[i]; i++) {
@@ -82,8 +82,8 @@ int xenstore_domain_init1(const char *kernel, const cha=
r *ramdisk,
=20
     /* cpus */
     for (i =3D 0; i < smp_cpus; i++) {
-	snprintf(path, sizeof(path), "cpu/%d/availability",i);
-	xenstore_write_str(dom, path, "online");
+        snprintf(path, sizeof(path), "cpu/%d/availability",i);
+        xenstore_write_str(dom, path, "online");
     }
     xenstore_write_int(vm, "vcpu_avail",  smp_cpus);
     xenstore_write_int(vm, "vcpus",       smp_cpus);
diff --git a/include/elf.h b/include/elf.h
index c151164b63..2a72b282f7 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -782,11 +782,11 @@ typedef struct {
 /* ARM-specific values for sh_flags */
 #define SHF_ARM_ENTRYSECT  0x10000000   /* Section contains an entry poi=
nt */
 #define SHF_ARM_COMDEF     0x80000000   /* Section may be multiply defin=
ed
-					   in the input to a link step */
+                                           in the input to a link step *=
/
=20
 /* ARM-specific program header flags */
 #define PF_ARM_SB          0x10000000   /* Segment contains the location
-					   addressed by the static base */
+                                           addressed by the static base =
*/
=20
 /* ARM relocs.  */
 #define R_ARM_NONE		0	/* No reloc */
@@ -1047,7 +1047,7 @@ typedef struct {
 #define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
 #define R_X86_64_RELATIVE	8	/* Adjust by program base */
 #define R_X86_64_GOTPCREL	9	/* 32 bit signed pc relative
-					   offset to GOT */
+                                           offset to GOT */
 #define R_X86_64_32		10	/* Direct 32 bit zero extended */
 #define R_X86_64_32S		11	/* Direct 32 bit sign extended */
 #define R_X86_64_16		12	/* Direct 16 bit zero extended */
@@ -1070,7 +1070,7 @@ typedef struct {
 #define EF_PARISC_LSB		0x00040000 /* Program expects little endian. */
 #define EF_PARISC_WIDE		0x00080000 /* Program expects wide mode.  */
 #define EF_PARISC_NO_KABP	0x00100000 /* No kernel assisted branch
-					      prediction.  */
+                                              prediction.  */
 #define EF_PARISC_LAZYSWAP	0x00400000 /* Allow lazy swapping.  */
 #define EF_PARISC_ARCH		0x0000ffff /* Architecture version.  */
=20
@@ -1083,7 +1083,7 @@ typedef struct {
 /* Additional section indeces.  */
=20
 #define SHN_PARISC_ANSI_COMMON	0xff00	   /* Section for tenatively decla=
red
-					      symbols in ANSI C.  */
+                                              symbols in ANSI C.  */
 #define SHN_PARISC_HUGE_COMMON	0xff01	   /* Common blocks in huge model.=
  */
=20
 /* Legal values for sh_type field of Elf32_Shdr.  */
diff --git a/include/hw/acpi/acpi.h b/include/hw/acpi/acpi.h
index c20ace0d0b..bbf541263a 100644
--- a/include/hw/acpi/acpi.h
+++ b/include/hw/acpi/acpi.h
@@ -69,13 +69,13 @@
 #define ACPI_BITMASK_WAKE_STATUS                0x8000
=20
 #define ACPI_BITMASK_ALL_FIXED_STATUS           (\
-	ACPI_BITMASK_TIMER_STATUS          | \
-	ACPI_BITMASK_BUS_MASTER_STATUS     | \
-	ACPI_BITMASK_GLOBAL_LOCK_STATUS    | \
-	ACPI_BITMASK_POWER_BUTTON_STATUS   | \
-	ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
-	ACPI_BITMASK_RT_CLOCK_STATUS       | \
-	ACPI_BITMASK_WAKE_STATUS)
+        ACPI_BITMASK_TIMER_STATUS          | \
+        ACPI_BITMASK_BUS_MASTER_STATUS     | \
+        ACPI_BITMASK_GLOBAL_LOCK_STATUS    | \
+        ACPI_BITMASK_POWER_BUTTON_STATUS   | \
+        ACPI_BITMASK_SLEEP_BUTTON_STATUS   | \
+        ACPI_BITMASK_RT_CLOCK_STATUS       | \
+        ACPI_BITMASK_WAKE_STATUS)
=20
 /* PM1x_EN */
 #define ACPI_BITMASK_TIMER_ENABLE               0x0001
diff --git a/include/hw/elf_ops.h b/include/hw/elf_ops.h
index af0a058e1d..e2cb675195 100644
--- a/include/hw/elf_ops.h
+++ b/include/hw/elf_ops.h
@@ -343,7 +343,7 @@ static int glue(load_elf, SZ)(const char *name, int f=
d,
     }
=20
     if (pentry)
-	*pentry =3D (uint64_t)(elf_sword)ehdr.e_entry;
+        *pentry =3D (uint64_t)(elf_sword)ehdr.e_entry;
=20
     glue(load_symbols, SZ)(&ehdr, fd, must_swab, clear_lsb, sym_cb);
=20
diff --git a/include/hw/ide/internal.h b/include/hw/ide/internal.h
index 594081e57f..880413ddc7 100644
--- a/include/hw/ide/internal.h
+++ b/include/hw/ide/internal.h
@@ -342,7 +342,7 @@ enum ide_dma_cmd {
 extern const char *IDE_DMA_CMD_lookup[IDE_DMA__COUNT];
=20
 #define ide_cmd_is_read(s) \
-	((s)->dma_cmd =3D=3D IDE_DMA_READ)
+        ((s)->dma_cmd =3D=3D IDE_DMA_READ)
=20
 typedef struct IDEBufferedRequest {
     QLIST_ENTRY(IDEBufferedRequest) list;
diff --git a/include/hw/sh4/sh_intc.h b/include/hw/sh4/sh_intc.h
index fbcee94ed7..adfedb2efc 100644
--- a/include/hw/sh4/sh_intc.h
+++ b/include/hw/sh4/sh_intc.h
@@ -61,21 +61,21 @@ struct intc_desc {
 int sh_intc_get_pending_vector(struct intc_desc *desc, int imask);
 struct intc_source *sh_intc_source(struct intc_desc *desc, intc_enum id)=
;
 void sh_intc_toggle_source(struct intc_source *source,
-			   int enable_adj, int assert_adj);
+                           int enable_adj, int assert_adj);
=20
 void sh_intc_register_sources(struct intc_desc *desc,
-			      struct intc_vect *vectors,
-			      int nr_vectors,
-			      struct intc_group *groups,
-			      int nr_groups);
+                              struct intc_vect *vectors,
+                              int nr_vectors,
+                              struct intc_group *groups,
+                              int nr_groups);
=20
 int sh_intc_init(MemoryRegion *sysmem,
                  struct intc_desc *desc,
-		 int nr_sources,
-		 struct intc_mask_reg *mask_regs,
-		 int nr_mask_regs,
-		 struct intc_prio_reg *prio_regs,
-		 int nr_prio_regs);
+                 int nr_sources,
+                 struct intc_mask_reg *mask_regs,
+                 int nr_mask_regs,
+                 struct intc_prio_reg *prio_regs,
+                 int nr_prio_regs);
=20
 void sh_intc_set_irl(void *opaque, int n, int level);
=20
diff --git a/include/hw/xen/io/ring.h b/include/hw/xen/io/ring.h
index ffa3ebadc8..1adacf09f9 100644
--- a/include/hw/xen/io/ring.h
+++ b/include/hw/xen/io/ring.h
@@ -235,8 +235,8 @@ typedef struct __name##_back_ring __name##_back_ring_=
t
  * to be ineffective where _req is a struct which consists of only bitfi=
elds.
  */
 #define RING_COPY_REQUEST(_r, _idx, _req) do {				\
-	/* Use volatile to force the copy into _req. */			\
-	*(_req) =3D *(volatile typeof(_req))RING_GET_REQUEST(_r, _idx);	\
+        /* Use volatile to force the copy into _req. */			\
+        *(_req) =3D *(volatile typeof(_req))RING_GET_REQUEST(_r, _idx);	=
\
 } while (0)
=20
 #define RING_GET_RESPONSE(_r, _idx)                                     =
\
diff --git a/include/qemu/acl.h b/include/qemu/acl.h
index 7c44119a47..73d2a71c8d 100644
--- a/include/qemu/acl.h
+++ b/include/qemu/acl.h
@@ -49,18 +49,18 @@ qemu_acl *qemu_acl_init(const char *aclname);
 qemu_acl *qemu_acl_find(const char *aclname);
=20
 int qemu_acl_party_is_allowed(qemu_acl *acl,
-			      const char *party);
+                              const char *party);
=20
 void qemu_acl_reset(qemu_acl *acl);
=20
 int qemu_acl_append(qemu_acl *acl,
-		    int deny,
-		    const char *match);
+                    int deny,
+                    const char *match);
 int qemu_acl_insert(qemu_acl *acl,
-		    int deny,
-		    const char *match,
-		    int index);
+                    int deny,
+                    const char *match,
+                    int index);
 int qemu_acl_remove(qemu_acl *acl,
-		    const char *match);
+                    const char *match);
=20
 #endif /* QEMU_ACL_H */
diff --git a/include/qemu/iov.h b/include/qemu/iov.h
index 72d4c559b4..5f433c7768 100644
--- a/include/qemu/iov.h
+++ b/include/qemu/iov.h
@@ -35,7 +35,7 @@ size_t iov_size(const struct iovec *iov, const unsigned=
 int iov_cnt);
 size_t iov_from_buf_full(const struct iovec *iov, unsigned int iov_cnt,
                          size_t offset, const void *buf, size_t bytes);
 size_t iov_to_buf_full(const struct iovec *iov, const unsigned int iov_c=
nt,
-		       size_t offset, void *buf, size_t bytes);
+                       size_t offset, void *buf, size_t bytes);
=20
 static inline size_t
 iov_from_buf(const struct iovec *iov, unsigned int iov_cnt,
diff --git a/include/scsi/constants.h b/include/scsi/constants.h
index 083a8e887a..0dc550732d 100644
--- a/include/scsi/constants.h
+++ b/include/scsi/constants.h
@@ -212,7 +212,7 @@
 #define TYPE_ROM            0x05
 #define TYPE_SCANNER        0x06
 #define TYPE_MOD            0x07    /* Magneto-optical disk -
-				     * - treated as TYPE_DISK */
+                                     * - treated as TYPE_DISK */
 #define TYPE_MEDIUM_CHANGER 0x08
 #define TYPE_STORAGE_ARRAY  0x0c    /* Storage array device */
 #define TYPE_ENCLOSURE      0x0d    /* Enclosure Services Device */
diff --git a/include/sysemu/balloon.h b/include/sysemu/balloon.h
index 66543ae8f4..c8f6145257 100644
--- a/include/sysemu/balloon.h
+++ b/include/sysemu/balloon.h
@@ -20,7 +20,7 @@ typedef void (QEMUBalloonEvent)(void *opaque, ram_addr_=
t target);
 typedef void (QEMUBalloonStatus)(void *opaque, BalloonInfo *info);
=20
 int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
-			     QEMUBalloonStatus *stat_func, void *opaque);
+                             QEMUBalloonStatus *stat_func, void *opaque)=
;
 void qemu_remove_balloon_handler(void *opaque);
 bool qemu_balloon_is_inhibited(void);
 void qemu_balloon_inhibit(bool state);
diff --git a/linux-user/linuxload.c b/linux-user/linuxload.c
index 6717c9c6f0..a27e1d0d8b 100644
--- a/linux-user/linuxload.c
+++ b/linux-user/linuxload.c
@@ -38,15 +38,15 @@ static int prepare_binprm(struct linux_binprm *bprm)
     int retval;
=20
     if(fstat(bprm->fd, &st) < 0) {
-	return(-errno);
+        return(-errno);
     }
=20
     mode =3D st.st_mode;
     if(!S_ISREG(mode)) {	/* Must be regular file */
-	return(-EACCES);
+        return(-EACCES);
     }
     if(!(mode & 0111)) {	/* Must have at least one execute bit set */
-	return(-EACCES);
+        return(-EACCES);
     }
=20
     bprm->e_uid =3D geteuid();
@@ -54,7 +54,7 @@ static int prepare_binprm(struct linux_binprm *bprm)
=20
     /* Set-uid? */
     if(mode & S_ISUID) {
-	bprm->e_uid =3D st.st_uid;
+        bprm->e_uid =3D st.st_uid;
     }
=20
     /* Set-gid? */
@@ -64,13 +64,13 @@ static int prepare_binprm(struct linux_binprm *bprm)
      * executable.
      */
     if ((mode & (S_ISGID | S_IXGRP)) =3D=3D (S_ISGID | S_IXGRP)) {
-	bprm->e_gid =3D st.st_gid;
+        bprm->e_gid =3D st.st_gid;
     }
=20
     retval =3D read(bprm->fd, bprm->buf, BPRM_BUF_SIZE);
     if (retval < 0) {
-	perror("prepare_binprm");
-	exit(-1);
+        perror("prepare_binprm");
+        exit(-1);
     }
     if (retval < BPRM_BUF_SIZE) {
         /* Make sure the rest of the loader won't read garbage.  */
diff --git a/linux-user/main.c b/linux-user/main.c
index 923cbb753a..a0aba9cb1e 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -740,8 +740,8 @@ int main(int argc, char **argv, char **envp)
     target_argc =3D argc - optind;
     target_argv =3D calloc(target_argc + 1, sizeof (char *));
     if (target_argv =3D=3D NULL) {
-	(void) fprintf(stderr, "Unable to allocate memory for target_argv\n");
-	exit(EXIT_FAILURE);
+        (void) fprintf(stderr, "Unable to allocate memory for target_arg=
v\n");
+        exit(EXIT_FAILURE);
     }
=20
     /*
diff --git a/linux-user/mmap.c b/linux-user/mmap.c
index 41e0983ce8..e0249efe4f 100644
--- a/linux-user/mmap.c
+++ b/linux-user/mmap.c
@@ -485,11 +485,11 @@ abi_long target_mmap(abi_ulong start, abi_ulong len=
, int prot,
         end =3D start + len;
         real_end =3D HOST_PAGE_ALIGN(end);
=20
-	/*
-	 * Test if requested memory area fits target address space
-	 * It can fail only on 64-bit host with 32-bit target.
-	 * On any other target/host host mmap() handles this error correctly.
-	 */
+        /*
+         * Test if requested memory area fits target address space
+         * It can fail only on 64-bit host with 32-bit target.
+         * On any other target/host host mmap() handles this error corre=
ctly.
+         */
         if (!guest_range_valid(start, len)) {
             errno =3D ENOMEM;
             goto fail;
diff --git a/linux-user/qemu.h b/linux-user/qemu.h
index dd5771ce0c..069df8f1f9 100644
--- a/linux-user/qemu.h
+++ b/linux-user/qemu.h
@@ -50,7 +50,7 @@ struct image_info {
         abi_ulong       env_strings;
         abi_ulong       file_string;
         uint32_t        elf_flags;
-	int		personality;
+        int		personality;
         abi_ulong       alignment;
=20
         /* The fields below are used in FDPIC mode.  */
@@ -174,7 +174,7 @@ extern unsigned long mmap_min_addr;
 struct linux_binprm {
         char buf[BPRM_BUF_SIZE] __attribute__((aligned));
         abi_ulong p;
-	int fd;
+        int fd;
         int e_uid, e_gid;
         int argc, envc;
         char **argv;
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 602b631b92..e2c0b37173 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -727,7 +727,7 @@ abi_long do_sigaltstack(abi_ulong uss_addr, abi_ulong=
 uoss_addr, abi_ulong sp)
         }
 #endif
=20
-	ret =3D -TARGET_EFAULT;
+        ret =3D -TARGET_EFAULT;
         if (!lock_user_struct(VERIFY_READ, uss, uss_addr, 1)) {
             goto out;
         }
@@ -736,25 +736,25 @@ abi_long do_sigaltstack(abi_ulong uss_addr, abi_ulo=
ng uoss_addr, abi_ulong sp)
         __get_user(ss.ss_flags, &uss->ss_flags);
         unlock_user_struct(uss, uss_addr, 0);
=20
-	ret =3D -TARGET_EPERM;
-	if (on_sig_stack(sp))
+        ret =3D -TARGET_EPERM;
+        if (on_sig_stack(sp))
             goto out;
=20
-	ret =3D -TARGET_EINVAL;
-	if (ss.ss_flags !=3D TARGET_SS_DISABLE
+        ret =3D -TARGET_EINVAL;
+        if (ss.ss_flags !=3D TARGET_SS_DISABLE
             && ss.ss_flags !=3D TARGET_SS_ONSTACK
             && ss.ss_flags !=3D 0)
             goto out;
=20
-	if (ss.ss_flags =3D=3D TARGET_SS_DISABLE) {
+        if (ss.ss_flags =3D=3D TARGET_SS_DISABLE) {
             ss.ss_size =3D 0;
             ss.ss_sp =3D 0;
-	} else {
+        } else {
             ret =3D -TARGET_ENOMEM;
             if (ss.ss_size < minstacksize) {
                 goto out;
             }
-	}
+        }
=20
         target_sigaltstack_used.ss_sp =3D ss.ss_sp;
         target_sigaltstack_used.ss_size =3D ss.ss_size;
diff --git a/linux-user/strace.c b/linux-user/strace.c
index d1d14945f9..7318392e57 100644
--- a/linux-user/strace.c
+++ b/linux-user/strace.c
@@ -647,11 +647,11 @@ print_execve(const struct syscallname *name,
     for (arg_ptr_addr =3D arg2; ; arg_ptr_addr +=3D sizeof(abi_ulong)) {
         abi_ulong *arg_ptr, arg_addr;
=20
-	arg_ptr =3D lock_user(VERIFY_READ, arg_ptr_addr, sizeof(abi_ulong), 1);
+        arg_ptr =3D lock_user(VERIFY_READ, arg_ptr_addr, sizeof(abi_ulon=
g), 1);
         if (!arg_ptr)
             return;
     arg_addr =3D tswapal(*arg_ptr);
-	unlock_user(arg_ptr, arg_ptr_addr, 0);
+        unlock_user(arg_ptr, arg_ptr_addr, 0);
         if (!arg_addr)
             break;
         if ((s =3D lock_user_string(arg_addr))) {
diff --git a/linux-user/uaccess.c b/linux-user/uaccess.c
index 0a5c0b0b29..e215ecc2a6 100644
--- a/linux-user/uaccess.c
+++ b/linux-user/uaccess.c
@@ -30,7 +30,7 @@ abi_long copy_to_user(abi_ulong gaddr, void *hptr, size=
_t len)
=20
     if ((ghptr =3D lock_user(VERIFY_WRITE, gaddr, len, 0))) {
         memcpy(ghptr, hptr, len);
-	unlock_user(ghptr, gaddr, len);
+        unlock_user(ghptr, gaddr, len);
     } else
         ret =3D -TARGET_EFAULT;
=20
diff --git a/linux-user/vm86.c b/linux-user/vm86.c
index 3829b9a677..9c393df424 100644
--- a/linux-user/vm86.c
+++ b/linux-user/vm86.c
@@ -257,7 +257,7 @@ void handle_vm86_trap(CPUX86State *env, int trapno)
 #define CHECK_IF_IN_TRAP() \
       if ((ts->vm86plus.vm86plus.flags & TARGET_vm86dbg_active) && \
           (ts->vm86plus.vm86plus.flags & TARGET_vm86dbg_TFpendig)) \
-		newflags |=3D TF_MASK
+                newflags |=3D TF_MASK
=20
 #define VM86_FAULT_RETURN \
         if ((ts->vm86plus.vm86plus.flags & TARGET_force_return_for_pic) =
&& \
diff --git a/nbd/client.c b/nbd/client.c
index b4d457a19a..69f5e1b7d2 100644
--- a/nbd/client.c
+++ b/nbd/client.c
@@ -1028,7 +1028,7 @@ int nbd_disconnect(int fd)
=20
 #else
 int nbd_init(int fd, QIOChannelSocket *ioc, NBDExportInfo *info,
-	     Error **errp)
+             Error **errp)
 {
     error_setg(errp, "nbd_init is only supported on Linux");
     return -ENOTSUP;
diff --git a/net/checksum.c b/net/checksum.c
index 4da72a6a6c..273bc9c6bc 100644
--- a/net/checksum.c
+++ b/net/checksum.c
@@ -43,7 +43,7 @@ uint32_t net_checksum_add_cont(int len, uint8_t *buf, i=
nt seq)
 uint16_t net_checksum_finish(uint32_t sum)
 {
     while (sum>>16)
-	sum =3D (sum & 0xFFFF)+(sum >> 16);
+        sum =3D (sum & 0xFFFF)+(sum >> 16);
     return ~sum;
 }
=20
diff --git a/qtest.c b/qtest.c
index 69b9e9962b..55df6c43db 100644
--- a/qtest.c
+++ b/qtest.c
@@ -290,7 +290,7 @@ static void qtest_process_command(CharBackend *chr, g=
char **words)
         if (!dev) {
             qtest_send_prefix(chr);
             qtest_send(chr, "FAIL Unknown device\n");
-	    return;
+            return;
         }
=20
         if (irq_intercept_dev) {
@@ -300,7 +300,7 @@ static void qtest_process_command(CharBackend *chr, g=
char **words)
             } else {
                 qtest_send(chr, "OK\n");
             }
-	    return;
+            return;
         }
=20
         QLIST_FOREACH(ngl, &dev->gpios, node) {
diff --git a/target/alpha/translate.c b/target/alpha/translate.c
index e5d62850c5..9d8f9b3eea 100644
--- a/target/alpha/translate.c
+++ b/target/alpha/translate.c
@@ -804,7 +804,7 @@ static void gen_cvttq(DisasContext *ctx, int rb, int =
rc, int fn11)
=20
 static void gen_ieee_intcvt(DisasContext *ctx,
                             void (*helper)(TCGv, TCGv_ptr, TCGv),
-			    int rb, int rc, int fn11)
+                            int rb, int rc, int fn11)
 {
     TCGv vb, vc;
=20
diff --git a/target/cris/helper.c b/target/cris/helper.c
index d2ec349191..b2dbb2075c 100644
--- a/target/cris/helper.c
+++ b/target/cris/helper.c
@@ -240,7 +240,7 @@ void cris_cpu_do_interrupt(CPUState *cs)
         /* Exception starts with dslot cleared.  */
         env->dslot =3D 0;
     }
-=09
+
     if (env->pregs[PR_CCS] & U_FLAG) {
         /* Swap stack pointers.  */
         env->pregs[PR_USP] =3D env->regs[R_SP];
diff --git a/target/cris/mmu.h b/target/cris/mmu.h
index 8e249e812b..0217f476de 100644
--- a/target/cris/mmu.h
+++ b/target/cris/mmu.h
@@ -5,13 +5,13 @@
=20
 struct cris_mmu_result
 {
-	uint32_t phy;
-	int prot;
-	int bf_vec;
+        uint32_t phy;
+        int prot;
+        int bf_vec;
 };
=20
 void cris_mmu_init(CPUCRISState *env);
 void cris_mmu_flush_pid(CPUCRISState *env, uint32_t pid);
 int cris_mmu_translate(struct cris_mmu_result *res,
-		       CPUCRISState *env, uint32_t vaddr,
-		       int rw, int mmu_idx, int debug);
+                       CPUCRISState *env, uint32_t vaddr,
+                       int rw, int mmu_idx, int debug);
diff --git a/target/cris/translate_v10.inc.c b/target/cris/translate_v10.=
inc.c
index fce78825cc..a87b8bb281 100644
--- a/target/cris/translate_v10.inc.c
+++ b/target/cris/translate_v10.inc.c
@@ -384,7 +384,7 @@ static unsigned int dec10_setclrf(DisasContext *dc)
 }
=20
 static inline void dec10_reg_prep_sext(DisasContext *dc, int size, int s=
ext,
-				       TCGv dd, TCGv ds, TCGv sd, TCGv ss)
+                                       TCGv dd, TCGv ds, TCGv sd, TCGv s=
s)
 {
     if (sext) {
         t_gen_sext(dd, sd, size);
diff --git a/target/i386/translate.c b/target/i386/translate.c
index 0dd5fbe45c..49cd298374 100644
--- a/target/i386/translate.c
+++ b/target/i386/translate.c
@@ -3445,7 +3445,7 @@ static void gen_sse(CPUX86State *env, DisasContext =
*s, int b,
         case 0x172:
         case 0x173:
             if (b1 >=3D 2) {
-	        goto unknown_op;
+                goto unknown_op;
             }
             val =3D x86_ldub_code(env, s);
             if (is_xmm) {
@@ -6400,7 +6400,7 @@ static target_ulong disas_insn(DisasContext *s, CPU=
State *cpu)
                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
         if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
             gen_io_start();
-	}
+        }
         tcg_gen_movi_i32(s->tmp2_i32, val);
         gen_helper_in_func(ot, s->T1, s->tmp2_i32);
         gen_op_mov_reg_v(s, ot, R_EAX, s->T1);
@@ -6421,7 +6421,7 @@ static target_ulong disas_insn(DisasContext *s, CPU=
State *cpu)
=20
         if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
             gen_io_start();
-	}
+        }
         tcg_gen_movi_i32(s->tmp2_i32, val);
         tcg_gen_trunc_tl_i32(s->tmp3_i32, s->T1);
         gen_helper_out_func(ot, s->tmp2_i32, s->tmp3_i32);
@@ -6439,7 +6439,7 @@ static target_ulong disas_insn(DisasContext *s, CPU=
State *cpu)
                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
         if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
             gen_io_start();
-	}
+        }
         tcg_gen_trunc_tl_i32(s->tmp2_i32, s->T0);
         gen_helper_in_func(ot, s->T1, s->tmp2_i32);
         gen_op_mov_reg_v(s, ot, R_EAX, s->T1);
@@ -6459,7 +6459,7 @@ static target_ulong disas_insn(DisasContext *s, CPU=
State *cpu)
=20
         if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
             gen_io_start();
-	}
+        }
         tcg_gen_trunc_tl_i32(s->tmp2_i32, s->T0);
         tcg_gen_trunc_tl_i32(s->tmp3_i32, s->T1);
         gen_helper_out_func(ot, s->tmp2_i32, s->tmp3_i32);
@@ -7166,7 +7166,7 @@ static target_ulong disas_insn(DisasContext *s, CPU=
State *cpu)
         gen_jmp_im(s, pc_start - s->cs_base);
         if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
             gen_io_start();
-	}
+        }
         gen_helper_rdtsc(cpu_env);
         if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {
             gen_io_end();
diff --git a/target/mips/translate.c b/target/mips/translate.c
index e9c23a594b..b8dcab5307 100644
--- a/target/mips/translate.c
+++ b/target/mips/translate.c
@@ -6942,7 +6942,7 @@ static void gen_mfc0(DisasContext *ctx, TCGv arg, i=
nt reg, int sel)
             /* Mark as an IO operation because we read the time.  */
             if (tb_cflags(ctx->base.tb) & CF_USE_ICOUNT) {
                 gen_io_start();
-	    }
+            }
             gen_helper_mfc0_count(arg, cpu_env);
             if (tb_cflags(ctx->base.tb) & CF_USE_ICOUNT) {
                 gen_io_end();
diff --git a/target/tilegx/translate.c b/target/tilegx/translate.c
index f201150fc7..df1e4d0fef 100644
--- a/target/tilegx/translate.c
+++ b/target/tilegx/translate.c
@@ -297,7 +297,7 @@ static TileExcp gen_st_opcode(DisasContext *dc, unsig=
ned dest, unsigned srca,
     }
=20
     tcg_gen_qemu_st_tl(load_gr(dc, srcb), load_gr(dc, srca),
-		       dc->mmuidx, memop);
+                       dc->mmuidx, memop);
=20
     qemu_log_mask(CPU_LOG_TB_IN_ASM, "%s %s, %s", name,
                   reg_names[srca], reg_names[srcb]);
diff --git a/tcg/i386/tcg-target.inc.c b/tcg/i386/tcg-target.inc.c
index c21c3272f2..1b4e3b80e1 100644
--- a/tcg/i386/tcg-target.inc.c
+++ b/tcg/i386/tcg-target.inc.c
@@ -3392,8 +3392,8 @@ static void tcg_target_qemu_prologue(TCGContext *s)
     tcg_out_addi(s, TCG_REG_ESP, -stack_addend);
     /* jmp *tb.  */
     tcg_out_modrm_offset(s, OPC_GRP5, EXT5_JMPN_Ev, TCG_REG_ESP,
-		         (ARRAY_SIZE(tcg_target_callee_save_regs) + 2) * 4
-			 + stack_addend);
+                         (ARRAY_SIZE(tcg_target_callee_save_regs) + 2) *=
 4
+                         + stack_addend);
 #else
 # if !defined(CONFIG_SOFTMMU) && TCG_TARGET_REG_BITS =3D=3D 64
     if (guest_base) {
diff --git a/tests/tcg/alpha/test-cond.c b/tests/tcg/alpha/test-cond.c
index e625313b3e..3e11c4c105 100644
--- a/tests/tcg/alpha/test-cond.c
+++ b/tests/tcg/alpha/test-cond.c
@@ -6,7 +6,7 @@
 int test_##N (long a)				\
 {						\
   int res =3D 1;					\
-						\
+                                                \
   asm ("cmov"#N" %1,$31,%0"			\
        : "+r" (res) : "r" (a));			\
   return !res;					\
@@ -18,7 +18,7 @@ int test_##N (long a)				\
 int test_##N (long a)				\
 {						\
   int res =3D 1;					\
-						\
+                                                \
   asm ("b"#N" %1,1f\n\t"			\
        "addq $31,$31,%0\n\t"			\
        "1: unop\n"				\
diff --git a/tests/tcg/arm/hello-arm.c b/tests/tcg/arm/hello-arm.c
index 6e5a93bccf..e33edf949f 100644
--- a/tests/tcg/arm/hello-arm.c
+++ b/tests/tcg/arm/hello-arm.c
@@ -11,7 +11,7 @@
=20
 #define __syscall_return(type, res)					\
 do {									\
-	return (type) (res);						\
+        return (type) (res);						\
 } while (0)
=20
 #define _syscall0(type,name)						\
@@ -33,7 +33,7 @@ type name(type1 arg1) {							\
   "mov %0,r0"								\
         : "=3Dr" (__res)							\
         : "r" ((long)(arg1))						\
-	: "r0","lr");							\
+        : "r0","lr");							\
   __syscall_return(type,__res);						\
 }
=20
@@ -47,7 +47,7 @@ type name(type1 arg1,type2 arg2) {					\
   "mov\t%0,r0"								\
         : "=3Dr" (__res)							\
         : "r" ((long)(arg1)),"r" ((long)(arg2))				\
-	: "r0","r1","lr");						\
+        : "r0","r1","lr");						\
   __syscall_return(type,__res);						\
 }
=20
@@ -78,9 +78,9 @@ type name(type1 arg1, type2 arg2, type3 arg3, type4 arg=
4) {				\
   "mov\tr3,%4\n\t"									\
   __syscall(name)									\
   "mov\t%0,r0"										\
-	: "=3Dr" (__res)									\
-	: "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r" ((long)(=
arg4))	\
-	: "r0","r1","r2","r3","lr");							\
+        : "=3Dr" (__res)									\
+        : "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r" (=
(long)(arg4))	\
+        : "r0","r1","r2","r3","lr");							\
   __syscall_return(type,__res);								\
 }
=20
@@ -96,10 +96,10 @@ type name(type1 arg1, type2 arg2, type3 arg3, type4 a=
rg4, type5 arg5) {			\
   "mov\tr4,%5\n\t"									\
   __syscall(name)									\
   "mov\t%0,r0"										\
-	: "=3Dr" (__res)									\
-	: "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r" ((long)(=
arg4)),	\
-	  "r" ((long)(arg5))								\
-	: "r0","r1","r2","r3","r4","lr");						\
+        : "=3Dr" (__res)									\
+        : "r" ((long)(arg1)),"r" ((long)(arg2)),"r" ((long)(arg3)),"r" (=
(long)(arg4)),	\
+          "r" ((long)(arg5))								\
+        : "r0","r1","r2","r3","r4","lr");						\
   __syscall_return(type,__res);								\
 }
=20
diff --git a/tests/tcg/cris/check_glibc_kernelversion.c b/tests/tcg/cris/=
check_glibc_kernelversion.c
index 07448722c0..7aada89911 100644
--- a/tests/tcg/cris/check_glibc_kernelversion.c
+++ b/tests/tcg/cris/check_glibc_kernelversion.c
@@ -109,8 +109,8 @@ int main(void)
=20
         if (parts < 3)
           version <<=3D 8 * (3 - parts);
-	if (version < __LINUX_KERNEL_VERSION)
-		err();
-	pass();
-	exit(0);
+        if (version < __LINUX_KERNEL_VERSION)
+                err();
+        pass();
+        exit(0);
 }
diff --git a/tests/tcg/cris/check_mmap3.c b/tests/tcg/cris/check_mmap3.c
index 34401fa0c9..cb890ef120 100644
--- a/tests/tcg/cris/check_mmap3.c
+++ b/tests/tcg/cris/check_mmap3.c
@@ -17,7 +17,7 @@ int main (int argc, char *argv[])
=20
   /* Check that we can map a non-multiple of a page and still get a full=
 page.  */
   a =3D mmap (NULL, 0x4c, PROT_READ | PROT_WRITE | PROT_EXEC,
-	    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
   if (a =3D=3D NULL || a =3D=3D (unsigned char *) -1)
     abort ();
=20
diff --git a/tests/tcg/cris/check_openpf1.c b/tests/tcg/cris/check_openpf=
1.c
index fdcf4c5c3f..251d26eec2 100644
--- a/tests/tcg/cris/check_openpf1.c
+++ b/tests/tcg/cris/check_openpf1.c
@@ -19,7 +19,7 @@ int main (int argc, char *argv[])
     {
       fnam =3D malloc (strlen (argv[0]) + 2);
       if (fnam =3D=3D NULL)
-	abort ();
+        abort ();
       strcpy (fnam, "/");
       strcat (fnam, argv[0]);
     }
diff --git a/tests/tcg/cris/check_settls1.c b/tests/tcg/cris/check_settls=
1.c
index 69d202652a..3abc3a9ea8 100644
--- a/tests/tcg/cris/check_settls1.c
+++ b/tests/tcg/cris/check_settls1.c
@@ -35,7 +35,7 @@ int main (void)
     syscall (SYS_set_thread_area, old_tp);
=20
     if (tp !=3D 0xeddeed00) {
-	* (volatile int *) 0 =3D 0;
+        * (volatile int *) 0 =3D 0;
         perror ("tls2");
         abort ();
     }
diff --git a/tests/tcg/i386/hello-i386.c b/tests/tcg/i386/hello-i386.c
index cfeb24b2f5..59196dd0b7 100644
--- a/tests/tcg/i386/hello-i386.c
+++ b/tests/tcg/i386/hello-i386.c
@@ -4,19 +4,19 @@ static inline void exit(int status)
 {
   int __res;
   __asm__ volatile ("movl %%ecx,%%ebx\n"\
-		    "int $0x80" \
-		    :  "=3Da" (__res) : "0" (__NR_exit),"c" ((long)(status)));
+                    "int $0x80" \
+                    :  "=3Da" (__res) : "0" (__NR_exit),"c" ((long)(stat=
us)));
 }
=20
 static inline int write(int fd, const char * buf, int len)
 {
   int status;
   __asm__ volatile ("pushl %%ebx\n"\
-		    "movl %%esi,%%ebx\n"\
-		    "int $0x80\n" \
-		    "popl %%ebx\n"\
-		    : "=3Da" (status) \
-		    : "0" (__NR_write),"S" ((long)(fd)),"c" ((long)(buf)),"d" ((long)(=
len)));
+                    "movl %%esi,%%ebx\n"\
+                    "int $0x80\n" \
+                    "popl %%ebx\n"\
+                    : "=3Da" (status) \
+                    : "0" (__NR_write),"S" ((long)(fd)),"c" ((long)(buf)=
),"d" ((long)(len)));
   return status;
 }
=20
diff --git a/tests/tcg/mips/hello-mips.c b/tests/tcg/mips/hello-mips.c
index f8256730dd..c7052fdf2e 100644
--- a/tests/tcg/mips/hello-mips.c
+++ b/tests/tcg/mips/hello-mips.c
@@ -24,9 +24,9 @@ static inline void exit1(int status)
         "	syscall		\n"
         "	.set pop	"
         :
-	: "i" (__NR_exit), "r" (__a0)
-	: "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15", "$24",
-	  "memory");
+        : "i" (__NR_exit), "r" (__a0)
+        : "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15", "$=
24",
+          "memory");
 }
=20
 static inline int write(int fd, const char *buf, int len)
@@ -46,8 +46,8 @@ static inline int write(int fd, const char *buf, int le=
n)
         "	.set pop	"
         : "=3Dr" (__v0), "=3Dr" (__a3)
         : "i" (__NR_write), "r" (__a0), "r" (__a1), "r" (__a2)
-	: "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15", "$24",
-	  "memory");
+        : "$2", "$8", "$9", "$10", "$11", "$12", "$13", "$14", "$15", "$=
24",
+          "memory");
=20
 /*    if (__a3 =3D=3D 0) */
         return (int) __v0;
diff --git a/tests/tcg/multiarch/sha1.c b/tests/tcg/multiarch/sha1.c
index 93b7c8e808..87bfbcdf52 100644
--- a/tests/tcg/multiarch/sha1.c
+++ b/tests/tcg/multiarch/sha1.c
@@ -152,7 +152,7 @@ uint32_t j;
=20
     j =3D context->count[0];
     if ((context->count[0] +=3D len << 3) < j)
-	context->count[1]++;
+        context->count[1]++;
     context->count[1] +=3D (len>>29);
     j =3D (j >> 3) & 63;
     if ((j + len) > 63) {
@@ -186,11 +186,11 @@ unsigned char c;
=20
     for (i =3D 0; i < 2; i++)
     {
-	uint32_t t =3D context->count[i];
-	int j;
+        uint32_t t =3D context->count[i];
+        int j;
=20
-	for (j =3D 0; j < 4; t >>=3D 8, j++)
-	    *--fcp =3D (unsigned char) t;
+        for (j =3D 0; j < 4; t >>=3D 8, j++)
+            *--fcp =3D (unsigned char) t;
     }
 #else
     for (i =3D 0; i < 8; i++) {
@@ -201,7 +201,7 @@ unsigned char c;
     c =3D 0200;
     SHA1Update(context, &c, 1);
     while ((context->count[0] & 504) !=3D 448) {
-	c =3D 0000;
+        c =3D 0000;
         SHA1Update(context, &c, 1);
     }
     SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform=
() */
diff --git a/tests/vhost-user-test.c b/tests/vhost-user-test.c
index 45d58d8ea2..54982f68e7 100644
--- a/tests/vhost-user-test.c
+++ b/tests/vhost-user-test.c
@@ -354,8 +354,8 @@ static void chr_read(void *opaque, const uint8_t *buf=
, int size)
         break;
=20
     case VHOST_USER_SET_FEATURES:
-	g_assert_cmpint(msg.payload.u64 & (0x1ULL << VHOST_USER_F_PROTOCOL_FEAT=
URES),
-			!=3D, 0ULL);
+        g_assert_cmpint(msg.payload.u64 & (0x1ULL << VHOST_USER_F_PROTOC=
OL_FEATURES),
+                        !=3D, 0ULL);
         if (s->test_flags =3D=3D TEST_FLAGS_DISCONNECT) {
             qemu_chr_fe_disconnect(chr);
             s->test_flags =3D TEST_FLAGS_BAD;
diff --git a/ui/keymaps.h b/ui/keymaps.h
index 98213a4191..4e9c87fb8f 100644
--- a/ui/keymaps.h
+++ b/ui/keymaps.h
@@ -28,8 +28,8 @@
 #include "qemu-common.h"
=20
 typedef struct {
-	const char* name;
-	int keysym;
+    const char* name;
+    int keysym;
 } name2keysym_t;
=20
 /* scancode without modifiers */
diff --git a/ui/qemu-pixman.c b/ui/qemu-pixman.c
index 3e52abd92d..1429cf08d5 100644
--- a/ui/qemu-pixman.c
+++ b/ui/qemu-pixman.c
@@ -36,7 +36,7 @@ PixelFormat qemu_pixelformat_from_pixman(pixman_format_=
code_t format)
         pf.rshift =3D 0;
         break;
     case PIXMAN_TYPE_BGRA:
-	pf.bshift =3D bpp - pf.bbits;
+        pf.bshift =3D bpp - pf.bbits;
         pf.gshift =3D bpp - (pf.bbits + pf.gbits);
         pf.rshift =3D bpp - (pf.bbits + pf.gbits + pf.rbits);
         pf.ashift =3D 0;
diff --git a/ui/vnc-enc-zywrle-template.c b/ui/vnc-enc-zywrle-template.c
index b446380a7a..e9be55966e 100644
--- a/ui/vnc-enc-zywrle-template.c
+++ b/ui/vnc-enc-zywrle-template.c
@@ -44,8 +44,8 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF=
 SUCH DAMAGE.
=20
 /* Change Log:
      V0.02 : 2008/02/04 : Fix mis encode/decode when width !=3D scanline
-	                     (Thanks Johannes Schindelin, author of LibVNC
-						  Server/Client)
+                             (Thanks Johannes Schindelin, author of LibV=
NC
+                                                  Server/Client)
      V0.01 : 2007/02/06 : Initial release
 */
=20
diff --git a/ui/vnc.c b/ui/vnc.c
index 0c1b477425..9e4b2beb71 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -3097,8 +3097,8 @@ static void vnc_connect(VncDisplay *vd, QIOChannelS=
ocket *sioc,
     buffer_init(&vs->zrle.zlib,      "vnc-zrle-zlib/%p", sioc);
=20
     if (skipauth) {
-	vs->auth =3D VNC_AUTH_NONE;
-	vs->subauth =3D VNC_AUTH_INVALID;
+        vs->auth =3D VNC_AUTH_NONE;
+        vs->subauth =3D VNC_AUTH_INVALID;
     } else {
         if (websocket) {
             vs->auth =3D vd->ws_auth;
diff --git a/util/bitops.c b/util/bitops.c
index f2364015c4..3fe6b1c4f1 100644
--- a/util/bitops.c
+++ b/util/bitops.c
@@ -18,7 +18,7 @@
  * Find the next set bit in a memory region.
  */
 unsigned long find_next_bit(const unsigned long *addr, unsigned long siz=
e,
-			    unsigned long offset)
+                            unsigned long offset)
 {
     const unsigned long *p =3D addr + BIT_WORD(offset);
     unsigned long result =3D offset & ~(BITS_PER_LONG-1);
@@ -83,7 +83,7 @@ found_middle:
  * Linus' asm-alpha/bitops.h.
  */
 unsigned long find_next_zero_bit(const unsigned long *addr, unsigned lon=
g size,
-				 unsigned long offset)
+                                 unsigned long offset)
 {
     const unsigned long *p =3D addr + BIT_WORD(offset);
     unsigned long result =3D offset & ~(BITS_PER_LONG-1);
diff --git a/util/osdep.c b/util/osdep.c
index 1c8d1e2ee0..4b5dc7287d 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -470,8 +470,8 @@ void fips_set_state(bool requested)
=20
 #ifdef _FIPS_DEBUG
     fprintf(stderr, "FIPS mode %s (requested %s)\n",
-	    (fips_enabled ? "enabled" : "disabled"),
-	    (requested ? "enabled" : "disabled"));
+            (fips_enabled ? "enabled" : "disabled"),
+            (requested ? "enabled" : "disabled"));
 #endif
 }
=20
diff --git a/util/qemu-sockets.c b/util/qemu-sockets.c
index 8bd8bb64eb..9705051690 100644
--- a/util/qemu-sockets.c
+++ b/util/qemu-sockets.c
@@ -270,8 +270,8 @@ static int inet_listen_saddr(InetSocketAddress *saddr=
,
     /* create socket + bind/listen */
     for (e =3D res; e !=3D NULL; e =3D e->ai_next) {
         getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,
-		        uaddr,INET6_ADDRSTRLEN,uport,32,
-		        NI_NUMERICHOST | NI_NUMERICSERV);
+                        uaddr,INET6_ADDRSTRLEN,uport,32,
+                        NI_NUMERICHOST | NI_NUMERICSERV);
=20
         port_min =3D inet_getport(e);
         port_max =3D saddr->has_to ? saddr->to + port_offset : port_min;
--=20
2.20.1


