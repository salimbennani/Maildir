Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:38:21 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga004.fm.intel.com (fmsmga004.fm.intel.com [10.253.24.48])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 6A3C0580460;
	Fri, 23 Nov 2018 19:15:03 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by fmsmga004-1.fm.intel.com with ESMTP; 23 Nov 2018 19:15:02 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AKxsQMhHCuyeOcIVrxoyshp1GYnF86YWxBRYc798d?=
 =?us-ascii?q?s5kLTJ75o8qybnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjm58axlVAHnhz?=
 =?us-ascii?q?sGNz4h8WHYlMpwjL5AoBm8oxBz2pPYbJ2JOPZ7eK7WYNEUSndbXstJSSJPAYGz?=
 =?us-ascii?q?b4UPAeQcM+hYtJH9qlkVoBeiGQWhHv/jxiNUinPq26AxzuQvERvB3AwlB98AsH?=
 =?us-ascii?q?XUrNPzNKwPT+61zLPHzTTFb/hL3jr95pTIchA7rvGNW7J9atbRxlcrFwzbgVWQ?=
 =?us-ascii?q?s5bqPyuV1uQMr2eb9PBsWv6oi24isQ1+uCWvy94qh4LUhYwV0kjJ+TtlzIsxP9?=
 =?us-ascii?q?G0VUB2bcC+HJdNtCyWK5F6T8IgTm1wvCs3yacKtYOlcCUF0pgqxgLTZ+aaf4WH?=
 =?us-ascii?q?7R/uUvuaLy1ii3J/Yr2/gg6/8Ui+xe34Ucm5yEhKriVbndnWrHwN1ALc6tKBSv?=
 =?us-ascii?q?Rj+ketwzGP1xrc6u1cIEA0k7TUK4I5z7IuipYetV7PEjL4lUnolqOaa0Yp9vSy?=
 =?us-ascii?q?5+nmYLjqvpqcOJV1igH6PKQugMu/AeEgPwgKXmib//m81bL68U36XrpKlPs2nb?=
 =?us-ascii?q?fdsJzDIsQaqKi5DBFP0os49Ra/ACmp0M4CkXkEMl1FYhSHgJbtO13UJ/D4F/i/?=
 =?us-ascii?q?j0y2kDh33/DGIqHhApLVI3jHkbfhfqhy51RTyQou1t1f45NUCrccIPP8QEPxtd?=
 =?us-ascii?q?rYDgMnPAyw2eroFNJ91oYGU2KVHqCZKL/SsUOP5u83I+mDfo4VuCrnJPgi/fLu?=
 =?us-ascii?q?jWI5lkUbfammxpYXbHG4HvJ7I0SWe3bsg9EBEXsUsQo6VuDllFqCUTtLbXaoQ6?=
 =?us-ascii?q?08/i07CJ6hDYrbRICth6KO0D24Hp1RYGBGDFeMHGzsd4WFXfcMdS2TLtVgkjwC?=
 =?us-ascii?q?SbiuVYsh2Quyuw/9zrptNvDU9TEAtZL/yNh14PXemgsp9Tx0CMSd0HuBT3tukW?=
 =?us-ascii?q?MKXDI22KF/oUpgylaMy6R4gvpYFcBN6PNNSAs1KZncz+liAdDoRg3BZsuJSEqh?=
 =?us-ascii?q?Qti+AjE+VNQxz8UKY0Z8AdqiiB/D0jGuA78UkbyLGZM1/rjd33j3O8Zy1XLG2L?=
 =?us-ascii?q?M9gFkhR8tFLXemibJn9wjPG47JlF2UmLuweqQCwiHB7meDwnCIvEFDTgFwV6LJ?=
 =?us-ascii?q?XXQcZkvTqdT0/UfCT76oCbQ6PQpN08+CKq1WatL3iVVKXuvsONPbY2ipgWe/GQ?=
 =?us-ascii?q?6Ixq+QbIrtY2gSwT/SCFYanAwJ/XaJLw4+Bjy/rGLYFzFuEVPvY0Xx8ehxsn+7?=
 =?us-ascii?q?T0k0zx2UYE1lzba65hkVhfmEQfMJwr0EoDshqylzHFulw9LWCt+Apw19fKVcYd?=
 =?us-ascii?q?Ix+ktH2XjetwxnOpygLqZihlEFfgRzvkPu0Qh3C4pancgrqnMq0BR9KaaC3Fxd?=
 =?us-ascii?q?cDOY2Ij6OqfLJWnq4BCvd6nW10nE39aS5KgO5+o3qlX5sA6yC0ot7m9o099W03?=
 =?us-ascii?q?ub+JXHFw4SUZP3UkYq+Bl2vbDaYi8h54zK0X1gK7W7sjjH29gxHusq1g6gf8tD?=
 =?us-ascii?q?MKODDALzE9AaC9KyJ+AwmlmpbggLPOZd9KMvO8Omdv2G2LOkPep6nTKmi3hH75?=
 =?us-ascii?q?550k6W6yV8TevI1Y4fw/6ExguHSyv8jFC5v8DtmIBLeSsdHnCixijjHoJRYLN9?=
 =?us-ascii?q?fZwKCWu3P8K43NF+iIPzVH5C816jAUgL2MuoeRqUclz80hdc1UURoXy7hyS4yy?=
 =?us-ascii?q?Z4nC0urqqaxCbO2fjtdAIbOm5XQ2lvlVftIYmug9EaRkSodBUplB2+6Eb+xqhb?=
 =?us-ascii?q?orl/LmbJTUdJeSj2M39tUq+qurWeZM5P7YsisT9LX+SkfVCaVrn9rgMY0yz5BW?=
 =?us-ascii?q?texzM7dzawtpXihRN6i2GdLHd1rHXHf8F93hPf5N3aRf5M0TsKXih4iT/LBlei?=
 =?us-ascii?q?O9ml58mbl5DGsuqmTWKuSoVTcTX3zYOHrCa65XdlARqlk/Cxm93nFxM30Sv619?=
 =?us-ascii?q?lsSCXJowzwYojt16SmL+1nelNkC0P768p/Aot+iJc/hIkM2XgGgZWY5XkHnn3y?=
 =?us-ascii?q?MdlB2aL+cWACRTgEw9PO5Ajl2UtjLm+Gxo7jV3WdxNdhaMe+Ym8Mxi096MVKAr?=
 =?us-ascii?q?+O7LNYhSt1vka4rQXJbPh4nzcdyuEh5GQUgu4Xowot0juSAqoJEkZGJyzsmA+F?=
 =?us-ascii?q?79S/rKVReWaufqK81Et4ndC9Er6CphtQV2r+epcnBSVw9NlwMErQ0H3v7YHpYM?=
 =?us-ascii?q?XQbdUWthGOkhbPle5VKI8qlvoRhCpqImb9vXwjy+4mgh1ix5C6vI6bK2pz+KK1?=
 =?us-ascii?q?GAJXNjrwZ8kL4DHikb5entqK34CoBphuAS8EXJzsTfK1Cj4SsennOh2KED09rH?=
 =?us-ascii?q?ebBLXeERWe6Edgs3LADZSrO2uLK3keyNVoXAOdK1BHgAAIQDU6mYY0FgKwy8zk?=
 =?us-ascii?q?bkh5/Sod5kLiphtP1+JoNAT/UmHFqwezcTo0TJmfLBxL7gBN/UvVMMqe7v5tEC?=
 =?us-ascii?q?Fc5JGusAuNKmmDbQRSEW4JQlCEB0zkPrS25djA9PWYBvOjL/TUZ7WCs/deV/CO?=
 =?us-ascii?q?xZKgyYZm+zeMNsOSPnhtFfE720xDXWxnFMTdgTkAVysXlyfVZc6BuBi84jF3rt?=
 =?us-ascii?q?y48PnzWALg+4qPC7hRMdVu4Ry2gr2DN+mfhClnMzZYy4gMyGTMyLge2l4Sli5v?=
 =?us-ascii?q?eyOsEbQGqS7CUqbQlrVLAB4cbiN5LNFI4L4k3glRJc7bjcv42aRljvEuEVdKS1?=
 =?us-ascii?q?zgltutZcwLOGy9MFLHBECWNLWJPzHLwsf3Yb+iRr1UlulbqxqwuTODGU/5IjuD?=
 =?us-ascii?q?jyXpVwyoMexUkCGbPRletJuhfRp3FWfjTMzpahugPd9zjD02x6A0h3zQOW4dNz?=
 =?us-ascii?q?h8b11CrrmK4SxEhfV/HnRL7mB5IumchyaZ8+7YJ44WsPRxBCR0kuNa4HIixLpU?=
 =?us-ascii?q?7CFLXvp1mCTJo95qolGmlPSPyzV9XBpPrDZLmJyEvUF4NarF8ZlAXCWMwBVYwm?=
 =?us-ascii?q?idEQhCmsp5FtD1u6dd1NXJ3Pb8JTpY7/rQ/M0BF43RdpKEdn07Pky6NiTTCV4r?=
 =?us-ascii?q?TDitfV3fjk1b2KWc6n2cr54StpXolZUUQ6dbVVcuUPgdDwJsAYpRc99MQjo4nO?=
 =?us-ascii?q?vD34Yz7n2koUyUHZ0Csw=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0A2AAAwwfhbh0O0hNFjHgEGBwaBUwcLA?=
 =?us-ascii?q?YNrJ5gRgWg5iHiOMIFzLBMBiFoiNgcNAQMBAQEBAQECARMBAQEIDQkIKS+CNiQ?=
 =?us-ascii?q?BgmIDAwECdgYJAQE+EgMeCysGEwWDHIFqAxUFp3uFQYI0DYIZjAkXgUA/gREzh?=
 =?us-ascii?q?TWBYoYhAoh/JIFuhAiQOy4Jf40Fg0OBWYguhwGOTYswAYIFMxoIFxmDJ4InF44?=
 =?us-ascii?q?wKzOBBQEBiWOCPgEB?=
X-IPAS-Result: =?us-ascii?q?A0A2AAAwwfhbh0O0hNFjHgEGBwaBUwcLAYNrJ5gRgWg5iHi?=
 =?us-ascii?q?OMIFzLBMBiFoiNgcNAQMBAQEBAQECARMBAQEIDQkIKS+CNiQBgmIDAwECdgYJA?=
 =?us-ascii?q?QE+EgMeCysGEwWDHIFqAxUFp3uFQYI0DYIZjAkXgUA/gREzhTWBYoYhAoh/JIF?=
 =?us-ascii?q?uhAiQOy4Jf40Fg0OBWYguhwGOTYswAYIFMxoIFxmDJ4InF44wKzOBBQEBiWOCP?=
 =?us-ascii?q?gEB?=
X-IronPort-AV: E=Sophos;i="5.56,272,1539673200"; 
   d="scan'208";a="41353676"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 19:15:01 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1730651AbeKXN6g (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sat, 24 Nov 2018 08:58:36 -0500
Received: from kvm5.telegraphics.com.au ([98.124.60.144]:56666 "EHLO
        kvm5.telegraphics.com.au" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1730204AbeKXN5y (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sat, 24 Nov 2018 08:57:54 -0500
Received: by kvm5.telegraphics.com.au (Postfix, from userid 502)
        id 8509028F72; Fri, 23 Nov 2018 22:11:08 -0500 (EST)
To: Geert Uytterhoeven <geert@linux-m68k.org>
Cc: Andreas Schwab <schwab@linux-m68k.org>,
        Arnd Bergmann <arnd@arndb.de>,
        Stephen N Chivers <schivers@csc.com.au>,
        Thomas Gleixner <tglx@linutronix.de>,
        Kars de Jong <jongk@linux-m68k.org>,
        Daniel Lezcano <daniel.lezcano@linaro.org>,
        Michael Schmitz <schmitzmic@gmail.com>,
        John Stultz <john.stultz@linaro.org>,
        Linus Walleij <linus.walleij@linaro.org>,
        linux-m68k@lists.linux-m68k.org, linux-kernel@vger.kernel.org
Message-Id: <d736dba8698479b330be8c371c3882e376c6769a.1543028943.git.fthain@telegraphics.com.au>
In-Reply-To: <cover.1543028943.git.fthain@telegraphics.com.au>
References: <cover.1543028943.git.fthain@telegraphics.com.au>
From: Finn Thain <fthain@telegraphics.com.au>
Subject: [RFC PATCH v3 06/14] m68k: atari: Convert to clocksource API
Date: Sat, 24 Nov 2018 14:09:03 +1100
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Add a platform clocksource by adapting the existing arch_gettimeoffset
implementation.

Normally the MFP timer C interrupt flag would be used to check for
timer counter wrap-around. Unfortunately, that flag gets cleared by the
MFP itself (due to automatic End-of-Interrupt mode). This means that
mfp_timer_c_handler() and atari_read_clk() must race when accounting
for counter wrap-around.

That problem is avoided by effectively stopping the clock when it might
otherwise jump backwards (due to interrupt latency). Note that this may
affect clock accuracy.

After the timer interrupt is asserted, wait for the counter to be
reloaded so that atari_read_clk() will not see the intermediate state
as that would cause the clock to jump backwards.

Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
Acked-by: Linus Walleij <linus.walleij@linaro.org>
Tested-by: Michael Schmitz <schmitzmic@gmail.com>
---
TODO: find a spare counter for the clocksource, rather than hanging
it off the HZ timer.

Changed since v2:
 - Wait for timer reload after timer interrupt.
 - Add comment and improve code style for better clarity.

Changed since v1:
 - Moved clk_total access to within the irq lock.
 - Renamed mfp_timer_handler and mfptimer_handler.
 - Avoid accessing the timer interrupt flag in atari_read_clk(). To
get monotonicity, keep track of the previous timer counter value.
---
 arch/m68k/atari/time.c | 53 ++++++++++++++++++++++++++++--------------
 1 file changed, 36 insertions(+), 17 deletions(-)

diff --git a/arch/m68k/atari/time.c b/arch/m68k/atari/time.c
index fafa20f75ab9..ce923a523695 100644
--- a/arch/m68k/atari/time.c
+++ b/arch/m68k/atari/time.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/rtc.h>
 #include <linux/bcd.h>
+#include <linux/clocksource.h>
 #include <linux/delay.h>
 #include <linux/export.h>
 
@@ -24,12 +25,29 @@
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL_GPL(rtc_lock);
 
+static u64 atari_read_clk(struct clocksource *cs);
+
+static struct clocksource atari_clk = {
+	.name   = "mfp",
+	.rating = 100,
+	.read   = atari_read_clk,
+	.mask   = CLOCKSOURCE_MASK(32),
+	.flags  = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static u32 clk_total;
+static u8 last_timer_count;
+
 static irqreturn_t mfp_timer_c_handler(int irq, void *dev_id)
 {
 	irq_handler_t timer_routine = dev_id;
 	unsigned long flags;
 
 	local_irq_save(flags);
+	do {
+		last_timer_count = st_mfp.tim_dt_c;
+	} while (last_timer_count == 1);
+	clk_total += INT_TICKS;
 	timer_routine(0, NULL);
 	local_irq_restore(flags);
 
@@ -44,32 +62,33 @@ atari_sched_init(irq_handler_t timer_routine)
     /* start timer C, div = 1:100 */
     st_mfp.tim_ct_cd = (st_mfp.tim_ct_cd & 15) | 0x60;
     /* install interrupt service routine for MFP Timer C */
-    if (request_irq(IRQ_MFP_TIMC, mfp_timer_c_handler, 0, "timer",
+    if (request_irq(IRQ_MFP_TIMC, mfp_timer_c_handler, IRQF_TIMER, "timer",
                     timer_routine))
 	pr_err("Couldn't register timer interrupt\n");
+
+    clocksource_register_hz(&atari_clk, INT_CLK);
 }
 
 /* ++andreas: gettimeoffset fixed to check for pending interrupt */
 
-#define TICK_SIZE 10000
-
-/* This is always executed with interrupts disabled.  */
-u32 atari_gettimeoffset(void)
+static u64 atari_read_clk(struct clocksource *cs)
 {
-  u32 ticks, offset = 0;
-
-  /* read MFP timer C current value */
-  ticks = st_mfp.tim_dt_c;
-  /* The probability of underflow is less than 2% */
-  if (ticks > INT_TICKS - INT_TICKS / 50)
-    /* Check for pending timer interrupt */
-    if (st_mfp.int_pn_b & (1 << 5))
-      offset = TICK_SIZE;
+	unsigned long flags;
+	u8 count;
+	u32 ticks;
 
-  ticks = INT_TICKS - ticks;
-  ticks = ticks * 10000L / INT_TICKS;
+	local_irq_save(flags);
+	/* Ensure that the count is monotonically decreasing, even though
+	 * the result may briefly stop changing after counter wrap-around.
+	 */
+	count = min(st_mfp.tim_dt_c, last_timer_count);
+	last_timer_count = count;
+
+	ticks = INT_TICKS - count;
+	ticks += clk_total;
+	local_irq_restore(flags);
 
-  return (ticks + offset) * 1000;
+	return ticks;
 }
 
 
-- 
2.18.1

