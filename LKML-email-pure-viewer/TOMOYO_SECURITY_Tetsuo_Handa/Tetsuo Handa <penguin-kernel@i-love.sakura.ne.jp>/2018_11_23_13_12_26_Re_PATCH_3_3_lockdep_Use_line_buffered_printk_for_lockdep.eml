Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:35:22 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id AF8105803EB;
	Fri, 23 Nov 2018 05:12:46 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 05:12:43 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ApPR5exSkQcWZx/gLXq+B3ZW4+dpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YB2At8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZH42y?=
 =?us-ascii?q?cYUPAeoCM+hWoYbyqFkBogexCwm3HOPiyCRFhmP00KAgz+gtDQ/L0Q4mEtkTsH?=
 =?us-ascii?q?rUttL1NKIKXO6r0qbI0S7Db+5R2Tzg6obHaBYhruyWUrltdsfR0VcgFwXKjlWN?=
 =?us-ascii?q?qIzlOSqZ1ucTvGiB6epvS+avhnUmqw1opjivwdkshZfTioIO0F/E9jh5wJwvKt?=
 =?us-ascii?q?GiTk50f8SoEJlItyyDMYZ9X8AsQ3lwtSok1rELvYS3cDUExZg53RLTdv+Kf5SS?=
 =?us-ascii?q?7h/iVuudOSp0iGxkdb6lmhq+70mtxvfhWsS13ltGtCRIn9jKu3sQzRLc8NKHRe?=
 =?us-ascii?q?F4/kq52TaAyQTT6uZcLEAqmqrUNYQhzqQzlpUNq0TDGDH5mEHsgK+RbEUk9fCk?=
 =?us-ascii?q?6+XhYrr4up+RL5F4hh36P6g0h8CyD/o0PhITU2WY5eiwzrzu8E/hTLVPlPI2k6?=
 =?us-ascii?q?3ZsJ7AJcQco660GwtV0ocl6xaiADaqydcYkmcdLFJDZh2Hi5HlO1bAIfD+E/i/?=
 =?us-ascii?q?mU+hkClkx//YJL3tGJbNIWbZkLfnY7l971RQyA0pzdBQ/55UEK0OIOrvWk/ts9?=
 =?us-ascii?q?zVFhs5Mw23w+n5Etl82Z4eVHmLAq+YNqPSrFCJ6vguI+mKeI8apjL9J+I56P7p?=
 =?us-ascii?q?iH8zgUUdcrWx3ZsLdHC4GexrI0WDbnrtntcOC2AKshA+TOz3klKCVzFTam22X6?=
 =?us-ascii?q?I94DE7FY2nAZ3CRoCrnLyOwiO7EodKaWBBD1CGCW3oeJmcW/cQdCKSJddskj4D?=
 =?us-ascii?q?Vbe/UYMh1hautAn8y7pgNefU/iwYtZT+1Nl6/eHTlBcy9SBqAMSZyW2CU2Z0nm?=
 =?us-ascii?q?YQTT8swK9/uVB9ykuE0aVgmfNYDtxT5/RKUgsgL57T1e56Bsv2WgLAeNeJVVmn?=
 =?us-ascii?q?Ts+nATE3UtI+3dsOb1xhFNWlixDJxzCqDKMNl7yXGJw09brR33vrKMZ70XrG0K?=
 =?us-ascii?q?ghgEMgQstALmCmgq9/9w7OB4/GiUmZlqCqdbgC0y7J7muM0W2OvERAWg5qTarF?=
 =?us-ascii?q?RWwfZlfRrdnh+0zNVaGuBqo9PgtB08GCLLBKZcPvjVlBQPfjO9HeY2aqlme0BB?=
 =?us-ascii?q?aIwK6MbYXwd2Uc2iXdFFYLkwQJ8XmaMgg+Az+ro3jCAzx2CVLvf0Ts/PFjp3yh?=
 =?us-ascii?q?UE870RuGb0172Lqz4R4am/qcRugX3rIFvichtjp1EEy839LQF9qPuQ5hcL9Abt?=
 =?us-ascii?q?M65VdNzXjZuBBlPpy8M6BigUYTcxh2v0Pr0BV3FoVAkMgwoHM21gZyLriY0FdA?=
 =?us-ascii?q?dzOe0pD9IbnXKmj0/BCyZK/awFDe0NCK+qgR7PQ0sUnsvAasFkA66XVoz8FV02?=
 =?us-ascii?q?eA5pXNFAcdS5bxXVg49hdkp7DWeDIy557J2nJ2N6m0sTjC28wyCeshyxagecpf?=
 =?us-ascii?q?MayeGA/zFc0aG9ahKOgwl1e1aRIEOfhY9LQoMMO+a/uGxKmrMf5gnTK7l2hI/J?=
 =?us-ascii?q?px00OM9yVmTO7I0I0Iw/WZ3guBSjf9g02tssHxmYBYez4SGnCzxjTjBI5Ufqdy?=
 =?us-ascii?q?Z5oECX+yI82rwdVzn4TtW39E+1G5HVMJxcipdQCUb1Pjxw1Q1F0brmC9liu80j?=
 =?us-ascii?q?N7jSsprq2Z3CHVx+TidRwHOnNERWV4jFfsJ5S0gM4eXESycwcpkx6l717gx6dH?=
 =?us-ascii?q?vKR/M3XTQUBQcin2LmFuSKuxuqCZY85S7pMlqiFXUOW6YVCHRb/xuRoa0yX/H2?=
 =?us-ascii?q?RAwDA3bS2lupL8nxZikmKSMG5zrGbFecF33Rrf5sbTReRS3joFQyl0kyLXCUK/?=
 =?us-ascii?q?P9mq/NWUkYnMsualWmKlV51TdzTrzIyauCu6421qHQOwn/SpltL7Fgg61Dfx18?=
 =?us-ascii?q?N2WiXQsBb8fo7r2ry6MO19eUlkHl3868t8GoxlloswhZcQ2WUVh5mP/HoHl3vz?=
 =?us-ascii?q?Pstf2a7kcHUNQjsLycbP4Af5wE1jMm6Jx4XhW3We2MRhZsO2YmML2i0n6cBKB7?=
 =?us-ascii?q?yZ7LhFnStzv1q5ohjdYfl7njcB1/Qu7GQWjP0OuAoo1i+dGKwdHVFEPSzwkBSF?=
 =?us-ascii?q?99W+rKRUZGm1a7Sx2lRxncu9DL6cuAFTQ2j2eo0tHSJr6sV/MVTM0GD8643+ed?=
 =?us-ascii?q?nQa84TuQOQkxvak+dVL5cxnOIQhSV7IWL9oWEly+kjgBxy2pG6uZKLKmR386K/?=
 =?us-ascii?q?Hx5YLSb1Z8II9zHpjKZemNuW3o+1EpVgHDULQIXnTfayHD0OsvTnMh6EECcgpX?=
 =?us-ascii?q?eDBbrfAQif5V99oH3VFJCrM2yXKGMdzdV/XxSdIE1fgAYJXDQ1hJI5FwaqxND/?=
 =?us-ascii?q?f0d9/Dwe+ln4qh5UwOJyKxb/SnvfpBuvajosSpiQNh9W4R9Z50vPLcyS9OFzHz?=
 =?us-ascii?q?xb/p28qgyCMHebah9MDWEIXEyEGl/iMqOv5dnG7+iXGO6+I+HSbrWJrOxUT+2I?=
 =?us-ascii?q?yo630ot64zaMMd2CP3llD/0mw0pDQGp2G8LDlzUUTCwXkS3NYtWfpBe9/C13s8?=
 =?us-ascii?q?++/O7qWALp+YuAFb9SPc9z9BCxhKeJL/SQizphKTZEypMMwmfFyLgB014TiCFu?=
 =?us-ascii?q?dDitHa4DtS7XS6LQlbFYDwQGayNoL8ZI66M83g9QOc/UkN/117h4juIrBFdBT1?=
 =?us-ascii?q?DuhsapZckSKWGnKFzHHFqLNKiBJTDT2c73fLizSadOg+RUrRGwvTebHlTnPjSC?=
 =?us-ascii?q?kTnpSh+uPftNjCGdIBxRpoW9fgxxBmjkSdLscge7P8NvjT0q3b00gWvHNXIdMT?=
 =?us-ascii?q?h5aU9Csqec4j9YgvphHWxM9X5lLeiCmyaE4OjUMJcWsf13Aitqk+JW+mg1y7xQ?=
 =?us-ascii?q?7CtcXvx6hDPSrsJyo1GhiuSOyiBoUBxLqjZKgoKEpURjOaXD+ZlGVnbJ5xYN7W?=
 =?us-ascii?q?SWCxQXqNppENzvu6ZMytfRkKL/MitN89XR/ZhUO8+BEM+bKjIENRPlFT2cWBMA?=
 =?us-ascii?q?STenOGL3nFFGnbeZ8XjD/bYgrZ25pJcSUaJcHHw8EP8TQhB9EdoNPZZxGzApi7?=
 =?us-ascii?q?iWiOYJoH65shSXX8xZo4rOEPSfR/f3fmXKxYJYbgcFlOurZb8YMZf2jgk7MgF3?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AnAACu+/dbh0O0hNFjHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUgYBAQsBgmx/hCCUF1ABAQaBCAglFIkFjiKCBQEBKwGIVyI1CA0BAwEBAQE?=
 =?us-ascii?q?BAQIBEwEBAQgNCQgpL4I2JAGCYgECAwECIARBEQYJAQEKDgoCAiYCAgNUBg0IA?=
 =?us-ascii?q?QEBgxyBdQwBBaZ6fDOFQIRZgQuKfoEPgQeBEScMgWF+iAKCVwKHFgeBYiSBboR?=
 =?us-ascii?q?LM49zCZEpHolhhyeRT4Y6AhEUgUgBggozGoNggiMDF44rgWgBAYweAwEB?=
X-IPAS-Result: =?us-ascii?q?A0AnAACu+/dbh0O0hNFjHAEBAQQBAQcEAQGBUgYBAQsBgmx?=
 =?us-ascii?q?/hCCUF1ABAQaBCAglFIkFjiKCBQEBKwGIVyI1CA0BAwEBAQEBAQIBEwEBAQgNC?=
 =?us-ascii?q?QgpL4I2JAGCYgECAwECIARBEQYJAQEKDgoCAiYCAgNUBg0IAQEBgxyBdQwBBaZ?=
 =?us-ascii?q?6fDOFQIRZgQuKfoEPgQeBEScMgWF+iAKCVwKHFgeBYiSBboRLM49zCZEpHolhh?=
 =?us-ascii?q?yeRT4Y6AhEUgUgBggozGoNggiMDF44rgWgBAYweAwEB?=
X-IronPort-AV: E=Sophos;i="5.56,269,1539673200"; 
   d="scan'208";a="53077249"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 05:12:40 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2439775AbeKWX4o (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 18:56:44 -0500
Received: from www262.sakura.ne.jp ([202.181.97.72]:63100 "EHLO
        www262.sakura.ne.jp" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2390867AbeKWX4n (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 18:56:43 -0500
Received: from fsav102.sakura.ne.jp (fsav102.sakura.ne.jp [27.133.134.229])
        by www262.sakura.ne.jp (8.15.2/8.15.2) with ESMTP id wANDCXXK081984;
        Fri, 23 Nov 2018 22:12:33 +0900 (JST)
        (envelope-from penguin-kernel@i-love.sakura.ne.jp)
Received: from www262.sakura.ne.jp (202.181.97.72)
 by fsav102.sakura.ne.jp (F-Secure/fsigk_smtp/530/fsav102.sakura.ne.jp);
 Fri, 23 Nov 2018 22:12:33 +0900 (JST)
X-Virus-Status: clean(F-Secure/fsigk_smtp/530/fsav102.sakura.ne.jp)
Received: from [192.168.1.8] (softbank126126163036.bbtec.net [126.126.163.36])
        (authenticated bits=0)
        by www262.sakura.ne.jp (8.15.2/8.15.2) with ESMTPSA id wANDCRkS081927
        (version=TLSv1.2 cipher=AES256-SHA bits=256 verify=NO);
        Fri, 23 Nov 2018 22:12:33 +0900 (JST)
        (envelope-from penguin-kernel@i-love.sakura.ne.jp)
Subject: Re: [PATCH 3/3] lockdep: Use line-buffered printk() for lockdep
 messages.
To: Petr Mladek <pmladek@suse.com>
Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>,
        Linus Torvalds <torvalds@linux-foundation.org>,
        Sergey Senozhatsky <sergey.senozhatsky@gmail.com>,
        Dmitriy Vyukov <dvyukov@google.com>,
        Steven Rostedt <rostedt@goodmis.org>,
        Alexander Potapenko <glider@google.com>,
        Fengguang Wu <fengguang.wu@intel.com>,
        Josh Poimboeuf <jpoimboe@redhat.com>,
        LKML <linux-kernel@vger.kernel.org>,
        Andrew Morton <akpm@linux-foundation.org>, linux-mm@kvack.org,
        Ingo Molnar <mingo@redhat.com>,
        Peter Zijlstra <peterz@infradead.org>,
        Will Deacon <will.deacon@arm.com>
References: <1541165517-3557-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp>
 <1541165517-3557-3-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp>
 <20181107151900.gxmdvx42qeanpoah@pathway.suse.cz>
 <20181108044510.GC2343@jagdpanzerIV>
 <9648a384-853c-942e-6a8d-80432d943aae@i-love.sakura.ne.jp>
 <20181109061204.GC599@jagdpanzerIV>
 <07dcbcb8-c5a7-8188-b641-c110ade1c5da@i-love.sakura.ne.jp>
 <20181109154326.apqkbsojmbg26o3b@pathway.suse.cz>
 <deb8d78b-0593-2b8e-1c7a-9203aa77005f@i-love.sakura.ne.jp>
 <20181123124647.jmewvgrqdpra7wbm@pathway.suse.cz>
From: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
Message-ID: <4ce501ef-92f5-7662-8105-49bfe06e109c@i-love.sakura.ne.jp>
Date: Fri, 23 Nov 2018 22:12:26 +0900
User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:60.0) Gecko/20100101
 Thunderbird/60.3.1
MIME-Version: 1.0
In-Reply-To: <20181123124647.jmewvgrqdpra7wbm@pathway.suse.cz>
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On 2018/11/23 21:46, Petr Mladek wrote:
> I am more and more wondering if the buffered printk is worth
> the effort. The more buffers we use the more we risk that nobody
> would see some important message. Even a part of the line
> might be crucial in some situations.
> 
> Steven told me on Plumbers conference that even few initial
> characters saved him a day few times.

Yes, few initial characters of one line might sometimes help.
But emitting one line at a time also helps sometimes; especially
when we need to interpret multiple lines and group these lines from
concurrent printk() callers.

> 
> 
>> But updating printk() users to always end with '\n' will be preferable.
> 
> This sounds like a whack a mole game. If I get it correctly, you write
> that it is "an impossible task for anybody" just few lines above.

Yes, updating printk() users is almost impossible. I think that something
like diff shown below is what we can afford at best. If you believe that
line buffering is wrong, I can tolerate with switching via kernel config
option like CONFIG_DEBUG_AID_FOR_SYZBOT=y.

 kernel/printk/printk.c | 263 +++++++++++++++++++++++++++++++++----------------
 1 file changed, 176 insertions(+), 87 deletions(-)

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 315718b..2276c99 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -584,6 +584,15 @@ static int log_store(int facility, int level,
 	struct printk_log *msg;
 	u32 size, pad_len;
 	u16 trunc_msg_len = 0;
+	static char id[32];
+	u16 id_len;
+
+	if (in_task())
+		id_len = scnprintf(id, sizeof(id), "[T%u] ", current->pid);
+	else
+		id_len = scnprintf(id, sizeof(id), "[C%u] ",
+				   raw_smp_processor_id());
+	text_len += id_len;
 
 	/* number of '\0' padding bytes to next message */
 	size = msg_used_size(text_len, dict_len, &pad_len);
@@ -607,12 +616,16 @@ static int log_store(int facility, int level,
 		log_next_idx = 0;
 	}
 
+	text_len -= id_len;
+
 	/* fill message */
 	msg = (struct printk_log *)(log_buf + log_next_idx);
-	memcpy(log_text(msg), text, text_len);
-	msg->text_len = text_len;
+	memcpy(log_text(msg), id, id_len);
+	memcpy(log_text(msg) + id_len, text, text_len);
+	msg->text_len = text_len + id_len;
 	if (trunc_msg_len) {
-		memcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);
+		memcpy(log_text(msg) + id_len + text_len, trunc_msg,
+		       trunc_msg_len);
 		msg->text_len += trunc_msg_len;
 	}
 	memcpy(log_dict(msg), dict, dict_len);
@@ -620,10 +633,7 @@ static int log_store(int facility, int level,
 	msg->facility = facility;
 	msg->level = level & 7;
 	msg->flags = flags & 0x1f;
-	if (ts_nsec > 0)
-		msg->ts_nsec = ts_nsec;
-	else
-		msg->ts_nsec = local_clock();
+	msg->ts_nsec = ts_nsec;
 	memset(log_dict(msg) + dict_len, 0, pad_len);
 	msg->len = size;
 
@@ -1758,87 +1768,154 @@ static inline void printk_delay(void)
 }
 
 /*
- * Continuation lines are buffered, and not committed to the record buffer
- * until the line is complete, or a race forces it. The line fragments
- * though, are printed immediately to the consoles to ensure everything has
- * reached the console in case of a kernel crash.
+ * Continuation lines are buffered based on type of context, and not committed
+ * to the record buffer until the line is complete, or a race forces it.
+ *
+ * While this context calculation is not perfect, asking printk() callers to
+ * explicitly pass "struct printk_buffer" (except "context" field) as their
+ * function arguments will require too large tree-wide changes. Therefore,
+ * let's tolerate failing to separate "up to one line of messages", and avoid
+ * bloating kernel code size for addressing infrequently happening races.
  */
-static struct cont {
-	char buf[LOG_LINE_MAX];
-	size_t len;			/* length == 0 means unused buffer */
-	struct task_struct *owner;	/* task of first print*/
-	u64 ts_nsec;			/* time of first print */
-	u8 level;			/* log level of first message */
-	u8 facility;			/* log facility of first message */
-	enum log_flags flags;		/* prefix, newline flags */
-} cont;
-
-static void cont_flush(void)
+static inline unsigned long printk_context(void)
 {
-	if (cont.len == 0)
-		return;
-
-	log_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,
-		  NULL, 0, cont.buf, cont.len);
-	cont.len = 0;
-}
+	unsigned long base;
 
-static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)
-{
-	/* If the line gets too long, split it up in separate records. */
-	if (cont.len + len > sizeof(cont.buf)) {
-		cont_flush();
-		return false;
-	}
-
-	if (!cont.len) {
-		cont.facility = facility;
-		cont.level = level;
-		cont.owner = current;
-		cont.ts_nsec = local_clock();
-		cont.flags = flags;
-	}
-
-	memcpy(cont.buf + cont.len, text, len);
-	cont.len += len;
-
-	// The original flags come from the first line,
-	// but later continuations can add a newline.
-	if (flags & LOG_NEWLINE) {
-		cont.flags |= LOG_NEWLINE;
-		cont_flush();
-	}
-
-	return true;
+	if (in_task())
+		return (unsigned long) current;
+	if (in_nmi())
+		base = NR_CPUS * 2;
+	else if (in_irq())
+		base = NR_CPUS;
+	else
+		base = 0;
+	return base + raw_smp_processor_id();
 }
 
-static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)
-{
+struct printk_buffer {
+	char buf[LOG_LINE_MAX];
+	/* valid bytes in buf[] */
+	size_t len;
 	/*
-	 * If an earlier line was buffered, and we're a continuation
-	 * write from the same process, try to add it to the buffer.
+	 * owner context of this buffer if len != 0
+	 *
+	 * 0 to NR_CPUS - 1: A soft IRQ context reserved.
+	 * NR_CPUS to NR_CPUS * 2 - 1: A hard IRQ context reserved.
+	 * NR_CPUS * 2 to NR_CPUS * 3 - 1: An NMI context reserved.
+	 * NR_CPUS * 3 to ULONG_MAX: Some task context reserved.
 	 */
-	if (cont.len) {
-		if (cont.owner == current && (lflags & LOG_CONT)) {
-			if (cont_add(facility, level, lflags, text, text_len))
-				return text_len;
+	unsigned long context;
+	/* last accessed jiffies */
+	unsigned long last_used;
+	/* time of first print */
+	u64 ts_nsec;
+	/* log flags of first message */
+	enum log_flags lflags;
+	/* log level of first message */
+	u8 level;
+} __aligned(1024);
+
+/* Number of line buffers. */
+#define NUM_LINE_BUFFERS 16
+
+/*
+ * Line buffered printk() tries to assign a buffer when printk() from a new
+ * context identifier comes in. And it automatically releases that buffer when
+ * one of three conditions listed below became true.
+ *
+ *   (1) printk() from that context identifier emitted '\n' as the last
+ *       character of output.
+ *   (2) printk() from that context identifier tried to print a too long line
+ *       which cannot be stored into a buffer.
+ *   (3) printk() from a new context identifier noticed that some context
+ *       identifier is reserving a buffer for more than 10 seconds without
+ *       emitting '\n'.
+ *
+ * Since (3) is based on a heuristic that somebody forgot to emit '\n' as the
+ * last character of output(), pr_cont()/KERN_CONT users are expected to emit
+ * '\n' within 10 seconds even if they reserved a buffer.
+ */
+static void log_output(const int facility, const int level,
+		       const enum log_flags lflags,
+		       const char *text, const size_t text_len)
+{
+	static struct printk_buffer printk_buffers[NUM_LINE_BUFFERS];
+	static struct printk_buffer static_buffer;
+	struct printk_buffer *ptr;
+	int i;
+	const unsigned long context = printk_context();
+	const unsigned long now = jiffies;
+
+	/* Only kernel-generated messages are subjected to buffering. */
+	if (facility) {
+		ptr = &static_buffer;
+		goto found;
+	}
+	/* Check if this context already reserved a buffer. */
+	for (i = 0; i < NUM_LINE_BUFFERS; i++) {
+		ptr = &printk_buffers[i];
+		if (ptr->len && context == ptr->context)
+			goto found;
+	}
+	/* Check if somebody is reserving a buffer for too long. */
+	for (i = 0; i < NUM_LINE_BUFFERS; i++) {
+		ptr = &printk_buffers[i];
+		if (!ptr->len || !time_after(now, ptr->last_used + 10 * HZ))
+			continue;
+		/* Forced flush due to timeout. */
+		log_store(facility, ptr->level, ptr->lflags, ptr->ts_nsec,
+			  NULL, 0, ptr->buf, ptr->len);
+		ptr->len = 0;
+	}
+	/* Check if this context can reserve a buffer. */
+	for (i = 0; i < NUM_LINE_BUFFERS; i++) {
+		ptr = &printk_buffers[i];
+		if (ptr->len == 0) {
+			ptr->context = context;
+			goto found;
 		}
-		/* Otherwise, make sure it's flushed */
-		cont_flush();
 	}
+	/* Forced assign due to out of buffers. */
+	ptr = &static_buffer;
+ found:
+	/* Forced flush due to log prefix or out of space. */
+	if (((ptr->len && (lflags & LOG_PREFIX)) ||
+	     text_len + ptr->len > sizeof(ptr->buf))) {
+		log_store(facility, ptr->level, ptr->lflags, ptr->ts_nsec,
+			  NULL, 0, ptr->buf, ptr->len);
+		ptr->len = 0;
+	}
+	if (ptr->len == 0) {
+		ptr->lflags = lflags;
+		ptr->level = level;
+		ptr->ts_nsec = local_clock();
+	}
+	/* 0 <= text_len <= LOG_LINE_MAX due to vscnprintf(). */
+	memmove(ptr->buf + ptr->len, text, text_len);
+	ptr->len += text_len;
+	/*
+	 * Flush already completed lines. By splitting at '\n', we can inject
+	 * caller id information to each line of text information.
+	 */
+	while (true) {
+		size_t len;
+		char *cp = memchr(ptr->buf, '\n', ptr->len);
 
-	/* Skip empty continuation lines that couldn't be added - they just flush */
-	if (!text_len && (lflags & LOG_CONT))
-		return 0;
-
-	/* If it doesn't end in a newline, try to buffer the current line */
-	if (!(lflags & LOG_NEWLINE)) {
-		if (cont_add(facility, level, lflags, text, text_len))
-			return text_len;
+		if (!cp)
+			break;
+		len = ++cp - ptr->buf;
+		log_store(facility, ptr->level, ptr->lflags, ptr->ts_nsec,
+			  NULL, 0, ptr->buf, len - 1);
+		ptr->len -= len;
+		memmove(ptr->buf, cp, ptr->len);
 	}
-
-	/* Store it in the record log */
-	return log_store(facility, level, lflags, 0, dict, dictlen, text, text_len);
+	/* Forced flush due to out of buffers. */
+	if (ptr == &static_buffer && ptr->len) {
+		log_store(facility, ptr->level, ptr->lflags, ptr->ts_nsec,
+			  NULL, 0, ptr->buf, ptr->len);
+		ptr->len = 0;
+	}
+	ptr->last_used = now;
 }
 
 /* Must be called under logbuf_lock. */
@@ -1857,12 +1934,6 @@ int vprintk_store(int facility, int level,
 	 */
 	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);
 
-	/* mark and strip a trailing newline */
-	if (text_len && text[text_len-1] == '\n') {
-		text_len--;
-		lflags |= LOG_NEWLINE;
-	}
-
 	/* strip kernel syslog prefix and extract log level or control flags */
 	if (facility == 0) {
 		int kern_level;
@@ -1888,11 +1959,29 @@ int vprintk_store(int facility, int level,
 	if (level == LOGLEVEL_DEFAULT)
 		level = default_message_loglevel;
 
-	if (dict)
-		lflags |= LOG_PREFIX|LOG_NEWLINE;
+	if (dict) {
+		char *cp;
 
-	return log_output(facility, level, lflags,
-			  dict, dictlen, text, text_len);
+		/* Remove the trailing newline. */
+		if (text_len && text[text_len-1] == '\n')
+			text_len--;
+		/*
+		 * Remove any newline because we don't want to duplicate dict
+		 * information while we want to prefix caller id information to
+		 * each line of text information.
+		 */
+		while ((cp = memchr(text, '\n', text_len)) != NULL)
+			*cp = ' ';
+		log_store(facility, level, lflags | LOG_PREFIX | LOG_NEWLINE,
+			  local_clock(), dict, dictlen, text, text_len);
+		return text_len;
+	}
+
+	/* Add '\n' via line buffering for kernel-generated messages. */
+	if (!facility)
+		lflags |= LOG_NEWLINE;
+	log_output(facility, level, lflags, text, text_len);
+	return text_len;
 }
 
 asmlinkage int vprintk_emit(int facility, int level,
-- 
1.8.3.1

