Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 22:13:26 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 0D0E45802E4;
	Sun, 25 Nov 2018 05:16:39 -0800 (PST)
Received: from orsmga102-1.jf.intel.com (HELO mga09.intel.com) ([10.7.208.27])
  by fmsmga006-1.fm.intel.com with ESMTP; 25 Nov 2018 05:16:38 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AVmH3gRQqwmGu37fC3CJFZ1GPUtpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YBKEt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZDI2y?=
 =?us-ascii?q?b5UBAfcCM+laoYnzoFQBogexCwm3HOPiyCRFhmP00KAgz+gsCx3K0BImEtkTsH?=
 =?us-ascii?q?rUttL1NKIKXO6xy6nIyy/Mb+9W2Tjn7ojDbw4sruuJXb1ua8rRzk8vHB7Cg1WS?=
 =?us-ascii?q?qIzqIy2Z2+oWvmiY8eVgT+SvhHAjqw1rpTiv3Mgsh5DPi4kIyV7E7T10zJgpKd?=
 =?us-ascii?q?C8UkJ3fNCpHIVKuy2HNIZ6XtkuTmBqtSoiybAKpIS3cSwLxZg92RLSZfOKf5KV?=
 =?us-ascii?q?7h/sV+ucJypzimh/d7KlnRmy9FCtyu3iWcmw11ZHtjRFktbSuXAXzRDT6daISu?=
 =?us-ascii?q?F7/ki/3TaDzQfT6vtLIUwslKrbLYAuwqIom5YNrUjOGjX6lFj4gaOIbEko5+ul?=
 =?us-ascii?q?5/j9brjnpJKQL4p0hRv/MqQqlMy/G+M4Mg0WUmif+OS80qDj/ELgTLVJkPI2iK?=
 =?us-ascii?q?/Zv47eJcgCoa64DQlV3Zg56xukETem38oXnWMdIFJGZh2HlY7pNE/KIPziCve/?=
 =?us-ascii?q?mVusnC9xx//aJr3hHonNLn/bnbflfLZ96FBTxBA8zNBC/J9UDrABIPTuWk7+rt?=
 =?us-ascii?q?DYDxk5MxCqzObjEtlyyoQeWWeXCK+DLKzSqUOI5v4oI+SUZI8aojf9K+Q/6P7p?=
 =?us-ascii?q?l3M5mUIdcrOv3ZsYc324GvVmI0OEYXvjmNsBEGEKvhYgQ+zuklGNTTlTZ3OqVa?=
 =?us-ascii?q?Im+j47EJ6mDZvERo21gryB2zm0EodVZmBBDFCMF3Doep6AW/cNbiKSP8BgniYF?=
 =?us-ascii?q?VbinV48uyxWuuBXmxLpgK+re4jcYuo771Nhp++3Tkgk/+iZvD8Sd1GGNTHt4nn?=
 =?us-ascii?q?kSSD80x61/pU19ylGe0al3mfBYFNpT5+9XXQc+L5LT0+t6C9XqUALbYtiJUEqm?=
 =?us-ascii?q?QsmhATwpTdI+2dkOb1x5G9WjlB/D2SWqDqQRl7yKApw0763d02LwJ8Z713bJyq?=
 =?us-ascii?q?0hg0M6TctIMG2snrR/+BTLB47Vj0WZkL6nerkG0y7T6miP12qOs1teUA5rT6rF?=
 =?us-ascii?q?W3cTZk/VrdT84kPPVLuuCbUhMgtcxs+OMKpKatv1jVpYQPfvIsjRY2W0m22oHx?=
 =?us-ascii?q?aH2quMbJb2e2UaxCjSFVILkx4N8nqcNQgxHCGho3nAAzxoDl/vZ0Ls8e9jqHK0?=
 =?us-ascii?q?VEM0zgeKb1F/2Lqx4BIamfucS/YL1LIepCghsyl0HEq639/OF9qApg9hfKJAYd?=
 =?us-ascii?q?M94FZLz37ZuxZ6Ppy6K6Bih1gecwtsskPq1hV3DJhAkMcwoHMrygpyNbyX0Fdb?=
 =?us-ascii?q?ezyE2pDwP6XdKnPu8xC3d67Wxlbe3c6M9acL9vs5pEvsvQGzGkU57nVozsNa03?=
 =?us-ascii?q?2f5pXNEgofSpbxUkcx9xhnqLDWeCg954XI1XJyNam4qCPN29UsBOE90BavY89f?=
 =?us-ascii?q?ML+YFA/1C8AbB9WuJPY2lFSzbxMEPPpd9Kg7P869c/uG2airPPtvnT68jGRH5p?=
 =?us-ascii?q?x93VyI9yZmVuHI2JMFyemC3gSbTzf8kEuhssfvlIBeZDEdAnCwyTL5C45WfKFy?=
 =?us-ascii?q?e5gECX2vI8Gu2tpxnZrtVGNG+165AFMG3tSkeR6Tb1z7wA1R2l4boX2hmSuk0T?=
 =?us-ascii?q?N0lyslobaY3CzL2+7ibgYIOnZXRGl+ilfhOYi1j9EAUEmodQQpjwal5UDhyqhf?=
 =?us-ascii?q?paR/KXTTQEhScyj3KWFiTrW/tr6Yb8FT75MotD1dUP6gblCCVr79vxwa3jvhH2?=
 =?us-ascii?q?RE3jA7dDKqupLjkxxhkm2dL3VzrHvfec5uwxfS/9jcRf9X3jobSyh0kzjXBl6g?=
 =?us-ascii?q?P9a3+dWYjYvMsue7V2i5TJ1cbTHrzZ+ctCu8/WBrAQewn/eplt3lEAg61zT219?=
 =?us-ascii?q?1rVSXOsRb9bZPn16W8MeJ7YEZoAEXw5NZ9GoF7ioEwno0f2WAGhpWJ+noKiWTz?=
 =?us-ascii?q?Ps9a2a7kbHoNWCQEw9ja4AX+3E1jL3SJx5/2V3mHw8thYcW6bX0S2i4n889KD6?=
 =?us-ascii?q?KU5qRenSRpulq4sR7RYf9lkzcYyPsu62QVj/sHuQUz1SWdHq4dHVNDMiPyjRSI?=
 =?us-ascii?q?4MuzrKFWZGapbLix21ByndGnDLGevA5cXGz1dYslHS919s9/Kk7D0GXv6oH4f9?=
 =?us-ascii?q?nddc4TthqRkxvajulaMpQxlucRhSp8OGLwpnkly+89jRxz0pC2pomHK2Nx/K2n?=
 =?us-ascii?q?Bh5ULCH6Z8QW+jv1l6ZRgt6W35yzHpVmAjgER4HnTfWsEDIPr/jnMxuOHSY4qn?=
 =?us-ascii?q?eaH7rfAACe5F1nr3LJD5CkKXWXKGMFwtVlQRmXPFZfjxwMXDUmgp45ERinxM77?=
 =?us-ascii?q?f0d8+D8R/UT0qgdWxuJrKhn/UXrfpAGyZTcvU5WfKBtW7gdf50baK8Ce7+RzHz?=
 =?us-ascii?q?1G8Z2ltgCCNmubZwFQB2ETRkOEH0zjPqWp5dTY8+mYAfe+L+LTYbqUr+xSTeyI?=
 =?us-ascii?q?xZWp0otp5DuMMsSPPn9/D/w0wEZDXHZ5G9jHlDULUSAYiyXNb8uDrhem5iJ3tt?=
 =?us-ascii?q?y/8OjsWA/35YuAFbpSMdZs+xC3m6uDNPSQhCF2KTlGzJMM2GTIxaMb3F4TjSFu?=
 =?us-ascii?q?ajasHa4BtS7LUKLfhKtXAwQHZCN0MctC97g80RVVOc7HltP10aZ1geQoC1heT1?=
 =?us-ascii?q?zuhMGoadYOI2G8L17HAEeLNLKbJTzE2c33YKW8SaFOg+VQrRG/pTGbE0r7NDSZ?=
 =?us-ascii?q?izbpTwyvMf1LjCyDIBxeuYS9fgxxBmT5UN3magO0MNlsgD0ywL00gG7KNGEGPT?=
 =?us-ascii?q?h9dUNNsqOf7SdCjvpjHGxB62JvLfOYlCaB8+nYNpEWvONrAytukeJa5XU6y71N?=
 =?us-ascii?q?4yBFRPx6gi3SrtF1rlGik+mPzCdnURVUpjZKgoKLoVttOaHD+pZcXnbE+UFF0W?=
 =?us-ascii?q?LFJR0AvdpuB5XAsrtWy9XV3Pb9IT1Y8tnZu8QVHM7VJdivK2ZnOh3sTm36FgwA?=
 =?us-ascii?q?GBysM2jDh0Vb2Nqb83CPqZ5y/prtk8BVYrxWTlo4ErUdEEszT49KG4t+Qj5xye?=
 =?us-ascii?q?3Tt8UP/3fr6UCJHMg=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AaAABjn/pbh0O0hNFiHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBg2snjBFfiyBQAQEGgTUUiQaEaok4gW8YGBMBiFoiNAkNAQMBAQE?=
 =?us-ascii?q?BAQECARMBAQEIDQkIKSMMgjYkAYJiAQICAQECJBMGAQE3AQQBCQEBCiElAwxIB?=
 =?us-ascii?q?hMFgxyBdQUIBAGlO4FsM4J2AQEFhxMIim2BHIEPgQeBEYMSgVSCZigRhWaBLAE?=
 =?us-ascii?q?Bh20KgW6ECEOBAo8jAQYCAZEkIwqQfpgwgUaCDTMaMIFhgU6CGwwXiF6FPkAyg?=
 =?us-ascii?q?QIDAQEhE4w2AQE?=
X-IPAS-Result: =?us-ascii?q?A0AaAABjn/pbh0O0hNFiHAEBAQQBAQcEAQGBUQcBAQsBg2s?=
 =?us-ascii?q?njBFfiyBQAQEGgTUUiQaEaok4gW8YGBMBiFoiNAkNAQMBAQEBAQECARMBAQEID?=
 =?us-ascii?q?QkIKSMMgjYkAYJiAQICAQECJBMGAQE3AQQBCQEBCiElAwxIBhMFgxyBdQUIBAG?=
 =?us-ascii?q?lO4FsM4J2AQEFhxMIim2BHIEPgQeBEYMSgVSCZigRhWaBLAEBh20KgW6ECEOBA?=
 =?us-ascii?q?o8jAQYCAZEkIwqQfpgwgUaCDTMaMIFhgU6CGwwXiF6FPkAygQIDAQEhE4w2AQE?=
X-IronPort-AV: E=Sophos;i="5.56,278,1539673200"; 
   d="scan'208";a="54693403"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 05:16:36 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726312AbeKZAHb (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 25 Nov 2018 19:07:31 -0500
Received: from mail.kernel.org ([198.145.29.99]:59482 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726062AbeKZAHa (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 25 Nov 2018 19:07:30 -0500
Received: from archlinux (cpc91196-cmbg18-2-0-cust659.5-4.cable.virginm.net [81.96.234.148])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 32C7620868;
        Sun, 25 Nov 2018 13:16:24 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1543151786;
        bh=GRueUYGmGccVBzWh7+R+O+zucf+IyUS1Nr5vIFi5fng=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=msTODB6vsk13AzKOWZaBVk9hTeFxC3M/ZAClZbVZM3lwvzc2vMnCDwCOnDt7kK/YD
         w+Lw0wU4z4SRYMZ2Mx6NQFjmYAAwu6RRmV4otgzKzQS5JM7cwYOT1T/MjZ+kXuwLcB
         yW/1TPHKJqeEurrBLeipu9XNMW7WdSUrMwmzdKrE=
Date: Sun, 25 Nov 2018 13:16:21 +0000
From: Jonathan Cameron <jic23@kernel.org>
To: Fabrice Gasnier <fabrice.gasnier@st.com>
Cc: <linux-arm-kernel@lists.infradead.org>,
        <linux-kernel@vger.kernel.org>, <mcoquelin.stm32@gmail.com>,
        <alexandre.torgue@st.com>, <linux-iio@vger.kernel.org>,
        <lars@metafoo.de>, <knaack.h@gmx.de>, <pmeerw@pmeerw.net>,
        <linux-stm32@st-md-mailman.stormreply.com>
Subject: Re: [PATCH 2/3] iio: adc: stm32-adc: add power management support
Message-ID: <20181125131621.65177c99@archlinux>
In-Reply-To: <1542708752-26163-3-git-send-email-fabrice.gasnier@st.com>
References: <1542708752-26163-1-git-send-email-fabrice.gasnier@st.com>
        <1542708752-26163-3-git-send-email-fabrice.gasnier@st.com>
X-Mailer: Claws Mail 3.17.1 (GTK+ 2.24.32; x86_64-pc-linux-gnu)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, 20 Nov 2018 11:12:31 +0100
Fabrice Gasnier <fabrice.gasnier@st.com> wrote:

> Add support for runtime PM & sleep. Move all regulator and clock management
> to dedicated HW start/stop routines. Then rely on (runtime) PM OPS to
> call them.
> 
> Signed-off-by: Fabrice Gasnier <fabrice.gasnier@st.com>
Whilst I'll be the first to admit that runtime pm in particular
gives me a headache everytime I try to review a patch with it in, this
looks good to me.

Applied to the togreg branch of iio.git and pushed out as testing for
the autobuilders to play with it.

Thanks,

Jonathan

> ---
>  drivers/iio/adc/stm32-adc-core.c | 182 +++++++++++++++++++++++++++------------
>  drivers/iio/adc/stm32-adc.c      | 169 ++++++++++++++++++++++++++++--------
>  2 files changed, 258 insertions(+), 93 deletions(-)
> 
> diff --git a/drivers/iio/adc/stm32-adc-core.c b/drivers/iio/adc/stm32-adc-core.c
> index ca432e7..2327ec1 100644
> --- a/drivers/iio/adc/stm32-adc-core.c
> +++ b/drivers/iio/adc/stm32-adc-core.c
> @@ -16,6 +16,7 @@
>  #include <linux/irqdomain.h>
>  #include <linux/module.h>
>  #include <linux/of_device.h>
> +#include <linux/pm_runtime.h>
>  #include <linux/regulator/consumer.h>
>  #include <linux/slab.h>
>  
> @@ -48,15 +49,19 @@
>  #define STM32H7_CKMODE_SHIFT		16
>  #define STM32H7_CKMODE_MASK		GENMASK(17, 16)
>  
> +#define STM32_ADC_CORE_SLEEP_DELAY_MS	2000
> +
>  /**
>   * stm32_adc_common_regs - stm32 common registers, compatible dependent data
>   * @csr:	common status register offset
> + * @ccr:	common control register offset
>   * @eoc1:	adc1 end of conversion flag in @csr
>   * @eoc2:	adc2 end of conversion flag in @csr
>   * @eoc3:	adc3 end of conversion flag in @csr
>   */
>  struct stm32_adc_common_regs {
>  	u32 csr;
> +	u32 ccr;
>  	u32 eoc1_msk;
>  	u32 eoc2_msk;
>  	u32 eoc3_msk;
> @@ -85,6 +90,7 @@ struct stm32_adc_priv_cfg {
>   * @vref:		regulator reference
>   * @cfg:		compatible configuration data
>   * @common:		common data for all ADC instances
> + * @ccr_bak:		backup CCR in low power mode
>   */
>  struct stm32_adc_priv {
>  	int				irq[STM32_ADC_MAX_ADCS];
> @@ -94,6 +100,7 @@ struct stm32_adc_priv {
>  	struct regulator		*vref;
>  	const struct stm32_adc_priv_cfg	*cfg;
>  	struct stm32_adc_common		common;
> +	u32				ccr_bak;
>  };
>  
>  static struct stm32_adc_priv *to_stm32_adc_priv(struct stm32_adc_common *com)
> @@ -265,6 +272,7 @@ static int stm32h7_adc_clk_sel(struct platform_device *pdev,
>  /* STM32F4 common registers definitions */
>  static const struct stm32_adc_common_regs stm32f4_adc_common_regs = {
>  	.csr = STM32F4_ADC_CSR,
> +	.ccr = STM32F4_ADC_CCR,
>  	.eoc1_msk = STM32F4_EOC1,
>  	.eoc2_msk = STM32F4_EOC2,
>  	.eoc3_msk = STM32F4_EOC3,
> @@ -273,6 +281,7 @@ static int stm32h7_adc_clk_sel(struct platform_device *pdev,
>  /* STM32H7 common registers definitions */
>  static const struct stm32_adc_common_regs stm32h7_adc_common_regs = {
>  	.csr = STM32H7_ADC_CSR,
> +	.ccr = STM32H7_ADC_CCR,
>  	.eoc1_msk = STM32H7_EOC_MST,
>  	.eoc2_msk = STM32H7_EOC_SLV,
>  };
> @@ -379,6 +388,61 @@ static void stm32_adc_irq_remove(struct platform_device *pdev,
>  	}
>  }
>  
> +static int stm32_adc_core_hw_start(struct device *dev)
> +{
> +	struct stm32_adc_common *common = dev_get_drvdata(dev);
> +	struct stm32_adc_priv *priv = to_stm32_adc_priv(common);
> +	int ret;
> +
> +	ret = regulator_enable(priv->vref);
> +	if (ret < 0) {
> +		dev_err(dev, "vref enable failed\n");
> +		return ret;
> +	}
> +
> +	if (priv->bclk) {
> +		ret = clk_prepare_enable(priv->bclk);
> +		if (ret < 0) {
> +			dev_err(dev, "bus clk enable failed\n");
> +			goto err_regulator_disable;
> +		}
> +	}
> +
> +	if (priv->aclk) {
> +		ret = clk_prepare_enable(priv->aclk);
> +		if (ret < 0) {
> +			dev_err(dev, "adc clk enable failed\n");
> +			goto err_bclk_disable;
> +		}
> +	}
> +
> +	writel_relaxed(priv->ccr_bak, priv->common.base + priv->cfg->regs->ccr);
> +
> +	return 0;
> +
> +err_bclk_disable:
> +	if (priv->bclk)
> +		clk_disable_unprepare(priv->bclk);
> +err_regulator_disable:
> +	regulator_disable(priv->vref);
> +
> +	return ret;
> +}
> +
> +static void stm32_adc_core_hw_stop(struct device *dev)
> +{
> +	struct stm32_adc_common *common = dev_get_drvdata(dev);
> +	struct stm32_adc_priv *priv = to_stm32_adc_priv(common);
> +
> +	/* Backup CCR that may be lost (depends on power state to achieve) */
> +	priv->ccr_bak = readl_relaxed(priv->common.base + priv->cfg->regs->ccr);
> +	if (priv->aclk)
> +		clk_disable_unprepare(priv->aclk);
> +	if (priv->bclk)
> +		clk_disable_unprepare(priv->bclk);
> +	regulator_disable(priv->vref);
> +}
> +
>  static int stm32_adc_probe(struct platform_device *pdev)
>  {
>  	struct stm32_adc_priv *priv;
> @@ -393,6 +457,7 @@ static int stm32_adc_probe(struct platform_device *pdev)
>  	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
>  	if (!priv)
>  		return -ENOMEM;
> +	platform_set_drvdata(pdev, &priv->common);
>  
>  	priv->cfg = (const struct stm32_adc_priv_cfg *)
>  		of_match_device(dev->driver->of_match_table, dev)->data;
> @@ -410,67 +475,51 @@ static int stm32_adc_probe(struct platform_device *pdev)
>  		return ret;
>  	}
>  
> -	ret = regulator_enable(priv->vref);
> -	if (ret < 0) {
> -		dev_err(&pdev->dev, "vref enable failed\n");
> -		return ret;
> -	}
> -
> -	ret = regulator_get_voltage(priv->vref);
> -	if (ret < 0) {
> -		dev_err(&pdev->dev, "vref get voltage failed, %d\n", ret);
> -		goto err_regulator_disable;
> -	}
> -	priv->common.vref_mv = ret / 1000;
> -	dev_dbg(&pdev->dev, "vref+=%dmV\n", priv->common.vref_mv);
> -
>  	priv->aclk = devm_clk_get(&pdev->dev, "adc");
>  	if (IS_ERR(priv->aclk)) {
>  		ret = PTR_ERR(priv->aclk);
> -		if (ret == -ENOENT) {
> -			priv->aclk = NULL;
> -		} else {
> +		if (ret != -ENOENT) {
>  			dev_err(&pdev->dev, "Can't get 'adc' clock\n");
> -			goto err_regulator_disable;
> -		}
> -	}
> -
> -	if (priv->aclk) {
> -		ret = clk_prepare_enable(priv->aclk);
> -		if (ret < 0) {
> -			dev_err(&pdev->dev, "adc clk enable failed\n");
> -			goto err_regulator_disable;
> +			return ret;
>  		}
> +		priv->aclk = NULL;
>  	}
>  
>  	priv->bclk = devm_clk_get(&pdev->dev, "bus");
>  	if (IS_ERR(priv->bclk)) {
>  		ret = PTR_ERR(priv->bclk);
> -		if (ret == -ENOENT) {
> -			priv->bclk = NULL;
> -		} else {
> +		if (ret != -ENOENT) {
>  			dev_err(&pdev->dev, "Can't get 'bus' clock\n");
> -			goto err_aclk_disable;
> +			return ret;
>  		}
> +		priv->bclk = NULL;
>  	}
>  
> -	if (priv->bclk) {
> -		ret = clk_prepare_enable(priv->bclk);
> -		if (ret < 0) {
> -			dev_err(&pdev->dev, "adc clk enable failed\n");
> -			goto err_aclk_disable;
> -		}
> +	pm_runtime_get_noresume(dev);
> +	pm_runtime_set_active(dev);
> +	pm_runtime_set_autosuspend_delay(dev, STM32_ADC_CORE_SLEEP_DELAY_MS);
> +	pm_runtime_use_autosuspend(dev);
> +	pm_runtime_enable(dev);
> +
> +	ret = stm32_adc_core_hw_start(dev);
> +	if (ret)
> +		goto err_pm_stop;
> +
> +	ret = regulator_get_voltage(priv->vref);
> +	if (ret < 0) {
> +		dev_err(&pdev->dev, "vref get voltage failed, %d\n", ret);
> +		goto err_hw_stop;
>  	}
> +	priv->common.vref_mv = ret / 1000;
> +	dev_dbg(&pdev->dev, "vref+=%dmV\n", priv->common.vref_mv);
>  
>  	ret = priv->cfg->clk_sel(pdev, priv);
>  	if (ret < 0)
> -		goto err_bclk_disable;
> +		goto err_hw_stop;
>  
>  	ret = stm32_adc_irq_probe(pdev, priv);
>  	if (ret < 0)
> -		goto err_bclk_disable;
> -
> -	platform_set_drvdata(pdev, &priv->common);
> +		goto err_hw_stop;
>  
>  	ret = of_platform_populate(np, NULL, NULL, &pdev->dev);
>  	if (ret < 0) {
> @@ -478,21 +527,19 @@ static int stm32_adc_probe(struct platform_device *pdev)
>  		goto err_irq_remove;
>  	}
>  
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
> +
>  	return 0;
>  
>  err_irq_remove:
>  	stm32_adc_irq_remove(pdev, priv);
> -
> -err_bclk_disable:
> -	if (priv->bclk)
> -		clk_disable_unprepare(priv->bclk);
> -
> -err_aclk_disable:
> -	if (priv->aclk)
> -		clk_disable_unprepare(priv->aclk);
> -
> -err_regulator_disable:
> -	regulator_disable(priv->vref);
> +err_hw_stop:
> +	stm32_adc_core_hw_stop(dev);
> +err_pm_stop:
> +	pm_runtime_disable(dev);
> +	pm_runtime_set_suspended(dev);
> +	pm_runtime_put_noidle(dev);
>  
>  	return ret;
>  }
> @@ -502,17 +549,39 @@ static int stm32_adc_remove(struct platform_device *pdev)
>  	struct stm32_adc_common *common = platform_get_drvdata(pdev);
>  	struct stm32_adc_priv *priv = to_stm32_adc_priv(common);
>  
> +	pm_runtime_get_sync(&pdev->dev);
>  	of_platform_depopulate(&pdev->dev);
>  	stm32_adc_irq_remove(pdev, priv);
> -	if (priv->bclk)
> -		clk_disable_unprepare(priv->bclk);
> -	if (priv->aclk)
> -		clk_disable_unprepare(priv->aclk);
> -	regulator_disable(priv->vref);
> +	stm32_adc_core_hw_stop(&pdev->dev);
> +	pm_runtime_disable(&pdev->dev);
> +	pm_runtime_set_suspended(&pdev->dev);
> +	pm_runtime_put_noidle(&pdev->dev);
>  
>  	return 0;
>  }
>  
> +#if defined(CONFIG_PM)
> +static int stm32_adc_core_runtime_suspend(struct device *dev)
> +{
> +	stm32_adc_core_hw_stop(dev);
> +
> +	return 0;
> +}
> +
> +static int stm32_adc_core_runtime_resume(struct device *dev)
> +{
> +	return stm32_adc_core_hw_start(dev);
> +}
> +#endif
> +
> +static const struct dev_pm_ops stm32_adc_core_pm_ops = {
> +	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
> +				pm_runtime_force_resume)
> +	SET_RUNTIME_PM_OPS(stm32_adc_core_runtime_suspend,
> +			   stm32_adc_core_runtime_resume,
> +			   NULL)
> +};
> +
>  static const struct stm32_adc_priv_cfg stm32f4_adc_priv_cfg = {
>  	.regs = &stm32f4_adc_common_regs,
>  	.clk_sel = stm32f4_adc_clk_sel,
> @@ -552,6 +621,7 @@ static int stm32_adc_remove(struct platform_device *pdev)
>  	.driver = {
>  		.name = "stm32-adc-core",
>  		.of_match_table = stm32_adc_of_match,
> +		.pm = &stm32_adc_core_pm_ops,
>  	},
>  };
>  module_platform_driver(stm32_adc_driver);
> diff --git a/drivers/iio/adc/stm32-adc.c b/drivers/iio/adc/stm32-adc.c
> index dca8733..32c9c61 100644
> --- a/drivers/iio/adc/stm32-adc.c
> +++ b/drivers/iio/adc/stm32-adc.c
> @@ -22,6 +22,7 @@
>  #include <linux/iopoll.h>
>  #include <linux/module.h>
>  #include <linux/platform_device.h>
> +#include <linux/pm_runtime.h>
>  #include <linux/of.h>
>  #include <linux/of_device.h>
>  
> @@ -148,6 +149,7 @@ enum stm32h7_adc_dmngt {
>  #define STM32_ADC_MAX_SMP		7	/* SMPx range is [0..7] */
>  #define STM32_ADC_TIMEOUT_US		100000
>  #define STM32_ADC_TIMEOUT	(msecs_to_jiffies(STM32_ADC_TIMEOUT_US / 1000))
> +#define STM32_ADC_HW_STOP_DELAY_MS	100
>  
>  #define STM32_DMA_BUFFER_SIZE		PAGE_SIZE
>  
> @@ -623,6 +625,47 @@ static void stm32_adc_set_res(struct stm32_adc *adc)
>  	stm32_adc_writel(adc, res->reg, val);
>  }
>  
> +static int stm32_adc_hw_stop(struct device *dev)
> +{
> +	struct stm32_adc *adc = dev_get_drvdata(dev);
> +
> +	if (adc->cfg->unprepare)
> +		adc->cfg->unprepare(adc);
> +
> +	if (adc->clk)
> +		clk_disable_unprepare(adc->clk);
> +
> +	return 0;
> +}
> +
> +static int stm32_adc_hw_start(struct device *dev)
> +{
> +	struct stm32_adc *adc = dev_get_drvdata(dev);
> +	int ret;
> +
> +	if (adc->clk) {
> +		ret = clk_prepare_enable(adc->clk);
> +		if (ret)
> +			return ret;
> +	}
> +
> +	stm32_adc_set_res(adc);
> +
> +	if (adc->cfg->prepare) {
> +		ret = adc->cfg->prepare(adc);
> +		if (ret)
> +			goto err_clk_dis;
> +	}
> +
> +	return 0;
> +
> +err_clk_dis:
> +	if (adc->clk)
> +		clk_disable_unprepare(adc->clk);
> +
> +	return ret;
> +}
> +
>  /**
>   * stm32f4_adc_start_conv() - Start conversions for regular channels.
>   * @adc: stm32 adc instance
> @@ -1171,6 +1214,7 @@ static int stm32_adc_single_conv(struct iio_dev *indio_dev,
>  				 int *res)
>  {
>  	struct stm32_adc *adc = iio_priv(indio_dev);
> +	struct device *dev = indio_dev->dev.parent;
>  	const struct stm32_adc_regspec *regs = adc->cfg->regs;
>  	long timeout;
>  	u32 val;
> @@ -1180,10 +1224,10 @@ static int stm32_adc_single_conv(struct iio_dev *indio_dev,
>  
>  	adc->bufi = 0;
>  
> -	if (adc->cfg->prepare) {
> -		ret = adc->cfg->prepare(adc);
> -		if (ret)
> -			return ret;
> +	ret = pm_runtime_get_sync(dev);
> +	if (ret < 0) {
> +		pm_runtime_put_noidle(dev);
> +		return ret;
>  	}
>  
>  	/* Apply sampling time settings */
> @@ -1221,8 +1265,8 @@ static int stm32_adc_single_conv(struct iio_dev *indio_dev,
>  
>  	stm32_adc_conv_irq_disable(adc);
>  
> -	if (adc->cfg->unprepare)
> -		adc->cfg->unprepare(adc);
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
>  
>  	return ret;
>  }
> @@ -1330,15 +1374,22 @@ static int stm32_adc_update_scan_mode(struct iio_dev *indio_dev,
>  				      const unsigned long *scan_mask)
>  {
>  	struct stm32_adc *adc = iio_priv(indio_dev);
> +	struct device *dev = indio_dev->dev.parent;
>  	int ret;
>  
> +	ret = pm_runtime_get_sync(dev);
> +	if (ret < 0) {
> +		pm_runtime_put_noidle(dev);
> +		return ret;
> +	}
> +
>  	adc->num_conv = bitmap_weight(scan_mask, indio_dev->masklength);
>  
>  	ret = stm32_adc_conf_scan_seq(indio_dev, scan_mask);
> -	if (ret)
> -		return ret;
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
>  
> -	return 0;
> +	return ret;
>  }
>  
>  static int stm32_adc_of_xlate(struct iio_dev *indio_dev,
> @@ -1368,12 +1419,23 @@ static int stm32_adc_debugfs_reg_access(struct iio_dev *indio_dev,
>  					unsigned *readval)
>  {
>  	struct stm32_adc *adc = iio_priv(indio_dev);
> +	struct device *dev = indio_dev->dev.parent;
> +	int ret;
> +
> +	ret = pm_runtime_get_sync(dev);
> +	if (ret < 0) {
> +		pm_runtime_put_noidle(dev);
> +		return ret;
> +	}
>  
>  	if (!readval)
>  		stm32_adc_writel(adc, reg, writeval);
>  	else
>  		*readval = stm32_adc_readl(adc, reg);
>  
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
> +
>  	return 0;
>  }
>  
> @@ -1459,18 +1521,19 @@ static int stm32_adc_dma_start(struct iio_dev *indio_dev)
>  static int stm32_adc_buffer_postenable(struct iio_dev *indio_dev)
>  {
>  	struct stm32_adc *adc = iio_priv(indio_dev);
> +	struct device *dev = indio_dev->dev.parent;
>  	int ret;
>  
> -	if (adc->cfg->prepare) {
> -		ret = adc->cfg->prepare(adc);
> -		if (ret)
> -			return ret;
> +	ret = pm_runtime_get_sync(dev);
> +	if (ret < 0) {
> +		pm_runtime_put_noidle(dev);
> +		return ret;
>  	}
>  
>  	ret = stm32_adc_set_trig(indio_dev, indio_dev->trig);
>  	if (ret) {
>  		dev_err(&indio_dev->dev, "Can't set trigger\n");
> -		goto err_unprepare;
> +		goto err_pm_put;
>  	}
>  
>  	ret = stm32_adc_dma_start(indio_dev);
> @@ -1498,9 +1561,9 @@ static int stm32_adc_buffer_postenable(struct iio_dev *indio_dev)
>  		dmaengine_terminate_all(adc->dma_chan);
>  err_clr_trig:
>  	stm32_adc_set_trig(indio_dev, NULL);
> -err_unprepare:
> -	if (adc->cfg->unprepare)
> -		adc->cfg->unprepare(adc);
> +err_pm_put:
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
>  
>  	return ret;
>  }
> @@ -1508,6 +1571,7 @@ static int stm32_adc_buffer_postenable(struct iio_dev *indio_dev)
>  static int stm32_adc_buffer_predisable(struct iio_dev *indio_dev)
>  {
>  	struct stm32_adc *adc = iio_priv(indio_dev);
> +	struct device *dev = indio_dev->dev.parent;
>  	int ret;
>  
>  	adc->cfg->stop_conv(adc);
> @@ -1524,8 +1588,8 @@ static int stm32_adc_buffer_predisable(struct iio_dev *indio_dev)
>  	if (stm32_adc_set_trig(indio_dev, NULL))
>  		dev_err(&indio_dev->dev, "Can't clear trigger\n");
>  
> -	if (adc->cfg->unprepare)
> -		adc->cfg->unprepare(adc);
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
>  
>  	return ret;
>  }
> @@ -1864,26 +1928,17 @@ static int stm32_adc_probe(struct platform_device *pdev)
>  		}
>  	}
>  
> -	if (adc->clk) {
> -		ret = clk_prepare_enable(adc->clk);
> -		if (ret < 0) {
> -			dev_err(&pdev->dev, "clk enable failed\n");
> -			return ret;
> -		}
> -	}
> -
>  	ret = stm32_adc_of_get_resolution(indio_dev);
>  	if (ret < 0)
> -		goto err_clk_disable;
> -	stm32_adc_set_res(adc);
> +		return ret;
>  
>  	ret = stm32_adc_chan_of_init(indio_dev);
>  	if (ret < 0)
> -		goto err_clk_disable;
> +		return ret;
>  
>  	ret = stm32_adc_dma_request(indio_dev);
>  	if (ret < 0)
> -		goto err_clk_disable;
> +		return ret;
>  
>  	ret = iio_triggered_buffer_setup(indio_dev,
>  					 &iio_pollfunc_store_time,
> @@ -1894,15 +1949,35 @@ static int stm32_adc_probe(struct platform_device *pdev)
>  		goto err_dma_disable;
>  	}
>  
> +	/* Get stm32-adc-core PM online */
> +	pm_runtime_get_noresume(dev);
> +	pm_runtime_set_active(dev);
> +	pm_runtime_set_autosuspend_delay(dev, STM32_ADC_HW_STOP_DELAY_MS);
> +	pm_runtime_use_autosuspend(dev);
> +	pm_runtime_enable(dev);
> +
> +	ret = stm32_adc_hw_start(dev);
> +	if (ret)
> +		goto err_buffer_cleanup;
> +
>  	ret = iio_device_register(indio_dev);
>  	if (ret) {
>  		dev_err(&pdev->dev, "iio dev register failed\n");
> -		goto err_buffer_cleanup;
> +		goto err_hw_stop;
>  	}
>  
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_put_autosuspend(dev);
> +
>  	return 0;
>  
> +err_hw_stop:
> +	stm32_adc_hw_stop(dev);
> +
>  err_buffer_cleanup:
> +	pm_runtime_disable(dev);
> +	pm_runtime_set_suspended(dev);
> +	pm_runtime_put_noidle(dev);
>  	iio_triggered_buffer_cleanup(indio_dev);
>  
>  err_dma_disable:
> @@ -1912,9 +1987,6 @@ static int stm32_adc_probe(struct platform_device *pdev)
>  				  adc->rx_buf, adc->rx_dma_buf);
>  		dma_release_channel(adc->dma_chan);
>  	}
> -err_clk_disable:
> -	if (adc->clk)
> -		clk_disable_unprepare(adc->clk);
>  
>  	return ret;
>  }
> @@ -1924,7 +1996,12 @@ static int stm32_adc_remove(struct platform_device *pdev)
>  	struct stm32_adc *adc = platform_get_drvdata(pdev);
>  	struct iio_dev *indio_dev = iio_priv_to_dev(adc);
>  
> +	pm_runtime_get_sync(&pdev->dev);
>  	iio_device_unregister(indio_dev);
> +	stm32_adc_hw_stop(&pdev->dev);
> +	pm_runtime_disable(&pdev->dev);
> +	pm_runtime_set_suspended(&pdev->dev);
> +	pm_runtime_put_noidle(&pdev->dev);
>  	iio_triggered_buffer_cleanup(indio_dev);
>  	if (adc->dma_chan) {
>  		dma_free_coherent(adc->dma_chan->device->dev,
> @@ -1932,12 +2009,29 @@ static int stm32_adc_remove(struct platform_device *pdev)
>  				  adc->rx_buf, adc->rx_dma_buf);
>  		dma_release_channel(adc->dma_chan);
>  	}
> -	if (adc->clk)
> -		clk_disable_unprepare(adc->clk);
>  
>  	return 0;
>  }
>  
> +#if defined(CONFIG_PM)
> +static int stm32_adc_runtime_suspend(struct device *dev)
> +{
> +	return stm32_adc_hw_stop(dev);
> +}
> +
> +static int stm32_adc_runtime_resume(struct device *dev)
> +{
> +	return stm32_adc_hw_start(dev);
> +}
> +#endif
> +
> +static const struct dev_pm_ops stm32_adc_pm_ops = {
> +	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
> +				pm_runtime_force_resume)
> +	SET_RUNTIME_PM_OPS(stm32_adc_runtime_suspend, stm32_adc_runtime_resume,
> +			   NULL)
> +};
> +
>  static const struct stm32_adc_cfg stm32f4_adc_cfg = {
>  	.regs = &stm32f4_adc_regspec,
>  	.adc_info = &stm32f4_adc_info,
> @@ -1985,6 +2079,7 @@ static int stm32_adc_remove(struct platform_device *pdev)
>  	.driver = {
>  		.name = "stm32-adc",
>  		.of_match_table = stm32_adc_of_match,
> +		.pm = &stm32_adc_pm_ops,
>  	},
>  };
>  module_platform_driver(stm32_adc_driver);

