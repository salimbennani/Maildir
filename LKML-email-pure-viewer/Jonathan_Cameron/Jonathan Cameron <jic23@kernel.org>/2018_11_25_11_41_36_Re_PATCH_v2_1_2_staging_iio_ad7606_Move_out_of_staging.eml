Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 22:13:16 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga005.fm.intel.com (fmsmga005.fm.intel.com [10.253.24.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 8B0415802E4;
	Sun, 25 Nov 2018 03:41:51 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by fmsmga005-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 03:41:51 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AMY70ChNcLCtzxK5nJvIl6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0KPjyoMbcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Qiqp4bt1RxD0iS?=
 =?us-ascii?q?cHLz85/3/Risxsl6JQvRatqwViz4LIfI2ZMfxzdb7fc9wHX2pMRshfWSxfDI2h?=
 =?us-ascii?q?bIUADeQBM+FXoIbhqFUOtgO+CAu3CePzyDJFnGP60Lcm3+g/FwzNwQwuH8gJsH?=
 =?us-ascii?q?TRtNj7MKASUeavw6nUzTXMdfVW0irj5YfSdxAuv+uMXbV2ccHMzkQvFQLFgUmO?=
 =?us-ascii?q?pYHrJD6V1foCs3Kd7+V+UeKjkWknqxt+ojW2wMonl4fHhoUQyl/e9CV5xp44Ks?=
 =?us-ascii?q?e+SEFhZd6kF5RQuzuGOItxR8MvRXxjtiUiyrAep5K3YCwHxI46yxPRdfCLaZWE?=
 =?us-ascii?q?7xH/WOqLIDp1hmppdbGiixqo9UWty/fwWte63VtFtCZJj9bBu3ML2hfO8MaIUO?=
 =?us-ascii?q?F98V2k2TuX1wDc9OVEIUcsmKrFJJ4u3KQwmoAQsUvdBC/2nlv5jKuMekUj4Oio?=
 =?us-ascii?q?5PzrYrTgppCCK495kh/yPrgql8ClHOg1PBYCU3KG9em/yLHv50z0TbdSgv0ziK?=
 =?us-ascii?q?bZsZTaJcoBpq6+Bg9YyoIj6xe5Dze739UUhHoHI0xfeBKBkYfpP0jCIPf2DPe5?=
 =?us-ascii?q?nVusiixmx+7JPrL/GJXBNHvDn6n7fbZ79UFczBA/zddF55JbEr0BOu78WlfttN?=
 =?us-ascii?q?zECR80Kwi0w+fkCNpjzI8fVn+PD7SdMKPTt1+I++0uL/ONZI8TpDbyNfwl6+Ty?=
 =?us-ascii?q?gn8+nF8XZbOp0ocPaHCkAvRmJF2UYXr2jdcADWcFpA0+QPbqiF2fSzFTYXmyUr?=
 =?us-ascii?q?k45jE6DoKmEIjCSpqsgLyHwCe0AJlWanpaBVCLFHfib5+EVOsUaCKOPs9hlSQJ?=
 =?us-ascii?q?VbqmS4A/zx2utwj6y7xhLurT4SAYsZPj1N5o5+zcjx0y9Dp0D9iD3GGJVW17gm?=
 =?us-ascii?q?QIRzou1qBlvUN90kuD0bR/g/FAD9NT/PNJUgA5NZLG1ex1EdLyVxnFfteITlam?=
 =?us-ascii?q?X9qnDSswTtI3398BfUJ9F8++gRDE2iqgG6UVmKCTBJwo7qLc2GD8J8VnxHbAzq?=
 =?us-ascii?q?Uhi1gmTdFJNW2pnaN/8wnTB4jUk0SWjaqqdKIc3DLT+2eH12aBoEZYUAtoW6Xf?=
 =?us-ascii?q?QX8fflfWrcj+5k7aUrChE6onPRVbxc6CMKRKbMbpgktARPvkPNTeYGexm2OrCB?=
 =?us-ascii?q?aMx7OMapfqemoH0CXcDkgEjx4c/XKcOQciASehpnrUDCZyGlL3f0Ps7e5+pWum?=
 =?us-ascii?q?QUAu0QGFcVdt17qv9R4TnvyTVfUT06kAuCcgrTV0AVm808jXC9qGuwpuYqFcbc?=
 =?us-ascii?q?kh71dA0GLTrxZ9MYC4L6B+ml4edBx6v1/v1xVyDYVAjcgqrXMwwApuM66Y10lB?=
 =?us-ascii?q?dzeZ3ZD2Nb3aMW3y/BGpa67L1VDSyteW+qET6Psmr1Xvph2mFk0n839/ydlaz2?=
 =?us-ascii?q?Oc5onWDAoVSZ/+SEI3+AZ1pr7EYigx/Zjb1WBxPqautD/C2NUpBPU+xxakftdf?=
 =?us-ascii?q?Nr6EFQDoH80bAciuNPIlm1yzYh0YO+BS8bY+P9m6ePuexK6rIOFgkSqmjGRa+o?=
 =?us-ascii?q?xyzliA9it8SuHS2ZYFzOqV3g+GVzf6kVegvdr7mYFCZTEOAGW/zTLoC5JWZq13?=
 =?us-ascii?q?ZYwLE3uhI9WrxtVigJ7gQ2RY9F+/CFwcws+mZB2SY0b73QJOz0QXoGWrljeiwD?=
 =?us-ascii?q?xwjj4msLCf3CvIw+n5cBoHO2hLRHRtjFv2IIi0icwaU1asbwQziBSl4kP6zbBB?=
 =?us-ascii?q?pKtjN2nTXVtIfy/uImBiU6u8rLqDb9RU6JM1tyVaS+C8YVGcSr7grBoWySLjH2?=
 =?us-ascii?q?1CxD8lczGmoIn2nxt/iGiFNnZ8sGLZed1sxRfY/NHcR+Re3iAFRCl7jjnbHEO8?=
 =?us-ascii?q?MMOq/dWXlpfDtP6xV2S6W51XcCnry56AtSSh6W1rBx2/g+68mtn9HQcm1i/70s?=
 =?us-ascii?q?FgVT/Uoxbkfonry6O6PPpnf0ZyA1/w8ch6GoB4koYrgJEQ2H4ahoia/HYdkGfz?=
 =?us-ascii?q?N8lb1rz6bHYXWTELxNvV6hD/2EJ/NnKJ2575VnKFz8tifda6Y3ka2iIg789QDq?=
 =?us-ascii?q?eU46dJnS90olq+sALQbuJxnjYbyfsy9nEah/sFtxYqziWYGroSB1VXPTTwlxSU?=
 =?us-ascii?q?6NCztKBXZGescbeqzkZ/k86uDKqeog5CQnb2YYktHTV/7shkNFLM0Xvz6pzred?=
 =?us-ascii?q?XKbNITsAGUnAnEj+RPNJ0xkf8KjzJ9OW3hpX0l1/I7jRt20JGmu4iHLn9h/aOj?=
 =?us-ascii?q?DR5eKz31fNgT+jD2gKZan8aW2Z2vH5p7FjUKWpvoUeynEDYIufv7MAaOFSU2qm?=
 =?us-ascii?q?2HFrrHAQ+f9EBmomrUHJ+xMHGXIGQZwc9mRBmAP0FfhAEUXDMnnp82DAyqxcrh?=
 =?us-ascii?q?cFtn6TAV/FL3thxMyudwPRnlTmjfvBuoaiszSJWHLhpZ9ARC6FnOMcCE8uJ/BS?=
 =?us-ascii?q?JY/oCirAyQLGyUfR9IAHoNWkyFAVDjI7av6cPB8+ieGuqxMf/Oba+SpuxZUveC?=
 =?us-ascii?q?3Yiv3Zd+/zaQKsWPOWFvDv082kpeRHB5Bt7WmzMVRywMkCLNacGbqQy4+i12qM?=
 =?us-ascii?q?C/7fvqVBju5YuJF7tdL9Fv9wqqjqeEMu6anDx5JipA1pMQ2X/Iz6AS3F4MhCFv?=
 =?us-ascii?q?dDmtErUAuTTOTKLKna9XAAAUazluNMtT9K882ghNOcjGitL6zLJ4j/g1C0tbWl?=
 =?us-ascii?q?zlgM2mecsKI2SlPlPdGEmLLKiGJSHMw8zve6y8VKZfjP9KuBywozqbF07jMy+H?=
 =?us-ascii?q?lznoURCvLO5NgDuaPBxYpIGybBJtBXL/Q9Lhbx2xKMV3giEuwb0omnPKMnYRMS?=
 =?us-ascii?q?R9c0NItLGf8TlUjel/G2Nf6HpoNu2Emyef7+nFJZcaq/prAiJol+1E5HQ20ada?=
 =?us-ascii?q?7CZBRPZtgivdssZuo026kumI0jdmUABBqjBOhIKKu0VtIaTY9plaVnbC8xIA9m?=
 =?us-ascii?q?GQCxUMp9t4BdzjoaFQyt7TlK3tLDdO6c7b/cwZB5ucFMXSC2YsPxPvUAbTFAJN?=
 =?us-ascii?q?GSW3OG/WgQpFl+mb3nSTp5w9pd7nn59YGZFBU1lgNPQcA1hlFdpKC55yUykjl/?=
 =?us-ascii?q?bPjs8DvyGWrxTLQshe+JfdWaTBUr3UND+FgOwcNFMzyrTiINFWb9Wj1g=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AaAABMifpbh0O0hNFjHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBgmmBAieMEV+LIFABAQaBNRSJBoRqiTgUgWMQGAsIAYhaIjQJDQE?=
 =?us-ascii?q?DAQEBAQEBAgETAQEBCA0JCCkjDII2JAGCYgECAgEBAhcBDBMGAQEjFAEEAQkBA?=
 =?us-ascii?q?QohJQMMSAYKCQUPgw0BgXQFCAQBCqVRgWwzgnYBAQWHEwiII4JKgRyBD4EHEn+?=
 =?us-ascii?q?DEoRDHwQBDIVmgSwBAYdtCiiBRoQIQ4ECjk9UAQYCAYZ8gy2GeyMKgU+ILocBh?=
 =?us-ascii?q?1SFb4ptgUaCDTMaMIFhgU4JghIMF4NKhRSFPkAygQIDAQEhE4lrK4IgAQE?=
X-IPAS-Result: =?us-ascii?q?A0AaAABMifpbh0O0hNFjHAEBAQQBAQcEAQGBUQcBAQsBgmm?=
 =?us-ascii?q?BAieMEV+LIFABAQaBNRSJBoRqiTgUgWMQGAsIAYhaIjQJDQEDAQEBAQEBAgETA?=
 =?us-ascii?q?QEBCA0JCCkjDII2JAGCYgECAgEBAhcBDBMGAQEjFAEEAQkBAQohJQMMSAYKCQU?=
 =?us-ascii?q?Pgw0BgXQFCAQBCqVRgWwzgnYBAQWHEwiII4JKgRyBD4EHEn+DEoRDHwQBDIVmg?=
 =?us-ascii?q?SwBAYdtCiiBRoQIQ4ECjk9UAQYCAYZ8gy2GeyMKgU+ILocBh1SFb4ptgUaCDTM?=
 =?us-ascii?q?aMIFhgU4JghIMF4NKhRSFPkAygQIDAQEhE4lrK4IgAQE?=
X-IronPort-AV: E=Sophos;i="5.56,277,1539673200"; 
   d="scan'208";a="52515126"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 03:41:49 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726458AbeKYWch (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 25 Nov 2018 17:32:37 -0500
Received: from mail.kernel.org ([198.145.29.99]:36026 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726023AbeKYWch (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 25 Nov 2018 17:32:37 -0500
Received: from archlinux (cpc91196-cmbg18-2-0-cust659.5-4.cable.virginm.net [81.96.234.148])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id C47C720865;
        Sun, 25 Nov 2018 11:41:39 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1543146101;
        bh=MFGtYUbMPPbGg/ceZzPgf9fqCgtVatwV1Cgy/Bqv3Bc=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=Iy5rhAQ5JT8xt0voKoHtQx33oJIHAbEL5dDFwtu1fJotGr6D6WEh59JTpa2D0SvCq
         2M04lJMwDuDAgellut5bG+OLGhlDj/CjJqfFWA3Jo63glyrDIWudM9QDfU1eO5MfaZ
         RtKOIo66NOLX7PKVCFQYdKRMwonTUg1LZGKgTitg=
Date: Sun, 25 Nov 2018 11:41:36 +0000
From: Jonathan Cameron <jic23@kernel.org>
To: Stefan Popa <stefan.popa@analog.com>
Cc: <Michael.Hennerich@analog.com>, <knaack.h@gmx.de>,
        <lars@metafoo.de>, <pmeerw@pmeerw.net>,
        <gregkh@linuxfoundation.org>, <linux-kernel@vger.kernel.org>,
        <linux-iio@vger.kernel.org>, <devel@driverdev.osuosl.org>
Subject: Re: [PATCH v2 1/2] staging: iio: ad7606: Move out of staging
Message-ID: <20181125114136.30a98e8f@archlinux>
In-Reply-To: <1542728626-25770-1-git-send-email-stefan.popa@analog.com>
References: <1542728626-25770-1-git-send-email-stefan.popa@analog.com>
X-Mailer: Claws Mail 3.17.1 (GTK+ 2.24.32; x86_64-pc-linux-gnu)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, 20 Nov 2018 17:43:46 +0200
Stefan Popa <stefan.popa@analog.com> wrote:

> Move ad7606 ADC driver out of staging and into the mainline.
> 
> Signed-off-by: Stefan Popa <stefan.popa@analog.com>

One idle thought, how much would the performance suffer if we moved
the parallel path over to the new gpiod_get/set_raw_array_value and friends?

If would relax some of the constraints on where this could be used.

There are some ordering issues in probe that need fixing.

There are also a few places where it feels 'racey' and might
need more comments to say why data is definitely ready when we try
to read it for example.

So nearly there, but one more cleanup series I think!

Thanks,

Jonathan


> ---
> Changes in v2:
> 	- Simplified the Kconfig menu.
> 	- Added SPDX-License-Identifier.
> 	- Ordered the includes alphabetically.
> 	- Used a threaded interrupt.
> 	- Replaced ad7606_poll_bh_to_ring() with ad7606_trigger_handler().
> 	- Used a trigger. 
> 	- Replaced wait_event_interruptible() with wait_for_completion_timeout().
> 	- Replaced wake_up_interruptible() with complete().
> 	- Used devm_iio_triggered_buffer_setup().
> 	- Added buffer_ops.
> 	- Used single line comments where needed.
> 	- Removed the gap between docs and struct.
> 	- Added ad7606_of_match[].
> 
>  MAINTAINERS                          |   7 +
>  drivers/iio/adc/Kconfig              |  28 ++
>  drivers/iio/adc/Makefile             |   3 +
>  drivers/iio/adc/ad7606.c             | 608 +++++++++++++++++++++++++++++++++++
>  drivers/iio/adc/ad7606.h             | 107 ++++++
>  drivers/iio/adc/ad7606_par.c         | 110 +++++++
>  drivers/iio/adc/ad7606_spi.c         |  88 +++++
>  drivers/staging/iio/adc/Kconfig      |  34 --
>  drivers/staging/iio/adc/Makefile     |   3 -
>  drivers/staging/iio/adc/ad7606.c     | 565 --------------------------------
>  drivers/staging/iio/adc/ad7606.h     | 106 ------
>  drivers/staging/iio/adc/ad7606_par.c | 113 -------
>  drivers/staging/iio/adc/ad7606_spi.c |  79 -----
>  13 files changed, 951 insertions(+), 900 deletions(-)
>  create mode 100644 drivers/iio/adc/ad7606.c
>  create mode 100644 drivers/iio/adc/ad7606.h
>  create mode 100644 drivers/iio/adc/ad7606_par.c
>  create mode 100644 drivers/iio/adc/ad7606_spi.c
>  delete mode 100644 drivers/staging/iio/adc/ad7606.c
>  delete mode 100644 drivers/staging/iio/adc/ad7606.h
>  delete mode 100644 drivers/staging/iio/adc/ad7606_par.c
>  delete mode 100644 drivers/staging/iio/adc/ad7606_spi.c
> 
> diff --git a/MAINTAINERS b/MAINTAINERS
> index f642044..843545d 100644
> --- a/MAINTAINERS
> +++ b/MAINTAINERS
> @@ -839,6 +839,13 @@ S:	Supported
>  F:	drivers/iio/dac/ad5758.c
>  F:	Documentation/devicetree/bindings/iio/dac/ad5758.txt
>  
> +ANALOG DEVICES INC AD7606 DRIVER
> +M:	Stefan Popa <stefan.popa@analog.com>
> +L:	linux-iio@vger.kernel.org
> +W:	http://ez.analog.com/community/linux-device-drivers
> +S:	Supported
> +F:	drivers/iio/adc/ad7606.c
> +
>  ANALOG DEVICES INC AD9389B DRIVER
>  M:	Hans Verkuil <hans.verkuil@cisco.com>
>  L:	linux-media@vger.kernel.org
> diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
> index a52fea8..c3f61c9 100644
> --- a/drivers/iio/adc/Kconfig
> +++ b/drivers/iio/adc/Kconfig
> @@ -58,6 +58,34 @@ config AD7476
>  	  To compile this driver as a module, choose M here: the
>  	  module will be called ad7476.
>  
> +config AD7606
> +	tristate
> +	depends on GPIOLIB || COMPILE_TEST
> +	depends on HAS_IOMEM
> +	select IIO_BUFFER
> +	select IIO_TRIGGERED_BUFFER
> +
> +config AD7606_IFACE_PARALLEL
> +	tristate "Analog Devices AD7606 ADC driver with parallel interface support"
> +	select AD7606
> +	help
> +	  Say yes here to build parallel interface support for Analog Devices:
> +	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
> +
> +	  To compile this driver as a module, choose M here: the
> +	  module will be called ad7606_parallel.
> +
> +config AD7606_IFACE_SPI
> +	tristate "Analog Devices AD7606 ADC driver with spi interface support"
> +	depends on SPI
> +	select AD7606
> +	help
> +	  Say yes here to build spi interface support for Analog Devices:
> +	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
> +
> +	  To compile this driver as a module, choose M here: the
> +	  module will be called ad7606_spi.
> +
>  config AD7766
>  	tristate "Analog Devices AD7766/AD7767 ADC driver"
>  	depends on SPI_MASTER
> diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
> index a6e6a0b..b734f4f 100644
> --- a/drivers/iio/adc/Makefile
> +++ b/drivers/iio/adc/Makefile
> @@ -8,6 +8,9 @@ obj-$(CONFIG_AD_SIGMA_DELTA) += ad_sigma_delta.o
>  obj-$(CONFIG_AD7266) += ad7266.o
>  obj-$(CONFIG_AD7291) += ad7291.o
>  obj-$(CONFIG_AD7298) += ad7298.o
> +obj-$(CONFIG_AD7606_IFACE_PARALLEL) += ad7606_par.o
> +obj-$(CONFIG_AD7606_IFACE_SPI) += ad7606_spi.o
> +obj-$(CONFIG_AD7606) += ad7606.o
>  obj-$(CONFIG_AD7923) += ad7923.o
>  obj-$(CONFIG_AD7476) += ad7476.o
>  obj-$(CONFIG_AD7766) += ad7766.o
> diff --git a/drivers/iio/adc/ad7606.c b/drivers/iio/adc/ad7606.c
> new file mode 100644
> index 0000000..4e09635
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606.c
> @@ -0,0 +1,608 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +/*
> + * AD7606 SPI ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#include <linux/delay.h>
> +#include <linux/device.h>
> +#include <linux/err.h>
> +#include <linux/gpio/consumer.h>
> +#include <linux/interrupt.h>
> +#include <linux/kernel.h>
> +#include <linux/module.h>
> +#include <linux/regulator/consumer.h>
> +#include <linux/sched.h>
> +#include <linux/slab.h>
> +#include <linux/sysfs.h>
> +
> +#include <linux/iio/iio.h>
> +#include <linux/iio/buffer.h>
> +#include <linux/iio/sysfs.h>
> +#include <linux/iio/trigger.h>
> +#include <linux/iio/triggered_buffer.h>
> +#include <linux/iio/trigger_consumer.h>
> +
> +#include "ad7606.h"
> +
> +/*
> + * Scales are computed as 5000/32768 and 10000/32768 respectively,
> + * so that when applied to the raw values they provide mV values
> + */
> +static const unsigned int scale_avail[2][2] = {
> +	{0, 152588}, {0, 305176}
> +};
> +
> +static int ad7606_reset(struct ad7606_state *st)
> +{
> +	if (st->gpio_reset) {
> +		gpiod_set_value(st->gpio_reset, 1);
> +		ndelay(100); /* t_reset >= 100ns */
> +		gpiod_set_value(st->gpio_reset, 0);
> +		return 0;
> +	}
> +
> +	return -ENODEV;
> +}
> +
> +static int ad7606_read_samples(struct ad7606_state *st)
> +{
> +	unsigned int num = st->chip_info->num_channels;
> +	u16 *data = st->data;
> +	int ret;
> +
> +	/*
> +	 * The frstdata signal is set to high while and after reading the sample
> +	 * of the first channel and low for all other channels. This can be used
> +	 * to check that the incoming data is correctly aligned. During normal
> +	 * operation the data should never become unaligned, but some glitch or
> +	 * electrostatic discharge might cause an extra read or clock cycle.
> +	 * Monitoring the frstdata signal allows to recover from such failure
> +	 * situations.
> +	 */
> +
> +	if (st->gpio_frstdata) {
> +		ret = st->bops->read_block(st->dev, 1, data);
> +		if (ret)
> +			return ret;
> +
> +		if (!gpiod_get_value(st->gpio_frstdata)) {
> +			ad7606_reset(st);
> +			return -EIO;
> +		}
> +
> +		data++;
> +		num--;
> +	}
> +
> +	return st->bops->read_block(st->dev, num, data);
> +}
> +
> +static irqreturn_t ad7606_trigger_handler(int irq, void *p)
> +{
> +	struct iio_poll_func *pf = p;
> +	struct iio_dev *indio_dev = pf->indio_dev;
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int ret;
> +
> +	mutex_lock(&st->lock);
> +
> +	ret = ad7606_read_samples(st);
> +	if (ret == 0)
> +		iio_push_to_buffers_with_timestamp(indio_dev, st->data,
> +						   iio_get_time_ns(indio_dev));
> +
> +	gpiod_set_value(st->gpio_convst, 0);
> +	iio_trigger_notify_done(indio_dev->trig);
> +
> +	mutex_unlock(&st->lock);
> +
> +	return IRQ_HANDLED;
> +}
> +
> +static int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned int ch)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int ret;
> +
> +	gpiod_set_value(st->gpio_convst, 1);
> +	ret = wait_for_completion_timeout(&st->completion,
> +					  msecs_to_jiffies(1000));
> +	if (!ret) {
> +		ret = -ETIMEDOUT;
> +		goto error_ret;
> +	}
> +
> +	ret = ad7606_read_samples(st);
> +	if (ret == 0)
> +		ret = st->data[ch];
> +
> +error_ret:
> +	gpiod_set_value(st->gpio_convst, 0);
> +
> +	return ret;
> +}
> +
> +static int ad7606_read_raw(struct iio_dev *indio_dev,
> +			   struct iio_chan_spec const *chan,
> +			   int *val,
> +			   int *val2,
> +			   long m)
> +{
> +	int ret;
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	switch (m) {
> +	case IIO_CHAN_INFO_RAW:
> +		ret = iio_device_claim_direct_mode(indio_dev);
> +		if (ret)
> +			return ret;
> +
> +		ret = ad7606_scan_direct(indio_dev, chan->address);
> +		iio_device_release_direct_mode(indio_dev);
> +
> +		if (ret < 0)
> +			return ret;
> +		*val = (short)ret;
> +		return IIO_VAL_INT;
> +	case IIO_CHAN_INFO_SCALE:
> +		*val = scale_avail[st->range][0];
> +		*val2 = scale_avail[st->range][1];
> +		return IIO_VAL_INT_PLUS_MICRO;
> +	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
> +		*val = st->oversampling;
> +		return IIO_VAL_INT;
> +	}
> +	return -EINVAL;
> +}
> +
> +static ssize_t in_voltage_scale_available_show(struct device *dev,
> +					       struct device_attribute *attr,
> +					       char *buf)
> +{
> +	int i, len = 0;
> +
> +	for (i = 0; i < ARRAY_SIZE(scale_avail); i++)
> +		len += scnprintf(buf + len, PAGE_SIZE - len, "%d.%06u ",
> +				 scale_avail[i][0], scale_avail[i][1]);
> +
> +	buf[len - 1] = '\n';
> +
> +	return len;
> +}
> +
> +static IIO_DEVICE_ATTR_RO(in_voltage_scale_available, 0);
> +
> +static int ad7606_oversampling_get_index(unsigned int val)
> +{
> +	unsigned char supported[] = {1, 2, 4, 8, 16, 32, 64};
> +	int i;
> +
> +	for (i = 0; i < ARRAY_SIZE(supported); i++)
> +		if (val == supported[i])
> +			return i;
> +
> +	return -EINVAL;
> +}
> +
> +static int ad7606_write_raw(struct iio_dev *indio_dev,
> +			    struct iio_chan_spec const *chan,
> +			    int val,
> +			    int val2,
> +			    long mask)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int values[3];
> +	int ret, i;
> +
> +	switch (mask) {
> +	case IIO_CHAN_INFO_SCALE:
> +		ret = -EINVAL;
> +		mutex_lock(&st->lock);
> +		for (i = 0; i < ARRAY_SIZE(scale_avail); i++)
> +			if (val2 == scale_avail[i][1]) {
> +				gpiod_set_value(st->gpio_range, i);
> +				st->range = i;
> +
> +				ret = 0;
> +				break;
> +			}
> +		mutex_unlock(&st->lock);
> +
> +		return ret;
> +	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
> +		if (val2)
> +			return -EINVAL;
> +		ret = ad7606_oversampling_get_index(val);
> +		if (ret < 0)
> +			return ret;
> +
> +		values[0] = (ret >> 0) & 1;
> +		values[1] = (ret >> 1) & 1;
> +		values[2] = (ret >> 2) & 1;
> +
> +		mutex_lock(&st->lock);
> +		gpiod_set_array_value(ARRAY_SIZE(values), st->gpio_os->desc,
> +				      values);
> +		st->oversampling = val;
> +		mutex_unlock(&st->lock);
> +
> +		return 0;
> +	default:
> +		return -EINVAL;
> +	}
> +}
> +
> +static IIO_CONST_ATTR(oversampling_ratio_available, "1 2 4 8 16 32 64");
> +
> +static struct attribute *ad7606_attributes_os_and_range[] = {
> +	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
> +	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group ad7606_attribute_group_os_and_range = {
> +	.attrs = ad7606_attributes_os_and_range,
> +};
> +
> +static struct attribute *ad7606_attributes_os[] = {
> +	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group ad7606_attribute_group_os = {
> +	.attrs = ad7606_attributes_os,
> +};
> +
> +static struct attribute *ad7606_attributes_range[] = {
> +	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group ad7606_attribute_group_range = {
> +	.attrs = ad7606_attributes_range,
> +};
> +
> +#define AD760X_CHANNEL(num, mask) {				\
> +		.type = IIO_VOLTAGE,				\
> +		.indexed = 1,					\
> +		.channel = num,					\
> +		.address = num,					\
> +		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
> +		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\
> +		.info_mask_shared_by_all = mask,		\
> +		.scan_index = num,				\
> +		.scan_type = {					\
> +			.sign = 's',				\
> +			.realbits = 16,				\
> +			.storagebits = 16,			\
> +			.endianness = IIO_BE,			\

Is that true?  It looks to me like you are doing the endian unwinding
in the read block functions.

> +		},						\
> +}
> +
> +#define AD7605_CHANNEL(num)	\
> +	AD760X_CHANNEL(num, 0)
> +
> +#define AD7606_CHANNEL(num)	\
> +	AD760X_CHANNEL(num, BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO))
> +
> +static const struct iio_chan_spec ad7605_channels[] = {
> +	IIO_CHAN_SOFT_TIMESTAMP(4),
> +	AD7605_CHANNEL(0),
> +	AD7605_CHANNEL(1),
> +	AD7605_CHANNEL(2),
> +	AD7605_CHANNEL(3),
> +};
> +
> +static const struct iio_chan_spec ad7606_channels[] = {
> +	IIO_CHAN_SOFT_TIMESTAMP(8),
> +	AD7606_CHANNEL(0),
> +	AD7606_CHANNEL(1),
> +	AD7606_CHANNEL(2),
> +	AD7606_CHANNEL(3),
> +	AD7606_CHANNEL(4),
> +	AD7606_CHANNEL(5),
> +	AD7606_CHANNEL(6),
> +	AD7606_CHANNEL(7),
> +};
> +
> +static const struct ad7606_chip_info ad7606_chip_info_tbl[] = {
> +	/* More devices added in future */
> +	[ID_AD7605_4] = {
> +		.channels = ad7605_channels,
> +		.num_channels = 5,
> +	},
> +	[ID_AD7606_8] = {
> +		.channels = ad7606_channels,
> +		.num_channels = 9,
> +		.has_oversampling = true,
> +	},
> +	[ID_AD7606_6] = {
> +		.channels = ad7606_channels,
> +		.num_channels = 7,
> +		.has_oversampling = true,
> +	},
> +	[ID_AD7606_4] = {
> +		.channels = ad7606_channels,
> +		.num_channels = 5,
> +		.has_oversampling = true,
> +	},
> +};
> +
> +static int ad7606_request_gpios(struct ad7606_state *st)
> +{
> +	struct device *dev = st->dev;
> +
> +	st->gpio_convst = devm_gpiod_get(dev, "adi,conversion-start",
> +					 GPIOD_OUT_LOW);
> +	if (IS_ERR(st->gpio_convst))
> +		return PTR_ERR(st->gpio_convst);
> +
> +	st->gpio_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
> +	if (IS_ERR(st->gpio_reset))
> +		return PTR_ERR(st->gpio_reset);
> +
> +	st->gpio_range = devm_gpiod_get_optional(dev, "adi,range",
> +						 GPIOD_OUT_LOW);
> +	if (IS_ERR(st->gpio_range))
> +		return PTR_ERR(st->gpio_range);
> +
> +	st->gpio_standby = devm_gpiod_get_optional(dev, "standby",
> +						   GPIOD_OUT_HIGH);
> +	if (IS_ERR(st->gpio_standby))
> +		return PTR_ERR(st->gpio_standby);
> +
> +	st->gpio_frstdata = devm_gpiod_get_optional(dev, "adi,first-data",
> +						    GPIOD_IN);
> +	if (IS_ERR(st->gpio_frstdata))
> +		return PTR_ERR(st->gpio_frstdata);
> +
> +	if (!st->chip_info->has_oversampling)
> +		return 0;
> +
> +	st->gpio_os = devm_gpiod_get_array_optional(dev, "oversampling-ratio",
> +			GPIOD_OUT_LOW);
> +	return PTR_ERR_OR_ZERO(st->gpio_os);
> +}
> +
> +/* Interrupt handler */

What interrupt this is handling is a bit less than obvious.  Perhaps
some more detailed comments?

> +static irqreturn_t ad7606_interrupt(int irq, void *dev_id)
> +{
> +	struct iio_dev *indio_dev = dev_id;
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (iio_buffer_enabled(indio_dev)) {
> +		gpiod_set_value(st->gpio_convst, 1);
When is the conversion done?  Superficially looks like we
are just hoping the read doesn't happen until after it is done.
> +		iio_trigger_poll_chained(st->trig);
> +	} else {
> +		complete(&st->completion);
> +	}
> +
> +	return IRQ_HANDLED;
> +};
> +
> +static int ad7606_validate_trigger(struct iio_dev *indio_dev,
> +				   struct iio_trigger *trig)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (st->trig != trig)
> +		return -EINVAL;
> +
> +	return 0;
> +}
> +
> +static int ad7606_buffer_postenable(struct iio_dev *indio_dev)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	mutex_lock(&st->lock);

Why take this lock here? It is non obvious enough that a comment
is needed I think.

> +
> +	iio_triggered_buffer_postenable(indio_dev);
> +	gpiod_set_value(st->gpio_convst, 1);
> +
> +	mutex_unlock(&st->lock);
> +
> +	return 0;
> +}
> +
> +static int ad7606_buffer_postdisable(struct iio_dev *indio_dev)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	gpiod_set_value(st->gpio_convst, 0);

I'm not sure which this should be in, but postenable should be balanced
by actions in predisable, not postdisable.

It probably doesn't actually matter in reality but if there is a reason
to do it like this I would like a comment to say why.


> +
> +	return 0;
> +}
> +
> +static const struct iio_buffer_setup_ops ad7606_buffer_ops = {
> +	.postenable = &ad7606_buffer_postenable,
> +	.predisable = &iio_triggered_buffer_predisable,
> +	.postdisable = &ad7606_buffer_postdisable,
> +};
> +
> +static const struct iio_info ad7606_info_no_os_or_range = {
> +	.read_raw = &ad7606_read_raw,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_info ad7606_info_os_and_range = {
> +	.read_raw = &ad7606_read_raw,
> +	.write_raw = &ad7606_write_raw,
> +	.attrs = &ad7606_attribute_group_os_and_range,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_info ad7606_info_os = {
> +	.read_raw = &ad7606_read_raw,
> +	.write_raw = &ad7606_write_raw,
> +	.attrs = &ad7606_attribute_group_os,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_info ad7606_info_range = {
> +	.read_raw = &ad7606_read_raw,
> +	.write_raw = &ad7606_write_raw,
> +	.attrs = &ad7606_attribute_group_range,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_trigger_ops ad7606_trigger_ops = {
> +	.validate_device = iio_trigger_validate_own_device,
> +};
> +
> +int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
> +		 const char *name, unsigned int id,
> +		 const struct ad7606_bus_ops *bops)
> +{
> +	struct ad7606_state *st;
> +	int ret;
> +	struct iio_dev *indio_dev;
> +
> +	indio_dev = devm_iio_device_alloc(dev, sizeof(*st));
> +	if (!indio_dev)
> +		return -ENOMEM;
> +
> +	st = iio_priv(indio_dev);
> +
> +	st->dev = dev;
> +	mutex_init(&st->lock);
> +	st->bops = bops;
> +	st->base_address = base_address;
> +	/* tied to logic low, analog input range is +/- 5V */
> +	st->range = 0;
> +	st->oversampling = 1;
> +
> +	st->reg = devm_regulator_get(dev, "avcc");
> +	if (IS_ERR(st->reg))
> +		return PTR_ERR(st->reg);
> +
> +	ret = regulator_enable(st->reg);
> +	if (ret) {
> +		dev_err(dev, "Failed to enable specified AVcc supply\n");
> +		return ret;
> +	}
> +
> +	st->chip_info = &ad7606_chip_info_tbl[id];
> +
> +	ret = ad7606_request_gpios(st);
> +	if (ret)
> +		goto error_disable_reg;
> +
> +	indio_dev->dev.parent = dev;
> +	if (st->gpio_os) {
> +		if (st->gpio_range)
> +			indio_dev->info = &ad7606_info_os_and_range;
> +		else
> +			indio_dev->info = &ad7606_info_os;
> +	} else {
> +		if (st->gpio_range)
> +			indio_dev->info = &ad7606_info_range;
> +		else
> +			indio_dev->info = &ad7606_info_no_os_or_range;
> +	}
> +	indio_dev->modes = INDIO_DIRECT_MODE;
> +	indio_dev->name = name;
> +	indio_dev->channels = st->chip_info->channels;
> +	indio_dev->num_channels = st->chip_info->num_channels;
> +
> +	ret = ad7606_reset(st);
> +	if (ret)
> +		dev_warn(st->dev, "failed to RESET: no RESET GPIO specified\n");
> +
> +	st->trig = devm_iio_trigger_alloc(dev, "%s-dev%d",
> +					  indio_dev->name, indio_dev->id);
> +	if (st->trig == NULL)
Nope.  Didn't disable regulator in this path...
> +		return -ENOMEM;
> +
> +	st->trig->ops = &ad7606_trigger_ops;
> +	st->trig->dev.parent = dev;
> +	iio_trigger_set_drvdata(st->trig, indio_dev);
> +	ret = devm_iio_trigger_register(dev, st->trig);
> +	if (ret)
Not disabled the regulator...
> +		return ret;
> +
> +	indio_dev->trig = iio_trigger_get(st->trig);
> +
> +	init_completion(&st->completion);
> +
> +	ret = devm_request_threaded_irq(dev, irq,
> +					NULL,
> +					&ad7606_interrupt,
> +					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
> +					name, indio_dev);
> +	if (ret)
> +		goto error_disable_reg;
> +
> +	ret = devm_iio_triggered_buffer_setup(dev, indio_dev,
> +					      &iio_pollfunc_store_time,
> +					      &ad7606_trigger_handler,
> +					      &ad7606_buffer_ops);
> +	if (ret)
I don't like the mixing the regulator disable in with devm functions
as it means the unwind is not the opposite order of the setup.

See suggestion below to just use a devm_add_action_or_reset call
to make this work as desired.

> +		goto error_disable_reg;
> +
> +	ret = iio_device_register(indio_dev);
> +	if (ret)
> +		goto error_disable_reg;
> +
> +	dev_set_drvdata(dev, indio_dev);
> +
> +	return 0;
> +
> +error_disable_reg:
> +	regulator_disable(st->reg);
> +	return ret;
> +}
> +EXPORT_SYMBOL_GPL(ad7606_probe);
> +
> +int ad7606_remove(struct device *dev, int irq)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	iio_device_unregister(indio_dev);
> +
> +	regulator_disable(st->reg);

Could use a devm_get_action_or_reset to tidy this up rather than
having a remove.  Up to you though as either is fine.

Actually given the ordering issues in probe, I would go for it
as it'll fix those in a natural fashion.
> +
> +	return 0;
> +}
> +EXPORT_SYMBOL_GPL(ad7606_remove);
> +
> +#ifdef CONFIG_PM_SLEEP
> +
> +static int ad7606_suspend(struct device *dev)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (st->gpio_standby) {
> +		gpiod_set_value(st->gpio_range, 1);
> +		gpiod_set_value(st->gpio_standby, 0);
> +	}
> +
> +	return 0;
> +}
> +
> +static int ad7606_resume(struct device *dev)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (st->gpio_standby) {
> +		gpiod_set_value(st->gpio_range, st->range);
> +		gpiod_set_value(st->gpio_standby, 1);
> +		ad7606_reset(st);
> +	}
> +
> +	return 0;
> +}
> +
> +SIMPLE_DEV_PM_OPS(ad7606_pm_ops, ad7606_suspend, ad7606_resume);
> +EXPORT_SYMBOL_GPL(ad7606_pm_ops);
> +
> +#endif
> +
> +MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
> +MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
> +MODULE_LICENSE("GPL");
> diff --git a/drivers/iio/adc/ad7606.h b/drivers/iio/adc/ad7606.h
> new file mode 100644
> index 0000000..9369201
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606.h
> @@ -0,0 +1,107 @@
> +/* SPDX-License-Identifier: GPL-2.0+ */
> +/*
> + * AD7606 ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#ifndef IIO_ADC_AD7606_H_
> +#define IIO_ADC_AD7606_H_
> +
> +/**
> + * struct ad7606_chip_info - chip specific information
> + * @channels:		channel specification
> + * @num_channels:	number of channels
> + * @has_oversampling:   whether the device has oversampling support
> + */
> +struct ad7606_chip_info {
> +	const struct iio_chan_spec	*channels;
> +	unsigned int			num_channels;
> +	bool				has_oversampling;
> +};
> +
> +/**
> + * struct ad7606_state - driver instance specific data
> + * @dev		pointer to kernel device
> + * @chip_info		entry in the table of chips that describes this device
> + * @reg		regulator info for the the power supply of the device
> + * @poll_work		work struct for continuously reading data from the device
> + *			into an IIO triggered buffer
> + * @wq_data_avail	wait queue struct for buffer mode
> + * @bops		bus operations (SPI or parallel)
> + * @range		voltage range selection, selects which scale to apply
> + * @oversampling	oversampling selection
> + * @done		marks whether reading data is done
> + * @base_address	address from where to read data in parallel operation
> + * @lock		protect sensor state from concurrent accesses to GPIOs
> + * @gpio_convst	GPIO descriptor for conversion start signal (CONVST)
> + * @gpio_reset		GPIO descriptor for device hard-reset
> + * @gpio_range		GPIO descriptor for range selection
> + * @gpio_standby	GPIO descriptor for stand-by signal (STBY),
> + *			controls power-down mode of device
> + * @gpio_frstdata	GPIO descriptor for reading from device when data
> + *			is being read on the first channel
> + * @gpio_os		GPIO descriptors to control oversampling on the device
> + * @complete		completion to indicate end of conversion
> + * @trig		The IIO trigger associated with the device.
> + * @data		buffer for reading data from the device
> + */
> +struct ad7606_state {
> +	struct device			*dev;
> +	const struct ad7606_chip_info	*chip_info;
> +	struct regulator		*reg;
> +	struct work_struct		poll_work;
> +	wait_queue_head_t		wq_data_avail;
> +	const struct ad7606_bus_ops	*bops;
> +	unsigned int			range;
> +	unsigned int			oversampling;
> +	bool				done;
> +	void __iomem			*base_address;
> +
> +	struct mutex			lock; /* protect sensor state */
> +	struct gpio_desc		*gpio_convst;
> +	struct gpio_desc		*gpio_reset;
> +	struct gpio_desc		*gpio_range;
> +	struct gpio_desc		*gpio_standby;
> +	struct gpio_desc		*gpio_frstdata;
> +	struct gpio_descs		*gpio_os;
> +	struct iio_trigger		*trig;
> +	struct completion		completion;
> +
> +	/*
> +	 * DMA (thus cache coherency maintenance) requires the
> +	 * transfer buffers to live in their own cache lines.
> +	 * 8 * 16-bit samples + 64-bit timestamp
> +	 */
> +	unsigned short			data[12] ____cacheline_aligned;
> +};
> +
> +/**
> + * struct ad7606_bus_ops - driver bus operations
> + * @read_block		function pointer for reading blocks of data
> + */
> +struct ad7606_bus_ops {
> +	/* more methods added in future? */
> +	int (*read_block)(struct device *dev, int num, void *data);
> +};
> +
> +int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
> +		 const char *name, unsigned int id,
> +		 const struct ad7606_bus_ops *bops);
> +int ad7606_remove(struct device *dev, int irq);
> +
> +enum ad7606_supported_device_ids {
> +	ID_AD7605_4,
> +	ID_AD7606_8,
> +	ID_AD7606_6,
> +	ID_AD7606_4
> +};
> +
> +#ifdef CONFIG_PM_SLEEP
> +extern const struct dev_pm_ops ad7606_pm_ops;
> +#define AD7606_PM_OPS (&ad7606_pm_ops)
> +#else
> +#define AD7606_PM_OPS NULL
> +#endif
> +
> +#endif /* IIO_ADC_AD7606_H_ */
> diff --git a/drivers/iio/adc/ad7606_par.c b/drivers/iio/adc/ad7606_par.c
> new file mode 100644
> index 0000000..879cb91
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606_par.c
> @@ -0,0 +1,110 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +/*
> + * AD7606 Parallel Interface ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#include <linux/module.h>
> +#include <linux/platform_device.h>
> +#include <linux/types.h>
> +#include <linux/err.h>
> +#include <linux/io.h>
> +
> +#include <linux/iio/iio.h>
> +#include "ad7606.h"
> +
> +static int ad7606_par16_read_block(struct device *dev,
> +				   int count, void *buf)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	insw((unsigned long)st->base_address, buf, count);
> +
> +	return 0;
> +}
> +
> +static const struct ad7606_bus_ops ad7606_par16_bops = {
> +	.read_block	= ad7606_par16_read_block,
> +};
> +
> +static int ad7606_par8_read_block(struct device *dev,
> +				  int count, void *buf)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	insb((unsigned long)st->base_address, buf, count * 2);
> +
> +	return 0;
> +}
> +
> +static const struct ad7606_bus_ops ad7606_par8_bops = {
> +	.read_block	= ad7606_par8_read_block,
> +};
> +
> +static int ad7606_par_probe(struct platform_device *pdev)
> +{
> +	const struct platform_device_id *id = platform_get_device_id(pdev);
> +	struct resource *res;
> +	void __iomem *addr;
> +	resource_size_t remap_size;
> +	int irq;
> +
> +	irq = platform_get_irq(pdev, 0);
> +	if (irq < 0) {
> +		dev_err(&pdev->dev, "no irq: %d\n", irq);
> +		return irq;
> +	}
> +
> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
> +	addr = devm_ioremap_resource(&pdev->dev, res);
> +	if (IS_ERR(addr))
> +		return PTR_ERR(addr);
> +
> +	remap_size = resource_size(res);
> +
> +	return ad7606_probe(&pdev->dev, irq, addr,
> +			    id->name, id->driver_data,
> +			    remap_size > 1 ? &ad7606_par16_bops :
> +			    &ad7606_par8_bops);
> +}
> +
> +static int ad7606_par_remove(struct platform_device *pdev)
> +{
> +	return ad7606_remove(&pdev->dev, platform_get_irq(pdev, 0));
> +}
> +
> +static const struct platform_device_id ad7606_driver_ids[] = {
> +	{
> +		.name		= "ad7605-4",
> +		.driver_data	= ID_AD7605_4,
A little inconsistent to spell this out here, but not in the spi
case.
	{ "ad7605-4", ID_AD7605_4 }, etc.

Not important though as either option is acceptable to my mind.

> +	}, {
> +		.name		= "ad7606-8",
> +		.driver_data	= ID_AD7606_8,
> +	}, {
> +		.name		= "ad7606-6",
> +		.driver_data	= ID_AD7606_6,
> +	}, {
> +		.name		= "ad7606-4",
> +		.driver_data	= ID_AD7606_4,
> +	},
> +	{ }
> +};
> +MODULE_DEVICE_TABLE(platform, ad7606_driver_ids);
> +
> +static struct platform_driver ad7606_driver = {
> +	.probe = ad7606_par_probe,
> +	.remove	= ad7606_par_remove,
> +	.id_table = ad7606_driver_ids,
> +	.driver = {
> +		.name	 = "ad7606",
> +		.pm	 = AD7606_PM_OPS,
> +	},
> +};
> +module_platform_driver(ad7606_driver);
> +
> +MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
> +MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
> +MODULE_LICENSE("GPL");
> diff --git a/drivers/iio/adc/ad7606_spi.c b/drivers/iio/adc/ad7606_spi.c
> new file mode 100644
> index 0000000..ef43367
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606_spi.c
> @@ -0,0 +1,88 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +/*
> + * AD7606 SPI ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#include <linux/module.h>
> +#include <linux/spi/spi.h>
> +#include <linux/types.h>
> +#include <linux/err.h>
> +
> +#include <linux/iio/iio.h>
> +#include "ad7606.h"
> +
> +#define MAX_SPI_FREQ_HZ		23500000	/* VDRIVE above 4.75 V */
> +
> +static int ad7606_spi_read_block(struct device *dev,
> +				 int count, void *buf)
> +{
> +	struct spi_device *spi = to_spi_device(dev);
> +	int i, ret;
> +	unsigned short *data = buf;
> +	__be16 *bdata = buf;
> +
> +	ret = spi_read(spi, buf, count * 2);
> +	if (ret < 0) {
> +		dev_err(&spi->dev, "SPI read error\n");
> +		return ret;
> +	}
> +
> +	for (i = 0; i < count; i++)
> +		data[i] = be16_to_cpu(bdata[i]);

I'm not overly keen on doing this in kernel when we could leave
it to userspace, but I would guess this is about consistency
across the interfaces so I suppose it is fair enough.

> +
> +	return 0;
> +}
> +
> +static const struct ad7606_bus_ops ad7606_spi_bops = {
> +	.read_block = ad7606_spi_read_block,
> +};
> +
> +static int ad7606_spi_probe(struct spi_device *spi)
> +{
> +	const struct spi_device_id *id = spi_get_device_id(spi);
> +
> +	return ad7606_probe(&spi->dev, spi->irq, NULL,
> +			    id->name, id->driver_data,
> +			    &ad7606_spi_bops);
> +}
> +
> +static int ad7606_spi_remove(struct spi_device *spi)
> +{
> +	return ad7606_remove(&spi->dev, spi->irq);
> +}
> +
> +static const struct spi_device_id ad7606_id_table[] = {
> +	{"ad7605-4", ID_AD7605_4},
> +	{"ad7606-8", ID_AD7606_8},
> +	{"ad7606-6", ID_AD7606_6},
> +	{"ad7606-4", ID_AD7606_4},
> +	{}
> +};
> +MODULE_DEVICE_TABLE(spi, ad7606_id_table);
> +
> +static const struct of_device_id ad7606_of_match[] = {
> +	{ .compatible = "adi,ad7605-4" },
> +	{ .compatible = "adi,ad7606-8" },
> +	{ .compatible = "adi,ad7606-6" },
> +	{ .compatible = "adi,ad7606-4" },
> +	{ },
> +};
> +MODULE_DEVICE_TABLE(of, ad7606_of_match);
> +
> +static struct spi_driver ad7606_driver = {
> +	.driver = {
> +		.name = "ad7606",
> +		.of_match_table = ad7606_of_match,
> +		.pm = AD7606_PM_OPS,
> +	},
> +	.probe = ad7606_spi_probe,
> +	.remove = ad7606_spi_remove,
> +	.id_table = ad7606_id_table,
> +};
> +module_spi_driver(ad7606_driver);
> +
> +MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
> +MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
> +MODULE_LICENSE("GPL v2");

...
