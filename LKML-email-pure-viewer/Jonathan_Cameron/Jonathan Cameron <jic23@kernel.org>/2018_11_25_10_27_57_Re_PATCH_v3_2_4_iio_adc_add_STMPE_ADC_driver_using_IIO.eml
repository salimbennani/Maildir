Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 22:12:59 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 64F76580474;
	Sun, 25 Nov 2018 02:28:15 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by fmsmga001-1.fm.intel.com with ESMTP; 25 Nov 2018 02:28:14 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AhHj0lhPwWTvmaeZcxEAl6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0KPj+rsbcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Qiqp4bt1RxD0iS?=
 =?us-ascii?q?cHLz85/3/Risxsl6JQvRatqwViz4LIfI2ZMfxzdb7fc9wHX2pMRshfWSxfDI2h?=
 =?us-ascii?q?bIUADeQBM+FXoIbhqFUOtgO+CAu3CePz0z9FnGP60Lcm3+kjFwzNwQwuH8gJsH?=
 =?us-ascii?q?TRtNj7MKASUeavw6nUzTXMdfVW0irj5YfSdxAuv+uMXbV2ccHMzkQvFQLFgUmO?=
 =?us-ascii?q?pYHrJD6V1foCs3Kd7+V+UeKjkWknqxt+ojW2wMonl4rHhpoNx1za6Sl0xJw5Kc?=
 =?us-ascii?q?C2RUJle9KoDZhduz2AO4Z3QM4uW2JltDsgxrACuJO3ZjYGxZooyhLFdvCKfIuF?=
 =?us-ascii?q?7xT+X+iLOzh4nmhqeLenihay70egzur8W9Gq0FZFsCVFiMPAtnMT2BzJ7MiIVP?=
 =?us-ascii?q?998l2m2TaV2ADf8uBEIUYqmqrHM5Mt3KI8m54JvUjeECL6hl/6gLKVe0k44OSl?=
 =?us-ascii?q?6ubqbq3jppCGNo90jg/+Mr4pmsy6Gek4NgkOX26G+eWzzbHj/lP2QK9MjvIolq?=
 =?us-ascii?q?nVqZfaJModpqGnGQ9YyZgj6xmhADe8ytgYnmcILEhDeB2Zi4jlIVbOIOr3Dfun?=
 =?us-ascii?q?mVSjjC9rx+zaPr3mGpjNKnnDkLT/crpn5E9c1RE+zdRe55JSF7EAL+j/Wk73tN?=
 =?us-ascii?q?zEEBA5Nxa4zPrgCNV4zokeQ36AAreFMKPOtl+F/uIvLPONZI8Jojn9LOIp5/7z?=
 =?us-ascii?q?jXAjn18dcrKk3Z8WaHC+A/RnLF+VYXvqgtcdD2gKuhAyQ/DtiF2HSTRTfWq9X7?=
 =?us-ascii?q?og5jEnD4KrFYXDRoezj7Cb3ye7GZtWZmZBCl2XFXfodoOEW+oDaS6II89hlCAE?=
 =?us-ascii?q?WqalS4M7yR6uswr6waJ9LuXI4i0YqY7j1N9t6uLJjhEy9Tt0D8eH32GXVW50nH?=
 =?us-ascii?q?gFRzs33KB5vEx8xU2P0al+g/xEC9NT4+lFXRs9NZ7Z1+Z6Ecz9WhrdfteVT1ar?=
 =?us-ascii?q?WtamDis3Tt4rx98OYlxyG9Otjh3Y2yqqArkVl6GEBZAu86Lc2WTxKNh5y3rcyK?=
 =?us-ascii?q?YhiFwmSNNVNWK6nq5/6xTTB4nRnkqEjamqa7oT0DTN9GiZy2qOp19XUAh3XaXB?=
 =?us-ascii?q?XnAfY0/WoM/95kPDSb+uFLsmPhFAyc6ENqtFdNnpgU9aS/fkPdTUe3ixlHuoBR?=
 =?us-ascii?q?aU2rOMa5LndHgH0yXDFkcIiQAT8myANQglGCihpXnTDDhvFVLpfkPt/vNyqHK9?=
 =?us-ascii?q?Tk8o0Q6Ka1dt2Kay+h4QnfacUe8c3qoYuCc9rDV5BEq939PTC9qHuwphfKVdbc?=
 =?us-ascii?q?kh4Ftd0mLZrQh9Pp2mL6BtnVMedwV3v0Xz1xR4EIlAkM4qrG80wwp2M66XzFRB?=
 =?us-ascii?q?dzaA15DqJrLXMnXy/Ayoa6POwF7e1MiZ+6gR5/U4sVnspxypGVc4/HVh0NlV1G?=
 =?us-ascii?q?Wc647ODAoTV5LxT0k2+wJ7p7Hcfiky+YfU2WdwPqmztz/Iw8gpC/c9yha8Y9df?=
 =?us-ascii?q?N7uJFQ/vE8EAG8eiMu0rm1izYRICM+Bf76o0P8Kgd/ub16+nJudgnDS6jWtZ5I?=
 =?us-ascii?q?BxyF6D9y15SuTQxZYK3+mY3hebVzf7lFqhqMH3lpxeajEIA2W/zjLoBIhPaa1o?=
 =?us-ascii?q?fIYHEHuhLNezxtpjmZHtQXlY9Fi4ClMC2c+pfweSblPn0Q1R00QXvWKomS+iwz?=
 =?us-ascii?q?NolDEpq7KV3DbSzOT6aBoHJmlLSXFijFftO4S1j8oWXFO1bwgvjxal4Uf6x65G?=
 =?us-ascii?q?pKVwNWXTQEFIfzToIGFmSKe/qr2CY8tX4pMyrSpXSPi8YUydSrPloRsVyTnjH2?=
 =?us-ascii?q?hdxDA8bT2qoY/2nx95iGKcKnZ8snzZdNp0xRfe4tzcWPFQ0iAHRCl+lTnYGFy8?=
 =?us-ascii?q?M8O18tWTkpfJqvq+WH65Vp1PbSnrypuNtSuh6m1tGxG/nfGzmtv8HAg+0C/70c?=
 =?us-ascii?q?RqVCrSoBb9ZInry7q1MeZ9ckZ0A1/87tJwGptinYsomJEQxX8ai42W/XUdkGf/?=
 =?us-ascii?q?K9Vb2b/kY3oLSj4G2NrV4Anj2E1+IXOF3YP5VnOBwsR/Y9m2eH8Z2iU478pSEq?=
 =?us-ascii?q?eb8KREnTdpolq/tQ/RZPl9njQHxvc05n8VnfoJuBYzwSWHGb8dA1NYPSP3mhSM?=
 =?us-ascii?q?7tC+qrhXZWm1fbix0kp+gc6uDLWYrg5AX3b5f48oHTVs4cVnLFLMzHrz55n4eN?=
 =?us-ascii?q?nXaNIfrByVnA3Gj+hIM5IxjfsKiDFjOWL8u30l1uE6gQZv3ZG8oIiINWFt8Lil?=
 =?us-ascii?q?DR5fMz3/f9kT9S31jaZCgsaW2JiiEY57FTUMWJvoUOikEDYPtfn8MwaOETs8qm?=
 =?us-ascii?q?qUGLbFHA+f7ltmoGzLE5yxK36XI3wZx814RBaBPExfnBwUXDIik547DA+qwdLu?=
 =?us-ascii?q?cFxj6jAN/FL4qQZMyuF1Nxn5SGjfvxylajM1SJiZMRpX4RtO50bTMcyC8O1zGz?=
 =?us-ascii?q?tU8YGmrAyIMmabfRhHDXkVWkyYAFDuJrmv5d7d8+iBG+qxNf3Oba+VqexZUfeI?=
 =?us-ascii?q?yomi0o9n/zaKK8WOMWNuD/w92kpfQ395H97VlCkISywSjyjNddKUpA+g+i1rqc?=
 =?us-ascii?q?Cy6PTrVxzu5YuMCLtSMM9j+xOsgaeEOO6fmjx5KStD1p4XwX/Iyb4f3EMdii10?=
 =?us-ascii?q?djmtF6gAujDJTK7KhqBXCBsbYTtpNMRU96I8whVNOcnDh9zvy753leQ1BElFVF?=
 =?us-ascii?q?D7nsGpZNcHI2W8NFPBGUaKO66KJTzNw8Hrf6y8Tadcg/lTtx21oTybCVPsPiyf?=
 =?us-ascii?q?lzn1UBCiKf1MjCCePBBEpI6xaApiCWj9Q9LgcRC7NN53jTsrwbw7nH/KNGgcMS?=
 =?us-ascii?q?RifENJtLGf8SRYgvBnEWxb8nVlNfWEmzqe7+TAKpcZq/1rAiF1l+Jc+Hs7yrtV?=
 =?us-ascii?q?4ztCRPx6gybSqt9uo1e7kuiA0DZnURxOqipVi4KPp0ltJaLZ9pwTEUrDqSoN7G?=
 =?us-ascii?q?GREwwH7+BuCtDpuK1KgozDmbzbMCxJ89/S/sYGQcPUfpGpKn0kZDjuHjfIDAID?=
 =?us-ascii?q?BRWiMGzFgEoVxPOT/SfOhps3sJ7hnNwJULANBw99Le8TFkkwRI9KG5xwRD5x1O?=
 =?us-ascii?q?fD1MM=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AtAABWePpbh0O0hNFdBh4BBgcGgVEJC?=
 =?us-ascii?q?wGDayeDeYh3iyBQAQEGgTUUiQaEaok4FIFjEBgTAYRAhBoiNAkNAQMBAQEBAQE?=
 =?us-ascii?q?CARMBAQEIDQkIKSMMgjYkAYJhAQEBAQIBAQILDAkEGQEBIxQBBAEJAQEKDgcFA?=
 =?us-ascii?q?gUhAgIDDEgGEwWDHIF1BQgEAaVecHwzgnYBAQWHEwiBC4ligRyBD4EHgRGDEoR?=
 =?us-ascii?q?DIwoDC4MEgleBLAEBh20GLIFGhAiBRY8jAQYCAZEkIwqBT4ULBYMehwGYMIFGg?=
 =?us-ascii?q?g0zGjCBYYFOghsMF4hehT5AMoECAwEBIROMNgEB?=
X-IPAS-Result: =?us-ascii?q?A0AtAABWePpbh0O0hNFdBh4BBgcGgVEJCwGDayeDeYh3iyB?=
 =?us-ascii?q?QAQEGgTUUiQaEaok4FIFjEBgTAYRAhBoiNAkNAQMBAQEBAQECARMBAQEIDQkIK?=
 =?us-ascii?q?SMMgjYkAYJhAQEBAQIBAQILDAkEGQEBIxQBBAEJAQEKDgcFAgUhAgIDDEgGEwW?=
 =?us-ascii?q?DHIF1BQgEAaVecHwzgnYBAQWHEwiBC4ligRyBD4EHgRGDEoRDIwoDC4MEgleBL?=
 =?us-ascii?q?AEBh20GLIFGhAiBRY8jAQYCAZEkIwqBT4ULBYMehwGYMIFGgg0zGjCBYYFOghs?=
 =?us-ascii?q?MF4hehT5AMoECAwEBIROMNgEB?=
X-IronPort-AV: E=Sophos;i="5.56,277,1539673200"; 
   d="scan'208";a="41428282"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 02:28:12 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727562AbeKYVSw (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 25 Nov 2018 16:18:52 -0500
Received: from mail.kernel.org ([198.145.29.99]:39982 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1727182AbeKYVSw (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 25 Nov 2018 16:18:52 -0500
Received: from archlinux (cpc91196-cmbg18-2-0-cust659.5-4.cable.virginm.net [81.96.234.148])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 6540120855;
        Sun, 25 Nov 2018 10:28:00 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1543141684;
        bh=ag8fjKCmWunV2Tfr+2walHCKkp1bV6GlAzs0+FHi0Us=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=fU6suo7HMB4hKV55D6S+bEkFKqBLk2Rt7/N20/l0UN7XKfom/JnoXB7YlNkK6yUpD
         6UpzKkE0nrAclZWnCxBTF/1kKno0bsox4uiuHMM1tD1vz9Hv5b08mXtLMxLK+2HH96
         3atitbGJIy/uOh0EXBYTXLe3ol0MDyZd8LuIP+Bs=
Date: Sun, 25 Nov 2018 10:27:57 +0000
From: Jonathan Cameron <jic23@kernel.org>
To: Philippe Schenker <dev@pschenker.ch>
Cc: marcel.ziswiler@toradex.com, stefan@agner.ch,
        Max Krummenacher <max.krummenacher@toradex.com>,
        Philippe Schenker <philippe.schenker@toradex.com>,
        Mark Brown <broonie@kernel.org>,
        Arnaud Pouliquen <arnaud.pouliquen@st.com>,
        linux-iio@vger.kernel.org,
        Geert Uytterhoeven <geert@linux-m68k.org>,
        William Breathitt Gray <vilhelm.gray@gmail.com>,
        linux-stm32@st-md-mailman.stormreply.com,
        Baolin Wang <baolin.wang@linaro.org>,
        Randy Dunlap <rdunlap@infradead.org>,
        Marcus Folkesson <marcus.folkesson@gmail.com>,
        Freeman Liu <freeman.liu@spreadtrum.com>,
        linux-input@vger.kernel.org,
        Eugen Hristev <eugen.hristev@microchip.com>,
        Maxime Coquelin <mcoquelin.stm32@gmail.com>,
        Peter Meerwald-Stadler <pmeerw@pmeerw.net>,
        Lee Jones <lee.jones@linaro.org>,
        Lars-Peter Clausen <lars@metafoo.de>,
        Hartmut Knaack <knaack.h@gmx.de>,
        linux-arm-kernel@lists.infradead.org,
        Alexandre Torgue <alexandre.torgue@st.com>,
        Siddartha Mohanadoss <smohanad@codeaurora.org>,
        linux-kernel@vger.kernel.org,
        Dmitry Torokhov <dmitry.torokhov@gmail.com>
Subject: Re: [PATCH v3 2/4] iio: adc: add STMPE ADC driver using IIO
 framework
Message-ID: <20181125102757.2c34371c@archlinux>
In-Reply-To: <20181123142411.8921-2-dev@pschenker.ch>
References: <20181123142411.8921-1-dev@pschenker.ch>
        <20181123142411.8921-2-dev@pschenker.ch>
X-Mailer: Claws Mail 3.17.1 (GTK+ 2.24.32; x86_64-pc-linux-gnu)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Fri, 23 Nov 2018 15:24:09 +0100
Philippe Schenker <dev@pschenker.ch> wrote:

> From: Stefan Agner <stefan@agner.ch>
>=20
> This adds an ADC driver for the STMPE device using the industrial
> input/output interface. The driver supports raw reading of values.
> The driver depends on the MFD STMPE driver. If the touchscreen
> block is enabled too, only four of the 8 ADC channels are available.
>=20
> Signed-off-by: Stefan Agner <stefan@agner.ch>
> Signed-off-by: Max Krummenacher <max.krummenacher@toradex.com>
> Signed-off-by: Philippe Schenker <philippe.schenker@toradex.com>

Given the dt related refactoring in here is mixed up somewhat with the
ADC driver, I would like to see that as a precursor patch.

Another area that I think needs a rethink is balance between
enable and disable.  The enable is in the mfd call, but the disable
in the iio driver remove which isn't right.  Not immediately
sure what we do about that, but it should be one or the other.

I'd previously missed your use of the IIO core mlock.  Please don't
use that in a driver directly.  It has very carefully defined
locking semantics which aren't even in use here.  A locally defined
lock with well documented scope is much better.  We 'used'
to abuse mlock for this and have spent years slowly unwinding that.

Thanks,

Jonathan

> ---
>=20
> Changes in v3:
>  - Undo ADC-settings related code-deletions in stmpe-ts.c that the code is
>    backwards-compatible to older devicetrees.
>=20
> Changes in v2:
>  - Code formatting
>  - Move code to setup ADC to MFD device, as it is used by both drivers
>    adc and touchscreen
>  - Removed unused includes
>  - Defined the macro STMPE_START_ONE_TEMP_CONV with other macros.
>  - Added new macro that defines the channel of the temperature sensor.
>    Took new name for STMPE_MAX_ADC->STMPE_ADC_LAST_NR and used it through=
out
>    the code for better readability.
>  - Added mutex_unlock where missing.
>=20
>  drivers/iio/adc/Kconfig              |   7 +
>  drivers/iio/adc/Makefile             |   1 +
>  drivers/iio/adc/stmpe-adc.c          | 326 +++++++++++++++++++++++++++
>  drivers/input/touchscreen/stmpe-ts.c |  36 +--
>  drivers/mfd/Kconfig                  |   3 +-
>  drivers/mfd/stmpe.c                  |  81 +++++++
>  include/linux/mfd/stmpe.h            |   9 +
>  7 files changed, 437 insertions(+), 26 deletions(-)
>  create mode 100644 drivers/iio/adc/stmpe-adc.c
>=20
> diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
> index a52fea8749a9..224f2067494d 100644
> --- a/drivers/iio/adc/Kconfig
> +++ b/drivers/iio/adc/Kconfig
> @@ -734,6 +734,13 @@ config STM32_DFSDM_ADC
>  	  This driver can also be built as a module.  If so, the module
>  	  will be called stm32-dfsdm-adc.
> =20
> +config STMPE_ADC
> +	tristate "STMicroelectronics STMPE ADC driver"
> +	depends on OF && MFD_STMPE
> +	help
> +	  Say yes here to build support for ST Microelectronics STMPE
> +	  built-in ADC block (stmpe811).
> +
>  config STX104
>  	tristate "Apex Embedded Systems STX104 driver"
>  	depends on PC104 && X86
> diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
> index a6e6a0b659e2..cba889c30bf9 100644
> --- a/drivers/iio/adc/Makefile
> +++ b/drivers/iio/adc/Makefile
> @@ -69,6 +69,7 @@ obj-$(CONFIG_STM32_ADC_CORE) +=3D stm32-adc-core.o
>  obj-$(CONFIG_STM32_ADC) +=3D stm32-adc.o
>  obj-$(CONFIG_STM32_DFSDM_CORE) +=3D stm32-dfsdm-core.o
>  obj-$(CONFIG_STM32_DFSDM_ADC) +=3D stm32-dfsdm-adc.o
> +obj-$(CONFIG_STMPE_ADC) +=3D stmpe-adc.o
>  obj-$(CONFIG_TI_ADC081C) +=3D ti-adc081c.o
>  obj-$(CONFIG_TI_ADC0832) +=3D ti-adc0832.o
>  obj-$(CONFIG_TI_ADC084S021) +=3D ti-adc084s021.o
> diff --git a/drivers/iio/adc/stmpe-adc.c b/drivers/iio/adc/stmpe-adc.c
> new file mode 100644
> index 000000000000..bea3f3c27bb5
> --- /dev/null
> +++ b/drivers/iio/adc/stmpe-adc.c
> @@ -0,0 +1,326 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + *  STMicroelectronics STMPE811 IIO ADC Driver
> + *
> + *  4 channel, 10/12-bit ADC
> + *
> + *  Copyright (C) 2013-2018 Toradex AG <stefan.agner@toradex.com>
> + */
> +
> +#include <linux/completion.h>
> +#include <linux/err.h>
> +#include <linux/iio/iio.h>
> +#include <linux/interrupt.h>
> +#include <linux/kernel.h>
> +#include <linux/mfd/stmpe.h>
> +#include <linux/module.h>
> +#include <linux/of_platform.h>
> +#include <linux/platform_device.h>
> +
> +#define STMPE_REG_INT_STA		0x0B
> +#define STMPE_REG_ADC_INT_EN		0x0E
> +#define STMPE_REG_ADC_INT_STA		0x0F
> +
> +#define STMPE_REG_ADC_CTRL1		0x20
> +#define STMPE_REG_ADC_CTRL2		0x21
> +#define STMPE_REG_ADC_CAPT		0x22
> +#define STMPE_REG_ADC_DATA_CH(channel)	(0x30 + 2 * (channel))
> +
> +#define STMPE_REG_TEMP_CTRL		0x60
> +#define STMPE_TEMP_CTRL_ENABLE		BIT(0)
> +#define STMPE_TEMP_CTRL_ACQ		BIT(1)
> +#define STMPE_TEMP_CTRL_THRES_EN	BIT(3)
> +#define STMPE_START_ONE_TEMP_CONV	(STMPE_TEMP_CTRL_ENABLE | \
> +					STMPE_TEMP_CTRL_ACQ | \
> +					STMPE_TEMP_CTRL_THRES_EN)
> +#define STMPE_REG_TEMP_DATA		0x61
> +#define STMPE_REG_TEMP_TH		0x63
> +#define STMPE_ADC_LAST_NR		7
> +#define STMPE_TEMP_CHANNEL		(STMPE_ADC_LAST_NR + 1)
> +
> +#define STMPE_ADC_CH(channel)		((1 << (channel)) & 0xff)
> +
> +#define STMPE_ADC_TIMEOUT		msecs_to_jiffies(1000)
> +
> +struct stmpe_adc {
> +	struct stmpe *stmpe;
> +	struct clk *clk;
> +	struct device *dev;
> +
> +	/* We are allocating plus one for the temperature channel */
> +	struct iio_chan_spec stmpe_adc_iio_channels[STMPE_ADC_LAST_NR + 2];
> +
> +	struct completion completion;
> +
> +	u8 channel;
> +	u32 value;
> +};
> +
> +static int stmpe_read_raw(struct iio_dev *indio_dev,
> +			  struct iio_chan_spec const *chan,
> +			  int *val,
> +			  int *val2,
> +			  long mask)
> +{
> +	struct stmpe_adc *info =3D iio_priv(indio_dev);
> +	long ret;
> +
> +	switch (mask) {
> +	case IIO_CHAN_INFO_RAW:
> +	case IIO_CHAN_INFO_PROCESSED:
> +
> +		mutex_lock(&indio_dev->mlock);

That's not what this lock is for and I think we have almost
entirely removed it's use from drivers.  That's the internal IIO lock
used to protect against changing from polled to trigger driven operation.

Please add your own local lock for which the scope can be cleanly defined
and documented.  Sorry I missed this before. I only noticed now whilst
trying to sanity check the documentation for a lock I expected to find
in the private data structure that wasn't there!.

> +
> +		info->channel =3D (u8)chan->channel;
> +
> +		switch (chan->type) {
> +		case IIO_VOLTAGE:
There isn't a whole lot shared in the voltage raw / temp processed
paths.  It might be more readable to separate them out - perhaps
as a pair of utility functions rather than having the
multiple switch statements with common blocks inbetween.

stmpe_read_voltage / stmpe_read_temp?

A few lines will get repeated, but the flow will be more obvious
I think and the indenting considerably reduced which always
helps!


> +			if (info->channel > STMPE_ADC_LAST_NR) {
> +				mutex_unlock(&indio_dev->mlock);
> +				return -EINVAL;
> +			}
> +
> +			stmpe_reg_write(info->stmpe, STMPE_REG_ADC_INT_EN,
> +					STMPE_ADC_CH(info->channel));
> +
> +			stmpe_reg_write(info->stmpe, STMPE_REG_ADC_CAPT,
> +					STMPE_ADC_CH(info->channel));
> +
> +			*val =3D info->value;
> +			break;
> +
> +		case IIO_TEMP:
> +			if (info->channel !=3D STMPE_TEMP_CHANNEL) {
> +				mutex_unlock(&indio_dev->mlock);
> +				return -EINVAL;
> +			}
> +
> +			stmpe_reg_write(info->stmpe, STMPE_REG_TEMP_CTRL,
> +					STMPE_START_ONE_TEMP_CONV);
> +			break;
> +		default:
> +			mutex_unlock(&indio_dev->mlock);
> +			return -EINVAL;
> +		}
> +
> +		ret =3D wait_for_completion_interruptible_timeout
> +			(&info->completion, STMPE_ADC_TIMEOUT);
> +
> +		if (ret <=3D 0) {
> +			mutex_unlock(&indio_dev->mlock);
> +			if (ret =3D=3D 0)
> +				return -ETIMEDOUT;
> +			else
> +				return ret;
> +		}
> +
> +		switch (chan->type) {
> +		case IIO_VOLTAGE:
> +			*val =3D info->value;
> +			break;
> +
> +		case IIO_TEMP:
> +			/*
> +			 * absolute temp =3D +V3.3 * value /7.51 [K]
> +			 * scale to [milli =C2=B0C]
> +			 */
> +			*val =3D ((449960l * info->value) / 1024l) - 273150;
> +			break;
> +		default:
> +			break;
> +		}
> +
> +		mutex_unlock(&indio_dev->mlock);
> +		return IIO_VAL_INT;
> +
> +	case IIO_CHAN_INFO_SCALE:
> +		*val =3D 3300;
> +		*val2 =3D info->stmpe->mod_12b ? 12 : 10;
> +		return IIO_VAL_FRACTIONAL_LOG2;
> +
> +	default:
> +		break;
> +	}
> +
> +	return -EINVAL;
> +}
> +
> +static irqreturn_t stmpe_adc_isr(int irq, void *dev_id)
> +{
> +	struct stmpe_adc *info =3D (struct stmpe_adc *)dev_id;
> +	u8 data[2];
> +
> +	if (info->channel > STMPE_TEMP_CHANNEL)
> +		return IRQ_NONE;
> +
> +	if (info->channel <=3D STMPE_ADC_LAST_NR) {
> +		int int_sta;
> +
> +		int_sta =3D stmpe_reg_read(info->stmpe, STMPE_REG_ADC_INT_STA);
> +
> +		/* Is the interrupt relevant */
> +		if (!(int_sta & STMPE_ADC_CH(info->channel)))
> +			return IRQ_NONE;
> +
> +		/* Read value */
> +		stmpe_block_read(info->stmpe,
> +			STMPE_REG_ADC_DATA_CH(info->channel), 2, data);
> +
> +		stmpe_reg_write(info->stmpe, STMPE_REG_ADC_INT_STA, int_sta);
> +	} else if (info->channel =3D=3D STMPE_TEMP_CHANNEL) {
> +		/* Read value */
> +		stmpe_block_read(info->stmpe, STMPE_REG_TEMP_DATA, 2, data);
> +	}
> +
> +	info->value =3D ((u32)data[0] << 8) + data[1];

This is an endian conversion of aligned data.  Can we use an appropriate
endian to cpu function to do it as cleaner and quite possibly a noop.

> +	complete(&info->completion);
> +
> +	return IRQ_HANDLED;
> +}
> +
> +static const struct iio_info stmpe_adc_iio_info =3D {
> +	.read_raw =3D &stmpe_read_raw,
> +};
> +
> +static void stmpe_adc_voltage_chan(struct iio_chan_spec *ics, int chan)
> +{
> +	ics->type =3D IIO_VOLTAGE;
> +	ics->info_mask_separate =3D BIT(IIO_CHAN_INFO_RAW);
> +	ics->info_mask_shared_by_type =3D BIT(IIO_CHAN_INFO_SCALE);
> +	ics->indexed =3D 1;
> +	ics->channel =3D chan;
> +}
> +
> +static void stmpe_adc_temp_chan(struct iio_chan_spec *ics, int chan)
> +{
> +	ics->type =3D IIO_TEMP;
> +	ics->info_mask_separate =3D BIT(IIO_CHAN_INFO_PROCESSED);
> +	ics->indexed =3D 1;
> +	ics->channel =3D chan;
> +}
> +
> +static int stmpe_adc_init_hw(struct stmpe_adc *adc)
> +{
> +	struct stmpe *stmpe =3D adc->stmpe;
> +
> +	/* use temp irq for each conversion completion */
> +	stmpe_reg_write(stmpe, STMPE_REG_TEMP_TH, 0);
> +	stmpe_reg_write(stmpe, STMPE_REG_TEMP_TH + 1, 0);
> +
> +	return 0;
> +}
> +
> +static int stmpe_adc_probe(struct platform_device *pdev)
> +{
> +	struct iio_dev *indio_dev =3D NULL;
> +	struct stmpe_adc *info =3D NULL;
> +	struct device_node *np;
> +	u32 norequest_mask =3D 0;
> +	int irq_temp, irq_adc;
> +	int num_chan =3D 0;
> +	int i =3D 0;
> +	int ret;
> +
> +	irq_adc =3D platform_get_irq_byname(pdev, "STMPE_ADC");
> +	if (irq_adc < 0)
> +		return irq_adc;
> +
> +	indio_dev =3D devm_iio_device_alloc(&pdev->dev, sizeof(struct stmpe_adc=
));
> +	if (!indio_dev) {
> +		dev_err(&pdev->dev, "failed allocating iio device\n");
> +		return -ENOMEM;
> +	}
> +
> +	info =3D iio_priv(indio_dev);
> +
> +	init_completion(&info->completion);
> +	ret =3D devm_request_threaded_irq(&pdev->dev, irq_adc, NULL,
> +					stmpe_adc_isr, IRQF_ONESHOT,
> +					"stmpe-adc", info);
> +	if (ret < 0) {
> +		dev_err(&pdev->dev, "failed requesting irq, irq =3D %d\n",
> +				irq_adc);
> +		return ret;
> +	}
> +
> +	irq_temp =3D platform_get_irq_byname(pdev, "STMPE_TEMP_SENS");
> +	if (irq_temp >=3D 0) {
> +		ret =3D devm_request_threaded_irq(&pdev->dev, irq_temp, NULL,
> +						stmpe_adc_isr, IRQF_ONESHOT,
> +						"stmpe-adc", info);
> +		if (ret < 0)
> +			dev_warn(&pdev->dev, "failed requesting irq for"
> +				 " temp sensor, irq =3D %d\n", irq_temp);
> +	}
> +
> +	platform_set_drvdata(pdev, indio_dev);
> +
> +	indio_dev->name		=3D dev_name(&pdev->dev);
> +	indio_dev->dev.parent	=3D &pdev->dev;
> +	indio_dev->info		=3D &stmpe_adc_iio_info;
> +	indio_dev->modes	=3D INDIO_DIRECT_MODE;
> +
> +	info->stmpe =3D dev_get_drvdata(pdev->dev.parent);
> +
> +	np =3D pdev->dev.of_node;
> +
> +	if (!np)
> +		dev_err(&pdev->dev, "no device tree node found\n");
> +
> +	of_property_read_u32(np, "st,norequest-mask", &norequest_mask);
> +
> +	for_each_clear_bit(i, (unsigned long *) &norequest_mask,
> +			   (STMPE_ADC_LAST_NR + 1)) {
> +		stmpe_adc_voltage_chan(&info->stmpe_adc_iio_channels[num_chan], i);
> +		num_chan++;
> +	}
> +	stmpe_adc_temp_chan(&info->stmpe_adc_iio_channels[num_chan], i);
> +	num_chan++;
> +	indio_dev->channels =3D info->stmpe_adc_iio_channels;
> +	indio_dev->num_channels =3D num_chan;
> +
> +	ret =3D stmpe_adc_init_hw(info);
> +	if (ret)
> +		return ret;
> +
> +	return iio_device_register(indio_dev);
> +}
> +
> +static int stmpe_adc_remove(struct platform_device *pdev)
> +{
> +	struct iio_dev *indio_dev =3D platform_get_drvdata(pdev);
> +	struct stmpe_adc *info =3D iio_priv(indio_dev);
> +
> +	iio_device_unregister(indio_dev);
> +	stmpe_disable(info->stmpe, STMPE_BLOCK_ADC);

Could we use a devm_add_action_or_reset call covering this so that
we can get rid of the remove function entirely?

Mind you, this is unwinding something being called from the mfd
I think rather than being called from the adc probe function.

We need to fix that balance by either calling the disable from
the ADC or moving the enable in here as necessary.

> +
> +	return 0;
> +}
> +
> +static int __maybe_unused stmpe_adc_resume(struct device *dev)
> +{
> +	struct iio_dev *indio_dev =3D dev_get_drvdata(dev);
> +	struct stmpe_adc *info =3D iio_priv(indio_dev);
> +
> +	stmpe_adc_init_hw(info);
> +
> +	return 0;
> +}
> +
> +static SIMPLE_DEV_PM_OPS(stmpe_adc_pm_ops, NULL, stmpe_adc_resume);
> +
> +static struct platform_driver stmpe_adc_driver =3D {
> +	.probe		=3D stmpe_adc_probe,
> +	.remove		=3D stmpe_adc_remove,
> +	.driver		=3D {
> +		.name	=3D "stmpe-adc",
> +		.pm	=3D &stmpe_adc_pm_ops,
> +	},
> +};
> +
> +module_platform_driver(stmpe_adc_driver);
> +
> +MODULE_AUTHOR("Stefan Agner <stefan.agner@toradex.com>");
> +MODULE_DESCRIPTION("STMPEXXX ADC driver");
> +MODULE_LICENSE("GPL v2");
> +MODULE_ALIAS("platform:stmpe-adc");
> diff --git a/drivers/input/touchscreen/stmpe-ts.c b/drivers/input/touchsc=
reen/stmpe-ts.c
> index c5d9006588a2..81aa313d6e5a 100644
> --- a/drivers/input/touchscreen/stmpe-ts.c
> +++ b/drivers/input/touchscreen/stmpe-ts.c
> @@ -30,8 +30,6 @@
>   * with touchscreen controller
>   */
>  #define STMPE_REG_INT_STA		0x0B
> -#define STMPE_REG_ADC_CTRL1		0x20
> -#define STMPE_REG_ADC_CTRL2		0x21
>  #define STMPE_REG_TSC_CTRL		0x40
>  #define STMPE_REG_TSC_CFG		0x41
>  #define STMPE_REG_FIFO_TH		0x4A
> @@ -58,15 +56,6 @@
>   * @idev: registered input device
>   * @work: a work item used to scan the device
>   * @dev: a pointer back to the MFD cell struct device*
> - * @sample_time: ADC converstion time in number of clock.
> - * (0 -> 36 clocks, 1 -> 44 clocks, 2 -> 56 clocks, 3 -> 64 clocks,
> - * 4 -> 80 clocks, 5 -> 96 clocks, 6 -> 144 clocks),
> - * recommended is 4.
> - * @mod_12b: ADC Bit mode (0 -> 10bit ADC, 1 -> 12bit ADC)
> - * @ref_sel: ADC reference source
> - * (0 -> internal reference, 1 -> external reference)
> - * @adc_freq: ADC Clock speed
> - * (0 -> 1.625 MHz, 1 -> 3.25 MHz, 2 || 3 -> 6.5 MHz)
>   * @ave_ctrl: Sample average control
>   * (0 -> 1 sample, 1 -> 2 samples, 2 -> 4 samples, 3 -> 8 samples)
>   * @touch_det_delay: Touch detect interrupt delay
> @@ -88,10 +77,6 @@ struct stmpe_touch {
>  	struct input_dev *idev;
>  	struct delayed_work work;
>  	struct device *dev;
> -	u8 sample_time;
> -	u8 mod_12b;
> -	u8 ref_sel;
> -	u8 adc_freq;
>  	u8 ave_ctrl;
>  	u8 touch_det_delay;
>  	u8 settling;
> @@ -176,7 +161,7 @@ static irqreturn_t stmpe_ts_handler(int irq, void *da=
ta)
>  	input_report_key(ts->idev, BTN_TOUCH, 1);
>  	input_sync(ts->idev);
> =20
> -       /* flush the FIFO after we have read out our values. */
> +	/* flush the FIFO after we have read out our values. */
>  	__stmpe_reset_fifo(ts->stmpe);
> =20
>  	/* reenable the tsc */
> @@ -202,20 +187,21 @@ static int stmpe_init_hw(struct stmpe_touch *ts)
>  		return ret;
>  	}
> =20
> -	adc_ctrl1 =3D STMPE_SAMPLE_TIME(ts->sample_time) |
> -		    STMPE_MOD_12B(ts->mod_12b) | STMPE_REF_SEL(ts->ref_sel);
> +	adc_ctrl1 =3D STMPE_SAMPLE_TIME(stmpe->sample_time) |
> +		    STMPE_MOD_12B(stmpe->mod_12b) |
> +		    STMPE_REF_SEL(stmpe->ref_sel);

Could we split this refactor out 'ahead' of the ADC patch?

>  	adc_ctrl1_mask =3D STMPE_SAMPLE_TIME(0xff) | STMPE_MOD_12B(0xff) |
>  			 STMPE_REF_SEL(0xff);
> =20
> -	ret =3D stmpe_set_bits(stmpe, STMPE_REG_ADC_CTRL1,
> +	ret =3D stmpe_set_bits(stmpe, STMPE811_REG_ADC_CTRL1,
>  			adc_ctrl1_mask, adc_ctrl1);
>  	if (ret) {
>  		dev_err(dev, "Could not setup ADC\n");
>  		return ret;
>  	}
> =20
> -	ret =3D stmpe_set_bits(stmpe, STMPE_REG_ADC_CTRL2,
> -			STMPE_ADC_FREQ(0xff), STMPE_ADC_FREQ(ts->adc_freq));
> +	ret =3D stmpe_set_bits(stmpe, STMPE811_REG_ADC_CTRL2,
> +			STMPE_ADC_FREQ(0xff), STMPE_ADC_FREQ(stmpe->adc_freq));
>  	if (ret) {
>  		dev_err(dev, "Could not setup ADC\n");
>  		return ret;
> @@ -295,13 +281,13 @@ static void stmpe_ts_get_platform_info(struct platf=
orm_device *pdev,
> =20
>  	if (np) {
>  		if (!of_property_read_u32(np, "st,sample-time", &val))
> -			ts->sample_time =3D val;
> +			ts->stmpe->sample_time =3D val;
>  		if (!of_property_read_u32(np, "st,mod-12b", &val))
> -			ts->mod_12b =3D val;
> +			ts->stmpe->mod_12b =3D val;
>  		if (!of_property_read_u32(np, "st,ref-sel", &val))
> -			ts->ref_sel =3D val;
> +			ts->stmpe->ref_sel =3D val;
>  		if (!of_property_read_u32(np, "st,adc-freq", &val))
> -			ts->adc_freq =3D val;
> +			ts->stmpe->adc_freq =3D val;
>  		if (!of_property_read_u32(np, "st,ave-ctrl", &val))
>  			ts->ave_ctrl =3D val;
>  		if (!of_property_read_u32(np, "st,touch-det-delay", &val))
> diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
> index 8c5dfdce4326..bba159e8eaa4 100644
> --- a/drivers/mfd/Kconfig
> +++ b/drivers/mfd/Kconfig
> @@ -1204,7 +1204,7 @@ config MFD_STMPE
> =20
>  	  Currently supported devices are:
> =20
> -		STMPE811: GPIO, Touchscreen
> +		STMPE811: GPIO, Touchscreen, ADC
>  		STMPE1601: GPIO, Keypad
>  		STMPE1801: GPIO, Keypad
>  		STMPE2401: GPIO, Keypad
> @@ -1217,6 +1217,7 @@ config MFD_STMPE
>  		GPIO: stmpe-gpio
>  		Keypad: stmpe-keypad
>  		Touchscreen: stmpe-ts
> +		ADC: stmpe-adc
> =20
>  menu "STMicroelectronics STMPE Interface Drivers"
>  depends on MFD_STMPE
> diff --git a/drivers/mfd/stmpe.c b/drivers/mfd/stmpe.c
> index 566caca4efd8..35390d1c2e64 100644
> --- a/drivers/mfd/stmpe.c
> +++ b/drivers/mfd/stmpe.c
> @@ -463,6 +463,28 @@ static const struct mfd_cell stmpe_ts_cell =3D {
>  	.num_resources	=3D ARRAY_SIZE(stmpe_ts_resources),
>  };
> =20
> +/*
> + * ADC (STMPE811)
> + */
> +
> +static struct resource stmpe_adc_resources[] =3D {
> +	{
> +		.name	=3D "STMPE_TEMP_SENS",
> +		.flags	=3D IORESOURCE_IRQ,
> +	},
> +	{
> +		.name	=3D "STMPE_ADC",
> +		.flags	=3D IORESOURCE_IRQ,
> +	},
> +};
> +
> +static const struct mfd_cell stmpe_adc_cell =3D {
> +	.name		=3D "stmpe-adc",
> +	.of_compatible	=3D "st,stmpe-adc",
> +	.resources	=3D stmpe_adc_resources,
> +	.num_resources	=3D ARRAY_SIZE(stmpe_adc_resources),
> +};
> +
>  /*
>   * STMPE811 or STMPE610
>   */
> @@ -497,6 +519,11 @@ static struct stmpe_variant_block stmpe811_blocks[] =
=3D {
>  		.irq	=3D STMPE811_IRQ_TOUCH_DET,
>  		.block	=3D STMPE_BLOCK_TOUCHSCREEN,
>  	},
> +	{
> +		.cell	=3D &stmpe_adc_cell,
> +		.irq	=3D STMPE811_IRQ_TEMP_SENS,
> +		.block	=3D STMPE_BLOCK_ADC,
> +	},
>  };
> =20
>  static int stmpe811_enable(struct stmpe *stmpe, unsigned int blocks,
> @@ -517,6 +544,44 @@ static int stmpe811_enable(struct stmpe *stmpe, unsi=
gned int blocks,
>  				enable ? 0 : mask);
>  }
> =20
> +static int stmpe811_init_adc(struct stmpe *stmpe)
> +{
> +	int ret;
> +	u8 adc_ctrl1, adc_ctrl1_mask;
> +
> +	ret =3D stmpe_enable(stmpe, STMPE_BLOCK_ADC);
> +	if (ret) {
> +		dev_err(stmpe->dev, "Could not enable clock for ADC\n");

This is a little unusual flow wise. It would be expected that stmpe_enable
would leave no visible effects if it fails, so we shouldn't need
to disable it explicitly in the error path here.  Any requirement
for that should have been done inside stmpe_enable when it detects
the error.  There are corner cases in which it might fail undetectably
up, but we typically wouldn't handle those odd ones.

If there is a really good reason that I'm missing I'd like to see
a comment here saying why.

> +		goto err_adc;
> +	}
> +
> +	adc_ctrl1 =3D STMPE_SAMPLE_TIME(stmpe->sample_time) |
> +		    STMPE_MOD_12B(stmpe->mod_12b) |
> +		    STMPE_REF_SEL(stmpe->ref_sel);
> +	adc_ctrl1_mask =3D STMPE_SAMPLE_TIME(0xff) | STMPE_MOD_12B(0xff) |
> +			 STMPE_REF_SEL(0xff);
> +
> +	ret =3D stmpe_set_bits(stmpe, STMPE811_REG_ADC_CTRL1,
> +			adc_ctrl1_mask, adc_ctrl1);
> +	if (ret) {
> +		dev_err(stmpe->dev, "Could not setup ADC\n");
> +		goto err_adc;
> +	}
> +
> +	ret =3D stmpe_set_bits(stmpe, STMPE811_REG_ADC_CTRL2,
> +			STMPE_ADC_FREQ(0xff), STMPE_ADC_FREQ(stmpe->adc_freq));
> +	if (ret) {
> +		dev_err(stmpe->dev, "Could not setup ADC\n");
> +		goto err_adc;
> +	}
> +
> +	return 0;
> +err_adc:
> +	stmpe_disable(stmpe, STMPE_BLOCK_ADC);
> +
> +	return ret;
> +}
> +
>  static int stmpe811_get_altfunc(struct stmpe *stmpe, enum stmpe_block bl=
ock)
>  {
>  	/* 0 for touchscreen, 1 for GPIO */
> @@ -1235,6 +1300,12 @@ static int stmpe_chip_init(struct stmpe *stmpe)
>  			return ret;
>  	}
> =20
> +	if (id =3D=3D STMPE811_ID) {
> +		ret =3D stmpe811_init_adc(stmpe);
> +		if (ret)
> +			return ret;
> +	}
> +
>  	return stmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_ICR_LSB], icr);
>  }
> =20
> @@ -1325,6 +1396,7 @@ int stmpe_probe(struct stmpe_client_info *ci, enum =
stmpe_partnum partnum)
>  	struct device_node *np =3D ci->dev->of_node;
>  	struct stmpe *stmpe;
>  	int ret;
> +	u32 val;
> =20
>  	pdata =3D devm_kzalloc(ci->dev, sizeof(*pdata), GFP_KERNEL);
>  	if (!pdata)
> @@ -1342,6 +1414,15 @@ int stmpe_probe(struct stmpe_client_info *ci, enum=
 stmpe_partnum partnum)
>  	mutex_init(&stmpe->irq_lock);
>  	mutex_init(&stmpe->lock);
> =20
> +	if (!of_property_read_u32(np, "st,sample-time", &val))
> +		stmpe->sample_time =3D val;
> +	if (!of_property_read_u32(np, "st,mod-12b", &val))
> +		stmpe->mod_12b =3D val;
> +	if (!of_property_read_u32(np, "st,ref-sel", &val))
> +		stmpe->ref_sel =3D val;
> +	if (!of_property_read_u32(np, "st,adc-freq", &val))
> +		stmpe->adc_freq =3D val;
> +
>  	stmpe->dev =3D ci->dev;
>  	stmpe->client =3D ci->client;
>  	stmpe->pdata =3D pdata;
> diff --git a/include/linux/mfd/stmpe.h b/include/linux/mfd/stmpe.h
> index c0353f6431f9..86dca9e9880a 100644
> --- a/include/linux/mfd/stmpe.h
> +++ b/include/linux/mfd/stmpe.h
> @@ -21,6 +21,9 @@
>  #define STMPE_I_DRIVE(x)	(x & 0x1)
>  #define STMPE_OP_MODE(x)	((x & 0x7) << 1)
> =20
> +#define STMPE811_REG_ADC_CTRL1	0x20
> +#define STMPE811_REG_ADC_CTRL2	0x21
> +
>  struct device;
>  struct regulator;
> =20
> @@ -134,6 +137,12 @@ struct stmpe {
>  	u8 ier[2];
>  	u8 oldier[2];
>  	struct stmpe_platform_data *pdata;
> +
> +	/* For devices that use an ADC */
> +	u8 sample_time;
> +	u8 mod_12b;
> +	u8 ref_sel;
> +	u8 adc_freq;
>  };
> =20
>  extern int stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 data);

