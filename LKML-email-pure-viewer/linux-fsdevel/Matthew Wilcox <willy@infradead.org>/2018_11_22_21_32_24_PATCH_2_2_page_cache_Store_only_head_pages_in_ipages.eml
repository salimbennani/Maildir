Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 08:32:20 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga007.fm.intel.com (fmsmga007.fm.intel.com [10.253.24.52])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 8379F58037D;
	Thu, 22 Nov 2018 13:32:45 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by fmsmga007-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 13:32:45 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AOJFZGBeQyUre938x5q6XIO1TlGMj4u6mDksu8pMi?=
 =?us-ascii?q?zoh2WeGdxc6/ZRWN2/xhgRfzUJnB7Loc0qyK6/CmATRIyK3CmUhKSIZLWR4BhJ?=
 =?us-ascii?q?detC0bK+nBN3fGKuX3ZTcxBsVIWQwt1Xi6NU9IBJS2PAWK8TW94jEIBxrwKxd+?=
 =?us-ascii?q?KPjrFY7OlcS30P2594HObwlSizexfbB/IA+qoQnNq8IbnZZsJqEtxxXTv3BGYf?=
 =?us-ascii?q?5WxWRmJVKSmxbz+MK994N9/ipTpvws6ddOXb31cKokQ7NYCi8mM30u683wqRbD?=
 =?us-ascii?q?VwqP6WACXWgQjxFFHhLK7BD+Xpf2ryv6qu9w0zSUMMHqUbw5Xymp4rx1QxH0li?=
 =?us-ascii?q?gIKz858HnWisNuiqJbvAmhrAF7z4LNfY2ZKOZycqbbcNgHR2ROQ9xRWjRBDI2i?=
 =?us-ascii?q?coUBAekPM+FaoInzvFsOtRmzCBKwCO/z0DJEmmX70bEm3+knDArI3BYgH9ULsH?=
 =?us-ascii?q?nMq9v6LrsSUfy1zKbWwzTIcvNZ2Tb56IfUdRAgruyHULV+cMrQzUkvEwPEg06R?=
 =?us-ascii?q?qYzjMTOVzP4CvHWF4OV6SO2jkWknqxt+ojW2wMonl4fHhoUQyl/e9CV5xp44Jd?=
 =?us-ascii?q?6mR05hZ96rDp9QuzudN4tsTcMvRXxjtiUiyrAep5K3YCwHxI46yxPRdfCLaZWE?=
 =?us-ascii?q?7xH/WOqLIDp1hmppdK+7ihux60Ss1+PxW8uu3FpUsiZJjMPAum0D2hHd7MWMV+?=
 =?us-ascii?q?Fz8V272TmV0gDe8uFELl4wlarcM5Mh3LEwmYQJsUjZHS/5hl/2jKmIeUUg4OSo?=
 =?us-ascii?q?7P7nYrr+qp+dMY97lB3+P7wwlsCjBek0KBUCUmaF9eimybHu/lH1TK9Lg/A0iq?=
 =?us-ascii?q?XZtYrVJcUfpq63GQ9V1YMj5g67Dzen1tQYgHYGIEtGeB2ZlYjpPU/BIPThAfe4?=
 =?us-ascii?q?jVWslilkx+rdM73/DZXCMGLDnK3ifblj8U5czhQ8zdRF65JTELEBL+r/WlXtu9?=
 =?us-ascii?q?zAEh85Lwu0zv7jCNV81YMRR3iDA6CEMK7JtV+I5+QvI/SDZYMPuTb9LeQl6ODq?=
 =?us-ascii?q?jXMjhVAdeqyp14MNaH+kBvRmP1mZYX30j9cBC2gKvxY+Q/btiFGYUT5Temy9X6?=
 =?us-ascii?q?Qz5jwgDIKmDIHDRp2igbCb3Se7GIFWaX5CClyWDXjocICEUe8WaC2OOs9hjiAE?=
 =?us-ascii?q?Vb+5Ro8j0hGhqhX2y7lgLurS/C0Ysonu1Nx05+3ViBEz+iZ4D8Wb02GRUW50mn?=
 =?us-ascii?q?kESCMx3KB6uUZ90EuM0bBkg/xEEtxe/+lGUhw6NZ7bzOx2EcryVRjDftqSTFam?=
 =?us-ascii?q?Q9OmASw+T94rwt8OZVp9FMumjhzZwyWqBLoVnaSRBJMo6qLcw2TxJ8FlxnbFzq?=
 =?us-ascii?q?YhiUMqQs9ONWK8gK5/+BPeB4rIk0Wfiqarer4Q3C/L9Gef02WOuFtUXxJ3UaXA?=
 =?us-ascii?q?RXoffFfZrczl5kPeSL+jEakoPRFfycGcMKdKasfmjVNdRPj9PtTSZGaxm2S1BR?=
 =?us-ascii?q?aM3b6MaIvqe2MA3CTSEkQEkgYT/WqYOgg6HCuuv2XeDDl2H1L1f0zs6fV+qG+8?=
 =?us-ascii?q?TkIs0g6FdVNh2KSv9h4Vn/OcTegT0awCuCo6rzV0HVC938/ZCtaapgpherlcbs?=
 =?us-ascii?q?054FtdyW3ZsAl9NIS6L69+nl4ebxh3v0T22hVrC4VAlM8qrG8qzAtyM66YzElN?=
 =?us-ascii?q?dzSC3ZD0O73XLGby8Qura67X3FHezdmX9r0O6PQ+t1XsogWpGlA+/HVg1tlfy2?=
 =?us-ascii?q?Gc6YnSDAoOTZLxVV46+AJ+p77EbSgy+YPV2Wd3PqmprzDNwdQpBOgiyha+ZNpf?=
 =?us-ascii?q?NKKEFAnvE8wVHcSuKeoqm0S3YRIAJuxd6Kk0P8a+ffucxKGrJPpgnC6hjWlf4I?=
 =?us-ascii?q?F9z1iA+DZmRu/J35YK2feY3gScWjf4jVehtN33mI9eaTETGGq/1TbrBIpLaqJu?=
 =?us-ascii?q?eoYLDH+kI9erydVmm57tR3lY+Ua5B1MHxMCmYwCSYEH63QFK00QYv2anmSqhwz?=
 =?us-ascii?q?NoiT4pqreQ0zLUw+TlchoKIWpLRGhkjVfxLom4ldEaXE60bwc3kBup/1r1x69e?=
 =?us-ascii?q?pK5nNWncXV9IfzTqL2FlSqaxtruCb9RP6Z8yqiVXTeK8bEueSr78pRsaziziE3?=
 =?us-ascii?q?FfxDA9azGlpJH5kwZmh2KaKXZ5tGDZdt1oxRfD+NzcQuZc3jgcSyliijnXBV+8?=
 =?us-ascii?q?M8Oy/dqOlJfDseG+V2S/WZ1VaiTryYKAtC2m5WxlGxG/nvazmsH5Hgg+yyP0y9?=
 =?us-ascii?q?5qVSDQphbmfobrz7i6Mf5gfkRwBF7z8c16Fpt8kosxgpEdwnwahpST/Xoanmb/?=
 =?us-ascii?q?K9Rb2aTibHUTQT4H2cLa4A/g2Ed7NHKG25r5VmmBwstmf9S6YXkZ2iMn48BKFa?=
 =?us-ascii?q?eb9rpEnSRur1q8rALRZ+V9nzgHxfsv7n4an/8GuA43wiqBBbASGFFSPTbwmBSQ?=
 =?us-ascii?q?89C+sKJXaX6qcbix10pxh8qtDb+crQFHRHb2ZI0iEjRu4cVlP1LBy3nz6oDieN?=
 =?us-ascii?q?nNYtMfrByUkxHcj+dLLJI9jOYFhS1iOWjlp30q1/Y7jQBy3ZG9pIWHN2Jt/Kej?=
 =?us-ascii?q?Dh9ZLDL1Yd4T+ir2jaZfhcuW24GvHpN8GjQERpfoTPSoEC4MuvTjLQqBDDo8qn?=
 =?us-ascii?q?KDE7rFAQCf8Ftmr27IE52zLH6YPn4ZzdF/RBWHIExfnRsZXDE7np4/CwCry9bt?=
 =?us-ascii?q?cEZ/5jAN+FH4rgFAxf5vNxn6Sm3fvhunai8oSJiDKxpb9gNC6F3QMcOA9eJ/BT?=
 =?us-ascii?q?1Y8oeirAyQKWybegJIAnsSWkGfA1DjP7+u5cTP8uSCB+q+KefObquKqeBES/iI?=
 =?us-ascii?q?wpev2JN8/zmQLsWPImViD/oj10tDWnB5Bt3ZmygVRCwRjS7NdMmbpBGz+iBsqs?=
 =?us-ascii?q?C/8fLrWB/g5IeVCrtSN8lv9A6ygauZK+GQgyN5Iy5C1pwQ3X/I1KQf3FkKhiFu?=
 =?us-ascii?q?aTatELcAtS3MTK7Kma9XFRkbayxtO8tS8qI8xRJAOcraitPzy755geQ5C1ZDVV?=
 =?us-ascii?q?z9hM6pYdYGLH26NFPCHEyLLqiJJSXXw8HrZqOxUadfjPhPuB2qpzmaE1XvPjCC?=
 =?us-ascii?q?lzTyUxCvMOdMjDyUPRBEuYG9dAptBnbnTN78dhK7N9p3hyUswbIonnPKKXIcMT?=
 =?us-ascii?q?9kfkNRr72Q6DlUjellF2Nd7npqM++Elj2d7+nZLJYWrPRqDj51l+Jc/HQ11b9V?=
 =?us-ascii?q?4DtYS/xynSvYtsRurE2+kumT1jpnVwJDqzZRi4KNuEViOKPZ+YFBWHbE5h0N62?=
 =?us-ascii?q?qQBg8Op9tkDN3vpq9RxsLOlKL1NDdN7dbU8dEACMjTLcLUeEYmZB7oHiPESQ4A?=
 =?us-ascii?q?ZT21PGrcwUtHn7Xa8nyTs4h/pIPglYQDTpdFW1EvUPAXEEJoGJoFOpgkcCkjlO?=
 =?us-ascii?q?u+hdIU5Xeh5CbQQM5drtiTSfOWBeTHKTCXl7BIahIEh7TiItJAZcXAx0V+Zwwi?=
 =?us-ascii?q?z8zxEE3KUIUI+3U5Yw=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0CGAAD2H/dbh0O0hNFiHQEBBQEHBQGBV?=
 =?us-ascii?q?AUBCwGCaYECJ5gRUAEBBoFJiQSQGCkNBgGIUiI3Bg0BAwEBAQEBAQIBEwEBAQg?=
 =?us-ascii?q?NCQgpIwyCNiQBgmIDAwECJBkBATcBBQkBAT4SAzkbBxIFgxwBgXQNBQqnQIFsM?=
 =?us-ascii?q?4J2AQEFgTABhWYDBYdehCsXeIEHhyWHV4kTEoZtj3IJhnyKKCORCCyNF4xJgXc?=
 =?us-ascii?q?zGggoCIMnEgGCCAwXiF6FXx4zAQEBAYEBAQGMVQEB?=
X-IPAS-Result: =?us-ascii?q?A0CGAAD2H/dbh0O0hNFiHQEBBQEHBQGBVAUBCwGCaYECJ5g?=
 =?us-ascii?q?RUAEBBoFJiQSQGCkNBgGIUiI3Bg0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBg?=
 =?us-ascii?q?mIDAwECJBkBATcBBQkBAT4SAzkbBxIFgxwBgXQNBQqnQIFsM4J2AQEFgTABhWY?=
 =?us-ascii?q?DBYdehCsXeIEHhyWHV4kTEoZtj3IJhnyKKCORCCyNF4xJgXczGggoCIMnEgGCC?=
 =?us-ascii?q?AwXiF6FXx4zAQEBAYEBAQGMVQEB?=
X-IronPort-AV: E=Sophos;i="5.56,267,1539673200"; 
   d="scan'208";a="52320961"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 13:32:43 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2438978AbeKWINx (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 03:13:53 -0500
Received: from bombadil.infradead.org ([198.137.202.133]:52106 "EHLO
        bombadil.infradead.org" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2407509AbeKWINt (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 03:13:49 -0500
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
        d=infradead.org; s=bombadil.20170209; h=References:In-Reply-To:Message-Id:
        Date:Subject:Cc:To:From:Sender:Reply-To:MIME-Version:Content-Type:
        Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:
        Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:List-Id:
        List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive;
         bh=0UsevhTtmZozmks7C4ffLdwiZeC+IEmI5pSfKcPr6N0=; b=p9RcQW/2LOptH4kN8G4iernL2
        OTD9HLzhuC2hsb3HDUdEHtteSTJ7Nr2WcTB3CVPTuV8xqPeG/MogXrjWgIdgbvVi80xxDfuQ8lQO7
        D748YMTz2iLTLtDgKZweJl82th0LFVmzsQwQkM/crGEEA/L+hxEX/y9ZhlOIEFNvIFnHRefOW8Ynn
        /jlMICpjiF5tnLM8ASSC+CHVSVOK8EvbLpWDc9wNnYuP0OYLIyCWhW+ckYtp1l7pwyepmLr89wRyZ
        xu+vFkVTJ946I/08w+Iz5NmQu1CiFYKOBNnX05n0gDRJDCE3+B/YBgb1GknzD9Q3MZtI84ml9kpQ6
        /dnMEavyw==;
Received: from willy by bombadil.infradead.org with local (Exim 4.90_1 #2 (Red Hat Linux))
        id 1gPwaS-0003Ld-JL; Thu, 22 Nov 2018 21:32:36 +0000
From: Matthew Wilcox <willy@infradead.org>
To: linux-mm@kvack.org, linux-fsdevel@vger.kernel.org
Cc: linux-kernel@vger.kernel.org,
        "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>,
        Hugh Dickins <hughd@google.com>,
        Matthew Wilcox <willy@infradead.org>
Subject: [PATCH 2/2] page cache: Store only head pages in i_pages
Date: Thu, 22 Nov 2018 13:32:24 -0800
Message-Id: <20181122213224.12793-3-willy@infradead.org>
X-Mailer: git-send-email 2.14.5
In-Reply-To: <20181122213224.12793-1-willy@infradead.org>
References: <20181122213224.12793-1-willy@infradead.org>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Transparent Huge Pages are currently stored in i_pages as pointers to
consecutive subpages.  This patch changes that to storing consecutive
pointers to the head page in preparation for storing huge pages more
efficiently in i_pages.

Large parts of this are "inspired" by Kirill's patch
https://lore.kernel.org/lkml/20170126115819.58875-2-kirill.shutemov@linux.intel.com/

Signed-off-by: Matthew Wilcox <willy@infradead.org>
---
 include/linux/pagemap.h |  9 ++++
 mm/filemap.c            | 96 +++++++++++++----------------------------
 mm/khugepaged.c         |  4 +-
 mm/shmem.c              |  2 +-
 mm/swap_state.c         |  2 +-
 5 files changed, 42 insertions(+), 71 deletions(-)

diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index 226f96f0dee06..41bf976574e74 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -345,6 +345,15 @@ static inline struct page *grab_cache_page_nowait(struct address_space *mapping,
 			mapping_gfp_mask(mapping));
 }
 
+static inline struct page *find_subpage(struct page *page, pgoff_t offset)
+{
+	VM_BUG_ON_PAGE(PageTail(page), page);
+	VM_BUG_ON_PAGE(page->index > offset, page);
+	VM_BUG_ON_PAGE(page->index + (1 << compound_order(page)) <= offset,
+			page);
+	return page - page->index + offset;
+}
+
 struct page *find_get_entry(struct address_space *mapping, pgoff_t offset);
 struct page *find_lock_entry(struct address_space *mapping, pgoff_t offset);
 unsigned find_get_entries(struct address_space *mapping, pgoff_t start,
diff --git a/mm/filemap.c b/mm/filemap.c
index 538531590ef2d..d7274591381ac 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1407,7 +1407,7 @@ EXPORT_SYMBOL(page_cache_prev_miss);
 struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)
 {
 	XA_STATE(xas, &mapping->i_pages, offset);
-	struct page *head, *page;
+	struct page *page;
 
 	rcu_read_lock();
 repeat:
@@ -1422,25 +1422,19 @@ struct page *find_get_entry(struct address_space *mapping, pgoff_t offset)
 	if (!page || xa_is_value(page))
 		goto out;
 
-	head = compound_head(page);
-	if (!page_cache_get_speculative(head))
-		goto repeat;
-
-	/* The page was split under us? */
-	if (compound_head(page) != head) {
-		put_page(head);
+	if (!page_cache_get_speculative(page))
 		goto repeat;
-	}
 
 	/*
-	 * Has the page moved?
+	 * Has the page moved or been split?
 	 * This is part of the lockless pagecache protocol. See
 	 * include/linux/pagemap.h for details.
 	 */
 	if (unlikely(page != xas_reload(&xas))) {
-		put_page(head);
+		put_page(page);
 		goto repeat;
 	}
+	page = find_subpage(page, offset);
 out:
 	rcu_read_unlock();
 
@@ -1611,7 +1605,6 @@ unsigned find_get_entries(struct address_space *mapping,
 
 	rcu_read_lock();
 	xas_for_each(&xas, page, ULONG_MAX) {
-		struct page *head;
 		if (xas_retry(&xas, page))
 			continue;
 		/*
@@ -1622,17 +1615,13 @@ unsigned find_get_entries(struct address_space *mapping,
 		if (xa_is_value(page))
 			goto export;
 
-		head = compound_head(page);
-		if (!page_cache_get_speculative(head))
+		if (!page_cache_get_speculative(page))
 			goto retry;
 
-		/* The page was split under us? */
-		if (compound_head(page) != head)
-			goto put_page;
-
-		/* Has the page moved? */
+		/* Has the page moved or been split? */
 		if (unlikely(page != xas_reload(&xas)))
 			goto put_page;
+		page = find_subpage(page, xas.xa_index);
 
 export:
 		indices[ret] = xas.xa_index;
@@ -1641,7 +1630,7 @@ unsigned find_get_entries(struct address_space *mapping,
 			break;
 		continue;
 put_page:
-		put_page(head);
+		put_page(page);
 retry:
 		xas_reset(&xas);
 	}
@@ -1683,33 +1672,27 @@ unsigned find_get_pages_range(struct address_space *mapping, pgoff_t *start,
 
 	rcu_read_lock();
 	xas_for_each(&xas, page, end) {
-		struct page *head;
 		if (xas_retry(&xas, page))
 			continue;
 		/* Skip over shadow, swap and DAX entries */
 		if (xa_is_value(page))
 			continue;
 
-		head = compound_head(page);
-		if (!page_cache_get_speculative(head))
+		if (!page_cache_get_speculative(page))
 			goto retry;
 
-		/* The page was split under us? */
-		if (compound_head(page) != head)
-			goto put_page;
-
-		/* Has the page moved? */
+		/* Has the page moved or been split? */
 		if (unlikely(page != xas_reload(&xas)))
 			goto put_page;
 
-		pages[ret] = page;
+		pages[ret] = find_subpage(page, xas.xa_index);
 		if (++ret == nr_pages) {
 			*start = page->index + 1;
 			goto out;
 		}
 		continue;
 put_page:
-		put_page(head);
+		put_page(page);
 retry:
 		xas_reset(&xas);
 	}
@@ -1754,7 +1737,6 @@ unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t index,
 
 	rcu_read_lock();
 	for (page = xas_load(&xas); page; page = xas_next(&xas)) {
-		struct page *head;
 		if (xas_retry(&xas, page))
 			continue;
 		/*
@@ -1764,24 +1746,19 @@ unsigned find_get_pages_contig(struct address_space *mapping, pgoff_t index,
 		if (xa_is_value(page))
 			break;
 
-		head = compound_head(page);
-		if (!page_cache_get_speculative(head))
+		if (!page_cache_get_speculative(page))
 			goto retry;
 
-		/* The page was split under us? */
-		if (compound_head(page) != head)
-			goto put_page;
-
-		/* Has the page moved? */
+		/* Has the page moved or been split? */
 		if (unlikely(page != xas_reload(&xas)))
 			goto put_page;
 
-		pages[ret] = page;
+		pages[ret] = find_subpage(page, xas.xa_index);
 		if (++ret == nr_pages)
 			break;
 		continue;
 put_page:
-		put_page(head);
+		put_page(page);
 retry:
 		xas_reset(&xas);
 	}
@@ -1815,7 +1792,6 @@ unsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,
 
 	rcu_read_lock();
 	xas_for_each_marked(&xas, page, end, tag) {
-		struct page *head;
 		if (xas_retry(&xas, page))
 			continue;
 		/*
@@ -1826,26 +1802,21 @@ unsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,
 		if (xa_is_value(page))
 			continue;
 
-		head = compound_head(page);
-		if (!page_cache_get_speculative(head))
+		if (!page_cache_get_speculative(page))
 			goto retry;
 
-		/* The page was split under us? */
-		if (compound_head(page) != head)
-			goto put_page;
-
-		/* Has the page moved? */
+		/* Has the page moved or been split? */
 		if (unlikely(page != xas_reload(&xas)))
 			goto put_page;
 
-		pages[ret] = page;
+		pages[ret] = find_subpage(page, xas.xa_index);
 		if (++ret == nr_pages) {
 			*index = page->index + 1;
 			goto out;
 		}
 		continue;
 put_page:
-		put_page(head);
+		put_page(page);
 retry:
 		xas_reset(&xas);
 	}
@@ -1892,7 +1863,6 @@ unsigned find_get_entries_tag(struct address_space *mapping, pgoff_t start,
 
 	rcu_read_lock();
 	xas_for_each_marked(&xas, page, ULONG_MAX, tag) {
-		struct page *head;
 		if (xas_retry(&xas, page))
 			continue;
 		/*
@@ -1903,17 +1873,13 @@ unsigned find_get_entries_tag(struct address_space *mapping, pgoff_t start,
 		if (xa_is_value(page))
 			goto export;
 
-		head = compound_head(page);
-		if (!page_cache_get_speculative(head))
+		if (!page_cache_get_speculative(page))
 			goto retry;
 
-		/* The page was split under us? */
-		if (compound_head(page) != head)
-			goto put_page;
-
-		/* Has the page moved? */
+		/* Has the page moved or been split? */
 		if (unlikely(page != xas_reload(&xas)))
 			goto put_page;
+		page = find_subpage(page, xas.xa_index);
 
 export:
 		indices[ret] = xas.xa_index;
@@ -1922,7 +1888,7 @@ unsigned find_get_entries_tag(struct address_space *mapping, pgoff_t start,
 			break;
 		continue;
 put_page:
-		put_page(head);
+		put_page(page);
 retry:
 		xas_reset(&xas);
 	}
@@ -2533,7 +2499,7 @@ void filemap_map_pages(struct vm_fault *vmf,
 	pgoff_t last_pgoff = start_pgoff;
 	unsigned long max_idx;
 	XA_STATE(xas, &mapping->i_pages, start_pgoff);
-	struct page *head, *page;
+	struct page *page;
 
 	rcu_read_lock();
 	xas_for_each(&xas, page, end_pgoff) {
@@ -2542,17 +2508,13 @@ void filemap_map_pages(struct vm_fault *vmf,
 		if (xa_is_value(page))
 			goto next;
 
-		head = compound_head(page);
-		if (!page_cache_get_speculative(head))
+		if (!page_cache_get_speculative(page))
 			goto next;
 
-		/* The page was split under us? */
-		if (compound_head(page) != head)
-			goto skip;
-
-		/* Has the page moved? */
+		/* Has the page moved or been split? */
 		if (unlikely(page != xas_reload(&xas)))
 			goto skip;
+		page = find_subpage(page, xas.xa_index);
 
 		if (!PageUptodate(page) ||
 				PageReadahead(page) ||
diff --git a/mm/khugepaged.c b/mm/khugepaged.c
index c13625c1ad5e5..7d6a1319dd42e 100644
--- a/mm/khugepaged.c
+++ b/mm/khugepaged.c
@@ -1363,7 +1363,7 @@ static void collapse_shmem(struct mm_struct *mm,
 				result = SCAN_FAIL;
 				break;
 			}
-			xas_store(&xas, new_page + (index % HPAGE_PMD_NR));
+			xas_store(&xas, new_page);
 			nr_none++;
 			continue;
 		}
@@ -1431,7 +1431,7 @@ static void collapse_shmem(struct mm_struct *mm,
 		list_add_tail(&page->lru, &pagelist);
 
 		/* Finally, replace with the new page. */
-		xas_store(&xas, new_page + (index % HPAGE_PMD_NR));
+		xas_store(&xas, new_page);
 		continue;
 out_lru:
 		xas_unlock_irq(&xas);
diff --git a/mm/shmem.c b/mm/shmem.c
index ea26d7a0342d7..c2ba84cbb0c0e 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -603,7 +603,7 @@ static int shmem_add_to_page_cache(struct page *page,
 		if (xas_error(&xas))
 			goto unlock;
 next:
-		xas_store(&xas, page + i);
+		xas_store(&xas, page);
 		if (++i < nr) {
 			xas_next(&xas);
 			goto next;
diff --git a/mm/swap_state.c b/mm/swap_state.c
index fd2f21e1c60ae..dcf9e466d2945 100644
--- a/mm/swap_state.c
+++ b/mm/swap_state.c
@@ -132,7 +132,7 @@ int add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)
 		for (i = 0; i < nr; i++) {
 			VM_BUG_ON_PAGE(xas.xa_index != idx + i, page);
 			set_page_private(page + i, entry.val + i);
-			xas_store(&xas, page + i);
+			xas_store(&xas, page);
 			xas_next(&xas);
 		}
 		address_space->nrpages += nr;
-- 
2.19.1

