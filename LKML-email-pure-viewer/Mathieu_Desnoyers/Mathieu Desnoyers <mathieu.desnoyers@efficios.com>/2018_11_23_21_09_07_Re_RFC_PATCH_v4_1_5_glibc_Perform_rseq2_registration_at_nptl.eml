Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:37:32 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga004.jf.intel.com (orsmga004.jf.intel.com [10.7.209.38])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id A441758037D;
	Fri, 23 Nov 2018 13:09:21 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga004-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 13:09:20 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AGxAMABKgTGRpKf/29tmcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgUL/j8rarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0vRz+s87lkRwPpiC?=
 =?us-ascii?q?cfNj427mfXitBrjKlGpB6tvgFzz5LIbI2QMvd1Y6HTcs4ARWdZUMhfVzJPDIC+?=
 =?us-ascii?q?YIsBEuQOMvpXoYb8p1UJsRu+HhGsCeH0xz9UhHL5wbE23v49HQzE2gErAtIAsG?=
 =?us-ascii?q?7TrNXwLKocVvq6zLXIzTXCcfxWxCr25obWfRA6p/GMWrJxftTLyUk0CgjIiVCQ?=
 =?us-ascii?q?ppb5PzOV1+QCrXWb4/B9Wu2xkG4nrQZxozixycc2kYnEnZwayl7K9SV43Ik1JN?=
 =?us-ascii?q?q4SFVhbdG4F5tQsjiXOo1rSc0sRGFovTw1yrwAuZOjYicKxponxx/DZPyGdIiI?=
 =?us-ascii?q?+QjvW/qWITd9gn9uZbGxhw6q/ES+1uHxUtO43EtEoyZbiNXAq3MA2wDJ5sWGSP?=
 =?us-ascii?q?Zx5lqt1DeN2gzJ9+1IPE85mbDGJ5Mu3LI8jIcfvErAEyLwhU74lrWZdl8+9eit?=
 =?us-ascii?q?8+nnYqvpppubN4JslAH+PbohmtalDeQ7LAcORW6b9vq41LH5+k35WrpKguU3kq?=
 =?us-ascii?q?nfrp/aOdwWqrClDwJRyIov9hiyAym83NgFnnQLMEhJdROFgoTxPlHBOvH4DfOx?=
 =?us-ascii?q?g1S2lzdrwujLPrngApXLM3jCn67tfbVj5E5Gzgo809Rf64tTCrAPJvL8RFXxuc?=
 =?us-ascii?q?fGDh82LQO02fzrCNZj2YMEX2KAHKuZPLnVsV+S6eIjO/OMa5MNuDbhN/gl4Obj?=
 =?us-ascii?q?jXs4mV8eY6alx5QWaG2jE/RiIkWZZ2fsg9gbHWcLuAo+UPLliFmYXTFPYHayWr?=
 =?us-ascii?q?o25isnB4K+EYfDWoetjaSB3CihH51WenpJCleWHXfoaoWLQfEMaC2JL89lkzwE?=
 =?us-ascii?q?U6WhSoA72RGvsg/616RoLu7O9iIEspLj0cB/5/fPmhEq6Tx0E8Od3nmPT2FzgG?=
 =?us-ascii?q?wEXTw23Kd5oUx7zVeOyqx4g/1eFdxO6PJFSAY6NZjAz+NkD9D+QB7OftCMSFy+?=
 =?us-ascii?q?WNWpHSkxTs4tw98Je0tyAc6ijhDE3yqpGbMVjaaEBJ4v/6LY3njxIdt9ynnc2K?=
 =?us-ascii?q?kgiVkmXtVANWm8iqFj8AjTApbDk1+FmKayaaQcwCnN+X+AzWWUukFUSgpwUaTf?=
 =?us-ascii?q?UnAZaUvbttD55kLET7+zBrUrKApBycieKqRUbt3ll0lJRPDmON7GeWK+h3+wBQ?=
 =?us-ascii?q?qUxrOLdIflZn8S3DvDB0QekwAc53CGNRMgCSenpG7eCD9uFVfrY0739el+qXW7?=
 =?us-ascii?q?TlI7zg2Qbk1h0aa19QARhfCGV/wT2bcEsj87qzpoBFa9w87WC92YqgV8Zqpcf8?=
 =?us-ascii?q?0y7E1H1W3DsQx9JYKvL6Z5i14acgR3uV7u1hptBoVBl8gqsG0lzA5oJa2E11NB?=
 =?us-ascii?q?ciuS3YrsNb3PNmny4BevZrbK2lHf1daW/bsP6PQ4qln5oAGlDE0i829j09lU1X?=
 =?us-ascii?q?uc6Y7HDA4TUZL3T0Y2+AJ2p7DcYikh+YzU0WdgPrWzsj/Hw9gpHvcqyg68f9dD?=
 =?us-ascii?q?N6OJDBX9E8kECMmhNuMrm0KlYQkZPO9P7qE0OcCmd/yY2KOwOOZgnTSmjXlI4Y?=
 =?us-ascii?q?xn00KM8TZ8RfDM35of3/6Y2Q6HXS/mjFi9qsD3hZxEZTYKE2u/1CjoHpJeardz?=
 =?us-ascii?q?fIYLE2iuJcK3y856h57sXX5Y6VGiC0kH2M+vZRqdcVj90RdM2kQQpHytgTG4wC?=
 =?us-ascii?q?BskzE1sqqf2zTDw/7jdBUbIGFLXnRtjVD2LYiykd8aRkmoYxE1mxS/4Ub12rZU?=
 =?us-ascii?q?pL54L2nVWkpIeyn2L2d/Uqq/rLaCYshP6I82viVTSuizfVeaSrvlqRsAzyzjB3?=
 =?us-ascii?q?dexCw8dzyyupT5ngZ2iWKHIHZosXrZf9p9xRPe5NzaWP5Q0SAKRCh+iTnLGFe8?=
 =?us-ascii?q?O8Ol8smTl5fGquq+TX6uVoVPcSn3yoONrCm76ndwAR28nPCzncfrERMg3i/41N?=
 =?us-ascii?q?lqVCPIowj6YoTw06S6MORnflRnBVPm6sp6HJ1+nZU0hJ0KxXcagZCV92IdkWjv?=
 =?us-ascii?q?KdVbxb7+bH0VSD8L2dHV5xLp2E9iLnKP3I/5UnSdws18Z9i1eG8W2yQ979xUB6?=
 =?us-ascii?q?eQ9rBLgSx1ol+gpwLLffd9hisdyecp6HMCgOEGogstwj+dArAPB0ZYOyPsmg+M?=
 =?us-ascii?q?79C/qqVXeWmufaKx1Ep4gdCuErWCrhtAV3b+f5coBTVw4dlnMFLQzH3z7ZnpeN?=
 =?us-ascii?q?zRbdIQrBKYiRnBgPZOKJItiPUKnzFoNnznvX0q0OM7iR1u3ZenvImIMWlt/aS5?=
 =?us-ascii?q?AgJGOT3xfc8c5jbtjaNGlMaMw4+vBolhGikMXJbwUfKoFzcSue7mNgmUFj08t2?=
 =?us-ascii?q?ybGaHeHQKE7EdmrnTPE42kNn2NJXkZy8liSweZJEBFnA8UWzA6lIYjFg+23Mzh?=
 =?us-ascii?q?bFt55jcJ61HjsBRMzeZoNwTlXmfbuQelcTM0SJmZLBpL4QBO/UbVMcqC7u1tGy?=
 =?us-ascii?q?FU5IGurAuIKmaDfQRHEXkJWlCYB1DkJrSu58PP8+2GCeqlNffOfa+Cqe9DV/eL?=
 =?us-ascii?q?2JKv1JFp/y2XO8WLP3liCeA720VZUXB4HcTZhysASygNmy3RaM6boQ+2+jdroc?=
 =?us-ascii?q?Cn7PTrRAXv6JOPCrtVLNVv4g22jr2FN+KKnyZ5LjBY1pwXyH/Mybgf2kMSii50?=
 =?us-ascii?q?ezmsF7QAqTDCTKbKlqBLCB4bbjt5NNFU4KIkwglNJcnbh8v11rFmj/41CFRFVV?=
 =?us-ascii?q?37lsGqf8wKJG69O03dBEaWL7SLPjnLw8DxYaOhRrxcluRUtxusuTmFF0/vJCiM?=
 =?us-ascii?q?lz7sVxq3K+FDkDmbPABCuIG6ahtiE3XjQ8n8ahKlMN57lzk2wbwvi3PONG4cNy?=
 =?us-ascii?q?V8ckxXor2R6yNYnutwG2hb4nV5KumEnj6T7/PEJZYOrftrHiN0mvpG4HQ7zrtZ?=
 =?us-ascii?q?9j1LSOZplyvSsNFupUqrku2OyjphTRpPpSxHhIONvUV+J6rZ8oNMVmrD/BII9W?=
 =?us-ascii?q?+QEQgFp8N5Ct3zvKBd0tjOm7j1KDdH8tLU+9MTBsnUKM2dNnohPgHkGDrVDAsD?=
 =?us-ascii?q?UD6qOnvTh01bkPGO6HKVqoI2pYTrmJoLGfdnUwkPF/gaQmpoGN8POt8jUjogkL?=
 =?us-ascii?q?eApMoJ73H4qwPeEpZ0pJfCA9ebHfXuJSvRobRfYRwZzKnjZdAWP5H72kF/LFV3?=
 =?us-ascii?q?h4LNCkfKRvhArCNgZQ4zuwNG930oHT574F7sdg74uCxbLvWzhBNjz1ImOek=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0B/AQAEbPhbh0O0hNFjHQEBBQEHBQGBZ?=
 =?us-ascii?q?YExgTmBAicKg2+Id4shgWglFJc7gV8sBwwBiFoiOBIBAwEBAQEBAQIBEwEBAQg?=
 =?us-ascii?q?NCQgpIwyCNiQBgmEBAQEBAgEBAiAdAQETJAEEAQkBAQEBCA4KAgINGQICA1QCB?=
 =?us-ascii?q?BMFgxwBgXkIAQSmHXCBL4J2AQEFhxYIgQuKfoFXP4FEgio1hEsBEgGDI4JXiRu?=
 =?us-ascii?q?BeIRLNE6EWIpMBwKCHASICYcekQiZVjeBBXFNI4M8CYISNYM4inBUgQIDAQEhE?=
 =?us-ascii?q?4kvgR8BgR4BAQ?=
X-IPAS-Result: =?us-ascii?q?A0B/AQAEbPhbh0O0hNFjHQEBBQEHBQGBZYExgTmBAicKg2+?=
 =?us-ascii?q?Id4shgWglFJc7gV8sBwwBiFoiOBIBAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBg?=
 =?us-ascii?q?mEBAQEBAgEBAiAdAQETJAEEAQkBAQEBCA4KAgINGQICA1QCBBMFgxwBgXkIAQS?=
 =?us-ascii?q?mHXCBL4J2AQEFhxYIgQuKfoFXP4FEgio1hEsBEgGDI4JXiRuBeIRLNE6EWIpMB?=
 =?us-ascii?q?wKCHASICYcekQiZVjeBBXFNI4M8CYISNYM4inBUgQIDAQEhE4kvgR8BgR4BAQ?=
X-IronPort-AV: E=Sophos;i="5.56,271,1539673200"; 
   d="scan'208";a="52423926"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 13:09:14 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726722AbeKXHzD (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sat, 24 Nov 2018 02:55:03 -0500
Received: from mail.efficios.com ([167.114.142.138]:36568 "EHLO
        mail.efficios.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726668AbeKXHzD (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sat, 24 Nov 2018 02:55:03 -0500
Received: from localhost (ip6-localhost [IPv6:::1])
        by mail.efficios.com (Postfix) with ESMTP id 550469ACC3;
        Fri, 23 Nov 2018 16:09:08 -0500 (EST)
Received: from mail.efficios.com ([IPv6:::1])
        by localhost (mail02.efficios.com [IPv6:::1]) (amavisd-new, port 10032)
        with ESMTP id 5-hhJ7RwYubo; Fri, 23 Nov 2018 16:09:07 -0500 (EST)
Received: from localhost (ip6-localhost [IPv6:::1])
        by mail.efficios.com (Postfix) with ESMTP id ABF809ACB7;
        Fri, 23 Nov 2018 16:09:07 -0500 (EST)
DKIM-Filter: OpenDKIM Filter v2.10.3 mail.efficios.com ABF809ACB7
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=efficios.com;
        s=default; t=1543007347;
        bh=OrbKv5IFil1JCcY2aYtDEIKFr4ZRWb/R8RG+ETlTIuA=;
        h=Date:From:To:Message-ID:MIME-Version;
        b=HlX7kxioma2CyO+I31RrsfXyHs/Ym/sRaS2VEsiQ0KRQbw0pa+C5YUQDq9muTaQ0p
         FCjPv/mNkZOAoFRrOLDgwUOSHVWx4ooKfGvnpZiomFOW1ZxC4JrkELGc+MJJ4KiEP1
         rmtRFNJ2Swu9++hkBDjaKulTfSLtzTN/ykNYskOH8XxJlZtHaJiy1r60YN93e2hFz+
         shA3muLVX0wXhBPgHqZeTmZkiiWKgSyRMe2WnptVjTcTM84JAxdWejEJQmcZZXH17K
         BZ7ghGcYSCljsvPBylbTJt9DvhDew4zukUiZnCfhUypQfxnWSrBat5AlNL1LZDmLzW
         9i3FWnyA/Y92Q==
X-Virus-Scanned: amavisd-new at efficios.com
Received: from mail.efficios.com ([IPv6:::1])
        by localhost (mail02.efficios.com [IPv6:::1]) (amavisd-new, port 10026)
        with ESMTP id EjLOfgWaK5_2; Fri, 23 Nov 2018 16:09:07 -0500 (EST)
Received: from mail02.efficios.com (mail02.efficios.com [167.114.142.138])
        by mail.efficios.com (Postfix) with ESMTP id 8AA2B9ACB0;
        Fri, 23 Nov 2018 16:09:07 -0500 (EST)
Date: Fri, 23 Nov 2018 16:09:07 -0500 (EST)
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
To: Rich Felker <dalias@libc.org>
Cc: Florian Weimer <fweimer@redhat.com>, carlos <carlos@redhat.com>,
        Joseph Myers <joseph@codesourcery.com>,
        Szabolcs Nagy <szabolcs.nagy@arm.com>,
        libc-alpha <libc-alpha@sourceware.org>,
        Thomas Gleixner <tglx@linutronix.de>,
        Ben Maurer <bmaurer@fb.com>,
        Peter Zijlstra <peterz@infradead.org>,
        "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>,
        Boqun Feng <boqun.feng@gmail.com>,
        Will Deacon <will.deacon@arm.com>,
        Dave Watson <davejwatson@fb.com>, Paul Turner <pjt@google.com>,
        linux-kernel <linux-kernel@vger.kernel.org>,
        linux-api <linux-api@vger.kernel.org>
Message-ID: <1758017676.12041.1543007347347.JavaMail.zimbra@efficios.com>
In-Reply-To: <20181123183558.GM23599@brightrain.aerifal.cx>
References: <20181121183936.8176-1-mathieu.desnoyers@efficios.com> <20181122171010.GH23599@brightrain.aerifal.cx> <871s7cvt1l.fsf@oldenburg.str.redhat.com> <20181123142843.GJ23599@brightrain.aerifal.cx> <1150466925.11664.1542992720871.JavaMail.zimbra@efficios.com> <20181123173019.GK23599@brightrain.aerifal.cx> <865273158.11687.1542995541389.JavaMail.zimbra@efficios.com> <20181123183558.GM23599@brightrain.aerifal.cx>
Subject: Re: [RFC PATCH v4 1/5] glibc: Perform rseq(2) registration at nptl
 init and thread creation
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 7bit
X-Originating-IP: [167.114.142.138]
X-Mailer: Zimbra 8.8.10_GA_3047 (ZimbraWebClient - FF52 (Linux)/8.8.10_GA_3041)
Thread-Topic: glibc: Perform rseq(2) registration at nptl init and thread creation
Thread-Index: Y0KdXQ8z9UGjS4gF+vUfwWTpiA8z3g==
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

----- On Nov 23, 2018, at 1:35 PM, Rich Felker dalias@libc.org wrote:

> On Fri, Nov 23, 2018 at 12:52:21PM -0500, Mathieu Desnoyers wrote:
>> ----- On Nov 23, 2018, at 12:30 PM, Rich Felker dalias@libc.org wrote:
>> 
>> > On Fri, Nov 23, 2018 at 12:05:20PM -0500, Mathieu Desnoyers wrote:
>> >> ----- On Nov 23, 2018, at 9:28 AM, Rich Felker dalias@libc.org wrote:
>> >> [...]
>> >> > 
>> >> > Absolutely. As long as it's in libc, implicit destruction will happen.
>> >> > Actually I think the glibc code shound unconditionally unregister the
>> >> > rseq address at exit (after blocking signals, so no application code
>> >> > can run) in case a third-party rseq library was linked and failed to
>> >> > do so before thread exit (e.g. due to mismatched ref counts) rather
>> >> > than respecting the reference count, since it knows it's the last
>> >> > user. This would make potentially-buggy code safer.
>> >> 
>> >> OK, let me go ahead with a few ideas/questions along that path.
>> >                                                 ^^^^^^^^^^^^^^^
>> >> 
>> >> Let's say our stated goal is to let the "exit" system call from the
>> >> glibc thread exit path perform rseq unregistration (without explicit
>> >> unregistration beforehand). Let's look at what we need.
>> > 
>> > This is not "along that path". The above-quoted text is not about
>> > assuming it's safe to make SYS_exit without unregistering the rseq
>> > object, but rather about glibc being able to perform the
>> > rseq-unregister syscall without caring about reference counts, since
>> > it knows no other code that might depend on rseq can run after it.
>> 
>> When saying "along that path", what I mean is: if we go in that direction,
>> then we should look into going all the way there, and rely on thread
>> exit to implicitly unregister the TLS area.
>> 
>> Do you see any reason for doing an explicit unregistration at thread
>> exit rather than simply rely on the exit system call ?
> 
> Whether this is needed is an implementation detail of glibc that
> should be permitted to vary between versions. Unless glibc wants to
> promise that it would become a public guarantee, it's not part of the
> discussion around the API/ABI. Only part of the discussion around
> implementation internals of the glibc rseq stuff.
> 
> Of course I may be biased thinking application code should not assume
> this since it's not true on musl -- for detached threads, the thread
> frees its own stack before exiting (and thus has to unregister
> set_tid_address and set_robustlist before exiting).

OK, so on glibc, the implementation could rely on exit side-effect to
implicitly unregister rseq. On musl, based on the scenario you describe,
the library should unregister rseq explicitly before stack reclaim.

Am I understanding the situation correctly ?

> 
>> >> First, we need the TLS area to be valid until the exit system call
>> >> is invoked by the thread. If glibc defines __rseq_abi as a weak symbol,
>> >> I'm not entirely sure we can guarantee the IE model if another library
>> >> gets its own global-dynamic weak symbol elected at execution time. Would
>> >> it be better to switch to a "strong" symbol for the glibc __rseq_abi
>> >> rather than weak ?
>> > 
>> > This doesn't help; still whichever comes first in link order would
>> > override. Either way __rseq_abi would be in static TLS, though,
>> > because any dynamically-loaded library is necessarily loaded after
>> > libc, which is loaded at initial exec time.
>> 
>> OK, AFAIU so you argue for leaving the __rseq_abi symbol "weak". Just making
>> sure I correctly understand your position.
> 
> I don't think it matters, and I don't think making it weak is
> meaningful or useful (weak in a shared library is largely meaningless)
> but maybe I'm missing something here.

Using a "weak" symbol in early adopter libraries is important, so they
can be loaded together into the same process without causing loader
errors due to many definitions of the same strong symbol.

Using "weak" in a C library is something I'm not sure is a characteristic
we want or need, because I doubt we would ever want to load two libc at the
same time in a given process.

The only reason I see for using "weak" for the __rseq_abi symbol in the
libc is if we want to allow early adopter applications to define
__rseq_abi as a strong symbol, which would make some sense.


> 
>> Something can be technically correct based on the current implementation,
>> but fragile with respect to future changes. We need to carefully distinguish
>> between the two when exposing ABIs.
> 
> Yes.
> 
>> >> There has been presumptions about signals being blocked when the thread
>> >> exits throughout this email thread. Out of curiosity, what code is
>> >> responsible for disabling signals in this situation ?
>> 
>> This question is still open.
> 
> I can't find it -- maybe it's not done in glibc. It is in musl, and I
> assumed glibc would also do it, because otherwise it's possible to see
> some inconsistent states from signal handlers. Maybe these are all
> undefined due to AS-unsafety of pthread_exit, but I think you can
> construct examples where something could be observably wrong without
> breaking any rules.

Good to know for the musl case.

> 
>> > Related to this,
>> >> is it valid to access a IE model TLS variable from a signal handler at
>> >> _any_ point where the signal handler nests over thread's execution ?
>> >> This includes early start and just before invoking the exit system call.
>> > 
>> > It should be valid to access *any* TLS object like this, but the
>> > standards don't cover it well. Right now access to dynamic TLS from
>> > signal handlers is unsafe in glibc, but static is safe.
>> 
>> Which is a shame for the lttng-ust tracer, which needs global-dynamic
>> TLS variables so it can be dlopen'd, but aims at allowing tracing from
>> signal handlers. It looks like due to limitations of global-dynamic
>> TLS, tracing from instrumented signal handlers with lttng-ust tracepoints
>> could crash the process if the signal handler nests early at thread start
>> or late before thread exit. One way out of this would be to ensure signals
>> are blocked at thread start/exit, but I can't find the code responsible for
>> doing this within glibc.
> 
> Just blocking at start/exit won't solve the problem because
> global-dynamic TLS in glibc involves dynamic allocation, which is hard
> to make AS-safe and of course can fail, leaving no way to make forward
> progress.

How hard would it be to create a async-signal-safe memory pool, which would
be always accessed with signals blocked, so we could fix those corner-cases
for good ?

Thanks,

Mathieu


-- 
Mathieu Desnoyers
EfficiOS Inc.
http://www.efficios.com
