Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 26 Nov 2018 08:51:27 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga007.fm.intel.com (fmsmga007.fm.intel.com [10.253.24.52])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 394935803C2;
	Sun, 25 Nov 2018 10:57:39 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by fmsmga007-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 10:57:38 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3A5tdedhW936NfWKWTSNN/Sg3vfWXV8LGtZVwlr6E/?=
 =?us-ascii?q?grcLSJyIuqrYZhCCuqdThVPEFb/W9+hDw7KP9fy4CSpYud6oizMrSNR0TRgLiM?=
 =?us-ascii?q?EbzUQLIfWuLgnFFsPsdDEwB89YVVVorDmROElRH9viNRWJ+iXhpTEdFQ/iOgVr?=
 =?us-ascii?q?O+/7BpDdj9it1+C15pbffxhEiCCybL9uLxi6txndutULioZ+N6g9zQfErGFVcO?=
 =?us-ascii?q?pM32NoIlyTnxf45siu+ZNo7jpdtfE8+cNeSKv2Z6s3Q6BWAzQgKGA1+dbktQLf?=
 =?us-ascii?q?QguV53sTSXsZnxxVCAXY9h76X5Pxsizntuph3SSRIMP7QawoVTmk8qxmUwHjhj?=
 =?us-ascii?q?sZODEl8WHXks1wg7xdoBK9vBx03orYbJiIOPZiYq/ReNUXTndDUMlMTSxMGoCy?=
 =?us-ascii?q?YIUBAeQBI+hWsof9qFQSohSjHgmsHOHixyRUhnPq06A2z/gtHBvE0QEmAtkAsG?=
 =?us-ascii?q?7UrNLwNKoKT+61zK7IzTDZYPNNxDzz6YzIfQ4gofCDW7J/b9DRwlQoGgPZgVWQ?=
 =?us-ascii?q?rYPkMiiR1uQMtWib8vZgVfioi24hqgFwrSKjydoyhYTQgI8e11PK9T1hzYorOd?=
 =?us-ascii?q?G1TFR3bcOqHZdOrS2WKoh7Tt84T2xpuis20qAKtJG6cSQQ1Jgr3QDTZvKEfoSS?=
 =?us-ascii?q?4B/vSOCcKipiin1/YrKwnROy/FCgyuLiUsm0105HrjRKktbSrHABzR/T5dadSv?=
 =?us-ascii?q?t74Eih3SyD1wfJ6uFLOUw0lKzbJIA9wrMoiJYfrUDOEjXrlEj4kqOabFgo9+u0?=
 =?us-ascii?q?5+j9Y7jrpIeQN4puhQH/NqQulNa/AeM9MgUWW2ib+OK81KDs/EHgQ7VFkOc2kq?=
 =?us-ascii?q?/Hv5DePMgboaC4AwlL3YY58Bu/ETim38oCnXUdL1JKZgiHj473NFHKOvz4Cu2/?=
 =?us-ascii?q?g1u0nDdx2//GJqHhAonKLnXblLfhfLV95FBGxAs80NBS/JZUCrAHIPLuVU79rt?=
 =?us-ascii?q?3YDhklMwOqx+brEsly1oQbWWiXGK+WLLvSsUOU5uIoO+SMZJUauDfhK/c/4P7i?=
 =?us-ascii?q?l385mUIHcqmv0psac3S4HvVgI0WEbnvgmNYBEWEWvgUgSOzmkkGNUTlWZ3yqRa?=
 =?us-ascii?q?Iz+ik7CJ66DYfEXo2tgruB0zmhEp1VYWBGDFaMEXDzeoWAWvcMbj+SI8B7njwF?=
 =?us-ascii?q?U7ihV5Eu1RW0uADmzLpnK/Le+jcEupL7yNh1++rTmAko+jxvD8Sd1GKNQ3tunm?=
 =?us-ascii?q?wSRT87x6R/oU17ylee3ql0mf1YFdpP5/xXVgc2L4LTz+t/C9rqQALOYs+JSEq6?=
 =?us-ascii?q?QtWhGTwxTcg+w9kUb0Z5GtWtlBbD3yWxDr8RlryLAoE0863G03jwIcZ912jJ1K?=
 =?us-ascii?q?07g1Y6RctPMHWshrRj+AjLG47Jj0KZmr63eqsGwi7C6n2PzWqUs0FeSw5/T6PF?=
 =?us-ascii?q?UXcbZkvVqNT54ljPT7uvCbQhLwtAxtSOKqpMat31k1pGQO3vN8jZY2K0g22wHw?=
 =?us-ascii?q?qHxquQbIr2fGUQxDjSB1Iakw8N53qGNRIxBiG6o23ACjxjDlbvY0Lq8eljp3K3?=
 =?us-ascii?q?VE40zweWb0J/07q54AIahfuZS/kLxLILpD8hqyloHFa6x9/WF9uApw9mfKVAYd?=
 =?us-ascii?q?M84E1L1X7Duwx6JJygK6FihlgRcwlsu0Pu1hN3CphPkMQwrXMqyhZyJryc0F9b?=
 =?us-ascii?q?azyY2pXwMKXNKmbu5BCvd7LW2lbG3dmM/qcA9vs5pEvjvQ2zDUUi7mho3MNT03?=
 =?us-ascii?q?uf4ZXKEhEfUZbwUkYx6hh7qKvWYig754PIy3JsNbO4vSPF29IsHOEl0Aqvf89D?=
 =?us-ascii?q?MKOYEw//C80bB9W0JOM2gVSobxIEM/pU9K47JM6mc/qG2Ki2POdvhj6mjGJH4J?=
 =?us-ascii?q?xj3UKI7SZzVunI35MdyfGCwgSHTyv8jEumss3vg4BEZC0dEXClySf5A45dfKty?=
 =?us-ascii?q?cpgRCWevOsG42s9xh5rwVHFG7l6jAFUG1dSteRqTaVz9wAJR2V4WoXyhhSu30T?=
 =?us-ascii?q?h0nys1oaqY2SzE2/7iewYfOm5XWGliik/hIIi1j9wAXEmkdRMplAaj5Uvhw6hb?=
 =?us-ascii?q?paJ/L3TcQEtSfij2KX1iXbW0traYf8FP75Youz1NUOugeVCaVqL9oxwC3iPhBW?=
 =?us-ascii?q?Re3jM7dzKtupnjhBx1kmGdLHVyrHrfZ85wwwzS5NjdRf5XwzoHSzN0iTjRBlig?=
 =?us-ascii?q?Idap+c+YmIvEsuC7T2ihTIFccTH3zYOcsyu2/W1rDge4n/ypmN3nEA463DT/19?=
 =?us-ascii?q?lrUyXIsRn9bpPq16S8LeJoYE1oCEXg5Mp9H4F0ipEwi40I2XgGmpWV+mIKkWTp?=
 =?us-ascii?q?PtVaw67+bGcNSiQNw97a+wXl3ExjLnSUx4P2THmdw81hZ8WkbWMSwC4y88dKCK?=
 =?us-ascii?q?KM5rxegSR1uka4rR7WYfVlmzcdyPgu52QAj+AHpgUt1TmdDa4IHUZDIyPsjRuI?=
 =?us-ascii?q?4su6rKVWYmavbLex2FB/ndCnELGNvAVcVGzldZclGC969t9/P07U0H3v9oHkf8?=
 =?us-ascii?q?Hdbc4Uth2RiRvBjvJaKJQslvoRnipnOHnwvXkky+49kBxv0ou2vImBK2Vx4q25?=
 =?us-ascii?q?BgRUOSHyZ8MW4jvtl7pRnt6K34CzGZVsAi4EU4HvTfKsDTIer/DnNxuVHT04q3?=
 =?us-ascii?q?ebH6ffHACF5EdnqXLPD46kN3WNKHYFytViQQGXJFZDjwAMQDU6gpk5GxioxMP7?=
 =?us-ascii?q?dUd2+CsR6kTkqhdWyeJoKhr/UnrZpAiycTc5U5yfLBtQ7gFf6EbZK82e7uRvHy?=
 =?us-ascii?q?5G+p2tthCCKmueZw5QF2EGRlSEB0z/Prmp/dTB8++YBvenL/vTe7qOr/ZSV+yP?=
 =?us-ascii?q?xZKp3Ytr5DKMNsSJPnl/APw3wEtDXXZlG8vHnzUDUTAYlyXIb8SDvhez5jV3rt?=
 =?us-ascii?q?yj8PTsQA/v5ZWAC7pRMdVs+hC6m6SDN/SXhCZ2NzlYzI4MxWTTxbgb3V4SjTxu?=
 =?us-ascii?q?dja3HbQBsy7NULzfmqtNAxEHbCNzMdNC77gg0QlVJc7bltT126Zigf4oEFhFT0?=
 =?us-ascii?q?Lum8GzacwOImGwL1fHBEeNNLSbKjzH2cD3YaWgSbJOiOVYrQG/uTGeE0X7JDSM?=
 =?us-ascii?q?iyHpVwyzMeFLlCybIB1euISnfhlxE2TsUNLmZQO9MNJsiT02wLs0hm7FNGIGMD?=
 =?us-ascii?q?h8dV9NoaOU7S9Cnvp/HGlB5GJ/LeaYgyaZ8/XYKpEOvPprGCt0keda4HU8y7RN?=
 =?us-ascii?q?7SBEROZ6mC3drtN1p1Gmk++PyidoURZUqzZLgp6LsltmOanD6pZAXnPEr1ox6j?=
 =?us-ascii?q?C0KDEu749hC9vyq+VTx8LJmabbNjhP6ZTX8NEaCsySL9iIZikPKx3sTQLUCw4M?=
 =?us-ascii?q?VnaEMWzel0pQirnG6nKRvrA+q57xhIAJTL5LElA4QKBJQn95FcAPdc8kFggvlq?=
 =?us-ascii?q?SW2YtRvSKz?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AiAABL7/pbh0O0hNFhHgEGBwaBUQkLA?=
 =?us-ascii?q?QGBVIIWJ4N5iHeLH1ABAQYFgURmiCCOIoF2KRMBiFoiNAkNAQMBAQEBAQECARM?=
 =?us-ascii?q?BAQEIDQkIKS9CARABgWIkAYJiAwMBAiAEUgYJAQEkAgUhAgIDDEgGEwWDHAGBd?=
 =?us-ascii?q?A0Fpgt8DCeFQYRHD4ELin4XeIEHgRGCXYUfgxiCVwKIfw8RBIFuhU2PJAmBEZA?=
 =?us-ascii?q?TI4lchywsmUqCDU0kFIMngicXjh0+ATKBBQEBhk+DLoJMAQE?=
X-IPAS-Result: =?us-ascii?q?A0AiAABL7/pbh0O0hNFhHgEGBwaBUQkLAQGBVIIWJ4N5iHe?=
 =?us-ascii?q?LH1ABAQYFgURmiCCOIoF2KRMBiFoiNAkNAQMBAQEBAQECARMBAQEIDQkIKS9CA?=
 =?us-ascii?q?RABgWIkAYJiAwMBAiAEUgYJAQEkAgUhAgIDDEgGEwWDHAGBdA0Fpgt8DCeFQYR?=
 =?us-ascii?q?HD4ELin4XeIEHgRGCXYUfgxiCVwKIfw8RBIFuhU2PJAmBEZATI4lchywsmUqCD?=
 =?us-ascii?q?U0kFIMngicXjh0+ATKBBQEBhk+DLoJMAQE?=
X-IronPort-AV: E=Sophos;i="5.56,279,1539673200"; 
   d="scan'208";a="52538129"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 10:57:37 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727443AbeKZFtP (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Mon, 26 Nov 2018 00:49:15 -0500
Received: from Galois.linutronix.de ([146.0.238.70]:52898 "EHLO
        Galois.linutronix.de" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726162AbeKZFtO (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 26 Nov 2018 00:49:14 -0500
Received: from localhost ([127.0.0.1] helo=nanos.tec.linutronix.de)
        by Galois.linutronix.de with esmtp (Exim 4.80)
        (envelope-from <tglx@linutronix.de>)
        id 1gQzay-0003Se-TX; Sun, 25 Nov 2018 19:57:29 +0100
Message-Id: <20181125185005.466447057@linutronix.de>
User-Agent: quilt/0.65
Date: Sun, 25 Nov 2018 19:33:49 +0100
From: Thomas Gleixner <tglx@linutronix.de>
To: LKML <linux-kernel@vger.kernel.org>
Cc: x86@kernel.org, Peter Zijlstra <peterz@infradead.org>,
        Andy Lutomirski <luto@kernel.org>,
        Linus Torvalds <torvalds@linux-foundation.org>,
        Jiri Kosina <jkosina@suse.cz>,
        Tom Lendacky <thomas.lendacky@amd.com>,
        Josh Poimboeuf <jpoimboe@redhat.com>,
        Andrea Arcangeli <aarcange@redhat.com>,
        David Woodhouse <dwmw@amazon.co.uk>,
        Tim Chen <tim.c.chen@linux.intel.com>,
        Andi Kleen <ak@linux.intel.com>,
        Dave Hansen <dave.hansen@intel.com>,
        Casey Schaufler <casey.schaufler@intel.com>,
        Asit Mallick <asit.k.mallick@intel.com>,
        Arjan van de Ven <arjan@linux.intel.com>,
        Jon Masters <jcm@redhat.com>,
        Waiman Long <longman9394@gmail.com>,
        Greg KH <gregkh@linuxfoundation.org>,
        Dave Stewart <david.c.stewart@intel.com>,
        Kees Cook <keescook@chromium.org>
Subject: [patch V2 21/28] x86/speculation: Prepare for conditional IBPB in
 switch_mm()
References: <20181125183328.318175777@linutronix.de>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Disposition: inline;
 filename=x86-speculation--Prepare-for-conditional-IBPB-in-switch_mm--.patch
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

The IBPB speculation barrier is issued from switch_mm() when the kernel
switches to a user space task with a different mm than the user space task
which ran last on the same CPU.

An additional optimization is to avoid IBPB when the incoming task can be
ptraced by the outgoing task. This optimization only works when switching
directly between two user space tasks. When switching from a kernel task to
a user space task the optimization fails because the previous task cannot
be accessed anymore. So for quite some scenarios the optimization is just
adding overhead.

The upcoming conditional IBPB support will issue IBPB only for user space
tasks which have the TIF_SPEC_IB bit set. This requires to handle the
following cases:

  1) Switch from a user space task (potential attacker) which has
     TIF_SPEC_IB set to a user space task (potential victim) which has
     TIF_SPEC_IB not set.

  2) Switch from a user space task (potential attacker) which has
     TIF_SPEC_IB not set to a user space task (potential victim) which has
     TIF_SPEC_IB set.

This needs to be optimized for the case where the IBPB can be avoided when
only kernel threads ran in between user space tasks which belong to the
same process.

The current check whether two tasks belong to the same context is using the
tasks context id. While correct, it's simpler to use the mm pointer because
it allows to mangle the TIF_SPEC_IB bit into it. The context id based
mechanism requires extra storage, which creates worse code.

When a task is scheduled out its TIF_SPEC_IB bit is mangled as bit 0 into
the per CPU storage which is used to track the last user space mm which was
running on a CPU. This bit can be used together with the TIF_SPEC_IB bit of
the incoming task to make the decision whether IBPB needs to be issued or
not to cover the two cases above.

As conditional IBPB is going to be the default, remove the dubious ptrace
check for the IBPB always case and simply issue IBPB always when the
process changes.

Move the storage to a different place in the struct as the original one
created a hole.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 arch/x86/include/asm/nospec-branch.h |    2 
 arch/x86/include/asm/tlbflush.h      |    8 +-
 arch/x86/kernel/cpu/bugs.c           |   29 +++++++--
 arch/x86/mm/tlb.c                    |  109 +++++++++++++++++++++++++----------
 4 files changed, 110 insertions(+), 38 deletions(-)

--- a/arch/x86/include/asm/nospec-branch.h
+++ b/arch/x86/include/asm/nospec-branch.h
@@ -312,6 +312,8 @@ do {									\
 } while (0)
 
 DECLARE_STATIC_KEY_FALSE(switch_to_cond_stibp);
+DECLARE_STATIC_KEY_FALSE(switch_mm_cond_ibpb);
+DECLARE_STATIC_KEY_FALSE(switch_mm_always_ibpb);
 
 #endif /* __ASSEMBLY__ */
 
--- a/arch/x86/include/asm/tlbflush.h
+++ b/arch/x86/include/asm/tlbflush.h
@@ -169,10 +169,14 @@ struct tlb_state {
 
 #define LOADED_MM_SWITCHING ((struct mm_struct *)1)
 
+	/* Last user mm for optimizing IBPB */
+	union {
+		struct mm_struct	*last_user_mm;
+		unsigned long		last_user_mm_ibpb;
+	};
+
 	u16 loaded_mm_asid;
 	u16 next_asid;
-	/* last user mm's ctx id */
-	u64 last_ctx_id;
 
 	/*
 	 * We can be in one of several states:
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -56,6 +56,10 @@ u64 __ro_after_init x86_amd_ls_cfg_ssbd_
 
 /* Control conditional STIPB in switch_to() */
 DEFINE_STATIC_KEY_FALSE(switch_to_cond_stibp);
+/* Control conditional IBPB in switch_mm() */
+DEFINE_STATIC_KEY_FALSE(switch_mm_cond_ibpb);
+/* Control unconditional IBPB in switch_mm() */
+DEFINE_STATIC_KEY_FALSE(switch_mm_always_ibpb);
 
 void __init check_bugs(void)
 {
@@ -331,7 +335,17 @@ spectre_v2_user_select_mitigation(enum s
 	/* Initialize Indirect Branch Prediction Barrier */
 	if (boot_cpu_has(X86_FEATURE_IBPB)) {
 		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
-		pr_info("Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\n");
+
+		switch (mode) {
+		case SPECTRE_V2_USER_STRICT:
+			static_branch_enable(&switch_mm_always_ibpb);
+			break;
+		default:
+			break;
+		}
+
+		pr_info("mitigation: Enabling %s Indirect Branch Prediction Barrier\n",
+			mode == SPECTRE_V2_USER_STRICT ? "always-on" : "conditional");
 	}
 
 	/* If enhanced IBRS is enabled no STIPB required */
@@ -955,10 +969,15 @@ static char *stibp_state(void)
 
 static char *ibpb_state(void)
 {
-	if (boot_cpu_has(X86_FEATURE_USE_IBPB))
-		return ", IBPB";
-	else
-		return "";
+	if (boot_cpu_has(X86_FEATURE_IBPB)) {
+		switch (spectre_v2_user) {
+		case SPECTRE_V2_USER_NONE:
+			return ", IBPB: disabled";
+		case SPECTRE_V2_USER_STRICT:
+			return ", IBPB: always-on";
+		}
+	}
+	return "";
 }
 
 static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -7,7 +7,6 @@
 #include <linux/export.h>
 #include <linux/cpu.h>
 #include <linux/debugfs.h>
-#include <linux/ptrace.h>
 
 #include <asm/tlbflush.h>
 #include <asm/mmu_context.h>
@@ -31,6 +30,12 @@
  */
 
 /*
+ * Use bit 0 to mangle the TIF_SPEC_IB state into the mm pointer which is
+ * stored in cpu_tlb_state.last_user_mm_ibpb.
+ */
+#define LAST_USER_MM_IBPB	0x1UL
+
+/*
  * We get here when we do something requiring a TLB invalidation
  * but could not go invalidate all of the contexts.  We do the
  * necessary invalidation by clearing out the 'ctx_id' which
@@ -181,17 +186,77 @@ static void sync_current_stack_to_mm(str
 	}
 }
 
-static bool ibpb_needed(struct task_struct *tsk, u64 last_ctx_id)
+static inline unsigned long mm_mangle_tif_spec_ib(struct task_struct *next)
 {
-	/*
-	 * Check if the current (previous) task has access to the memory
-	 * of the @tsk (next) task. If access is denied, make sure to
-	 * issue a IBPB to stop user->user Spectre-v2 attacks.
-	 *
-	 * Note: __ptrace_may_access() returns 0 or -ERRNO.
-	 */
-	return (tsk && tsk->mm && tsk->mm->context.ctx_id != last_ctx_id &&
-		ptrace_may_access_sched(tsk, PTRACE_MODE_SPEC_IBPB));
+	unsigned long next_tif = task_thread_info(next)->flags;
+	unsigned long ibpb = (next_tif >> TIF_SPEC_IB) & LAST_USR_MM_IBPB;
+
+	return (unsigned long)next->mm | ibpb;
+}
+
+static void cond_ibpb(struct task_struct *next)
+{
+	if (!next || !next->mm)
+		return;
+
+	if (static_branch_likely(&switch_mm_cond_ibpb)) {
+		unsigned long prev_mm, next_mm;
+
+		/*
+		 * This is a bit more complex than the always mode because
+		 * it has to handle two cases:
+		 *
+		 * 1) Switch from a user space task (potential attacker)
+		 *    which has TIF_SPEC_IB set to a user space task
+		 *    (potential victim) which has TIF_SPEC_IB not set.
+		 *
+		 * 2) Switch from a user space task (potential attacker)
+		 *    which has TIF_SPEC_IB not set to a user space task
+		 *    (potential victim) which has TIF_SPEC_IB set.
+		 *
+		 * This could be done by unconditionally issuing IBPB when
+		 * a task which has TIF_SPEC_IB set is either scheduled in
+		 * or out. Though that results in two flushes when:
+		 *
+		 * - the same user space task is scheduled out and later
+		 *   scheduled in again and only a kernel thread ran in
+		 *   between.
+		 *
+		 * - a user space task belonging to the same process is
+		 *   scheduled in after a kernel thread ran in between
+		 *
+		 * - a user space task belonging to the same process is
+		 *   scheduled in immediately.
+		 *
+		 * Optimize this with reasonably small overhead for the
+		 * above cases. Mangle the TIF_SPEC_IB bit into the mm
+		 * pointer of the incoming task which is stored in
+		 * cpu_tlbstate.last_user_mm_ibpb for comparison.
+		 */
+		next_mm = mm_mangle_tif_spec_ib(next);
+		prev_mm = this_cpu_read(cpu_tlbstate.last_user_mm_ibpb);
+
+		/*
+		 * Issue IBPB only if the mm's are different and one or
+		 * both have the IBPB bit set.
+		 */
+		if (next_mm != prev_mm && (next_mm | prev_mm) & LAST_USR_MM_IBPB)
+			indirect_branch_prediction_barrier();
+
+		this_cpu_write(cpu_tlbstate.last_user_mm_ibpb, next_mm);
+	}
+
+	if (static_branch_unlikely(&switch_mm_always_ibpb)) {
+		/*
+		 * Only flush when switching to a user space task with a
+		 * different context than the user space task which ran
+		 * last on this CPU.
+		 */
+		if (this_cpu_read(cpu_tlbstate.last_user_mm) != next->mm) {
+			indirect_branch_prediction_barrier();
+			this_cpu_write(cpu_tlbstate.last_user_mm, next->mm);
+		}
+	}
 }
 
 void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,
@@ -292,22 +357,12 @@ void switch_mm_irqs_off(struct mm_struct
 		new_asid = prev_asid;
 		need_flush = true;
 	} else {
-		u64 last_ctx_id = this_cpu_read(cpu_tlbstate.last_ctx_id);
-
 		/*
 		 * Avoid user/user BTB poisoning by flushing the branch
 		 * predictor when switching between processes. This stops
 		 * one process from doing Spectre-v2 attacks on another.
-		 *
-		 * As an optimization, flush indirect branches only when
-		 * switching into a processes that can't be ptrace by the
-		 * current one (as in such case, attacker has much more
-		 * convenient way how to tamper with the next process than
-		 * branch buffer poisoning).
 		 */
-		if (static_cpu_has(X86_FEATURE_USE_IBPB) &&
-				ibpb_needed(tsk, last_ctx_id))
-			indirect_branch_prediction_barrier();
+		cond_ibpb(tsk);
 
 		if (IS_ENABLED(CONFIG_VMAP_STACK)) {
 			/*
@@ -365,14 +420,6 @@ void switch_mm_irqs_off(struct mm_struct
 		trace_tlb_flush_rcuidle(TLB_FLUSH_ON_TASK_SWITCH, 0);
 	}
 
-	/*
-	 * Record last user mm's context id, so we can avoid
-	 * flushing branch buffer with IBPB if we switch back
-	 * to the same user.
-	 */
-	if (next != &init_mm)
-		this_cpu_write(cpu_tlbstate.last_ctx_id, next->context.ctx_id);
-
 	/* Make sure we write CR3 before loaded_mm. */
 	barrier();
 
@@ -441,7 +488,7 @@ void initialize_tlbstate_and_flush(void)
 	write_cr3(build_cr3(mm->pgd, 0));
 
 	/* Reinitialize tlbstate. */
-	this_cpu_write(cpu_tlbstate.last_ctx_id, mm->context.ctx_id);
+	this_cpu_write(cpu_tlbstate.last_user_mm_ibpb, LAST_USR_MM_IBPB);
 	this_cpu_write(cpu_tlbstate.loaded_mm_asid, 0);
 	this_cpu_write(cpu_tlbstate.next_asid, 1);
 	this_cpu_write(cpu_tlbstate.ctxs[0].ctx_id, mm->context.ctx_id);


