Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:36:52 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id BAC54580460
	for <like.xu@linux.intel.com>; Fri, 23 Nov 2018 10:30:52 -0800 (PST)
Received: from fmsmga105.fm.intel.com ([10.1.193.10])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 10:30:52 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AtDljbBwDFemoY4XXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0uoXKPad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXXRPXshRWSJCDI2z?=
 =?us-ascii?q?YYQAAOgdMuhXsof9v1kDoxmxCAWxCu7j1iFHhmTt0K0m0eksCx3K0BAuEt8Mtn?=
 =?us-ascii?q?nfsdX7NL0VUeCw1KTG1y/Mb/RS2Tf69YPFbxchofeNXLJxd8rRyFQkGgTdjlqL?=
 =?us-ascii?q?rozlOTKU1uULs2ia9OdgT/yghHMnqw5rvjij3Nsjio7Mho8MzF3P6CZ3wJ4tKN?=
 =?us-ascii?q?GmVEJ2YsSoHIZNuyyZLYd6XM0vTmFytConyLAKoYC3cDQOxZg92hLSZeKLf5KV?=
 =?us-ascii?q?7h/gWuudOyl0iXFjdbminRi961Kgxff5VsSs0FZFsC5Fkt7Uu3AJ1hzT8dSHSu?=
 =?us-ascii?q?Bn8keu3zaPyhrf6uZeIUA7jabbKpghzaAslpcLr0jPAiz7lF/rgKOLdUgo4Pak?=
 =?us-ascii?q?5urnb7n8u5ORNZd4igTkPaQvnsy/D/44Mg8LX2WD4OSzyrjj/VDgTLpXkPI2jL?=
 =?us-ascii?q?fWsJTDKcsAoa65HglV3Zo95BakCDum1NUYnXoZI15fdxOHkpDkO1XPIPD+EPe+?=
 =?us-ascii?q?jE6gkDZtx/DaILLhBo/BIWTEkLfkZrt97UlcyAw8zdBZ+pJYELYBIOj8WkPprt?=
 =?us-ascii?q?zXEgc5MxCow+bgENh90oIeWWGRDaODP6LSrESF5uYuI+mKeY8UtyzxK/kj5/7y?=
 =?us-ascii?q?k3A5nUURcrWu3ZsSOziFGO97KRCZfWb0mYVGVmMLpRYlCurtjlKETHhUfXn1Wq?=
 =?us-ascii?q?s94jQyDsWhFZvCQYa2x6WM2Tr+EpBIa2QVN1aXDH29coyFX+sLOjufJ9IknjEa?=
 =?us-ascii?q?WLzkUYI4yBy1qCf8zLxoKPeS/TcX4on+3tp47PGGiBcp6DZvBN6c2Wzec2Yh1E?=
 =?us-ascii?q?8SAXca1b5+rQRUzl6FmYd5h/ZVD8AZr6dFXQY+P5PG08RgBtzyUx6HddCMHhLu?=
 =?us-ascii?q?TcivBz4rSdQ+hc8PakFVFNCrjxSF1C2vUJEPkLnePJUz9qWU9X/3Ncd7yj6SzK?=
 =?us-ascii?q?MmiUsnRMpnL2CqhqdjsQPUAtiawA2ii6+2ePFEj2b2/2CZwD/L5RkAXQ=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AKAACMRvhbhxHrdtBjGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUgUBAQELAYEwgk8Tg3mId4shgWAtiQuOMIF2ERgUiFoiNQgNAQMBAQE?=
 =?us-ascii?q?BAQECARMBAQEKCwkIGw4vgjYFAgMaAQaCWwEBAQEDAQIgBB8KKQMDAQIGAQEKF?=
 =?us-ascii?q?QMCAiIEAgIDAR02BgEJAwYCAQEBgxyBagMVAQSnCHwzh3QNghmBC4p+F4FAP4E?=
 =?us-ascii?q?RJ4JrglaFLIJXAokjhjmPeC4JjgSDJQYYgVmFC4JtEIcnjk2GMYMygUgCggkzG?=
 =?us-ascii?q?ggbFYMngicXEo4LQDGBBxyKDoF3AQE?=
X-IPAS-Result: =?us-ascii?q?A0AKAACMRvhbhxHrdtBjGwEBAQEDAQEBBwMBAQGBUgUBAQE?=
 =?us-ascii?q?LAYEwgk8Tg3mId4shgWAtiQuOMIF2ERgUiFoiNQgNAQMBAQEBAQECARMBAQEKC?=
 =?us-ascii?q?wkIGw4vgjYFAgMaAQaCWwEBAQEDAQIgBB8KKQMDAQIGAQEKFQMCAiIEAgIDAR0?=
 =?us-ascii?q?2BgEJAwYCAQEBgxyBagMVAQSnCHwzh3QNghmBC4p+F4FAP4ERJ4JrglaFLIJXA?=
 =?us-ascii?q?okjhjmPeC4JjgSDJQYYgVmFC4JtEIcnjk2GMYMygUgCggkzGggbFYMngicXEo4?=
 =?us-ascii?q?LQDGBBxyKDoF3AQE?=
X-IronPort-AV: E=Sophos;i="5.56,270,1539673200"; 
   d="scan'208";a="139345745"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 23 Nov 2018 10:30:51 -0800
Received: from localhost ([::1]:53867 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQGE6-00041q-Ob
	for like.xu@linux.intel.com; Fri, 23 Nov 2018 13:30:50 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:34403)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <pbonzini@redhat.com>) id 1gQGDA-0003c1-Qg
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 13:29:55 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <pbonzini@redhat.com>) id 1gQG6U-00062O-AW
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 13:23:02 -0500
Received: from mx1.redhat.com ([209.132.183.28]:37982)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <pbonzini@redhat.com>) id 1gQG6T-00060C-Ty
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 13:22:58 -0500
Received: from smtp.corp.redhat.com (int-mx04.intmail.prod.int.phx2.redhat.com
	[10.5.11.14])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id B580783F3E;
	Fri, 23 Nov 2018 18:22:56 +0000 (UTC)
Received: from [10.36.112.71] (ovpn-112-71.ams2.redhat.com [10.36.112.71])
	by smtp.corp.redhat.com (Postfix) with ESMTPS id 355875DE01;
	Fri, 23 Nov 2018 18:22:45 +0000 (UTC)
To: "Dr. David Alan Gilbert" <dgilbert@redhat.com>, guangrong.xiao@gmail.com
References: <20181122072028.22819-1-xiaoguangrong@tencent.com>
	<20181122072028.22819-4-xiaoguangrong@tencent.com>
	<20181123181717.GH2373@work-vm>
From: Paolo Bonzini <pbonzini@redhat.com>
Openpgp: preference=signencrypt
Autocrypt: addr=pbonzini@redhat.com; prefer-encrypt=mutual; keydata=
	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
Message-ID: <ec42ec4b-652d-807e-2d88-94a2d52e9cec@redhat.com>
Date: Fri, 23 Nov 2018 19:22:44 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
	Thunderbird/60.3.0
MIME-Version: 1.0
In-Reply-To: <20181123181717.GH2373@work-vm>
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.14
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.27]);
	Fri, 23 Nov 2018 18:22:56 +0000 (UTC)
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 209.132.183.28
Subject: Re: [Qemu-devel] [PATCH v3 3/5] migration: use threaded workqueue
 for compression
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: kvm@vger.kernel.org, mst@redhat.com, mtosatti@redhat.com,
	Xiao Guangrong <xiaoguangrong@tencent.com>,
	qemu-devel@nongnu.org, peterx@redhat.com, quintela@redhat.com,
	wei.w.wang@intel.com, cota@braap.org, jiang.biao2@zte.com.cn
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On 23/11/18 19:17, Dr. David Alan Gilbert wrote:
> * guangrong.xiao@gmail.com (guangrong.xiao@gmail.com) wrote:
>> From: Xiao Guangrong <xiaoguangrong@tencent.com>
>>
>> Adapt the compression code to the threaded workqueue
>>
>> Signed-off-by: Xiao Guangrong <xiaoguangrong@tencent.com>
>> ---
>>  migration/ram.c | 308 ++++++++++++++++++++------------------------------------
>>  1 file changed, 110 insertions(+), 198 deletions(-)
>>
>> diff --git a/migration/ram.c b/migration/ram.c
>> index 7e7deec4d8..254c08f27b 100644
>> --- a/migration/ram.c
>> +++ b/migration/ram.c
>> @@ -57,6 +57,7 @@
>>  #include "qemu/uuid.h"
>>  #include "savevm.h"
>>  #include "qemu/iov.h"
>> +#include "qemu/threaded-workqueue.h"
>>  
>>  /***********************************************************/
>>  /* ram save/restore */
>> @@ -349,22 +350,6 @@ typedef struct PageSearchStatus PageSearchStatus;
>>  
>>  CompressionStats compression_counters;
>>  
>> -struct CompressParam {
>> -    bool done;
>> -    bool quit;
>> -    bool zero_page;
>> -    QEMUFile *file;
>> -    QemuMutex mutex;
>> -    QemuCond cond;
>> -    RAMBlock *block;
>> -    ram_addr_t offset;
>> -
>> -    /* internally used fields */
>> -    z_stream stream;
>> -    uint8_t *originbuf;
>> -};
>> -typedef struct CompressParam CompressParam;
>> -
>>  struct DecompressParam {
>>      bool done;
>>      bool quit;
>> @@ -377,15 +362,6 @@ struct DecompressParam {
>>  };
>>  typedef struct DecompressParam DecompressParam;
>>  
>> -static CompressParam *comp_param;
>> -static QemuThread *compress_threads;
>> -/* comp_done_cond is used to wake up the migration thread when
>> - * one of the compression threads has finished the compression.
>> - * comp_done_lock is used to co-work with comp_done_cond.
>> - */
>> -static QemuMutex comp_done_lock;
>> -static QemuCond comp_done_cond;
>> -/* The empty QEMUFileOps will be used by file in CompressParam */
>>  static const QEMUFileOps empty_ops = { };
>>  
>>  static QEMUFile *decomp_file;
>> @@ -394,125 +370,6 @@ static QemuThread *decompress_threads;
>>  static QemuMutex decomp_done_lock;
>>  static QemuCond decomp_done_cond;
>>  
>> -static bool do_compress_ram_page(QEMUFile *f, z_stream *stream, RAMBlock *block,
>> -                                 ram_addr_t offset, uint8_t *source_buf);
>> -
>> -static void *do_data_compress(void *opaque)
>> -{
>> -    CompressParam *param = opaque;
>> -    RAMBlock *block;
>> -    ram_addr_t offset;
>> -    bool zero_page;
>> -
>> -    qemu_mutex_lock(&param->mutex);
>> -    while (!param->quit) {
>> -        if (param->block) {
>> -            block = param->block;
>> -            offset = param->offset;
>> -            param->block = NULL;
>> -            qemu_mutex_unlock(&param->mutex);
>> -
>> -            zero_page = do_compress_ram_page(param->file, &param->stream,
>> -                                             block, offset, param->originbuf);
>> -
>> -            qemu_mutex_lock(&comp_done_lock);
>> -            param->done = true;
>> -            param->zero_page = zero_page;
>> -            qemu_cond_signal(&comp_done_cond);
>> -            qemu_mutex_unlock(&comp_done_lock);
>> -
>> -            qemu_mutex_lock(&param->mutex);
>> -        } else {
>> -            qemu_cond_wait(&param->cond, &param->mutex);
>> -        }
>> -    }
>> -    qemu_mutex_unlock(&param->mutex);
>> -
>> -    return NULL;
>> -}
>> -
>> -static void compress_threads_save_cleanup(void)
>> -{
>> -    int i, thread_count;
>> -
>> -    if (!migrate_use_compression() || !comp_param) {
>> -        return;
>> -    }
>> -
>> -    thread_count = migrate_compress_threads();
>> -    for (i = 0; i < thread_count; i++) {
>> -        /*
>> -         * we use it as a indicator which shows if the thread is
>> -         * properly init'd or not
>> -         */
>> -        if (!comp_param[i].file) {
>> -            break;
>> -        }
>> -
>> -        qemu_mutex_lock(&comp_param[i].mutex);
>> -        comp_param[i].quit = true;
>> -        qemu_cond_signal(&comp_param[i].cond);
>> -        qemu_mutex_unlock(&comp_param[i].mutex);
>> -
>> -        qemu_thread_join(compress_threads + i);
>> -        qemu_mutex_destroy(&comp_param[i].mutex);
>> -        qemu_cond_destroy(&comp_param[i].cond);
>> -        deflateEnd(&comp_param[i].stream);
>> -        g_free(comp_param[i].originbuf);
>> -        qemu_fclose(comp_param[i].file);
>> -        comp_param[i].file = NULL;
>> -    }
>> -    qemu_mutex_destroy(&comp_done_lock);
>> -    qemu_cond_destroy(&comp_done_cond);
>> -    g_free(compress_threads);
>> -    g_free(comp_param);
>> -    compress_threads = NULL;
>> -    comp_param = NULL;
>> -}
>> -
>> -static int compress_threads_save_setup(void)
>> -{
>> -    int i, thread_count;
>> -
>> -    if (!migrate_use_compression()) {
>> -        return 0;
>> -    }
>> -    thread_count = migrate_compress_threads();
>> -    compress_threads = g_new0(QemuThread, thread_count);
>> -    comp_param = g_new0(CompressParam, thread_count);
>> -    qemu_cond_init(&comp_done_cond);
>> -    qemu_mutex_init(&comp_done_lock);
>> -    for (i = 0; i < thread_count; i++) {
>> -        comp_param[i].originbuf = g_try_malloc(TARGET_PAGE_SIZE);
>> -        if (!comp_param[i].originbuf) {
>> -            goto exit;
>> -        }
>> -
>> -        if (deflateInit(&comp_param[i].stream,
>> -                        migrate_compress_level()) != Z_OK) {
>> -            g_free(comp_param[i].originbuf);
>> -            goto exit;
>> -        }
>> -
>> -        /* comp_param[i].file is just used as a dummy buffer to save data,
>> -         * set its ops to empty.
>> -         */
>> -        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);
>> -        comp_param[i].done = true;
>> -        comp_param[i].quit = false;
>> -        qemu_mutex_init(&comp_param[i].mutex);
>> -        qemu_cond_init(&comp_param[i].cond);
>> -        qemu_thread_create(compress_threads + i, "compress",
>> -                           do_data_compress, comp_param + i,
>> -                           QEMU_THREAD_JOINABLE);
>> -    }
>> -    return 0;
>> -
>> -exit:
>> -    compress_threads_save_cleanup();
>> -    return -1;
>> -}
>> -
>>  /* Multiple fd's */
>>  
>>  #define MULTIFD_MAGIC 0x11223344U
>> @@ -1909,12 +1766,25 @@ exit:
>>      return zero_page;
>>  }
>>  
>> +struct CompressData {
>> +    /* filled by migration thread.*/
>> +    RAMBlock *block;
>> +    ram_addr_t offset;
>> +
>> +    /* filled by compress thread. */
>> +    QEMUFile *file;
>> +    z_stream stream;
>> +    uint8_t *originbuf;
>> +    bool zero_page;
>> +};
>> +typedef struct CompressData CompressData;
>> +
>>  static void
>> -update_compress_thread_counts(const CompressParam *param, int bytes_xmit)
>> +update_compress_thread_counts(CompressData *cd, int bytes_xmit)
> 
> Keep the const?
>>  {
>>      ram_counters.transferred += bytes_xmit;
>>  
>> -    if (param->zero_page) {
>> +    if (cd->zero_page) {
>>          ram_counters.duplicate++;
>>          return;
>>      }
>> @@ -1924,81 +1794,123 @@ update_compress_thread_counts(const CompressParam *param, int bytes_xmit)
>>      compression_counters.pages++;
>>  }
>>  
>> +static int compress_thread_data_init(void *request)
>> +{
>> +    CompressData *cd = request;
>> +
>> +    cd->originbuf = g_try_malloc(TARGET_PAGE_SIZE);
>> +    if (!cd->originbuf) {
>> +        return -1;
>> +    }
>> +
>> +    if (deflateInit(&cd->stream, migrate_compress_level()) != Z_OK) {
>> +        g_free(cd->originbuf);
>> +        return -1;
>> +    }
> 
> Please print errors if you fail in any case so we can easily tell what
> happened.
> 
>> +    cd->file = qemu_fopen_ops(NULL, &empty_ops);
>> +    return 0;
>> +}
>> +
>> +static void compress_thread_data_fini(void *request)
>> +{
>> +    CompressData *cd = request;
>> +
>> +    qemu_fclose(cd->file);
>> +    deflateEnd(&cd->stream);
>> +    g_free(cd->originbuf);
>> +}
>> +
>> +static void compress_thread_data_handler(void *request)
>> +{
>> +    CompressData *cd = request;
>> +
>> +    /*
>> +     * if compression fails, it will be indicated by
>> +     * migrate_get_current()->to_dst_file.
>> +     */
>> +    cd->zero_page = do_compress_ram_page(cd->file, &cd->stream, cd->block,
>> +                                         cd->offset, cd->originbuf);
>> +}
>> +
>> +static void compress_thread_data_done(void *request)
>> +{
>> +    CompressData *cd = request;
>> +    RAMState *rs = ram_state;
>> +    int bytes_xmit;
>> +
>> +    bytes_xmit = qemu_put_qemu_file(rs->f, cd->file);
>> +    update_compress_thread_counts(cd, bytes_xmit);
>> +}
>> +
>> +static const ThreadedWorkqueueOps compress_ops = {
>> +    .thread_request_init = compress_thread_data_init,
>> +    .thread_request_uninit = compress_thread_data_fini,
>> +    .thread_request_handler = compress_thread_data_handler,
>> +    .thread_request_done = compress_thread_data_done,
>> +    .request_size = sizeof(CompressData),
>> +};
>> +
>> +static Threads *compress_threads;
>> +
>>  static bool save_page_use_compression(RAMState *rs);
>>  
>>  static void flush_compressed_data(RAMState *rs)
>>  {
>> -    int idx, len, thread_count;
>> -
>>      if (!save_page_use_compression(rs)) {
>>          return;
>>      }
>> -    thread_count = migrate_compress_threads();
>>  
>> -    qemu_mutex_lock(&comp_done_lock);
>> -    for (idx = 0; idx < thread_count; idx++) {
>> -        while (!comp_param[idx].done) {
>> -            qemu_cond_wait(&comp_done_cond, &comp_done_lock);
>> -        }
>> -    }
>> -    qemu_mutex_unlock(&comp_done_lock);
>> +    threaded_workqueue_wait_for_requests(compress_threads);
>> +}
>>  
>> -    for (idx = 0; idx < thread_count; idx++) {
>> -        qemu_mutex_lock(&comp_param[idx].mutex);
>> -        if (!comp_param[idx].quit) {
>> -            len = qemu_put_qemu_file(rs->f, comp_param[idx].file);
>> -            /*
>> -             * it's safe to fetch zero_page without holding comp_done_lock
>> -             * as there is no further request submitted to the thread,
>> -             * i.e, the thread should be waiting for a request at this point.
>> -             */
>> -            update_compress_thread_counts(&comp_param[idx], len);
>> -        }
>> -        qemu_mutex_unlock(&comp_param[idx].mutex);
>> +static void compress_threads_save_cleanup(void)
>> +{
>> +    if (!compress_threads) {
>> +        return;
>>      }
>> +
>> +    threaded_workqueue_destroy(compress_threads);
>> +    compress_threads = NULL;
>>  }
>>  
>> -static inline void set_compress_params(CompressParam *param, RAMBlock *block,
>> -                                       ram_addr_t offset)
>> +static int compress_threads_save_setup(void)
>>  {
>> -    param->block = block;
>> -    param->offset = offset;
>> +    if (!migrate_use_compression()) {
>> +        return 0;
>> +    }
>> +
>> +    compress_threads = threaded_workqueue_create("compress",
>> +                                migrate_compress_threads(),
>> +                                DEFAULT_THREAD_REQUEST_NR, &compress_ops);
>> +    return compress_threads ? 0 : -1;
>>  }
>>  
>>  static int compress_page_with_multi_thread(RAMState *rs, RAMBlock *block,
>>                                             ram_addr_t offset)
>>  {
>> -    int idx, thread_count, bytes_xmit = -1, pages = -1;
>> +    CompressData *cd;
>>      bool wait = migrate_compress_wait_thread();
>>  
>> -    thread_count = migrate_compress_threads();
>> -    qemu_mutex_lock(&comp_done_lock);
>>  retry:
>> -    for (idx = 0; idx < thread_count; idx++) {
>> -        if (comp_param[idx].done) {
>> -            comp_param[idx].done = false;
>> -            bytes_xmit = qemu_put_qemu_file(rs->f, comp_param[idx].file);
>> -            qemu_mutex_lock(&comp_param[idx].mutex);
>> -            set_compress_params(&comp_param[idx], block, offset);
>> -            qemu_cond_signal(&comp_param[idx].cond);
>> -            qemu_mutex_unlock(&comp_param[idx].mutex);
>> -            pages = 1;
>> -            update_compress_thread_counts(&comp_param[idx], bytes_xmit);
>> -            break;
>> +    cd = threaded_workqueue_get_request(compress_threads);
>> +    if (!cd) {
>> +        /*
>> +         * wait for the free thread if the user specifies
>> +         * 'compress-wait-thread', otherwise we will post
>> +         *  the page out in the main thread as normal page.
>> +         */
>> +        if (wait) {
>> +            cpu_relax();
>> +            goto retry;
> 
> Is there nothing better we can use to wait without eating CPU time?

There is a mechanism to wait without eating CPU time in the data
structure, but it makes sense to busy wait.  There are 4 threads in the
workqueue, so you have to compare 1/4th of the time spent compressing a
page, with the trip into the kernel to wake you up.  You're adding 20%
CPU usage, but I'm not surprised it's worthwhile.

Paolo


