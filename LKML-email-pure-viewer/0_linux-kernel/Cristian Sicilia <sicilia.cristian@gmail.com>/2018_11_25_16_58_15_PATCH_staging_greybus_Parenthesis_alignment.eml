Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 26 Nov 2018 08:51:09 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga004.jf.intel.com (orsmga004.jf.intel.com [10.7.209.38])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id AF7185802E4;
	Sun, 25 Nov 2018 08:59:46 -0800 (PST)
Received: from fmsmga105.fm.intel.com ([10.1.193.10])
  by orsmga004-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 08:59:45 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3APmD+qRZN6DtGyOnIdJTq4jD/LSx+4OfEezUN459i?=
 =?us-ascii?q?sYplN5qZpcu+Zx7h7PlgxGXEQZ/co6odzbaO4+a4ASQp2tWoiDg6aptCVhsI24?=
 =?us-ascii?q?09vjcLJ4q7M3D9N+PgdCcgHc5PBxdP9nC/NlVJSo6lPwWB6nK94iQPFRrhKAF7?=
 =?us-ascii?q?Ovr6GpLIj8Swyuu+54Dfbx9HiTahYr5+Ngm6oRnMvcQKnIVuLbo8xAHUqXVSYe?=
 =?us-ascii?q?RWwm1oJVOXnxni48q74YBu/SdNtf8/7sBMSar1cbg2QrxeFzQmLns65Nb3uhnZ?=
 =?us-ascii?q?TAuA/WUTX2MLmRdVGQfF7RX6XpDssivms+d2xSeXMdHqQb0yRD+v9LlgRgP2hy?=
 =?us-ascii?q?gbNj456GDXhdJ2jKJHuxKquhhzz5fJbI2JKPZye6XQds4YS2VcRMZcTyxPDJ2h?=
 =?us-ascii?q?YYUBDOQPOv1Yr5H/qlYVsReyGROhCP/1xzNUmnP727Ax3eQ7EQHB2QwtB8wDsG?=
 =?us-ascii?q?7VrNXuKKcSUPq6zK/VxjvebvNZxTb96IzJch87vPqBWqlwccvNxkkuEwPFj0+f?=
 =?us-ascii?q?pZb5MDOP1+QNqHSb7+t6WuKpkGMnpARxrSKuxscokIXGmoUVylXd+Ch/3Y07Js?=
 =?us-ascii?q?W4RVZlbdK4FJZcrTyWOoVoTs84Xm1luzo2xqcHtJO5ZCQHy4grywTCZ/GEboSE?=
 =?us-ascii?q?+BbuWeWLLTtlmH5pZrSyjAuo/0e60O3zTMy03U5KriVbltnMsWgA1wLc6seZUP?=
 =?us-ascii?q?tx5ESh1iiV1wDV9O5EJVo4la3BK54u2rIwl5wTvlrfHiLuhkn6kKubel859uWm?=
 =?us-ascii?q?9ejreKjqq5yAO4NuiwzzMLwimsmlDuQ5NggOUXKb+eO51LD7+U35QbNKjuA5k6?=
 =?us-ascii?q?XAs5DVO94bpqinDA9Ry4oj7Bi+DzG439QChnQHMl1Fdwydj4TzOFHBPur4DfGh?=
 =?us-ascii?q?jFSoijtrwOrGPrL5DpXXMnfDiKvhfap660NEzAozzNNf6IxOBrAOPfL+QUvxtN?=
 =?us-ascii?q?3eDh8kPA242efnCNNh1owAXWKDGLOWMKTXsVWQ/OIgP/GMZJMJuDb6M/Ul5+Th?=
 =?us-ascii?q?jX4lmVAHeqmlx5sXaG2iEfRgLEWUen7sgtYHEWcXsQsyVu3qiFueUTFNY3a+Rb?=
 =?us-ascii?q?4z5jY+CIi+F4fMWpitgKCd3Ce8BpBWZGdGBU6WHXfrcIWEXfEMaCWJL89lkzwE?=
 =?us-ascii?q?U6WhSoA72RGvsg/616RoLu7O9iIEspLj0cB/5/fPmhEq6Tx0E8Od3nmXQGFvnm?=
 =?us-ascii?q?MIQDw20LploUNnyFeOyqx4g/1eFdxO6PJFSAY6NZjAz+NkD9D+QB7OftCMSFy+?=
 =?us-ascii?q?WNWpHSkxTs4tw98Je0t9GM+tjhbZ0yquAr8ajbqLBJMv/6LY3njxIdt9ynnc2K?=
 =?us-ascii?q?kgiVkmXtVANWm8iqFj8AjTApbDk1+FmKayaaQcwCnN+X+ewmWUokFXThR8UaXf?=
 =?us-ascii?q?UnAZfUvZs9L56kTGT7+tDLQnNhBMycqDKqtMd93ogk9KRPblONTCfW2xn328Cg?=
 =?us-ascii?q?qPxrOJdIDqYXkS3D3BCEgYlAAe5WuJOhIgBii/uW7eDCZhFVT0Y0zy9+lzs3e7?=
 =?us-ascii?q?Tk4yzwGXYExtzbu1+hgJhfOCT/MfxK4LuCAkqz9sBlayw8rWC8acpwpmZKhcfd?=
 =?us-ascii?q?I94FJA1WLFtwx8PoasL7x4il4ZaQR3u0Lu1xN4CohblcgqrXUqzBd9KK6C0VNB?=
 =?us-ascii?q?cS+Y0o70OrHNNmby+xWvYbbM2l7CyNaW5rsP6PMgplr5uAGmCEUj/Gtn0tVPyH?=
 =?us-ascii?q?Sc+4jFAxAUUZLyVUY36QN3p7XbYik7+oPV2mdgMaiysj/exd0pAPEpxQqnf9da?=
 =?us-ascii?q?KKmEDhP9E9UGB8iyL+wng1iobg8eMO9O7qI1PsOmeOGA2K6kJ+tgmDOmjWJa4I?=
 =?us-ascii?q?FyyE6M9ix8SvLW0JYB2f2XwgyHVzLkhle7rs/3gZxEZS0VHmen0yjkBZJeabdo?=
 =?us-ascii?q?fYkWDmeiOcu3yctkh57sQnJX6ESsB1cb18C3YxqSaFr90BZU1UQWp3ynhCS5wy?=
 =?us-ascii?q?Z1kzEvsqqQwijOz/7+exoAP25BXHNigkv0IYiok9AaW1ClbggolBe/5Uf23bNb?=
 =?us-ascii?q?pLl5L2TIRUdIfi72L3xtU6eqt7qCZdJP540ssSlNTOu8ZlWaQKbnoxQGyyPjA3?=
 =?us-ascii?q?dexDcjejGooJr5hR96iGGaLHppt3rWY8JwxRTe5NzaW/FR2CELRC15iTnRG1i9?=
 =?us-ascii?q?MMOl/dSSl5ffrO++U3itWYFUcSnu1YmArje05XV2AR2jmPC+gt3mHhI90SPh1d?=
 =?us-ascii?q?lqVCPIoQ34Yonq0aS6LO1mclNpBF/698p1BIV+npEsi5EX3HgQno+V8mYfkWfv?=
 =?us-ascii?q?LdVb3rrzbHkXSj4K2dLV4BXl11dlLnKG3I/5UnSdws18Z9i1eG8W2yQ979xUB6?=
 =?us-ascii?q?eQ9rBLgSx1ol+gpwLLffd9hisdyecp6HMChuEJuQktwT+HDrEcA0ZYJjDsmAqS?=
 =?us-ascii?q?79+lsqpXfmmvfKO01Ep/m9ChEb6DrhtdWHb/ZpctAytw4t9jP1LL1X358pvkd8?=
 =?us-ascii?q?XIbdIPqh2UlA/Nj/RSKJI0jPYLhDBoOWTgvX0+0O47jAdj3ZW7vIiBNmVs87i1?=
 =?us-ascii?q?Ah9eNj3pecwT/ivhgrpZnsaTx4qvBIluGi0XXJv0SvKlCCkduu7gNwaKDT0wsH?=
 =?us-ascii?q?ObGafEEA+b6UdmqW/PEp+xO3GWInkZ0cttRB2HKENDhwAUWS0wnoQlGQCy2Mzh?=
 =?us-ascii?q?bEB56ygT5lHirxtD1PloOwPjUmvFpweodzQ0SIWZLBVM9QFP/EPVMc2Y7uJuEC?=
 =?us-ascii?q?BU5JyhrAqRKmOFYwREF30GWkuBB1r7JLmh+cHA8/SEBuq5N/bPYbKOqfFHV/eV?=
 =?us-ascii?q?352v1JFq/y2LNsWJMXlvFPk72ktFXXBkFMXVgTQPSyoLly3Ta86Xvguz+ipyrs?=
 =?us-ascii?q?qn6vTkRBrv5ZeTC7tVKdhv+w65gaaAN+6ThSZ1MzVY1okLxX/H1rcfxkMSizp1?=
 =?us-ascii?q?ejmpELQAszPNTa3Klq9WCR4bdz18NM9S460g2QlNPNbRisnp2b5gkv41F1BFWE?=
 =?us-ascii?q?T7lcG0fsMKOX+yNVPdCEaPNbSLPjnLw8DxYaOhRrxcluRUtxusuTmFF0/vJCiM?=
 =?us-ascii?q?lz7sVxq3K+FDkDmbPABCuIG6ahttFWnjTNf8ZhKnKtN4kT02zqMyhn7RMW4cMD?=
 =?us-ascii?q?58c15Cr7GK7CNYhOl/FHJF7nZ/MeaEnCOZ5fHCKpkKqftrHjh0l+VC7XU60bRV?=
 =?us-ascii?q?6iRERP1zmCTKr99uo0upku+Ayjd8VBpOqzBLhJ+EvEl4OKXZ8IVAVmjA/B4X8W?=
 =?us-ascii?q?qQDBEK9JNZDYjRsqFaytHR3ILyMjpH+s7UtZ8cGcHVIsKOLjwlMBz0CBbbCQIE?=
 =?us-ascii?q?SXigMmSJwwR/l/Gb8DW1qYY9rpSkzJgJSrZdfF84DPUXDgJiBtNUZN9eWj402Z?=
 =?us-ascii?q?OfgMMSrS6zqBXcXu1Zs4rBW/bUBu/gfnLRoqNJaFMr27TxLcEzP5fn3kVkIg11?=
 =?us-ascii?q?honFGEr4WdFLvz1vaRIyrExR8X94CGop1BShIj2k4XUTHOD8txE/kBR3Zax56j?=
 =?us-ascii?q?7t6Vc+OBzRvgM/lUAwnZPuhjXHNHbUJb2zFa5MBifu/xw0PYn2ThxdZAuzmEVg?=
 =?us-ascii?q?Py3JSrEXhLxlIyQjshLd8b5OFuNRSeV/YRsOzLnDffAmy1pHgiqizE5Do+DCDM?=
 =?us-ascii?q?0m3Ccjb5+g51ZB3Uo3YMIqIa3WDKVMx1lUwKmJu3n7+Po2xVo1PUcW7GKbfmYz?=
 =?us-ascii?q?uUcJMrgvb36z/+dt7Q2L3TBZeXMQVvMsiv1v/0I5fe+HynSzgPZ4NkmtOrnHfO?=
 =?us-ascii?q?uisG/amJvNGwto2w=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0DiAQBy1Ppbh0O0hNFiHgEGBwaBZYFbg?=
 =?us-ascii?q?hEnjHCLIIIhiyaMFoFjDgEBGBMBiFoiOBIBAwEBAQEBAQIBEwEBAQgNCQgpIwy?=
 =?us-ascii?q?CNiQBgmkCFwEMGQEbGAUBAwIJAgUQAzgDHgIRAQUBIgEJCQWCUUuBaQEDFQQBm?=
 =?us-ascii?q?mc8jAkWBQEXgncFgQYBgyUKGScNWoE3AgYSh0yDD4EcghaBEYVoggYGBAGFcgK?=
 =?us-ascii?q?JCw4KhXaBRY52LgcChhSHcIMrAhZeiHOHNgGOTYk8AgQCBAUCBQ8hgTyBdjMaI?=
 =?us-ascii?q?1AxgjuCGwkDF4NKihwBNj8ygQIDAQEhE4lXgj4BAQ?=
X-IPAS-Result: =?us-ascii?q?A0DiAQBy1Ppbh0O0hNFiHgEGBwaBZYFbghEnjHCLIIIhiya?=
 =?us-ascii?q?MFoFjDgEBGBMBiFoiOBIBAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmkCFwEMG?=
 =?us-ascii?q?QEbGAUBAwIJAgUQAzgDHgIRAQUBIgEJCQWCUUuBaQEDFQQBmmc8jAkWBQEXgnc?=
 =?us-ascii?q?FgQYBgyUKGScNWoE3AgYSh0yDD4EcghaBEYVoggYGBAGFcgKJCw4KhXaBRY52L?=
 =?us-ascii?q?gcChhSHcIMrAhZeiHOHNgGOTYk8AgQCBAUCBQ8hgTyBdjMaI1AxgjuCGwkDF4N?=
 =?us-ascii?q?KihwBNj8ygQIDAQEhE4lXgj4BAQ?=
X-IronPort-AV: E=Sophos;i="5.56,278,1539673200"; 
   d="scan'208";a="139465308"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 08:59:41 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726724AbeKZDvH (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 25 Nov 2018 22:51:07 -0500
Received: from mail-wr1-f68.google.com ([209.85.221.68]:46823 "EHLO
        mail-wr1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726302AbeKZDvG (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 25 Nov 2018 22:51:06 -0500
Received: by mail-wr1-f68.google.com with SMTP id l9so16477074wrt.13
        for <linux-kernel@vger.kernel.org>; Sun, 25 Nov 2018 08:59:33 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id;
        bh=dxlHDLbZZg/WCM7f5QN35KjhAk/j1zxnKAmYSO3k8oQ=;
        b=n02T/mEGMxTRWr7JnePHZ8asbh9Ozc3Ct4D4Y255p1XEpWwddMSus7WaTIR+DywEZr
         syh/WMJXu3n8cib9mEHUsN8EDomAN9SnvWeYEuXLBIPD4abe64jFRNOgeIBdSzBbX2jH
         OwyDsU82ThE4T7vsSE8ULeR5sqUG1yEqiVFzIJqm0Cwjfhal3U8hFy4xnxmuuwQTMp5D
         33yrMiWpaJr5EBKe3X++CNiuj2Ji0NgDNqZ2IbhH9PSNsQW4NElUdsIsSxYmsX+yjrIj
         2FbIPIW5Ur9HsB7CtHynHOtMuBnvMxe2rfVVz3vNK4tDjvhc7aLNR9mns7r/qSzqZHHg
         DYzw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id;
        bh=dxlHDLbZZg/WCM7f5QN35KjhAk/j1zxnKAmYSO3k8oQ=;
        b=InjzKdVK532YTKjmR1xm+Gj/YhGJgPRXiNFZvJZDUA5QjkQI4BdHuEjBd/5c9A164I
         T2nQdx0yCE1ZxQOF4jztUvvfpOlrhpMA9qZaBjKWTnvxlCyRb2dCAn5SZPnphR+28on+
         R7ld8RWXoJPdPF6VTvGpCwzUhsbppvGWAPtl8Vv+LJNgDGIu3567YsjdGUbuJvN3lmt/
         co7H8C4/AIJ9j+iQqx8G8pmpG5/2v/lH5TJQoeBQ0r3E0d9Is2DoExD2XGAEdlYkzEH1
         odUJpV0tu8RHV9N3e7aumRoY9lAaDDptCayYFqIB6qFsXVG68piumE8j27nThxD7PnA8
         CSXg==
X-Gm-Message-State: AA+aEWYgvaPlPO40XGo1CFkeiYVXe/FFCY+eBciZO5ogHIhqVJvpvcvz
        2G+JN2zJ7kMXtxEdbtw8B+c=
X-Google-Smtp-Source: AFSGD/WISGavvwjV6yc09RHg/5p7Y9Kq8XiBr1o/jFk8Li1jGw2CoQD7+UVwLt2WVtXirPNs0SHrlg==
X-Received: by 2002:adf:8323:: with SMTP id 32mr10941552wrd.176.1543165172241;
        Sun, 25 Nov 2018 08:59:32 -0800 (PST)
Received: from localhost (host102-98-dynamic.181-80-r.retail.telecomitalia.it. [80.181.98.102])
        by smtp.gmail.com with ESMTPSA id 5sm22848472wmw.8.2018.11.25.08.59.30
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Sun, 25 Nov 2018 08:59:30 -0800 (PST)
From: Cristian Sicilia <sicilia.cristian@gmail.com>
To: Vaibhav Hiremath <hvaibhav.linux@gmail.com>,
        Johan Hovold <johan@kernel.org>, Alex Elder <elder@kernel.org>,
        Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        Vaibhav Agarwal <vaibhav.sr@gmail.com>,
        Mark Greer <mgreer@animalcreek.com>,
        Rui Miguel Silva <rmfrfs@gmail.com>,
        David Lin <dtwlin@gmail.com>
Cc: Viresh Kumar <vireshk@kernel.org>,
        "Bryan O'Donoghue" <pure.logic@nexus-software.ie>,
        Cristian Sicilia <sicilia.cristian@gmail.com>,
        linux-kernel@vger.kernel.org
Subject: [PATCH] staging: greybus: Parenthesis alignment
Date: Sun, 25 Nov 2018 17:58:15 +0100
Message-Id: <1543165109-4845-1-git-send-email-sicilia.cristian@gmail.com>
X-Mailer: git-send-email 2.7.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Some parameters are aligned with parentheses.
Some parentheses was opened at end of line.

Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>

---
Changes on v2:
 * There was some function that was splitted in two line,
    as suggested, is better to keep it in one line.

 drivers/staging/greybus/audio_manager_module.c |   4 +-
 drivers/staging/greybus/audio_manager_sysfs.c  |  22 ++--
 drivers/staging/greybus/audio_module.c         |  20 ++--
 drivers/staging/greybus/audio_topology.c       |  63 ++++++------
 drivers/staging/greybus/bootrom.c              |  25 ++---
 drivers/staging/greybus/camera.c               |  12 +--
 drivers/staging/greybus/connection.c           |  82 +++++++--------
 drivers/staging/greybus/control.c              |  53 +++++-----
 drivers/staging/greybus/es2.c                  |  70 ++++++-------
 drivers/staging/greybus/gpio.c                 |  39 +++----
 drivers/staging/greybus/hid.c                  |  18 ++--
 drivers/staging/greybus/i2c.c                  |  21 ++--
 drivers/staging/greybus/module.c               |  19 ++--
 drivers/staging/greybus/operation.c            | 135 +++++++++++++------------
 drivers/staging/greybus/svc.c                  |  93 +++++++++--------
 15 files changed, 343 insertions(+), 333 deletions(-)

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index 52342e8..2bfd804 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -25,8 +25,8 @@ struct gb_audio_manager_module_attribute {
 			 const char *buf, size_t count);
 };
 
-static ssize_t gb_audio_module_attr_show(
-	struct kobject *kobj, struct attribute *attr, char *buf)
+static ssize_t gb_audio_module_attr_show(struct kobject *kobj,
+					 struct attribute *attr, char *buf)
 {
 	struct gb_audio_manager_module_attribute *attribute;
 	struct gb_audio_manager_module *module;
diff --git a/drivers/staging/greybus/audio_manager_sysfs.c b/drivers/staging/greybus/audio_manager_sysfs.c
index 283fbed..ab882cc 100644
--- a/drivers/staging/greybus/audio_manager_sysfs.c
+++ b/drivers/staging/greybus/audio_manager_sysfs.c
@@ -11,9 +11,9 @@
 #include "audio_manager.h"
 #include "audio_manager_private.h"
 
-static ssize_t manager_sysfs_add_store(
-	struct kobject *kobj, struct kobj_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t manager_sysfs_add_store(struct kobject *kobj,
+				       struct kobj_attribute *attr,
+				       const char *buf, size_t count)
 {
 	struct gb_audio_manager_module_descriptor desc = { {0} };
 
@@ -36,9 +36,9 @@ static ssize_t manager_sysfs_add_store(
 static struct kobj_attribute manager_add_attribute =
 	__ATTR(add, 0664, NULL, manager_sysfs_add_store);
 
-static ssize_t manager_sysfs_remove_store(
-	struct kobject *kobj, struct kobj_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t manager_sysfs_remove_store(struct kobject *kobj,
+					  struct kobj_attribute *attr,
+					  const char *buf, size_t count)
 {
 	int id;
 
@@ -57,9 +57,9 @@ static ssize_t manager_sysfs_remove_store(
 static struct kobj_attribute manager_remove_attribute =
 	__ATTR(remove, 0664, NULL, manager_sysfs_remove_store);
 
-static ssize_t manager_sysfs_dump_store(
-	struct kobject *kobj, struct kobj_attribute *attr,
-	const char *buf, size_t count)
+static ssize_t manager_sysfs_dump_store(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t count)
 {
 	int id;
 
@@ -81,8 +81,8 @@ static ssize_t manager_sysfs_dump_store(
 static struct kobj_attribute manager_dump_attribute =
 	__ATTR(dump, 0664, NULL, manager_sysfs_dump_store);
 
-static void manager_sysfs_init_attribute(
-		struct kobject *kobj, struct kobj_attribute *kattr)
+static void manager_sysfs_init_attribute(struct kobject *kobj,
+					 struct kobj_attribute *kattr)
 {
 	int err;
 
diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index d065334..300a2b4 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -18,7 +18,7 @@
  */
 
 static int gbaudio_request_jack(struct gbaudio_module_info *module,
-				  struct gb_audio_jack_event_request *req)
+				struct gb_audio_jack_event_request *req)
 {
 	int report;
 	struct snd_jack *jack = module->headset_jack.jack;
@@ -26,8 +26,8 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 
 	if (!jack) {
 		dev_err_ratelimited(module->dev,
-			"Invalid jack event received:type: %u, event: %u\n",
-			req->jack_attribute, req->event);
+				    "Invalid jack event received:type: %u, event: %u\n",
+				    req->jack_attribute, req->event);
 		return -EINVAL;
 	}
 
@@ -50,8 +50,8 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 	report = req->jack_attribute & module->jack_mask;
 	if (!report) {
 		dev_err_ratelimited(module->dev,
-			"Invalid jack event received:type: %u, event: %u\n",
-			req->jack_attribute, req->event);
+				    "Invalid jack event received:type: %u, event: %u\n",
+				    req->jack_attribute, req->event);
 		return -EINVAL;
 	}
 
@@ -74,8 +74,8 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 
 	if (!btn_jack) {
 		dev_err_ratelimited(module->dev,
-			"Invalid button event received:type: %u, event: %u\n",
-			req->button_id, req->event);
+				    "Invalid button event received:type: %u, event: %u\n",
+				    req->button_id, req->event);
 		return -EINVAL;
 	}
 
@@ -210,8 +210,8 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 		return -ENOMEM;
 
 	connection = gb_connection_create_offloaded(bundle,
-					le16_to_cpu(cport_desc->id),
-					GB_CONNECTION_FLAG_CSD);
+						    le16_to_cpu(cport_desc->id),
+						    GB_CONNECTION_FLAG_CSD);
 	if (IS_ERR(connection)) {
 		devm_kfree(gbmodule->dev, dai);
 		return PTR_ERR(connection);
@@ -317,7 +317,7 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	ret = gbaudio_tplg_parse_data(gbmodule, topology);
 	if (ret) {
 		dev_err(dev, "%d:Error while parsing topology data\n",
-			  ret);
+			ret);
 		goto free_topology;
 	}
 	gbmodule->topology = topology;
diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index b710783..8bcbc3c 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -158,7 +158,7 @@ static const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
 }
 
 static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_info *uinfo)
+				  struct snd_ctl_elem_info *uinfo)
 {
 	unsigned int max;
 	const char *name;
@@ -209,7 +209,7 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	int ret;
 	struct gb_audio_ctl_elem_info *info;
@@ -271,7 +271,7 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	int ret = 0;
 	struct gb_audio_ctl_elem_info *info;
@@ -347,7 +347,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
  * of DAPM related sequencing, etc.
  */
 static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_info *uinfo)
+				       struct snd_ctl_elem_info *uinfo)
 {
 	int platform_max, platform_min;
 	struct gbaudio_ctl_pvt *data;
@@ -378,7 +378,7 @@ static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	int ret;
 	struct gb_audio_ctl_elem_info *info;
@@ -427,7 +427,7 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	int ret, wi, max, connect;
 	unsigned int mask, val;
@@ -501,7 +501,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	.private_value = (unsigned long)data}
 
 static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+			     struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB speaker is connected */
 
@@ -509,7 +509,7 @@ static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
 }
 
 static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+			    struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB module supports jack slot */
 
@@ -517,7 +517,7 @@ static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
 }
 
 static int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+				 struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB module supports jack slot */
 
@@ -664,7 +664,7 @@ static int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,
 
 	/* debug enum info */
 	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
-		 le16_to_cpu(gb_enum->names_length));
+		le16_to_cpu(gb_enum->names_length));
 	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
@@ -873,7 +873,7 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 
 	/* debug enum info */
 	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
-		 le16_to_cpu(gb_enum->names_length));
+		le16_to_cpu(gb_enum->names_length));
 	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
@@ -884,8 +884,8 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 }
 
 static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
-					     struct snd_kcontrol_new *kctl,
-					     struct gb_audio_control *ctl)
+					 struct snd_kcontrol_new *kctl,
+					 struct gb_audio_control *ctl)
 {
 	struct gbaudio_ctl_pvt *ctldata;
 
@@ -905,8 +905,8 @@ static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
 }
 
 static int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,
-					     struct snd_kcontrol_new *kctl,
-					     struct gb_audio_control *ctl)
+					struct snd_kcontrol_new *kctl,
+					struct gb_audio_control *ctl)
 {
 	int ret;
 
@@ -1086,9 +1086,10 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_switch:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_SWITCH_E(w->name, SND_SOC_NOPM, 0, 0,
-					    widget_kctls, gbaudio_widget_event,
-					    SND_SOC_DAPM_PRE_PMU |
-					    SND_SOC_DAPM_POST_PMD);
+					      widget_kctls,
+					      gbaudio_widget_event,
+					      SND_SOC_DAPM_PRE_PMU |
+					      SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_pga:
 		*dw = (struct snd_soc_dapm_widget)
@@ -1100,16 +1101,16 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_mixer:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MIXER_E(w->name, SND_SOC_NOPM, 0, 0, NULL,
-					   0, gbaudio_widget_event,
-					   SND_SOC_DAPM_PRE_PMU |
-					   SND_SOC_DAPM_POST_PMD);
+					     0, gbaudio_widget_event,
+					     SND_SOC_DAPM_PRE_PMU |
+					     SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_mux:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MUX_E(w->name, SND_SOC_NOPM, 0, 0,
-					 widget_kctls, gbaudio_widget_event,
-					 SND_SOC_DAPM_PRE_PMU |
-					 SND_SOC_DAPM_POST_PMD);
+					   widget_kctls, gbaudio_widget_event,
+					   SND_SOC_DAPM_PRE_PMU |
+					   SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_aif_in:
 		*dw = (struct snd_soc_dapm_widget)
@@ -1145,7 +1146,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
-				   struct gb_audio_control *controls)
+					  struct gb_audio_control *controls)
 {
 	int i, csize, ret;
 	struct snd_kcontrol_new *dapm_kctls;
@@ -1215,7 +1216,7 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
-				   struct gb_audio_widget *widgets)
+					struct gb_audio_widget *widgets)
 {
 	int i, ret, w_size;
 	struct snd_soc_dapm_widget *dapm_widgets;
@@ -1264,7 +1265,7 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
-				   struct gb_audio_route *routes)
+				       struct gb_audio_route *routes)
 {
 	int i, ret;
 	struct snd_soc_dapm_route *dapm_routes;
@@ -1300,8 +1301,8 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 		}
 		dapm_routes->control =
 			gbaudio_map_controlid(module,
-						      curr->control_id,
-						      curr->index);
+					      curr->control_id,
+					      curr->index);
 		if ((curr->control_id !=  GBAUDIO_INVALID_ID) &&
 		    !dapm_routes->control) {
 			dev_err(module->dev, "%d:%d:%d:%d - Invalid control\n",
@@ -1325,7 +1326,7 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
-				 struct gb_audio_topology *tplg_data)
+				       struct gb_audio_topology *tplg_data)
 {
 	/* fetch no. of kcontrols, widgets & routes */
 	module->num_controls = tplg_data->num_controls;
@@ -1351,7 +1352,7 @@ static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
 }
 
 int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
-			       struct gb_audio_topology *tplg_data)
+			    struct gb_audio_topology *tplg_data)
 {
 	int ret;
 	struct gb_audio_control *controls;
diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index e85ffae..402e636 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -86,7 +86,8 @@ static void gb_bootrom_timedout(struct work_struct *work)
 }
 
 static void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,
-			enum next_request_type next, unsigned long timeout)
+				   enum next_request_type next,
+				   unsigned long timeout)
 {
 	bootrom->next_request = next;
 	schedule_delayed_work(&bootrom->dwork, msecs_to_jiffies(timeout));
@@ -175,7 +176,7 @@ static int find_firmware(struct gb_bootrom *bootrom, u8 stage)
 		 firmware_name);
 
 	rc = request_firmware(&bootrom->fw, firmware_name,
-		&connection->bundle->dev);
+			      &connection->bundle->dev);
 	if (rc) {
 		dev_err(&connection->bundle->dev,
 			"failed to find %s firmware (%d)\n", firmware_name, rc);
@@ -274,7 +275,7 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 
 	if (offset >= fw->size || size > fw->size - offset) {
 		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
-				offset, size);
+			 offset, size);
 		ret = -EINVAL;
 		goto unlock;
 	}
@@ -387,15 +388,15 @@ static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
 				sizeof(response));
 	if (ret) {
 		dev_err(&bundle->dev,
-				"failed to get protocol version: %d\n",
-				ret);
+			"failed to get protocol version: %d\n",
+			ret);
 		return ret;
 	}
 
 	if (response.major > request.major) {
 		dev_err(&bundle->dev,
-				"unsupported major protocol version (%u > %u)\n",
-				response.major, request.major);
+			"unsupported major protocol version (%u > %u)\n",
+			response.major, request.major);
 		return -ENOTSUPP;
 	}
 
@@ -403,13 +404,13 @@ static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
 	bootrom->protocol_minor = response.minor;
 
 	dev_dbg(&bundle->dev, "%s - %u.%u\n", __func__, response.major,
-			response.minor);
+		response.minor);
 
 	return 0;
 }
 
 static int gb_bootrom_probe(struct gb_bundle *bundle,
-					const struct greybus_bundle_id *id)
+			    const struct greybus_bundle_id *id)
 {
 	struct greybus_descriptor_cport *cport_desc;
 	struct gb_connection *connection;
@@ -428,8 +429,8 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	connection = gb_connection_create(bundle,
-						le16_to_cpu(cport_desc->id),
-						gb_bootrom_request_handler);
+					  le16_to_cpu(cport_desc->id),
+					  gb_bootrom_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto err_free_bootrom;
@@ -466,7 +467,7 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 				NULL, 0);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
-				"failed to send AP READY: %d\n", ret);
+			"failed to send AP READY: %d\n", ret);
 		goto err_cancel_timeout;
 	}
 
diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index c6d6543..615c8e7 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -841,8 +841,8 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
 }
 
 static int gb_camera_op_capture(void *priv, u32 request_id,
-		unsigned int streams, unsigned int num_frames,
-		size_t settings_size, const void *settings)
+				unsigned int streams, unsigned int num_frames,
+				size_t settings_size, const void *settings)
 {
 	struct gb_camera *gcam = priv;
 
@@ -869,7 +869,7 @@ static const struct gb_camera_ops gb_cam_ops = {
  */
 
 static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
-		char *buf, size_t len)
+					      char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES];
@@ -905,7 +905,7 @@ static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
 }
 
 static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
-		char *buf, size_t len)
+						   char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];
@@ -999,7 +999,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 };
 
 static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
-		char *buf, size_t len)
+					 char *buf, size_t len)
 {
 	unsigned int request_id;
 	unsigned int streams_mask;
@@ -1040,7 +1040,7 @@ static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
 }
 
 static ssize_t gb_camera_debugfs_flush(struct gb_camera *gcam,
-		char *buf, size_t len)
+				       char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_FLUSH];
diff --git a/drivers/staging/greybus/connection.c b/drivers/staging/greybus/connection.c
index 56ae305..eda96420 100644
--- a/drivers/staging/greybus/connection.c
+++ b/drivers/staging/greybus/connection.c
@@ -26,7 +26,7 @@ static bool gb_connection_cport_in_use(struct gb_interface *intf, u16 cport_id)
 
 	list_for_each_entry(connection, &hd->connections, hd_links) {
 		if (connection->intf == intf &&
-				connection->intf_cport_id == cport_id)
+		    connection->intf_cport_id == cport_id)
 			return true;
 	}
 
@@ -74,7 +74,7 @@ gb_connection_hd_find(struct gb_host_device *hd, u16 cport_id)
  * received on the bundle.
  */
 void greybus_data_rcvd(struct gb_host_device *hd, u16 cport_id,
-			u8 *data, size_t length)
+		       u8 *data, size_t length)
 {
 	struct gb_connection *connection;
 
@@ -114,7 +114,7 @@ static void gb_connection_init_name(struct gb_connection *connection)
 	}
 
 	snprintf(connection->name, sizeof(connection->name),
-			"%u/%u:%u", hd_cport_id, intf_id, cport_id);
+		 "%u/%u:%u", hd_cport_id, intf_id, cport_id);
 }
 
 /*
@@ -142,10 +142,10 @@ static void gb_connection_init_name(struct gb_connection *connection)
  */
 static struct gb_connection *
 _gb_connection_create(struct gb_host_device *hd, int hd_cport_id,
-				struct gb_interface *intf,
-				struct gb_bundle *bundle, int cport_id,
-				gb_request_handler_t handler,
-				unsigned long flags)
+		      struct gb_interface *intf,
+		      struct gb_bundle *bundle, int cport_id,
+		      gb_request_handler_t handler,
+		      unsigned long flags)
 {
 	struct gb_connection *connection;
 	int ret;
@@ -226,35 +226,35 @@ _gb_connection_create(struct gb_host_device *hd, int hd_cport_id,
 
 struct gb_connection *
 gb_connection_create_static(struct gb_host_device *hd, u16 hd_cport_id,
-					gb_request_handler_t handler)
+			    gb_request_handler_t handler)
 {
 	return _gb_connection_create(hd, hd_cport_id, NULL, NULL, 0, handler,
-					GB_CONNECTION_FLAG_HIGH_PRIO);
+				     GB_CONNECTION_FLAG_HIGH_PRIO);
 }
 
 struct gb_connection *
 gb_connection_create_control(struct gb_interface *intf)
 {
 	return _gb_connection_create(intf->hd, -1, intf, NULL, 0, NULL,
-					GB_CONNECTION_FLAG_CONTROL |
-					GB_CONNECTION_FLAG_HIGH_PRIO);
+				     GB_CONNECTION_FLAG_CONTROL |
+				     GB_CONNECTION_FLAG_HIGH_PRIO);
 }
 
 struct gb_connection *
 gb_connection_create(struct gb_bundle *bundle, u16 cport_id,
-					gb_request_handler_t handler)
+		     gb_request_handler_t handler)
 {
 	struct gb_interface *intf = bundle->intf;
 
 	return _gb_connection_create(intf->hd, -1, intf, bundle, cport_id,
-					handler, 0);
+				     handler, 0);
 }
 EXPORT_SYMBOL_GPL(gb_connection_create);
 
 struct gb_connection *
 gb_connection_create_flags(struct gb_bundle *bundle, u16 cport_id,
-					gb_request_handler_t handler,
-					unsigned long flags)
+			   gb_request_handler_t handler,
+			   unsigned long flags)
 {
 	struct gb_interface *intf = bundle->intf;
 
@@ -262,13 +262,13 @@ gb_connection_create_flags(struct gb_bundle *bundle, u16 cport_id,
 		flags &= ~GB_CONNECTION_FLAG_CORE_MASK;
 
 	return _gb_connection_create(intf->hd, -1, intf, bundle, cport_id,
-					handler, flags);
+				     handler, flags);
 }
 EXPORT_SYMBOL_GPL(gb_connection_create_flags);
 
 struct gb_connection *
 gb_connection_create_offloaded(struct gb_bundle *bundle, u16 cport_id,
-					unsigned long flags)
+			       unsigned long flags)
 {
 	flags |= GB_CONNECTION_FLAG_OFFLOADED;
 
@@ -285,10 +285,10 @@ static int gb_connection_hd_cport_enable(struct gb_connection *connection)
 		return 0;
 
 	ret = hd->driver->cport_enable(hd, connection->hd_cport_id,
-					connection->flags);
+				       connection->flags);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to enable host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -306,7 +306,7 @@ static void gb_connection_hd_cport_disable(struct gb_connection *connection)
 	ret = hd->driver->cport_disable(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to disable host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 	}
 }
 
@@ -321,7 +321,7 @@ static int gb_connection_hd_cport_connected(struct gb_connection *connection)
 	ret = hd->driver->cport_connected(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to set connected state: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -339,7 +339,7 @@ static int gb_connection_hd_cport_flush(struct gb_connection *connection)
 	ret = hd->driver->cport_flush(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to flush host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -369,7 +369,7 @@ static int gb_connection_hd_cport_quiesce(struct gb_connection *connection)
 					GB_CONNECTION_CPORT_QUIESCE_TIMEOUT);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to quiesce host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -387,7 +387,7 @@ static int gb_connection_hd_cport_clear(struct gb_connection *connection)
 	ret = hd->driver->cport_clear(hd, connection->hd_cport_id);
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to clear host cport: %d\n",
-				connection->name, ret);
+			connection->name, ret);
 		return ret;
 	}
 
@@ -423,11 +423,11 @@ gb_connection_svc_connection_create(struct gb_connection *connection)
 	}
 
 	ret = gb_svc_connection_create(hd->svc,
-			hd->svc->ap_intf_id,
-			connection->hd_cport_id,
-			intf->interface_id,
-			connection->intf_cport_id,
-			cport_flags);
+				       hd->svc->ap_intf_id,
+				       connection->hd_cport_id,
+				       intf->interface_id,
+				       connection->intf_cport_id,
+				       cport_flags);
 	if (ret) {
 		dev_err(&connection->hd->dev,
 			"%s: failed to create svc connection: %d\n",
@@ -491,8 +491,8 @@ gb_connection_control_disconnecting(struct gb_connection *connection)
 	ret = gb_control_disconnecting_operation(control, cport_id);
 	if (ret) {
 		dev_err(&connection->hd->dev,
-				"%s: failed to send disconnecting: %d\n",
-				connection->name, ret);
+			"%s: failed to send disconnecting: %d\n",
+			connection->name, ret);
 	}
 }
 
@@ -531,16 +531,16 @@ gb_connection_control_disconnected(struct gb_connection *connection)
 }
 
 static int gb_connection_shutdown_operation(struct gb_connection *connection,
-						u8 phase)
+					    u8 phase)
 {
 	struct gb_cport_shutdown_request *req;
 	struct gb_operation *operation;
 	int ret;
 
 	operation = gb_operation_create_core(connection,
-						GB_REQUEST_TYPE_CPORT_SHUTDOWN,
-						sizeof(*req), 0, 0,
-						GFP_KERNEL);
+					     GB_REQUEST_TYPE_CPORT_SHUTDOWN,
+					     sizeof(*req), 0, 0,
+					     GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -569,14 +569,14 @@ static int gb_connection_cport_shutdown(struct gb_connection *connection,
 			return 0;
 
 		ret = drv->cport_shutdown(hd, connection->hd_cport_id, phase,
-						GB_OPERATION_TIMEOUT_DEFAULT);
+					  GB_OPERATION_TIMEOUT_DEFAULT);
 	} else {
 		ret = gb_connection_shutdown_operation(connection, phase);
 	}
 
 	if (ret) {
 		dev_err(&hd->dev, "%s: failed to send cport shutdown (phase %d): %d\n",
-				connection->name, phase, ret);
+			connection->name, phase, ret);
 		return ret;
 	}
 
@@ -602,14 +602,14 @@ gb_connection_cport_shutdown_phase_2(struct gb_connection *connection)
  * DISCONNECTING.
  */
 static void gb_connection_cancel_operations(struct gb_connection *connection,
-						int errno)
+					    int errno)
 	__must_hold(&connection->lock)
 {
 	struct gb_operation *operation;
 
 	while (!list_empty(&connection->operations)) {
 		operation = list_last_entry(&connection->operations,
-						struct gb_operation, links);
+					    struct gb_operation, links);
 		gb_operation_get(operation);
 		spin_unlock_irq(&connection->lock);
 
@@ -631,7 +631,7 @@ static void gb_connection_cancel_operations(struct gb_connection *connection,
  */
 static void
 gb_connection_flush_incoming_operations(struct gb_connection *connection,
-						int errno)
+					int errno)
 	__must_hold(&connection->lock)
 {
 	struct gb_operation *operation;
@@ -640,7 +640,7 @@ gb_connection_flush_incoming_operations(struct gb_connection *connection,
 	while (!list_empty(&connection->operations)) {
 		incoming = false;
 		list_for_each_entry(operation, &connection->operations,
-								links) {
+				    links) {
 			if (gb_operation_is_incoming(operation)) {
 				gb_operation_get(operation);
 				incoming = true;
diff --git a/drivers/staging/greybus/control.c b/drivers/staging/greybus/control.c
index 35f945a..ffa41d3 100644
--- a/drivers/staging/greybus/control.c
+++ b/drivers/staging/greybus/control.c
@@ -32,15 +32,15 @@ static int gb_control_get_version(struct gb_control *control)
 				sizeof(response));
 	if (ret) {
 		dev_err(&intf->dev,
-				"failed to get control-protocol version: %d\n",
-				ret);
+			"failed to get control-protocol version: %d\n",
+			ret);
 		return ret;
 	}
 
 	if (response.major > request.major) {
 		dev_err(&intf->dev,
-				"unsupported major control-protocol version (%u > %u)\n",
-				response.major, request.major);
+			"unsupported major control-protocol version (%u > %u)\n",
+			response.major, request.major);
 		return -ENOTSUPP;
 	}
 
@@ -48,13 +48,13 @@ static int gb_control_get_version(struct gb_control *control)
 	control->protocol_minor = response.minor;
 
 	dev_dbg(&intf->dev, "%s - %u.%u\n", __func__, response.major,
-			response.minor);
+		response.minor);
 
 	return 0;
 }
 
 static int gb_control_get_bundle_version(struct gb_control *control,
-						struct gb_bundle *bundle)
+					 struct gb_bundle *bundle)
 {
 	struct gb_interface *intf = control->connection->intf;
 	struct gb_control_bundle_version_request request;
@@ -69,8 +69,8 @@ static int gb_control_get_bundle_version(struct gb_control *control,
 				&response, sizeof(response));
 	if (ret) {
 		dev_err(&intf->dev,
-				"failed to get bundle %u class version: %d\n",
-				bundle->id, ret);
+			"failed to get bundle %u class version: %d\n",
+			bundle->id, ret);
 		return ret;
 	}
 
@@ -78,7 +78,7 @@ static int gb_control_get_bundle_version(struct gb_control *control,
 	bundle->class_minor = response.minor;
 
 	dev_dbg(&intf->dev, "%s - %u: %u.%u\n", __func__, bundle->id,
-			response.major, response.minor);
+		response.major, response.minor);
 
 	return 0;
 }
@@ -112,7 +112,7 @@ int gb_control_get_manifest_size_operation(struct gb_interface *intf)
 				NULL, 0, &response, sizeof(response));
 	if (ret) {
 		dev_err(&connection->intf->dev,
-				"failed to get manifest size: %d\n", ret);
+			"failed to get manifest size: %d\n", ret);
 		return ret;
 	}
 
@@ -149,16 +149,16 @@ int gb_control_disconnected_operation(struct gb_control *control, u16 cport_id)
 }
 
 int gb_control_disconnecting_operation(struct gb_control *control,
-					u16 cport_id)
+				       u16 cport_id)
 {
 	struct gb_control_disconnecting_request *request;
 	struct gb_operation *operation;
 	int ret;
 
 	operation = gb_operation_create_core(control->connection,
-					GB_CONTROL_TYPE_DISCONNECTING,
-					sizeof(*request), 0, 0,
-					GFP_KERNEL);
+					     GB_CONTROL_TYPE_DISCONNECTING,
+					     sizeof(*request), 0, 0,
+					     GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -168,7 +168,7 @@ int gb_control_disconnecting_operation(struct gb_control *control,
 	ret = gb_operation_request_send_sync(operation);
 	if (ret) {
 		dev_err(&control->dev, "failed to send disconnecting: %d\n",
-				ret);
+			ret);
 	}
 
 	gb_operation_put(operation);
@@ -182,9 +182,10 @@ int gb_control_mode_switch_operation(struct gb_control *control)
 	int ret;
 
 	operation = gb_operation_create_core(control->connection,
-					GB_CONTROL_TYPE_MODE_SWITCH,
-					0, 0, GB_OPERATION_FLAG_UNIDIRECTIONAL,
-					GFP_KERNEL);
+					     GB_CONTROL_TYPE_MODE_SWITCH,
+					     0, 0,
+					     GB_OPERATION_FLAG_UNIDIRECTIONAL,
+					     GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -400,7 +401,7 @@ int gb_control_interface_hibernate_abort(struct gb_control *control)
 }
 
 static ssize_t vendor_string_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				  struct device_attribute *attr, char *buf)
 {
 	struct gb_control *control = to_gb_control(dev);
 
@@ -409,7 +410,7 @@ static ssize_t vendor_string_show(struct device *dev,
 static DEVICE_ATTR_RO(vendor_string);
 
 static ssize_t product_string_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct gb_control *control = to_gb_control(dev);
 
@@ -455,8 +456,8 @@ struct gb_control *gb_control_create(struct gb_interface *intf)
 	connection = gb_connection_create_control(intf);
 	if (IS_ERR(connection)) {
 		dev_err(&intf->dev,
-				"failed to create control connection: %ld\n",
-				PTR_ERR(connection));
+			"failed to create control connection: %ld\n",
+			PTR_ERR(connection));
 		kfree(control);
 		return ERR_CAST(connection);
 	}
@@ -485,8 +486,8 @@ int gb_control_enable(struct gb_control *control)
 	ret = gb_connection_enable_tx(control->connection);
 	if (ret) {
 		dev_err(&control->connection->intf->dev,
-				"failed to enable control connection: %d\n",
-				ret);
+			"failed to enable control connection: %d\n",
+			ret);
 		return ret;
 	}
 
@@ -547,8 +548,8 @@ int gb_control_add(struct gb_control *control)
 	ret = device_add(&control->dev);
 	if (ret) {
 		dev_err(&control->dev,
-				"failed to register control device: %d\n",
-				ret);
+			"failed to register control device: %d\n",
+			ret);
 		return ret;
 	}
 
diff --git a/drivers/staging/greybus/es2.c b/drivers/staging/greybus/es2.c
index b4e3d6a..be6af18c 100644
--- a/drivers/staging/greybus/es2.c
+++ b/drivers/staging/greybus/es2.c
@@ -216,7 +216,7 @@ static int output_async(struct es2_ap_dev *es2, void *req, u16 size, u8 cmd)
 }
 
 static int output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,
-		     bool async)
+		  bool async)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 
@@ -227,7 +227,7 @@ static int output(struct gb_host_device *hd, void *req, u16 size, u8 cmd,
 }
 
 static int es2_cport_in_enable(struct es2_ap_dev *es2,
-				struct es2_cport_in *cport_in)
+			       struct es2_cport_in *cport_in)
 {
 	struct urb *urb;
 	int ret;
@@ -239,7 +239,7 @@ static int es2_cport_in_enable(struct es2_ap_dev *es2,
 		ret = usb_submit_urb(urb, GFP_KERNEL);
 		if (ret) {
 			dev_err(&es2->usb_dev->dev,
-					"failed to submit in-urb: %d\n", ret);
+				"failed to submit in-urb: %d\n", ret);
 			goto err_kill_urbs;
 		}
 	}
@@ -256,7 +256,7 @@ static int es2_cport_in_enable(struct es2_ap_dev *es2,
 }
 
 static void es2_cport_in_disable(struct es2_ap_dev *es2,
-				struct es2_cport_in *cport_in)
+				 struct es2_cport_in *cport_in)
 {
 	struct urb *urb;
 	int i;
@@ -487,7 +487,7 @@ static void message_cancel(struct gb_message *message)
 }
 
 static int es2_cport_allocate(struct gb_host_device *hd, int cport_id,
-				unsigned long flags)
+			      unsigned long flags)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 	struct ida *id_map = &hd->cport_id_map;
@@ -501,7 +501,7 @@ static int es2_cport_allocate(struct gb_host_device *hd, int cport_id,
 	}
 
 	if (flags & GB_CONNECTION_FLAG_OFFLOADED &&
-			flags & GB_CONNECTION_FLAG_CDSI1) {
+	    flags & GB_CONNECTION_FLAG_CDSI1) {
 		if (es2->cdsi1_in_use) {
 			dev_err(&hd->dev, "CDSI1 already in use\n");
 			return -EBUSY;
@@ -561,16 +561,16 @@ static int cport_enable(struct gb_host_device *hd, u16 cport_id,
 	req->flags = cpu_to_le32(connection_flags);
 
 	dev_dbg(&hd->dev, "%s - cport = %u, flags = %02x\n", __func__,
-			cport_id, connection_flags);
+		cport_id, connection_flags);
 
 	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-				GB_APB_REQUEST_CPORT_FLAGS,
-				USB_DIR_OUT | USB_TYPE_VENDOR |
-				USB_RECIP_INTERFACE, cport_id, 0,
-				req, sizeof(*req), ES2_USB_CTRL_TIMEOUT);
+			      GB_APB_REQUEST_CPORT_FLAGS,
+			      USB_DIR_OUT | USB_TYPE_VENDOR |
+			      USB_RECIP_INTERFACE, cport_id, 0,
+			      req, sizeof(*req), ES2_USB_CTRL_TIMEOUT);
 	if (ret != sizeof(*req)) {
 		dev_err(&udev->dev, "failed to set cport flags for port %d\n",
-				cport_id);
+			cport_id);
 		if (ret >= 0)
 			ret = -EIO;
 
@@ -596,7 +596,7 @@ static int es2_cport_connected(struct gb_host_device *hd, u16 cport_id)
 			NULL, ES2_ARPC_CPORT_TIMEOUT);
 	if (ret) {
 		dev_err(dev, "failed to set connected state for cport %u: %d\n",
-				cport_id, ret);
+			cport_id, ret);
 		return ret;
 	}
 
@@ -622,7 +622,7 @@ static int es2_cport_flush(struct gb_host_device *hd, u16 cport_id)
 }
 
 static int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,
-				u8 phase, unsigned int timeout)
+			      u8 phase, unsigned int timeout)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 	struct device *dev = &es2->usb_dev->dev;
@@ -640,7 +640,7 @@ static int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,
 			&result, ES2_ARPC_CPORT_TIMEOUT + timeout);
 	if (ret) {
 		dev_err(dev, "failed to send shutdown over cport %u: %d (%d)\n",
-				cport_id, ret, result);
+			cport_id, ret, result);
 		return ret;
 	}
 
@@ -648,7 +648,7 @@ static int es2_cport_shutdown(struct gb_host_device *hd, u16 cport_id,
 }
 
 static int es2_cport_quiesce(struct gb_host_device *hd, u16 cport_id,
-				size_t peer_space, unsigned int timeout)
+			     size_t peer_space, unsigned int timeout)
 {
 	struct es2_ap_dev *es2 = hd_to_es2(hd);
 	struct device *dev = &es2->usb_dev->dev;
@@ -669,7 +669,7 @@ static int es2_cport_quiesce(struct gb_host_device *hd, u16 cport_id,
 			&result, ES2_ARPC_CPORT_TIMEOUT + timeout);
 	if (ret) {
 		dev_err(dev, "failed to quiesce cport %u: %d (%d)\n",
-				cport_id, ret, result);
+			cport_id, ret, result);
 		return ret;
 	}
 
@@ -846,7 +846,7 @@ static void cport_in_callback(struct urb *urb)
 
 	if (cport_id_valid(hd, cport_id)) {
 		greybus_data_rcvd(hd, cport_id, urb->transfer_buffer,
-							urb->actual_length);
+				  urb->actual_length);
 	} else {
 		dev_err(dev, "invalid cport id %u received\n", cport_id);
 	}
@@ -1083,14 +1083,14 @@ static void apb_log_get(struct es2_ap_dev *es2, char *buf)
 
 	do {
 		retval = usb_control_msg(es2->usb_dev,
-					usb_rcvctrlpipe(es2->usb_dev, 0),
-					GB_APB_REQUEST_LOG,
-					USB_DIR_IN | USB_TYPE_VENDOR |
-					USB_RECIP_INTERFACE,
-					0x00, 0x00,
-					buf,
-					APB1_LOG_MSG_SIZE,
-					ES2_USB_CTRL_TIMEOUT);
+					 usb_rcvctrlpipe(es2->usb_dev, 0),
+					 GB_APB_REQUEST_LOG,
+					 USB_DIR_IN | USB_TYPE_VENDOR |
+					 USB_RECIP_INTERFACE,
+					 0x00, 0x00,
+					 buf,
+					 APB1_LOG_MSG_SIZE,
+					 ES2_USB_CTRL_TIMEOUT);
 		if (retval > 0)
 			kfifo_in(&es2->apb_log_fifo, buf, retval);
 	} while (retval > 0);
@@ -1116,7 +1116,7 @@ static int apb_log_poll(void *data)
 }
 
 static ssize_t apb_log_read(struct file *f, char __user *buf,
-				size_t count, loff_t *ppos)
+			    size_t count, loff_t *ppos)
 {
 	struct es2_ap_dev *es2 = file_inode(f)->i_private;
 	ssize_t ret;
@@ -1153,8 +1153,8 @@ static void usb_log_enable(struct es2_ap_dev *es2)
 		return;
 	/* XXX We will need to rename this per APB */
 	es2->apb_log_dentry = debugfs_create_file("apb_log", 0444,
-						gb_debugfs_get(), es2,
-						&apb_log_fops);
+						  gb_debugfs_get(), es2,
+						  &apb_log_fops);
 }
 
 static void usb_log_disable(struct es2_ap_dev *es2)
@@ -1170,7 +1170,7 @@ static void usb_log_disable(struct es2_ap_dev *es2)
 }
 
 static ssize_t apb_log_enable_read(struct file *f, char __user *buf,
-				size_t count, loff_t *ppos)
+				   size_t count, loff_t *ppos)
 {
 	struct es2_ap_dev *es2 = file_inode(f)->i_private;
 	int enable = !IS_ERR_OR_NULL(es2->apb_log_task);
@@ -1181,7 +1181,7 @@ static ssize_t apb_log_enable_read(struct file *f, char __user *buf,
 }
 
 static ssize_t apb_log_enable_write(struct file *f, const char __user *buf,
-				size_t count, loff_t *ppos)
+				    size_t count, loff_t *ppos)
 {
 	int enable;
 	ssize_t retval;
@@ -1274,7 +1274,7 @@ static int ap_probe(struct usb_interface *interface,
 	}
 
 	hd = gb_hd_create(&es2_driver, &udev->dev, ES2_GBUF_MSG_SIZE_MAX,
-				num_cports);
+			  num_cports);
 	if (IS_ERR(hd)) {
 		usb_put_dev(udev);
 		return PTR_ERR(hd);
@@ -1409,9 +1409,9 @@ static int ap_probe(struct usb_interface *interface,
 
 	/* XXX We will need to rename this per APB */
 	es2->apb_log_enable_dentry = debugfs_create_file("apb_log_enable",
-							0644,
-							gb_debugfs_get(), es2,
-							&apb_log_enable_fops);
+							 0644,
+							 gb_debugfs_get(), es2,
+							 &apb_log_enable_fops);
 
 	INIT_LIST_HEAD(&es2->arpcs);
 	spin_lock_init(&es2->arpc_lock);
diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index b1d46980..e110681 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -74,7 +74,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,
-				 &request, sizeof(request), NULL, 0);
+				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		gbphy_runtime_put_autosuspend(gbphy_dev);
 		return ret;
@@ -86,7 +86,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 }
 
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					 u8 which)
 {
 	struct gbphy_device *gbphy_dev = ggc->gbphy_dev;
 	struct device *dev = &gbphy_dev->dev;
@@ -95,7 +95,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
-				 &request, sizeof(request), NULL, 0);
+				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(dev, "failed to deactivate gpio %u\n", which);
 		goto out_pm_put;
@@ -108,7 +108,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					   u8 which)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_direction_request request;
@@ -133,7 +133,7 @@ static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					  u8 which)
 {
 	struct gb_gpio_direction_in_request request;
 	int ret;
@@ -147,7 +147,7 @@ static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
-					u8 which, bool value_high)
+					   u8 which, bool value_high)
 {
 	struct gb_gpio_direction_out_request request;
 	int ret;
@@ -162,7 +162,7 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+				       u8 which)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_value_request request;
@@ -214,7 +214,7 @@ static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
-					u8 which, u16 debounce_usec)
+					  u8 which, u16 debounce_usec)
 {
 	struct gb_gpio_set_debounce_request request;
 	int ret;
@@ -257,7 +257,7 @@ static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 }
 
 static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
-					u8 hwirq, u8 type)
+				  u8 hwirq, u8 type)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_irq_type_request request;
@@ -589,10 +589,10 @@ static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
  * before calling this function.
  */
 static int gb_gpio_irqchip_add(struct gpio_chip *chip,
-			 struct irq_chip *irqchip,
-			 unsigned int first_irq,
-			 irq_flow_handler_t handler,
-			 unsigned int type)
+			       struct irq_chip *irqchip,
+			       unsigned int first_irq,
+			       irq_flow_handler_t handler,
+			       unsigned int type)
 {
 	struct gb_gpio_controller *ggc;
 	unsigned int offset;
@@ -607,8 +607,8 @@ static int gb_gpio_irqchip_add(struct gpio_chip *chip,
 	ggc->irq_handler = handler;
 	ggc->irq_default_type = type;
 	ggc->irqdomain = irq_domain_add_simple(NULL,
-					ggc->line_max + 1, first_irq,
-					&gb_gpio_domain_ops, chip);
+					       ggc->line_max + 1, first_irq,
+					       &gb_gpio_domain_ops, chip);
 	if (!ggc->irqdomain) {
 		ggc->irqchip = NULL;
 		return -EINVAL;
@@ -648,9 +648,10 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	if (!ggc)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gbphy_dev->bundle,
-					  le16_to_cpu(gbphy_dev->cport_desc->id),
-					  gb_gpio_request_handler);
+	connection =
+		gb_connection_create(gbphy_dev->bundle,
+				     le16_to_cpu(gbphy_dev->cport_desc->id),
+				     gb_gpio_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto exit_ggc_free;
@@ -703,7 +704,7 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 		goto exit_line_free;
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
-				   handle_level_irq, IRQ_TYPE_NONE);
+				  handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(&gbphy_dev->dev, "failed to add irq chip: %d\n", ret);
 		goto exit_line_free;
diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 04053ff..0b72e1b 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -49,8 +49,8 @@ static int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)
 		return ret;
 
 	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,
-				 NULL, 0, rdesc,
-				 le16_to_cpu(ghid->hdesc.wReportDescLength));
+				NULL, 0, rdesc,
+				le16_to_cpu(ghid->hdesc.wReportDescLength));
 
 	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
@@ -86,7 +86,7 @@ static int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	request.report_id = report_id;
 
 	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,
-				 &request, sizeof(request), buf, len);
+				&request, sizeof(request), buf, len);
 
 	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
@@ -211,11 +211,13 @@ static void gb_hid_init_reports(struct gb_hid *ghid)
 	struct hid_report *report;
 
 	list_for_each_entry(report,
-		&hid->report_enum[HID_INPUT_REPORT].report_list, list)
+			    &hid->report_enum[HID_INPUT_REPORT].report_list,
+			    list)
 		gb_hid_init_report(ghid, report);
 
 	list_for_each_entry(report,
-		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+			    &hid->report_enum[HID_FEATURE_REPORT].report_list,
+			    list)
 		gb_hid_init_report(ghid, report);
 }
 
@@ -259,8 +261,8 @@ static int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
 }
 
 static int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
-			       __u8 *buf, size_t len, unsigned char rtype,
-			       int reqtype)
+			      __u8 *buf, size_t len, unsigned char rtype,
+			      int reqtype)
 {
 	switch (reqtype) {
 	case HID_REQ_GET_REPORT:
@@ -440,7 +442,7 @@ static int gb_hid_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
-						gb_hid_request_handler);
+					  gb_hid_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto err_free_ghid;
diff --git a/drivers/staging/greybus/i2c.c b/drivers/staging/greybus/i2c.c
index 58a37de..7bb85a75 100644
--- a/drivers/staging/greybus/i2c.c
+++ b/drivers/staging/greybus/i2c.c
@@ -107,7 +107,7 @@ gb_i2c_operation_create(struct gb_connection *connection,
 
 	/* Response consists only of incoming data */
 	operation = gb_operation_create(connection, GB_I2C_TYPE_TRANSFER,
-				request_size, data_in_size, GFP_KERNEL);
+					request_size, data_in_size, GFP_KERNEL);
 	if (!operation)
 		return NULL;
 
@@ -137,7 +137,7 @@ gb_i2c_operation_create(struct gb_connection *connection,
 }
 
 static void gb_i2c_decode_response(struct i2c_msg *msgs, u32 msg_count,
-				struct gb_i2c_transfer_response *response)
+				   struct gb_i2c_transfer_response *response)
 {
 	struct i2c_msg *msg = msgs;
 	u8 *data;
@@ -164,7 +164,7 @@ static bool gb_i2c_expected_transfer_error(int errno)
 }
 
 static int gb_i2c_transfer_operation(struct gb_i2c_device *gb_i2c_dev,
-					struct i2c_msg *msgs, u32 msg_count)
+				     struct i2c_msg *msgs, u32 msg_count)
 {
 	struct gb_connection *connection = gb_i2c_dev->connection;
 	struct device *dev = &gb_i2c_dev->gbphy_dev->dev;
@@ -199,7 +199,7 @@ static int gb_i2c_transfer_operation(struct gb_i2c_device *gb_i2c_dev,
 }
 
 static int gb_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
-		int msg_count)
+			      int msg_count)
 {
 	struct gb_i2c_device *gb_i2c_dev;
 
@@ -211,8 +211,8 @@ static int gb_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 #if 0
 /* Later */
 static int gb_i2c_smbus_xfer(struct i2c_adapter *adap,
-			u16 addr, unsigned short flags, char read_write,
-			u8 command, int size, union i2c_smbus_data *data)
+			     u16 addr, unsigned short flags, char read_write,
+			     u8 command, int size, union i2c_smbus_data *data)
 {
 	struct gb_i2c_device *gb_i2c_dev;
 
@@ -249,7 +249,7 @@ static int gb_i2c_device_setup(struct gb_i2c_device *gb_i2c_dev)
 }
 
 static int gb_i2c_probe(struct gbphy_device *gbphy_dev,
-			 const struct gbphy_device_id *id)
+			const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
 	struct gb_i2c_device *gb_i2c_dev;
@@ -260,9 +260,10 @@ static int gb_i2c_probe(struct gbphy_device *gbphy_dev,
 	if (!gb_i2c_dev)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gbphy_dev->bundle,
-					  le16_to_cpu(gbphy_dev->cport_desc->id),
-					  NULL);
+	connection =
+		gb_connection_create(gbphy_dev->bundle,
+				     le16_to_cpu(gbphy_dev->cport_desc->id),
+				     NULL);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto exit_i2cdev_free;
diff --git a/drivers/staging/greybus/module.c b/drivers/staging/greybus/module.c
index 894d02e..b251a53 100644
--- a/drivers/staging/greybus/module.c
+++ b/drivers/staging/greybus/module.c
@@ -9,10 +9,9 @@
 #include "greybus.h"
 #include "greybus_trace.h"
 
-
 static ssize_t eject_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t len)
+			   struct device_attribute *attr,
+			   const char *buf, size_t len)
 {
 	struct gb_module *module = to_gb_module(dev);
 	struct gb_interface *intf;
@@ -48,7 +47,7 @@ static ssize_t eject_store(struct device *dev,
 static DEVICE_ATTR_WO(eject);
 
 static ssize_t module_id_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+			      struct device_attribute *attr, char *buf)
 {
 	struct gb_module *module = to_gb_module(dev);
 
@@ -57,7 +56,7 @@ static ssize_t module_id_show(struct device *dev,
 static DEVICE_ATTR_RO(module_id);
 
 static ssize_t num_interfaces_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct gb_module *module = to_gb_module(dev);
 
@@ -88,7 +87,7 @@ struct device_type greybus_module_type = {
 };
 
 struct gb_module *gb_module_create(struct gb_host_device *hd, u8 module_id,
-					size_t num_interfaces)
+				   size_t num_interfaces)
 {
 	struct gb_interface *intf;
 	struct gb_module *module;
@@ -117,7 +116,7 @@ struct gb_module *gb_module_create(struct gb_host_device *hd, u8 module_id,
 		intf = gb_interface_create(module, module_id + i);
 		if (!intf) {
 			dev_err(&module->dev, "failed to create interface %u\n",
-					module_id + i);
+				module_id + i);
 			goto err_put_interfaces;
 		}
 		module->interfaces[i] = intf;
@@ -149,8 +148,8 @@ static void gb_module_register_interface(struct gb_interface *intf)
 	if (ret) {
 		if (intf->type != GB_INTERFACE_TYPE_DUMMY) {
 			dev_err(&module->dev,
-					"failed to activate interface %u: %d\n",
-					intf_id, ret);
+				"failed to activate interface %u: %d\n",
+				intf_id, ret);
 		}
 
 		gb_interface_add(intf);
@@ -164,7 +163,7 @@ static void gb_module_register_interface(struct gb_interface *intf)
 	ret = gb_interface_enable(intf);
 	if (ret) {
 		dev_err(&module->dev, "failed to enable interface %u: %d\n",
-				intf_id, ret);
+			intf_id, ret);
 		goto err_interface_deactivate;
 	}
 
diff --git a/drivers/staging/greybus/operation.c b/drivers/staging/greybus/operation.c
index c462b1c..fe268f7 100644
--- a/drivers/staging/greybus/operation.c
+++ b/drivers/staging/greybus/operation.c
@@ -31,7 +31,7 @@ static DECLARE_WAIT_QUEUE_HEAD(gb_operation_cancellation_queue);
 static DEFINE_SPINLOCK(gb_operations_lock);
 
 static int gb_operation_response_send(struct gb_operation *operation,
-					int errno);
+				      int errno);
 
 /*
  * Increment operation active count and add to connection list unless the
@@ -202,7 +202,7 @@ gb_operation_find_outgoing(struct gb_connection *connection, u16 operation_id)
 	spin_lock_irqsave(&connection->lock, flags);
 	list_for_each_entry(operation, &connection->operations, links)
 		if (operation->id == operation_id &&
-				!gb_operation_is_incoming(operation)) {
+		    !gb_operation_is_incoming(operation)) {
 			gb_operation_get(operation);
 			found = true;
 			break;
@@ -307,8 +307,9 @@ static void gb_operation_timeout(struct timer_list *t)
 }
 
 static void gb_operation_message_init(struct gb_host_device *hd,
-				struct gb_message *message, u16 operation_id,
-				size_t payload_size, u8 type)
+				      struct gb_message *message,
+				      u16 operation_id,
+				      size_t payload_size, u8 type)
 {
 	struct gb_operation_msg_hdr *header;
 
@@ -358,7 +359,7 @@ static void gb_operation_message_init(struct gb_host_device *hd,
  */
 static struct gb_message *
 gb_operation_message_alloc(struct gb_host_device *hd, u8 type,
-				size_t payload_size, gfp_t gfp_flags)
+			   size_t payload_size, gfp_t gfp_flags)
 {
 	struct gb_message *message;
 	struct gb_operation_msg_hdr *header;
@@ -366,7 +367,7 @@ gb_operation_message_alloc(struct gb_host_device *hd, u8 type,
 
 	if (message_size > hd->buffer_size_max) {
 		dev_warn(&hd->dev, "requested message size too big (%zu > %zu)\n",
-				message_size, hd->buffer_size_max);
+			 message_size, hd->buffer_size_max);
 		return NULL;
 	}
 
@@ -465,7 +466,7 @@ static u8 gb_operation_errno_map(int errno)
 }
 
 bool gb_operation_response_alloc(struct gb_operation *operation,
-					size_t response_size, gfp_t gfp)
+				 size_t response_size, gfp_t gfp)
 {
 	struct gb_host_device *hd = operation->connection->hd;
 	struct gb_operation_msg_hdr *request_header;
@@ -516,8 +517,8 @@ EXPORT_SYMBOL_GPL(gb_operation_response_alloc);
  */
 static struct gb_operation *
 gb_operation_create_common(struct gb_connection *connection, u8 type,
-				size_t request_size, size_t response_size,
-				unsigned long op_flags, gfp_t gfp_flags)
+			   size_t request_size, size_t response_size,
+			   unsigned long op_flags, gfp_t gfp_flags)
 {
 	struct gb_host_device *hd = connection->hd;
 	struct gb_operation *operation;
@@ -572,9 +573,9 @@ gb_operation_create_common(struct gb_connection *connection, u8 type,
  */
 struct gb_operation *
 gb_operation_create_flags(struct gb_connection *connection,
-				u8 type, size_t request_size,
-				size_t response_size, unsigned long flags,
-				gfp_t gfp)
+			  u8 type, size_t request_size,
+			  size_t response_size, unsigned long flags,
+			  gfp_t gfp)
 {
 	struct gb_operation *operation;
 
@@ -587,8 +588,8 @@ gb_operation_create_flags(struct gb_connection *connection,
 		flags &= GB_OPERATION_FLAG_USER_MASK;
 
 	operation = gb_operation_create_common(connection, type,
-						request_size, response_size,
-						flags, gfp);
+					       request_size, response_size,
+					       flags, gfp);
 	if (operation)
 		trace_gb_operation_create(operation);
 
@@ -598,22 +599,23 @@ EXPORT_SYMBOL_GPL(gb_operation_create_flags);
 
 struct gb_operation *
 gb_operation_create_core(struct gb_connection *connection,
-				u8 type, size_t request_size,
-				size_t response_size, unsigned long flags,
-				gfp_t gfp)
+			 u8 type, size_t request_size,
+			 size_t response_size, unsigned long flags,
+			 gfp_t gfp)
 {
 	struct gb_operation *operation;
 
 	flags |= GB_OPERATION_FLAG_CORE;
 
 	operation = gb_operation_create_common(connection, type,
-						request_size, response_size,
-						flags, gfp);
+					       request_size, response_size,
+					       flags, gfp);
 	if (operation)
 		trace_gb_operation_create_core(operation);
 
 	return operation;
 }
+
 /* Do not export this function. */
 
 size_t gb_operation_get_payload_size_max(struct gb_connection *connection)
@@ -626,7 +628,7 @@ EXPORT_SYMBOL_GPL(gb_operation_get_payload_size_max);
 
 static struct gb_operation *
 gb_operation_create_incoming(struct gb_connection *connection, u16 id,
-				u8 type, void *data, size_t size)
+			     u8 type, void *data, size_t size)
 {
 	struct gb_operation *operation;
 	size_t request_size;
@@ -639,9 +641,9 @@ gb_operation_create_incoming(struct gb_connection *connection, u16 id,
 		flags |= GB_OPERATION_FLAG_UNIDIRECTIONAL;
 
 	operation = gb_operation_create_common(connection, type,
-						request_size,
-						GB_REQUEST_TYPE_INVALID,
-						flags, GFP_ATOMIC);
+					       request_size,
+					       GB_REQUEST_TYPE_INVALID,
+					       flags, GFP_ATOMIC);
 	if (!operation)
 		return NULL;
 
@@ -716,9 +718,9 @@ static void gb_operation_sync_callback(struct gb_operation *operation)
  * or a negative errno.
  */
 int gb_operation_request_send(struct gb_operation *operation,
-				gb_operation_callback callback,
-				unsigned int timeout,
-				gfp_t gfp)
+			      gb_operation_callback callback,
+			      unsigned int timeout,
+			      gfp_t gfp)
 {
 	struct gb_connection *connection = operation->connection;
 	struct gb_operation_msg_hdr *header;
@@ -790,7 +792,7 @@ EXPORT_SYMBOL_GPL(gb_operation_request_send);
  * operation.
  */
 int gb_operation_request_send_sync_timeout(struct gb_operation *operation,
-						unsigned int timeout)
+					   unsigned int timeout)
 {
 	int ret;
 
@@ -819,13 +821,13 @@ EXPORT_SYMBOL_GPL(gb_operation_request_send_sync_timeout);
  * allocate the response message if necessary.
  */
 static int gb_operation_response_send(struct gb_operation *operation,
-					int errno)
+				      int errno)
 {
 	struct gb_connection *connection = operation->connection;
 	int ret;
 
 	if (!operation->response &&
-			!gb_operation_is_unidirectional(operation)) {
+	    !gb_operation_is_unidirectional(operation)) {
 		if (!gb_operation_response_alloc(operation, 0, GFP_KERNEL))
 			return -ENOMEM;
 	}
@@ -867,7 +869,7 @@ static int gb_operation_response_send(struct gb_operation *operation,
  * This function is called when a message send request has completed.
  */
 void greybus_message_sent(struct gb_host_device *hd,
-					struct gb_message *message, int status)
+			  struct gb_message *message, int status)
 {
 	struct gb_operation *operation = message->operation;
 	struct gb_connection *connection = operation->connection;
@@ -895,7 +897,7 @@ void greybus_message_sent(struct gb_host_device *hd,
 	} else if (status || gb_operation_is_unidirectional(operation)) {
 		if (gb_operation_result_set(operation, status)) {
 			queue_work(gb_operation_completion_wq,
-					&operation->work);
+				   &operation->work);
 		}
 	}
 }
@@ -921,7 +923,7 @@ static void gb_connection_recv_request(struct gb_connection *connection,
 	type = header->type;
 
 	operation = gb_operation_create_incoming(connection, operation_id,
-						type, data, size);
+						 type, data, size);
 	if (!operation) {
 		dev_err(&connection->hd->dev,
 			"%s: can't create incoming operation\n",
@@ -966,16 +968,16 @@ static void gb_connection_recv_response(struct gb_connection *connection,
 
 	if (!operation_id) {
 		dev_err_ratelimited(&connection->hd->dev,
-				"%s: invalid response id 0 received\n",
-				connection->name);
+				    "%s: invalid response id 0 received\n",
+				    connection->name);
 		return;
 	}
 
 	operation = gb_operation_find_outgoing(connection, operation_id);
 	if (!operation) {
 		dev_err_ratelimited(&connection->hd->dev,
-				"%s: unexpected response id 0x%04x received\n",
-				connection->name, operation_id);
+				    "%s: unexpected response id 0x%04x received\n",
+				    connection->name, operation_id);
 		return;
 	}
 
@@ -984,18 +986,18 @@ static void gb_connection_recv_response(struct gb_connection *connection,
 	message_size = sizeof(*header) + message->payload_size;
 	if (!errno && size > message_size) {
 		dev_err_ratelimited(&connection->hd->dev,
-				"%s: malformed response 0x%02x received (%zu > %zu)\n",
-				connection->name, header->type,
-				size, message_size);
+				    "%s: malformed response 0x%02x received (%zu > %zu)\n",
+				    connection->name, header->type,
+				    size, message_size);
 		errno = -EMSGSIZE;
 	} else if (!errno && size < message_size) {
 		if (gb_operation_short_response_allowed(operation)) {
 			message->payload_size = size - sizeof(*header);
 		} else {
 			dev_err_ratelimited(&connection->hd->dev,
-					"%s: short response 0x%02x received (%zu < %zu)\n",
-					connection->name, header->type,
-					size, message_size);
+					    "%s: short response 0x%02x received (%zu < %zu)\n",
+					    connection->name, header->type,
+					    size, message_size);
 			errno = -EMSGSIZE;
 		}
 	}
@@ -1022,22 +1024,22 @@ static void gb_connection_recv_response(struct gb_connection *connection,
  * with, it's effectively dropped).
  */
 void gb_connection_recv(struct gb_connection *connection,
-				void *data, size_t size)
+			void *data, size_t size)
 {
 	struct gb_operation_msg_hdr header;
 	struct device *dev = &connection->hd->dev;
 	size_t msg_size;
 
 	if (connection->state == GB_CONNECTION_STATE_DISABLED ||
-			gb_connection_is_offloaded(connection)) {
+	    gb_connection_is_offloaded(connection)) {
 		dev_warn_ratelimited(dev, "%s: dropping %zu received bytes\n",
-				connection->name, size);
+				     connection->name, size);
 		return;
 	}
 
 	if (size < sizeof(header)) {
 		dev_err_ratelimited(dev, "%s: short message received\n",
-				connection->name);
+				    connection->name);
 		return;
 	}
 
@@ -1046,19 +1048,19 @@ void gb_connection_recv(struct gb_connection *connection,
 	msg_size = le16_to_cpu(header.size);
 	if (size < msg_size) {
 		dev_err_ratelimited(dev,
-				"%s: incomplete message 0x%04x of type 0x%02x received (%zu < %zu)\n",
-				connection->name,
-				le16_to_cpu(header.operation_id),
-				header.type, size, msg_size);
+				    "%s: incomplete message 0x%04x of type 0x%02x received (%zu < %zu)\n",
+				    connection->name,
+				    le16_to_cpu(header.operation_id),
+				    header.type, size, msg_size);
 		return;		/* XXX Should still complete operation */
 	}
 
 	if (header.type & GB_MESSAGE_TYPE_RESPONSE) {
 		gb_connection_recv_response(connection,	&header, data,
-						msg_size);
+					    msg_size);
 	} else {
 		gb_connection_recv_request(connection, &header, data,
-						msg_size);
+					   msg_size);
 	}
 }
 
@@ -1079,7 +1081,7 @@ void gb_operation_cancel(struct gb_operation *operation, int errno)
 
 	atomic_inc(&operation->waiters);
 	wait_event(gb_operation_cancellation_queue,
-			!gb_operation_is_active(operation));
+		   !gb_operation_is_active(operation));
 	atomic_dec(&operation->waiters);
 }
 EXPORT_SYMBOL_GPL(gb_operation_cancel);
@@ -1106,7 +1108,7 @@ void gb_operation_cancel_incoming(struct gb_operation *operation, int errno)
 
 	atomic_inc(&operation->waiters);
 	wait_event(gb_operation_cancellation_queue,
-			!gb_operation_is_active(operation));
+		   !gb_operation_is_active(operation));
 	atomic_dec(&operation->waiters);
 }
 
@@ -1134,9 +1136,9 @@ void gb_operation_cancel_incoming(struct gb_operation *operation, int errno)
  * If there is an error, the response buffer is left alone.
  */
 int gb_operation_sync_timeout(struct gb_connection *connection, int type,
-				void *request, int request_size,
-				void *response, int response_size,
-				unsigned int timeout)
+			      void *request, int request_size,
+			      void *response, int response_size,
+			      unsigned int timeout)
 {
 	struct gb_operation *operation;
 	int ret;
@@ -1187,8 +1189,9 @@ EXPORT_SYMBOL_GPL(gb_operation_sync_timeout);
  * the request as actually reached the remote end of the connection.
  */
 int gb_operation_unidirectional_timeout(struct gb_connection *connection,
-				int type, void *request, int request_size,
-				unsigned int timeout)
+					int type, void *request,
+					int request_size,
+					unsigned int timeout)
 {
 	struct gb_operation *operation;
 	int ret;
@@ -1197,9 +1200,9 @@ int gb_operation_unidirectional_timeout(struct gb_connection *connection,
 		return -EINVAL;
 
 	operation = gb_operation_create_flags(connection, type,
-					request_size, 0,
-					GB_OPERATION_FLAG_UNIDIRECTIONAL,
-					GFP_KERNEL);
+					      request_size, 0,
+					      GB_OPERATION_FLAG_UNIDIRECTIONAL,
+					      GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 
@@ -1222,17 +1225,19 @@ EXPORT_SYMBOL_GPL(gb_operation_unidirectional_timeout);
 int __init gb_operation_init(void)
 {
 	gb_message_cache = kmem_cache_create("gb_message_cache",
-				sizeof(struct gb_message), 0, 0, NULL);
+					     sizeof(struct gb_message), 0, 0,
+					     NULL);
 	if (!gb_message_cache)
 		return -ENOMEM;
 
 	gb_operation_cache = kmem_cache_create("gb_operation_cache",
-				sizeof(struct gb_operation), 0, 0, NULL);
+					       sizeof(struct gb_operation), 0,
+					       0, NULL);
 	if (!gb_operation_cache)
 		goto err_destroy_message_cache;
 
 	gb_operation_completion_wq = alloc_workqueue("greybus_completion",
-				0, 0);
+						     0, 0);
 	if (!gb_operation_completion_wq)
 		goto err_destroy_operation_cache;
 
diff --git a/drivers/staging/greybus/svc.c b/drivers/staging/greybus/svc.c
index a2bb7e1..05bc452 100644
--- a/drivers/staging/greybus/svc.c
+++ b/drivers/staging/greybus/svc.c
@@ -20,11 +20,10 @@ struct gb_svc_deferred_request {
 	struct gb_operation *operation;
 };
 
-
 static int gb_svc_queue_deferred_request(struct gb_operation *operation);
 
 static ssize_t endo_id_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+			    struct device_attribute *attr, char *buf)
 {
 	struct gb_svc *svc = to_gb_svc(dev);
 
@@ -33,7 +32,7 @@ static ssize_t endo_id_show(struct device *dev,
 static DEVICE_ATTR_RO(endo_id);
 
 static ssize_t ap_intf_id_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+			       struct device_attribute *attr, char *buf)
 {
 	struct gb_svc *svc = to_gb_svc(dev);
 
@@ -304,8 +303,8 @@ int gb_svc_intf_vsys_set(struct gb_svc *svc, u8 intf_id, bool enable)
 		type = GB_SVC_TYPE_INTF_VSYS_DISABLE;
 
 	ret = gb_operation_sync(svc->connection, type,
-			&request, sizeof(request),
-			&response, sizeof(response));
+				&request, sizeof(request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 	if (response.result_code != GB_SVC_INTF_VSYS_OK)
@@ -327,8 +326,8 @@ int gb_svc_intf_refclk_set(struct gb_svc *svc, u8 intf_id, bool enable)
 		type = GB_SVC_TYPE_INTF_REFCLK_DISABLE;
 
 	ret = gb_operation_sync(svc->connection, type,
-			&request, sizeof(request),
-			&response, sizeof(response));
+				&request, sizeof(request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 	if (response.result_code != GB_SVC_INTF_REFCLK_OK)
@@ -350,8 +349,8 @@ int gb_svc_intf_unipro_set(struct gb_svc *svc, u8 intf_id, bool enable)
 		type = GB_SVC_TYPE_INTF_UNIPRO_DISABLE;
 
 	ret = gb_operation_sync(svc->connection, type,
-			&request, sizeof(request),
-			&response, sizeof(response));
+				&request, sizeof(request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 	if (response.result_code != GB_SVC_INTF_UNIPRO_OK)
@@ -368,15 +367,15 @@ int gb_svc_intf_activate(struct gb_svc *svc, u8 intf_id, u8 *intf_type)
 	request.intf_id = intf_id;
 
 	ret = gb_operation_sync_timeout(svc->connection,
-			GB_SVC_TYPE_INTF_ACTIVATE,
-			&request, sizeof(request),
-			&response, sizeof(response),
-			SVC_INTF_ACTIVATE_TIMEOUT);
+					GB_SVC_TYPE_INTF_ACTIVATE,
+					&request, sizeof(request),
+					&response, sizeof(response),
+					SVC_INTF_ACTIVATE_TIMEOUT);
 	if (ret < 0)
 		return ret;
 	if (response.status != GB_SVC_OP_SUCCESS) {
 		dev_err(&svc->dev, "failed to activate interface %u: %u\n",
-				intf_id, response.status);
+			intf_id, response.status);
 		return -EREMOTEIO;
 	}
 
@@ -430,14 +429,14 @@ int gb_svc_dme_peer_get(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,
 				&response, sizeof(response));
 	if (ret) {
 		dev_err(&svc->dev, "failed to get DME attribute (%u 0x%04x %u): %d\n",
-				intf_id, attr, selector, ret);
+			intf_id, attr, selector, ret);
 		return ret;
 	}
 
 	result = le16_to_cpu(response.result_code);
 	if (result) {
 		dev_err(&svc->dev, "UniPro error while getting DME attribute (%u 0x%04x %u): %u\n",
-				intf_id, attr, selector, result);
+			intf_id, attr, selector, result);
 		return -EREMOTEIO;
 	}
 
@@ -465,14 +464,14 @@ int gb_svc_dme_peer_set(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,
 				&response, sizeof(response));
 	if (ret) {
 		dev_err(&svc->dev, "failed to set DME attribute (%u 0x%04x %u %u): %d\n",
-				intf_id, attr, selector, value, ret);
+			intf_id, attr, selector, value, ret);
 		return ret;
 	}
 
 	result = le16_to_cpu(response.result_code);
 	if (result) {
 		dev_err(&svc->dev, "UniPro error while setting DME attribute (%u 0x%04x %u %u): %u\n",
-				intf_id, attr, selector, value, result);
+			intf_id, attr, selector, value, result);
 		return -EREMOTEIO;
 	}
 
@@ -480,9 +479,9 @@ int gb_svc_dme_peer_set(struct gb_svc *svc, u8 intf_id, u16 attr, u16 selector,
 }
 
 int gb_svc_connection_create(struct gb_svc *svc,
-				u8 intf1_id, u16 cport1_id,
-				u8 intf2_id, u16 cport2_id,
-				u8 cport_flags)
+			     u8 intf1_id, u16 cport1_id,
+			     u8 intf2_id, u16 cport2_id,
+			     u8 cport_flags)
 {
 	struct gb_svc_conn_create_request request;
 
@@ -513,13 +512,13 @@ void gb_svc_connection_destroy(struct gb_svc *svc, u8 intf1_id, u16 cport1_id,
 				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(&svc->dev, "failed to destroy connection (%u:%u %u:%u): %d\n",
-				intf1_id, cport1_id, intf2_id, cport2_id, ret);
+			intf1_id, cport1_id, intf2_id, cport2_id, ret);
 	}
 }
 
 /* Creates bi-directional routes between the devices */
 int gb_svc_route_create(struct gb_svc *svc, u8 intf1_id, u8 dev1_id,
-			       u8 intf2_id, u8 dev2_id)
+			u8 intf2_id, u8 dev2_id)
 {
 	struct gb_svc_route_create_request request;
 
@@ -545,7 +544,7 @@ void gb_svc_route_destroy(struct gb_svc *svc, u8 intf1_id, u8 intf2_id)
 				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(&svc->dev, "failed to destroy route (%u %u): %d\n",
-				intf1_id, intf2_id, ret);
+			intf1_id, intf2_id, ret);
 	}
 }
 
@@ -648,8 +647,8 @@ static int gb_svc_version_request(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_err(&svc->dev, "short version request (%zu < %zu)\n",
-				op->request->payload_size,
-				sizeof(*request));
+			op->request->payload_size,
+			sizeof(*request));
 		return -EINVAL;
 	}
 
@@ -657,7 +656,7 @@ static int gb_svc_version_request(struct gb_operation *op)
 
 	if (request->major > GB_SVC_VERSION_MAJOR) {
 		dev_warn(&svc->dev, "unsupported major version (%u > %u)\n",
-				request->major, GB_SVC_VERSION_MAJOR);
+			 request->major, GB_SVC_VERSION_MAJOR);
 		return -ENOTSUPP;
 	}
 
@@ -845,8 +844,8 @@ static int gb_svc_hello(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*hello_request)) {
 		dev_warn(&svc->dev, "short hello request (%zu < %zu)\n",
-				op->request->payload_size,
-				sizeof(*hello_request));
+			 op->request->payload_size,
+			 sizeof(*hello_request));
 		return -EINVAL;
 	}
 
@@ -877,7 +876,7 @@ static int gb_svc_hello(struct gb_operation *op)
 }
 
 static struct gb_interface *gb_svc_interface_lookup(struct gb_svc *svc,
-							u8 intf_id)
+						    u8 intf_id)
 {
 	struct gb_host_device *hd = svc->hd;
 	struct gb_module *module;
@@ -889,7 +888,7 @@ static struct gb_interface *gb_svc_interface_lookup(struct gb_svc *svc,
 		num_interfaces = module->num_interfaces;
 
 		if (intf_id >= module_id &&
-				intf_id < module_id + num_interfaces) {
+		    intf_id < module_id + num_interfaces) {
 			return module->interfaces[intf_id - module_id];
 		}
 	}
@@ -938,8 +937,8 @@ static void gb_svc_process_hello_deferred(struct gb_operation *operation)
 
 	if (ret)
 		dev_warn(&svc->dev,
-			"power mode change failed on AP to switch link: %d\n",
-			ret);
+			 "power mode change failed on AP to switch link: %d\n",
+			 ret);
 }
 
 static void gb_svc_process_module_inserted(struct gb_operation *operation)
@@ -961,17 +960,17 @@ static void gb_svc_process_module_inserted(struct gb_operation *operation)
 	flags = le16_to_cpu(request->flags);
 
 	dev_dbg(&svc->dev, "%s - id = %u, num_interfaces = %zu, flags = 0x%04x\n",
-			__func__, module_id, num_interfaces, flags);
+		__func__, module_id, num_interfaces, flags);
 
 	if (flags & GB_SVC_MODULE_INSERTED_FLAG_NO_PRIMARY) {
 		dev_warn(&svc->dev, "no primary interface detected on module %u\n",
-				module_id);
+			 module_id);
 	}
 
 	module = gb_svc_module_lookup(svc, module_id);
 	if (module) {
 		dev_warn(&svc->dev, "unexpected module-inserted event %u\n",
-				module_id);
+			 module_id);
 		return;
 	}
 
@@ -1007,7 +1006,7 @@ static void gb_svc_process_module_removed(struct gb_operation *operation)
 	module = gb_svc_module_lookup(svc, module_id);
 	if (!module) {
 		dev_warn(&svc->dev, "unexpected module-removed event %u\n",
-				module_id);
+			 module_id);
 		return;
 	}
 
@@ -1066,7 +1065,7 @@ static void gb_svc_process_intf_mailbox_event(struct gb_operation *operation)
 	mailbox = le32_to_cpu(request->mailbox);
 
 	dev_dbg(&svc->dev, "%s - id = %u, result = 0x%04x, mailbox = 0x%08x\n",
-			__func__, intf_id, result_code, mailbox);
+		__func__, intf_id, result_code, mailbox);
 
 	intf = gb_svc_interface_lookup(svc, intf_id);
 	if (!intf) {
@@ -1140,7 +1139,7 @@ static int gb_svc_intf_reset_recv(struct gb_operation *op)
 
 	if (request->payload_size < sizeof(*reset)) {
 		dev_warn(&svc->dev, "short reset request received (%zu < %zu)\n",
-				request->payload_size, sizeof(*reset));
+			 request->payload_size, sizeof(*reset));
 		return -EINVAL;
 	}
 	reset = request->payload;
@@ -1157,14 +1156,14 @@ static int gb_svc_module_inserted_recv(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_warn(&svc->dev, "short module-inserted request received (%zu < %zu)\n",
-				op->request->payload_size, sizeof(*request));
+			 op->request->payload_size, sizeof(*request));
 		return -EINVAL;
 	}
 
 	request = op->request->payload;
 
 	dev_dbg(&svc->dev, "%s - id = %u\n", __func__,
-			request->primary_intf_id);
+		request->primary_intf_id);
 
 	return gb_svc_queue_deferred_request(op);
 }
@@ -1176,14 +1175,14 @@ static int gb_svc_module_removed_recv(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_warn(&svc->dev, "short module-removed request received (%zu < %zu)\n",
-				op->request->payload_size, sizeof(*request));
+			 op->request->payload_size, sizeof(*request));
 		return -EINVAL;
 	}
 
 	request = op->request->payload;
 
 	dev_dbg(&svc->dev, "%s - id = %u\n", __func__,
-			request->primary_intf_id);
+		request->primary_intf_id);
 
 	return gb_svc_queue_deferred_request(op);
 }
@@ -1209,7 +1208,7 @@ static int gb_svc_intf_mailbox_event_recv(struct gb_operation *op)
 
 	if (op->request->payload_size < sizeof(*request)) {
 		dev_warn(&svc->dev, "short mailbox request received (%zu < %zu)\n",
-				op->request->payload_size, sizeof(*request));
+			 op->request->payload_size, sizeof(*request));
 		return -EINVAL;
 	}
 
@@ -1254,7 +1253,7 @@ static int gb_svc_request_handler(struct gb_operation *op)
 
 	if (ret) {
 		dev_warn(&svc->dev, "unexpected request 0x%02x received (state %u)\n",
-				type, svc->state);
+			 type, svc->state);
 		return ret;
 	}
 
@@ -1329,10 +1328,10 @@ struct gb_svc *gb_svc_create(struct gb_host_device *hd)
 	svc->hd = hd;
 
 	svc->connection = gb_connection_create_static(hd, GB_SVC_CPORT_ID,
-						gb_svc_request_handler);
+						      gb_svc_request_handler);
 	if (IS_ERR(svc->connection)) {
 		dev_err(&svc->dev, "failed to create connection: %ld\n",
-				PTR_ERR(svc->connection));
+			PTR_ERR(svc->connection));
 		goto err_put_device;
 	}
 
-- 
2.7.4

