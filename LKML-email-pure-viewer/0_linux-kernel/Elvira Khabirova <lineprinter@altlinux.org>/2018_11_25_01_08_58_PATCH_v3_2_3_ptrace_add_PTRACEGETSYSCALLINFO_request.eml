Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 14:43:09 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 5EB8D5803C2;
	Sat, 24 Nov 2018 17:09:10 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by fmsmga001-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 24 Nov 2018 17:09:09 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AkNJ5JRJnO/CNXYpi/9mcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgUL/zzrarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0yRD+s7bpkSAXwhS?=
 =?us-ascii?q?kJNzA37nzZhM9yg6JVrx2uuxNxw5XMYIyXL/d+YqHQcMkGSWZdQspdSSpMCZ68?=
 =?us-ascii?q?YYsVCOoBOP5VoYb5p1sQrBu+HxOjD/7qxD9InHD5xqw60/4mEQHYxgMrAtUDsH?=
 =?us-ascii?q?DVrNXzKqgSSfq1zKjOzTXfcfxWwyzw55LMchA9pfGMXLRwcdfeyEU1EAPFlFqQ?=
 =?us-ascii?q?pJXjMjiI2OoNtG2b4PBhVeKpk2MotQ5wojmzxss2i4nJnZoZxU7C9SVl2oY0Jc?=
 =?us-ascii?q?e0SEhhYdOiDZBetDmaOpNoTs8+R2xkojs2x7MYtZKhYSQHy4grywTeZvGFa4SF?=
 =?us-ascii?q?7RPuWPyMLTp7h39pYq+zihao/US9xeDxWc+520tQoCVfiNnDrHUN2gTT6seZTv?=
 =?us-ascii?q?t9+V+s2SiA1w/N8OFIO0M0mrTBK54n3LEwkoAfsUPZHi/5gEn2jamWeVs4+uWw?=
 =?us-ascii?q?9ejrfrHrqoWBO4J6lA3yKLkil8+jDegiMwUDXXCX+eGm273i+U35Tq9Kjvozkq?=
 =?us-ascii?q?TBtJDaJMIbprO2AgNM0YYs9Qy/DzG439QchHUHK1xEeBSZgIjzIFzOPv/4Auml?=
 =?us-ascii?q?g1i2kzdk2erGPrv/DZXJNHTDl63hfbll505G1AUz1cxf545TCrwZJPLzW0zxu8?=
 =?us-ascii?q?LCAh42Lgy52OLnCNR71oMDVmODGK6ZMKXOsVCW4uIjOfWDZIgQuDzlMfgq++bu?=
 =?us-ascii?q?jWMlmV8aZaSp3YEYaHGkHvt8JEWVe3rsgsobHmcMsQozV+jqiFyEUT5OaHe+Ra?=
 =?us-ascii?q?M85jcnCI24CYfPXJyigLuE3C2jBJ1ZenhGCkyQEXfvb4iEWfAMZzyILs9ilTwE?=
 =?us-ascii?q?U76hS4g62BGqtQ/6zadnL+XO9i0Zs5LjyMZ65+nJmR4u8jx0CtyX03uRQGFsgm?=
 =?us-ascii?q?MIWzg20bhlrkxmyleD1qt4j+ZCFdNJ5fNESQM6NZ/az+xnBNH+QAPBftGVSFm4?=
 =?us-ascii?q?RtWqGy0+TtU0w9UWeUZyB82ijgzf3yqtG7IVlKaEBJou/qLY3nj+PcB9y3nd2a?=
 =?us-ascii?q?kljlkmRNZPNGK8iq5+8QjTG5DGk0GDm6m2cqQc2TbH9H2fwmqWoEFYTAlwXL3Y?=
 =?us-ascii?q?Un8FeEvZs8715kPYQL+oErQoLA1BxcmGKqtJb93piU5LRPPiONTYfmKwlH28BR?=
 =?us-ascii?q?eOxrOQcoXqf38R0znaCEgBiwoT52qJNRAiBie9pGLTFCFhGkjxY0zy6+V+qGm0?=
 =?us-ascii?q?Tkkvzw6UaU1szL61+h8ThfyBRPIfxLMEuCE9qzpqGFaxxc7ZC92FpwB5ZqVTfc?=
 =?us-ascii?q?s94Etb1WLerwF9Ip2gL6Vlhl4CcwR2v1ni1wltBoVHi8gqqHIqzAx9Ka+D1FNB?=
 =?us-ascii?q?djWY3Y3/O7HNK2ny+gyvZLDS2l3EzNmW/aIP4uwiq1r/pAGpClYi83J/3tZP13?=
 =?us-ascii?q?uT+JrLAxQSUJ7rSUk36gV1qKvcYik+4IPUy2ZhMa21sj/ExtIoC/Epyhemf9dD?=
 =?us-ascii?q?LqyEEBX+HNEdB8irMOYqgUSmbgoYPOBO8645J8Ond+ac1KG3JuphnTKmgn5B4I?=
 =?us-ascii?q?ByyU+M8yt8SujV35cK2f2Y3w2HVyvig1elqMz4hYdEZTQKFGql1SfkHJJRZrF1?=
 =?us-ascii?q?fYsTE2euItG4yc9kh5HwXH5U7lijCE0c2M+oYBadc0by3QlN2ksJu3ynni24wi?=
 =?us-ascii?q?dwkzEoqKqfwSPPz/7jdBoBJm5EWm1igU3wLoizitAQRFKoYBQxlBu5+Ub6wLBW?=
 =?us-ascii?q?paR+L2XJQUZEZTP2L3xkUqarsrqCYshP6I4nsClNUeS8Z0yaRaD5oxcAzyzjGG?=
 =?us-ascii?q?5ezighdz62opX5gwB6iGWFIXZxtnXZY8JwxRTY5NDGXv5exDkGRCp5iTnRGFe8?=
 =?us-ascii?q?OcKk/dGVl5fFr+C/WHitVpxVcSn304yAsDG36nFtAR26h/qzgMHoERAm0S/n0N?=
 =?us-ascii?q?lnTSXJowz7YoXx1aS6MORnc1JsBF/97cp6B45/npExhJEWxXgVmJGV8WAbnmf0?=
 =?us-ascii?q?NNVRwbj+Y2YVRT4X397V5xDo2E55IXKI3Y75VmidzdFnZ9m1eW4W3iM978ZXCK?=
 =?us-ascii?q?ab9rBEnC11okamogLVe/RygjAdyf424n4An+4JoBYtzjmaAr0KGElYPC/smA6S?=
 =?us-ascii?q?49GwsqpXf3qvfqaq1EVlg9+hFr6CrxpYWHb4fJciACBx4t9+MFLKzH389IXkdM?=
 =?us-ascii?q?PMYtIUsx2eiw3AgPRNKJItivoKgjJqOX76vX0g0eI6jAZh3ZenvIicMGVt/bm0?=
 =?us-ascii?q?AhpZNj3zesMS9SvhjadYnsaKwY+vGo9tFSkMXJvtVfioCi4dtez7NwaSFz0xsm?=
 =?us-ascii?q?yUFqDYHQ+b9UdqtXbPE42wOnGTJXkZy8hiRRaHKExehgAUQCs1npojGg+2w8zh?=
 =?us-ascii?q?dV9z5ioN6V7gthtM1uVoOgH9UmjFoQendCw0RIKDLBZM7QFC+kTVMdGY7u1pBC?=
 =?us-ascii?q?FV5ZmhrA2LKmyGaAVEF2AJWkqYB1/9Ormi/8XP8++dBuCmNfvBfa2OqfBCV/eP?=
 =?us-ascii?q?3Z+u0oxm/yuVNsWSJHZiCec32lFEXXB/FMTUgDEPSy0RlyLQYM+Xvha8+itrrs?=
 =?us-ascii?q?+h9PTnQh7g5YyKC7FKK9Vg5wi2gbufN+6XnCt5KShX1pIPxX/LybgTxl0Siztp?=
 =?us-ascii?q?dzmiD7sArzPNTLnLl69TDh4bbT5zNcRS46I92AlNJdDUitfv2rFkif41Dk9PVU?=
 =?us-ascii?q?b9lcGxecwKP2a9OUvdC0aWL7uGPyPEwsHtbaO4SL1dl+FUtxy2uTaGHE7vJDWD?=
 =?us-ascii?q?lz/1Vx+xNeFAlj2UPBtbuIulaBZiFXDjTM76ah28KNJ3kTw2wbguinzWL2ITLT?=
 =?us-ascii?q?h8fF1LrrCL6SNYg/N/G3FO73Z/LOmEnTqZ4PfcKpoMrfRrBSF0nfpA4Hsm07tV?=
 =?us-ascii?q?8D1ERPttlSrStNFupVSmkuiJyjV/URtOqixEhISEvUh5PaXZ959AWWvL/R4X7G?=
 =?us-ascii?q?WQDQgKqMVhCtH1p69Qzd3Px+rPL2JF99/b1dERC8jdNISMN39leQDuAyLZABct?=
 =?us-ascii?q?QjmsOWTenApaiv7WvniUqJc9goLhlJoHVvlQU1lmOOkdDxFIGMIDOp4/fTMtm7?=
 =?us-ascii?q?+Bi9ABrS66rR/cXN9buIzKTNqbBenrKTCEnf9DfRRekuCwFpgaKoCugx8qUVJ9?=
 =?us-ascii?q?homfQ0c=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ANAABY9flbh0O0hNFiGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYJpgQInjBFfiyFYgUmJBoRqhA00hHeBcywDEAGEQIQaIjQ?=
 =?us-ascii?q?JDQEDAQEBAQEBAgETAQEBCA0JCCkjDII2IoJlAwMBAiQTPwYJAQErJQMMHSsHE?=
 =?us-ascii?q?gWDHAGBdA0EAaU7M4oajAkXeIEHg26BXRkBgnZyhS8CiRGGS49RVQmGfIMthns?=
 =?us-ascii?q?jCoFPTYdhMoZPLJlKgg1NMIMvCYIbAwwLiEOFWj8ygQIDAQEhE4lsgj4BAQ?=
X-IPAS-Result: =?us-ascii?q?A0ANAABY9flbh0O0hNFiGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYJpgQInjBFfiyFYgUmJBoRqhA00hHeBcywDEAGEQIQaIjQJDQEDAQEBAQEBA?=
 =?us-ascii?q?gETAQEBCA0JCCkjDII2IoJlAwMBAiQTPwYJAQErJQMMHSsHEgWDHAGBdA0EAaU?=
 =?us-ascii?q?7M4oajAkXeIEHg26BXRkBgnZyhS8CiRGGS49RVQmGfIMthnsjCoFPTYdhMoZPL?=
 =?us-ascii?q?JlKgg1NMIMvCYIbAwwLiEOFWj8ygQIDAQEhE4lsgj4BAQ?=
X-IronPort-AV: E=Sophos;i="5.56,276,1539673200"; 
   d="scan'208";a="42109414"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 24 Nov 2018 17:09:07 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726988AbeKYL6u (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 25 Nov 2018 06:58:50 -0500
Received: from air.basealt.ru ([194.107.17.39]:58928 "EHLO air.basealt.ru"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726400AbeKYL6u (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 25 Nov 2018 06:58:50 -0500
Received: by air.basealt.ru (Postfix, from userid 490)
        id 9A0F4589AE8; Sun, 25 Nov 2018 01:09:01 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.4.1 (2015-04-28) on
        sa.local.altlinux.org
X-Spam-Level: 
X-Spam-Status: No, score=-2.9 required=5.0 tests=ALL_TRUSTED,BAYES_00
        autolearn=ham autolearn_force=no version=3.4.1
Received: from akathisia (broadband-46-188-15-144.2com.net [46.188.15.144])
        by air.basealt.ru (Postfix) with ESMTPSA id 139F4589AE8;
        Sun, 25 Nov 2018 01:08:59 +0000 (UTC)
Date: Sun, 25 Nov 2018 02:08:58 +0100
From: Elvira Khabirova <lineprinter@altlinux.org>
To: oleg@redhat.com, rostedt@goodmis.org, mingo@redhat.com
Cc: linux-kernel@vger.kernel.org, ldv@altlinux.org, esyr@redhat.com,
        luto@kernel.org, strace-devel@lists.strace.io
Subject: [PATCH v3 2/3] ptrace: add PTRACE_GET_SYSCALL_INFO request
Message-ID: <20181125020858.039d9c45@akathisia>
In-Reply-To: <20181125020659.785c7b29@akathisia>
References: <20181125020659.785c7b29@akathisia>
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

PTRACE_GET_SYSCALL_INFO lets ptracer obtain details of the syscall
the tracee is blocked in.  The request succeeds when the tracee is in a
syscall-enter-stop or syscall-exit-stop, and fails with -EINVAL otherwise.
A subsequent change may extend PTRACE_GET_SYSCALL_INFO for the case
of PTRACE_EVENT_SECCOMP stop.

There are two reasons for a special syscall-related ptrace request.

Firstly, with the current ptrace API there are cases when ptracer cannot
retrieve necessary information about syscalls.  Some examples include:
* The notorious int-0x80-from-64-bit-task issue.  See [1] for details.
In short, if a 64-bit task performs a syscall through int 0x80, its tracer
has no reliable means to find out that the syscall was, in fact,
a compat syscall, and misidentifies it.
* Syscall-enter-stop and syscall-exit-stop look the same for the tracer.
Common practice is to keep track of the sequence of ptrace-stops in order
not to mix the two syscall-stops up.  But it is not as simple as it looks;
for example, strace had a (just recently fixed) long-standing bug where
attaching strace to a tracee that is performing the execve system call
led to the tracer identifying the following syscall-exit-stop as
syscall-enter-stop, which messed up all the state tracking.
* Since the introduction of commit 84d77d3f06e7e8dea057d10e8ec77ad71f721be3
("ptrace: Don't allow accessing an undumpable mm"), both PTRACE_PEEKDATA
and process_vm_readv become unavailable when the process dumpable flag
is cleared.  On such architectures as ia64 this results in all syscall
arguments being unavailable.

Secondly, ptracers also have to support a lot of arch-specific code for
obtaining information about the tracee.  For some architectures, this
requires a ptrace(PTRACE_PEEKUSER, ...) invocation for every syscall
argument and return value.

ptrace(2) man page:

long ptrace(enum __ptrace_request request, pid_t pid,
            void *addr, void *data);
...
PTRACE_GET_SYSCALL_INFO
       Retrieve information about the syscall that caused the stop.
       The information is placed into the buffer pointed by "data"
       argument, which should be a pointer to a buffer of type
       "struct ptrace_syscall_info".
       The "addr" argument contains the size of the buffer pointed to
       by "data" (i.e., sizeof(struct ptrace_syscall_info)).
       The return value contains the number of bytes available
       to be written by the kernel.
       If the size of data to be written by the kernel exceeds the size
       specified by "addr" argument, the output is truncated.
       This operation fails with EINVAL if the tracee is not
       in a syscall-enter-stop, a syscall-exit-stop, or
       a PTRACE_EVENT_SECCOMP stop.

Signed-off-by: Elvira Khabirova <lineprinter@altlinux.org>
Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
---
 include/uapi/linux/ptrace.h | 24 ++++++++++++++++++
 kernel/ptrace.c             | 50 +++++++++++++++++++++++++++++++++++++
 2 files changed, 74 insertions(+)

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index cb138902d042..49b0b1b41943 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -73,6 +73,30 @@ struct seccomp_metadata {
 	__u64 flags;		/* Output: filter's flags */
 };
 
+#define PTRACE_GET_SYSCALL_INFO		0x420f
+#define PTRACE_SYSCALL_INFO_ENTRY	0
+#define PTRACE_SYSCALL_INFO_EXIT	1
+
+struct ptrace_syscall_info {
+	__u8 op;	/* PTRACE_SYSCALL_INFO_* */
+	__u8 __pad0[3];
+	__u32 arch;
+	union {
+		struct {
+			__u64 nr;
+			__u64 instruction_pointer;
+			__u64 stack_pointer;
+			__u64 frame_pointer;
+			__u64 args[6];
+		} entry;
+		struct {
+			__s64 rval;
+			__u8 is_error;
+			__u8 __pad1[7];
+		} exit;
+	};
+};
+
 /* Read signals from a shared (process wide) queue */
 #define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)
 
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 80b34dffdfb9..92c47cd5ad84 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -30,6 +30,10 @@
 #include <linux/cn_proc.h>
 #include <linux/compat.h>
 
+#ifdef CONFIG_HAVE_ARCH_TRACEHOOK
+#include <asm/syscall.h>	/* For syscall_get_* */
+#endif
+
 /*
  * Access another process' address space via ptrace.
  * Source/target buffer must be kernel space,
@@ -890,6 +894,46 @@ static int ptrace_regset(struct task_struct *task, int req, unsigned int type,
 EXPORT_SYMBOL_GPL(task_user_regset_view);
 #endif
 
+#ifdef CONFIG_HAVE_ARCH_TRACEHOOK
+static int ptrace_get_syscall(struct task_struct *child,
+			      unsigned long user_size, void __user *datavp)
+{
+	struct ptrace_syscall_info info;
+	struct pt_regs *regs = task_pt_regs(child);
+	unsigned long args[ARRAY_SIZE(info.entry.args)];
+	unsigned long actual_size;
+	unsigned long write_size;
+
+	if (child->ptrace_message == PTRACE_EVENTMSG_SYSCALL_ENTRY) {
+		int i;
+
+		info.op = PTRACE_SYSCALL_INFO_ENTRY;
+		info.arch = syscall_get_arch(child);
+		info.entry.nr = syscall_get_nr(child, regs);
+		info.entry.instruction_pointer = instruction_pointer(regs);
+		info.entry.stack_pointer = user_stack_pointer(regs);
+		info.entry.frame_pointer = frame_pointer(regs);
+		syscall_get_arguments(child, regs, 0, ARRAY_SIZE(args), args);
+		for (i = 0; i < ARRAY_SIZE(args); i++)
+			info.entry.args[i] = args[i];
+		actual_size = offsetofend(struct ptrace_syscall_info, entry);
+	} else if (child->ptrace_message == PTRACE_EVENTMSG_SYSCALL_EXIT) {
+		info.op = PTRACE_SYSCALL_INFO_EXIT;
+		info.arch = syscall_get_arch(child);
+		info.exit.rval = syscall_get_error(child, regs);
+		info.exit.is_error = !!info.exit.rval;
+		if (!info.exit.is_error)
+			info.exit.rval = syscall_get_return_value(child, regs);
+		actual_size = offsetofend(struct ptrace_syscall_info, exit);
+	} else {
+		return -EINVAL;
+	}
+
+	write_size = min(actual_size, user_size);
+	return copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;
+}
+#endif
+
 int ptrace_request(struct task_struct *child, long request,
 		   unsigned long addr, unsigned long data)
 {
@@ -1105,6 +1149,12 @@ int ptrace_request(struct task_struct *child, long request,
 		ret = seccomp_get_metadata(child, addr, datavp);
 		break;
 
+#ifdef CONFIG_HAVE_ARCH_TRACEHOOK
+	case PTRACE_GET_SYSCALL_INFO:
+		ret = ptrace_get_syscall(child, addr, datavp);
+		break;
+#endif
+
 	default:
 		break;
 	}
-- 
2.19.1

