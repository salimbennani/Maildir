Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 07 Dec 2018 16:18:06 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga001.jf.intel.com (orsmga001.jf.intel.com [10.7.209.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 84A1458042F;
	Thu,  6 Dec 2018 21:43:08 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga001-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 06 Dec 2018 21:43:07 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AK1BPThy9noUVvFXXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0e4TKvad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWpPUNhMWSJPAY2y?=
 =?us-ascii?q?aIkAD+QaPeZArYTwvEcCoQekCAWwHu7j1iNEi3nr1qM6yeQhFgTG0RQiEdITqn?=
 =?us-ascii?q?vUqtr1P7oQXuC0yqnIwijIYvRW2Df87ojIfQotofGRXb1qd8rRxlIiFwLDjlWM?=
 =?us-ascii?q?t4PlOymZ2fgKs2ie9udtU/+khW0/qwxpvDSj2sMhhpPUio8b1FzI7zh1zYUpKd?=
 =?us-ascii?q?GiSUN2Y8aoHIZUui2ELYd7QsMvT3totSok0LELup22cS4Xw5o93RHfceaIc42Q?=
 =?us-ascii?q?7xLjSumRJTB4iWp7eLKwmRmy61Ksyu7iWcmu1lZFsC5FnsPLtnAX2Bzf8smHSv?=
 =?us-ascii?q?1j8Ue9wTuDyRzf5+VeLUwpm6fXNYQtzqMzm5YPq0jOHy37lF3zjKCMd0Uk/uao?=
 =?us-ascii?q?6/7gYrXjvpKcM450igfjMqUhg8C/Avo3MhIIX2eF/eSwzbrj/EP/QLpUlP07ib?=
 =?us-ascii?q?fZsJ/EKsQBvKK5ABFa0pwl6xmhCzeqytMYnWMILF5dYhKIk5DpO03SIPD/Ffq/?=
 =?us-ascii?q?h1WskDR1yPzcMbzhH47ALnzCkLfnYLZ85FRQyAs1zdBD+Z1UDqsNL+70Wk/0rN?=
 =?us-ascii?q?bYFAM2MxSow+b7D9VwzoMeVniOAq+FKqzStkWE5uIyI+aWYo8Vty3wK/wk5/7o?=
 =?us-ascii?q?kH84lkURfaiv3ZsLdn+4Gu5qLFmeYXrpmt0BC3sFvhIiTOz2j12PSTxTZ3GsUK?=
 =?us-ascii?q?4m5TE7D4SmDYHERo22hLyB3SG7HoBZZ2xcC1CMF2voeJuAW/sWdC2SJcphmCQe?=
 =?us-ascii?q?Vbe9U48hyQ2utAjixrV9NerU+ioYtZH52Nhv/eLTlwo/9Th1D8SbzmGMQHt4nm?=
 =?us-ascii?q?IORz8qwq9/pVZxxUuE0ah9m/ZYD8Bc5+tVUgcmMp7R1+96BMr0Wg7beteJSUyp?=
 =?us-ascii?q?QtOpATwqStIxwtkOY1tyGtm4jxDD2TaqDKERl7CRGJM09afc1WDrJ8lh03bGyL?=
 =?us-ascii?q?Uhj14+T8RSL2KmmLBw+xLTB4HTlUWZjLildaIb0C7J92eDyG6OsVpcUA5xV6XF?=
 =?us-ascii?q?QH8ealHXrdT/+kPNUbuuBa47PQtGzM6IMrFKZcHxjVVaWPfjP8zTbH+rlGeuGx?=
 =?us-ascii?q?mE3LOMY5Dse2UGwirdDlMJkwQS/XaAKAg/CT2to2PYDDxyC13vZ1ng/vV5qHO+?=
 =?us-ascii?q?VkU01R2Fb1V917qp/R4YneCcS/IW3rIDpCchqzV1EEyh397MDNqAvQ5hfKRaYd?=
 =?us-ascii?q?My+1pH0WPZtwpgPp2vNaxih1gecxhpsEPqzRl4FoJAkc0ypnMw0AVyMb6Y0E9G?=
 =?us-ascii?q?dz6Ax5/wPqPYK2bs8xGvcaLZwUze38uM9acJ6/Q4rEvjsRqtFkoj9XVnztZU32?=
 =?us-ascii?q?Gd5pXMEAodT5bxXlwr+Bh9orHQejM96J/M1X1wLam0tSfP2tI0BOc/1hmsZdZe?=
 =?us-ascii?q?MKOeGw/0HM0XHMyuKO0sm1i0YRMIJuFS9KgoP8y4c/uKwrKkPOFlnDi+l2RI/J?=
 =?us-ascii?q?h90l6Q9yp7UuPIxZcFzO2C0QudSjj8i02tssbploBeZDEeB3awxjLgBIFMeKJy?=
 =?us-ascii?q?Z4ELCWG1Ls2zx9V+gYPtWnFC+F6iAVMGxNGmeR6IY1Ph2g1Q0FwdoWa7liug0z?=
 =?us-ascii?q?x0jzYpo7Kf3SzP2ejjdAALOnVWRGlkllrsJYm0j9YHXEmndQQplR2l5VrkyKhf?=
 =?us-ascii?q?vqhwM27TQUJQdSjsM25iSrewtqaFY8NX6pMnqz9XUOe/YVCdULL9uAEV0yDgH2?=
 =?us-ascii?q?tfwjA0aTeqt479nxx7jmKdMXlyoGDYecF22RfQ+tjcSeRN0ToBQSlykSPXCUSk?=
 =?us-ascii?q?P9m14dWUkI/Os+CkWGKmTJFTcyjrzYWbuSu/5G1qBwC/nv+plt3mFwg6zTH019?=
 =?us-ascii?q?1wWSrUqxb8Z5Hh176mPuJ/YkloGFj85tJ5Go5kk4s8npEQ2WUAiZWT8noKimPz?=
 =?us-ascii?q?MdRd2aLjY3sBXz8Lw9jJ4Af73E1vNG6Gx4X8Vn+F2Mtue8G6Yn8K2iI6981KDa?=
 =?us-ascii?q?aU7L9ekidvrFu3sxnRYeRjkTcH0vQh9mQag+4StQopzyWdBK0SHEZCMSztkRSI?=
 =?us-ascii?q?886xrKFNaGmzdriw0VJ0ncq9A7GavgFcRHH5d48+HS9368VzKlPN32f16oH5Y9?=
 =?us-ascii?q?nQdtMTuwaQkxfBiehVNZ0wmuALhSphJWLyo3klx/Qnghxp2JGwpJKHJHl1/KKl?=
 =?us-ascii?q?Hh5YMSX4aNgJ9THqiaZeg9ya34SyHph6HjULXZ3oTe+nET4ItPTnMRqOHyM4qn?=
 =?us-ascii?q?uBBbXfGgqf4l98r33TC5CrK22XJH4BwNVgXhadIVJQgBsOUDUmhJI5FR2qxM/8?=
 =?us-ascii?q?cEd//D8R/UX1qh9NyuJuKhn+XX3TpAauajcoVpefKABa4R1F50fQKcae9P58Hz?=
 =?us-ascii?q?lE/p29qwyAMmyaZwNVDWEQR0yLHVbjMqO15dnH9eiYCfGzL//PYbWItOxfWO2E?=
 =?us-ascii?q?xZOp0ot64TmMMt+DMWVlD/0+wkBDR2x2G9zFmzUTTCwajyLNYNCapBe/+S13r9?=
 =?us-ascii?q?qz8PfxWALo6ouAFaFSMch0+x2thaeDNuiQhDt2KDpC15MMw2PIx6Yb3FIIly5u?=
 =?us-ascii?q?cDytG6watSHRVKLQhrNXDxkDZixpKctH9Lg80RdNOMLBjtP116V1jvo0C1dDSF?=
 =?us-ascii?q?zgldulZc0MI2GhKlzHAFyHO6iBJT3O28v3e7+zSaVMjOVIsB29oSqbE07mPjiZ?=
 =?us-ascii?q?izblTQygMeFSgyGdJxFevIC9chBwCWnsVt7maxu7MMNpgj0y27E7mnTKNWsEOz?=
 =?us-ascii?q?hmb0xNtqGQ7T9fgvhnG21O9HxlLeyFmyaf9+bZK5YWvuFtAiR7jO9a5HU6y71I?=
 =?us-ascii?q?7CBLXvB1mS3SrsJwrFGiiOWA1j1nUB8d4gpM0auNsV9vJu388YNcXnCMqBsO9W?=
 =?us-ascii?q?C4DxUMussgBNryvaxZ1tnIkuT0MjgUoPzO+s5JJ9XdLs3PAXsnPlK9CT/SA00F?=
 =?us-ascii?q?UDetOknegVBQlLeZ8XjD/ctykYTlhJdbEuwTb1cyDP5PTx09RNE=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ADAADoBwpch0O0hNFbCBsBAQEBAwEBA?=
 =?us-ascii?q?QcDAQEBgVEGAQEBCwGDayeME44xlzuBJANPERgTAYdXIjQJDQEDAQEBAQEBAgE?=
 =?us-ascii?q?TAQEBCA0JCCkvgjYkAYJiAwMBAiRSBgkBARg4A1QGEwWDHIICBaZ2M4owh3CEL?=
 =?us-ascii?q?4IWgRGCZIUKhgACiQ0fgXmFD1GPXQcCkT8LGF99iDyHHQGZGoFGbIEhMxojgzy?=
 =?us-ascii?q?CJxeOKjIBATEBgQQBAYo/AQE?=
X-IPAS-Result: =?us-ascii?q?A0ADAADoBwpch0O0hNFbCBsBAQEBAwEBAQcDAQEBgVEGAQE?=
 =?us-ascii?q?BCwGDayeME44xlzuBJANPERgTAYdXIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkvg?=
 =?us-ascii?q?jYkAYJiAwMBAiRSBgkBARg4A1QGEwWDHIICBaZ2M4owh3CEL4IWgRGCZIUKhgA?=
 =?us-ascii?q?CiQ0fgXmFD1GPXQcCkT8LGF99iDyHHQGZGoFGbIEhMxojgzyCJxeOKjIBATEBg?=
 =?us-ascii?q?QQBAYo/AQE?=
X-IronPort-AV: E=Sophos;i="5.56,324,1539673200"; 
   d="scan'208";a="54932929"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 06 Dec 2018 21:43:06 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726154AbeLGFlx (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 7 Dec 2018 00:41:53 -0500
Received: from mga01.intel.com ([192.55.52.88]:55177 "EHLO mga01.intel.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726140AbeLGFlu (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 7 Dec 2018 00:41:50 -0500
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from fmsmga007.fm.intel.com ([10.253.24.52])
  by fmsmga101.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 06 Dec 2018 21:41:50 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="5.56,324,1539673200"; 
   d="scan'208";a="105567249"
Received: from yhuang-mobile.sh.intel.com ([10.239.196.133])
  by fmsmga007.fm.intel.com with ESMTP; 06 Dec 2018 21:41:47 -0800
From: Huang Ying <ying.huang@intel.com>
To: Andrew Morton <akpm@linux-foundation.org>
Cc: linux-mm@kvack.org, linux-kernel@vger.kernel.org,
        Huang Ying <ying.huang@intel.com>,
        "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>,
        Andrea Arcangeli <aarcange@redhat.com>,
        Michal Hocko <mhocko@kernel.org>,
        Johannes Weiner <hannes@cmpxchg.org>,
        Shaohua Li <shli@kernel.org>, Hugh Dickins <hughd@google.com>,
        Minchan Kim <minchan@kernel.org>,
        Rik van Riel <riel@redhat.com>,
        Dave Hansen <dave.hansen@linux.intel.com>,
        Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>,
        Zi Yan <zi.yan@cs.rutgers.edu>,
        Daniel Jordan <daniel.m.jordan@oracle.com>
Subject: [PATCH -V8 08/21] swap: Support to read a huge swap cluster for swapin a THP
Date: Fri,  7 Dec 2018 13:41:08 +0800
Message-Id: <20181207054122.27822-9-ying.huang@intel.com>
X-Mailer: git-send-email 2.18.1
In-Reply-To: <20181207054122.27822-1-ying.huang@intel.com>
References: <20181207054122.27822-1-ying.huang@intel.com>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

To swapin a THP in one piece, we need to read a huge swap cluster from
the swap device.  This patch revised the __read_swap_cache_async() and
its callers and callees to support this.  If __read_swap_cache_async()
find the swap cluster of the specified swap entry is huge, it will try
to allocate a THP, add it into the swap cache.  So later the contents
of the huge swap cluster can be read into the THP.

Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
Cc: Andrea Arcangeli <aarcange@redhat.com>
Cc: Michal Hocko <mhocko@kernel.org>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Cc: Shaohua Li <shli@kernel.org>
Cc: Hugh Dickins <hughd@google.com>
Cc: Minchan Kim <minchan@kernel.org>
Cc: Rik van Riel <riel@redhat.com>
Cc: Dave Hansen <dave.hansen@linux.intel.com>
Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
Cc: Zi Yan <zi.yan@cs.rutgers.edu>
Cc: Daniel Jordan <daniel.m.jordan@oracle.com>
---
 include/linux/huge_mm.h |  8 ++++++
 include/linux/swap.h    |  4 +--
 mm/huge_memory.c        |  5 ++--
 mm/swap_state.c         | 61 +++++++++++++++++++++++++++++++++--------
 mm/swapfile.c           |  9 ++++--
 5 files changed, 68 insertions(+), 19 deletions(-)

diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h
index 1c0fda003d6a..f4dbd0662438 100644
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@ -250,6 +250,8 @@ static inline bool thp_migration_supported(void)
 	return IS_ENABLED(CONFIG_ARCH_ENABLE_THP_MIGRATION);
 }
 
+gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma,
+				    unsigned long addr);
 #else /* CONFIG_TRANSPARENT_HUGEPAGE */
 #define HPAGE_PMD_SHIFT ({ BUILD_BUG(); 0; })
 #define HPAGE_PMD_MASK ({ BUILD_BUG(); 0; })
@@ -363,6 +365,12 @@ static inline bool thp_migration_supported(void)
 {
 	return false;
 }
+
+static inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma,
+						  unsigned long addr)
+{
+	return 0;
+}
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE */
 
 #endif /* _LINUX_HUGE_MM_H */
diff --git a/include/linux/swap.h b/include/linux/swap.h
index 441da4a832a6..4bd532c9315e 100644
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -462,7 +462,7 @@ extern sector_t map_swap_page(struct page *, struct block_device **);
 extern sector_t swapdev_block(int, pgoff_t);
 extern int page_swapcount(struct page *);
 extern int __swap_count(swp_entry_t entry);
-extern int __swp_swapcount(swp_entry_t entry);
+extern int __swp_swapcount(swp_entry_t entry, int *entry_size);
 extern int swp_swapcount(swp_entry_t entry);
 extern struct swap_info_struct *page_swap_info(struct page *);
 extern struct swap_info_struct *swp_swap_info(swp_entry_t entry);
@@ -590,7 +590,7 @@ static inline int __swap_count(swp_entry_t entry)
 	return 0;
 }
 
-static inline int __swp_swapcount(swp_entry_t entry)
+static inline int __swp_swapcount(swp_entry_t entry, int *entry_size)
 {
 	return 0;
 }
diff --git a/mm/huge_memory.c b/mm/huge_memory.c
index d23e18c0c07e..2004d8ae4390 100644
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -630,9 +630,10 @@ static vm_fault_t __do_huge_pmd_anonymous_page(struct vm_fault *vmf,
  *	    available
  * never: never stall for any thp allocation
  */
-static inline gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma, unsigned long addr)
+gfp_t alloc_hugepage_direct_gfpmask(struct vm_area_struct *vma,
+				    unsigned long addr)
 {
-	const bool vma_madvised = !!(vma->vm_flags & VM_HUGEPAGE);
+	const bool vma_madvised = vma ? !!(vma->vm_flags & VM_HUGEPAGE) : false;
 	gfp_t this_node = 0;
 
 #ifdef CONFIG_NUMA
diff --git a/mm/swap_state.c b/mm/swap_state.c
index 97831166994a..1eedbc0aede2 100644
--- a/mm/swap_state.c
+++ b/mm/swap_state.c
@@ -361,7 +361,9 @@ struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 {
 	struct page *found_page = NULL, *new_page = NULL;
 	struct swap_info_struct *si;
-	int err;
+	int err, entry_size = 1;
+	swp_entry_t hentry;
+
 	*new_page_allocated = false;
 
 	do {
@@ -387,14 +389,42 @@ struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 		 * as SWAP_HAS_CACHE.  That's done in later part of code or
 		 * else swap_off will be aborted if we return NULL.
 		 */
-		if (!__swp_swapcount(entry) && swap_slot_cache_enabled)
+		if (!__swp_swapcount(entry, &entry_size) &&
+		    swap_slot_cache_enabled)
 			break;
 
 		/*
 		 * Get a new page to read into from swap.
 		 */
-		if (!new_page) {
-			new_page = alloc_page_vma(gfp_mask, vma, addr);
+		if (!new_page ||
+		    (IS_ENABLED(CONFIG_THP_SWAP) &&
+		     hpage_nr_pages(new_page) != entry_size)) {
+			if (new_page)
+				put_page(new_page);
+			if (IS_ENABLED(CONFIG_THP_SWAP) &&
+			    entry_size == HPAGE_PMD_NR) {
+				gfp_t gfp;
+
+				gfp = alloc_hugepage_direct_gfpmask(vma, addr);
+				/*
+				 * Make sure huge page allocation flags are
+				 * compatible with that of normal page
+				 */
+				VM_WARN_ONCE(gfp_mask & ~(gfp | __GFP_RECLAIM),
+					     "ignoring gfp_mask bits: %x",
+					     gfp_mask & ~(gfp | __GFP_RECLAIM));
+				new_page = alloc_pages_vma(gfp, HPAGE_PMD_ORDER,
+							   vma, addr,
+							   numa_node_id());
+				if (new_page)
+					prep_transhuge_page(new_page);
+				hentry = swp_entry(swp_type(entry),
+						   round_down(swp_offset(entry),
+							      HPAGE_PMD_NR));
+			} else {
+				new_page = alloc_page_vma(gfp_mask, vma, addr);
+				hentry = entry;
+			}
 			if (!new_page)
 				break;		/* Out of memory */
 		}
@@ -402,7 +432,7 @@ struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 		/*
 		 * Swap entry may have been freed since our caller observed it.
 		 */
-		err = swapcache_prepare(entry, 1);
+		err = swapcache_prepare(hentry, entry_size);
 		if (err == -EEXIST) {
 			/*
 			 * We might race against get_swap_page() and stumble
@@ -411,18 +441,24 @@ struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 			 */
 			cond_resched();
 			continue;
+		} else if (err == -ENOTDIR) {
+			/* huge swap cluster has been split under us */
+			continue;
 		} else if (err)		/* swp entry is obsolete ? */
 			break;
 
 		/* May fail (-ENOMEM) if XArray node allocation failed. */
 		__SetPageLocked(new_page);
 		__SetPageSwapBacked(new_page);
-		err = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);
+		err = add_to_swap_cache(new_page, hentry, gfp_mask & GFP_KERNEL);
 		if (likely(!err)) {
 			/* Initiate read into locked page */
 			SetPageWorkingset(new_page);
 			lru_cache_add_anon(new_page);
 			*new_page_allocated = true;
+			if (IS_ENABLED(CONFIG_THP_SWAP))
+				new_page += swp_offset(entry) &
+					(entry_size - 1);
 			return new_page;
 		}
 		__ClearPageLocked(new_page);
@@ -430,7 +466,7 @@ struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 		 * add_to_swap_cache() doesn't return -EEXIST, so we can safely
 		 * clear SWAP_HAS_CACHE flag.
 		 */
-		put_swap_page(new_page, entry);
+		put_swap_page(new_page, hentry);
 	} while (err != -ENOMEM);
 
 	if (new_page)
@@ -452,7 +488,7 @@ struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,
 			vma, addr, &page_was_allocated);
 
 	if (page_was_allocated)
-		swap_readpage(retpage, do_poll);
+		swap_readpage(compound_head(retpage), do_poll);
 
 	return retpage;
 }
@@ -571,8 +607,9 @@ struct page *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,
 		if (!page)
 			continue;
 		if (page_allocated) {
-			swap_readpage(page, false);
-			if (offset != entry_offset) {
+			swap_readpage(compound_head(page), false);
+			if (offset != entry_offset &&
+			    !PageTransCompound(page)) {
 				SetPageReadahead(page);
 				count_vm_event(SWAP_RA);
 			}
@@ -733,8 +770,8 @@ static struct page *swap_vma_readahead(swp_entry_t fentry, gfp_t gfp_mask,
 		if (!page)
 			continue;
 		if (page_allocated) {
-			swap_readpage(page, false);
-			if (i != ra_info.offset) {
+			swap_readpage(compound_head(page), false);
+			if (i != ra_info.offset && !PageTransCompound(page)) {
 				SetPageReadahead(page);
 				count_vm_event(SWAP_RA);
 			}
diff --git a/mm/swapfile.c b/mm/swapfile.c
index a57967292a8d..c22c11b4a879 100644
--- a/mm/swapfile.c
+++ b/mm/swapfile.c
@@ -1542,7 +1542,8 @@ int __swap_count(swp_entry_t entry)
 	return count;
 }
 
-static int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)
+static int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry,
+			  int *entry_size)
 {
 	int count = 0;
 	pgoff_t offset = swp_offset(entry);
@@ -1550,6 +1551,8 @@ static int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)
 
 	ci = lock_cluster_or_swap_info(si, offset);
 	count = swap_count(si->swap_map[offset]);
+	if (entry_size)
+		*entry_size = ci && cluster_is_huge(ci) ? SWAPFILE_CLUSTER : 1;
 	unlock_cluster_or_swap_info(si, ci);
 	return count;
 }
@@ -1559,14 +1562,14 @@ static int swap_swapcount(struct swap_info_struct *si, swp_entry_t entry)
  * This does not give an exact answer when swap count is continued,
  * but does include the high COUNT_CONTINUED flag to allow for that.
  */
-int __swp_swapcount(swp_entry_t entry)
+int __swp_swapcount(swp_entry_t entry, int *entry_size)
 {
 	int count = 0;
 	struct swap_info_struct *si;
 
 	si = get_swap_device(entry);
 	if (si) {
-		count = swap_swapcount(si, entry);
+		count = swap_swapcount(si, entry, entry_size);
 		put_swap_device(si);
 	}
 	return count;
-- 
2.18.1

