Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 26 Nov 2018 08:52:53 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 7EBCF5802E4;
	Sun, 25 Nov 2018 16:16:40 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by fmsmga006-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 16:16:40 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AqtOA7hGSrQ7qe6OHvmsptJ1GYnF86YWxBRYc798d?=
 =?us-ascii?q?s5kLTJ75oc69bnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjm58axlVAHnhz?=
 =?us-ascii?q?sGNz4h8WHYlMpwjL5AoBm8oxBz2pPYbJ2JOPZ7eK7WYNEUSndbXstJVyJPHJ6y?=
 =?us-ascii?q?YYUMAeQGP+lYoYbyqEcVrRumBwShH//vxiNSi3Pqx6A2z/gtHAfb1wIgBdIOt3?=
 =?us-ascii?q?HUoc30OqcIUeG1w67IzS/Cb/NXxDzz9ZTIcgo7rvGXXbJwcs3RwlQoGgPKlFWR?=
 =?us-ascii?q?qYPlPzSP1uQMsmiX9fFgVf61i2E9sAFxojuvxsA3h4nVh4IZ0EzL9SJ8wIssI9?=
 =?us-ascii?q?CzVUB1YdmhEJRKtiGaMZN7Qt8jQ21ypCk6zbgGtJimdyYJ0JQq3wDTZ+CDfoSS?=
 =?us-ascii?q?/x7uWvidLS1liH9mZL6znRe//Eq4xuHhSMW500xGojRKn9TOrHwA1xje5tKaRv?=
 =?us-ascii?q?Zy/Eqs3yuE2RrJ5eFeO080kLLWK54/zb40kZoeqVrDHiDol0XslqOWdVsr+vKu?=
 =?us-ascii?q?6+v5ZrXqvJicN5V7ig3mM6QunNKwAfggPwQQQ2SW/f6w2KDt8EHnWrlGk/47nr?=
 =?us-ascii?q?XDvJ3bJ8kXvqu5DBVU0oYn5Ra/FTCm0NEAkHkDLVJFfg+HjofwN1HNPv/4F/G/?=
 =?us-ascii?q?jEqokDtywPDHMLvhDYvXLnXYjrfhcqhy61RGxAow099f/ZRUBa8FIP7pXU/xrt?=
 =?us-ascii?q?PYAgcjMwOo2+bnFMl91oQGVGKLA6+ZM73dvUWH5+IyOOSMYI4VuDDgK/kq/fLu?=
 =?us-ascii?q?jHk5mUMDcqmtx5cYdHe4HvF+KUWDfXXsmssBEXsNvgcmTOzlklyCUSJJaHa1Ra?=
 =?us-ascii?q?485iw7B5igDYfMXY2thL2B3CGmHpxZfGxGC1aMEWv2eIWAQfsDdCWSIsp5mDwe?=
 =?us-ascii?q?SbehU5Mh1Q2ptALiybpnKfTb9jcbtZLk0th14erTmAo29Tx1CcSdzm6MQ3t1nm?=
 =?us-ascii?q?MOWz85wqR/rVZhxVeE1Khym+ZYGsBL5/NVTgc6MobRwPZhC9DyXQLBfc2FSEy8?=
 =?us-ascii?q?TdWkGjwxStMxw9kTY0dyAdmijxbD3za0DL8RjbCEGJs08qfE1XjrO8l902rG1L?=
 =?us-ascii?q?Umj1Q+QctAL2umirR79wjSHYHJlUqZmr2udaQd2i7N6WiCwXCPvEFeTA5/T6HF?=
 =?us-ascii?q?UWoDaUvRqNTz/lnCQKO2CbQ7LgtBztaPJbZQZd33k1pKXvfjN87YY2KqhWiwAx?=
 =?us-ascii?q?GExrePbIrvf2UQxyHdCEkCkwAO8neKLwk+BiG9o23ACDxiD07gY0Tp8eNmsnO0?=
 =?us-ascii?q?Ulc0zx2Wb01mz7e65wQaheKCRP8J3rILoiEhqy5qE1a7xN/WD9uApwx8fKRTe9?=
 =?us-ascii?q?894VFH1X7HuAx5JJCvM6dihlsGeQRto0zuzwl3CplHkcUysHMqzQ9yKaWE0FNB?=
 =?us-ascii?q?dzKUx4zwNqfQKmno+BCvaqjW2l7F3daS+6cP7uk4qlr5sAGoEEoi72to091P33?=
 =?us-ascii?q?SA4ZXKCRIYUYjtXUYv6xh6u7babzEn6IPQy3JtPre7sz/Y190yGesq1wyvf9Fc?=
 =?us-ascii?q?MKODCg//CMkaB8moKOw3lFmldBMEPOZO9KEqO8OqbeeJ2KmuPOx4hjKpkXxH4J?=
 =?us-ascii?q?xh0kKL7yd9SvPI04wZzP2C3wqHVy3zjFGuss3snYBEZDcSHnewyCT+BY5RYLFy?=
 =?us-ascii?q?cpgPCWu0P8K3wdB+jYb3W3FE7F6jG08G2MixdBqIblzywRdf1V4Krnyggye4yS?=
 =?us-ascii?q?J7kysorqaGwCPB2eDiewcZNW5RQ2lii0zhIYy1j9AcQUipYBIllBqj5Ubm2adb?=
 =?us-ascii?q?oL5zIHXUQUdNZyL2NX1tUrOstrqeZM5C8JMpsSRNXOW8e1yaUaP9ox0B3iPnHm?=
 =?us-ascii?q?tewi07dj6wtpX4mRx6lHySLHJpoHXFfsFwwA/V5MbASv5JwjoGWC54hCHVBlem?=
 =?us-ascii?q?Jdmp/taUl5DZvuClTW2hVZ5TcSjtzYyesiu2/mlqARy5n/CuldzrCwk60Snn19?=
 =?us-ascii?q?Z0USXEtgrzYo7u166iK+JoYlFoBEPg68p9Aox/kpE/hJYK1XgYh5WV+2EKkWPy?=
 =?us-ascii?q?MdVdxKL/Y2ABRT8Nw97J/gfl3FdvIW6Ox4L8Tn+d2NduZ8GmYmMK3SIw98NKB7?=
 =?us-ascii?q?2V7LBenSt1v0C3rQTeYfVmmjcdyP0u6GMVgu0TuQotyDmdDa4WHUVCISPskBGI?=
 =?us-ascii?q?5cikrKpLfGavbaSw1E1mkNCkDbGCoRtTVGz3e5g8Bi9w8ttwMEjX33Lt8IHkd8?=
 =?us-ascii?q?LdbdYSth2SjhfBgPJZKJM3lvoWmyVnPXjxsmEiy+4+lRZux421vJCbK2Vx+6K0?=
 =?us-ascii?q?GgJYNjrwZ88J+zDil6BentuN34C0H5VsATELXJruTfK1HzMer/XnNwCSEDIirn?=
 =?us-ascii?q?eXA6bQHQia6E1+tXLAD4irN22LJHke1dhtXwOSJEtbgAAJRjk6moM5GxuuxMzg?=
 =?us-ascii?q?dkd5+z8Q6kT5qhtK1uJnKR3/Xn3Dqwevbzc+UIKfIwZO7gFe+0fVNtST7uBpEC?=
 =?us-ascii?q?Fd4JKhtxaBKnCBawRLEGEJWVGEB1b5Mbm1/tTA9+mYBuyjL/rBe7mOqOpeV+uW?=
 =?us-ascii?q?ypKryIdp4zGMNsCXNHl4E/I7wlZDXWx+G8nBmzQPTDEXlzvQb8GBohew4DZ3rs?=
 =?us-ascii?q?e58PTkQw/v4YqPC71PMdRg4Ry2gKGDN/KOiyZ9MzpXypQMxXrQwrgFwFESkz1u?=
 =?us-ascii?q?dyWqEbkYtS7CUqPQmqxUDx4acS9zN9FI76Uz3gZTI87bl8j126V8jv40DVdFSF?=
 =?us-ascii?q?PgltuoZcwMP2GyKlfHCFyXO7SBID3B29v3br+kSb1MkOVUsAW9tiyGE0D4JDSM?=
 =?us-ascii?q?iTnoWwqrMeFNlyybOB1euIegchdiE2TjTdTmagGlP99zlzE53bo0hnbSP24GLT?=
 =?us-ascii?q?d8a19NrqGX7S5AnvV/GmlB4mB5IuWehymZ7/fXKpANvPtvAyR0kf9a4Xsgx7tU?=
 =?us-ascii?q?6iFEWOJ6mC/IotFypFGml/GFyiB7XxpWtjZLmIWLsF1iOKrD8JlAXHfE/BQV4m?=
 =?us-ascii?q?SRCxQFvd1lCtL0tqBUy9jPkr/zKThY/9LV+8scG9bbKMadPHU9NhrpHW2cMAxQ?=
 =?us-ascii?q?BxKiK2DTz3cb2NST8nmYtNJy/pTlhpcLYrNSSlEwEvQUFgJjEcBUZN9LWTU12Z?=
 =?us-ascii?q?qaisIH/3e45E3NQ8NLlpnbUfeTDfipIzGc2/0MRBoTwbT+ZboSNITqk2VocFB6?=
 =?us-ascii?q?lYGCOgKEXtFWoipnRhM15k5K9S46Blc00QrFZxm34XkcXaqumRQ2yQdiSecg7j?=
 =?us-ascii?q?Hh5xEwPFWc9wUql0xkts/0jjeLcT+5F7uqVJpWCC2840crI5z8WQd0Kxauh0V/?=
 =?us-ascii?q?NDTDb65QybBncDY420fnpZJTFKsEHuV/axgKyKTSPq1w3A=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAAC0Ovtbh0O0hNFhGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYJpgQInjBFfix+CIZcoFIFiDwEBGAMQAYhaIjQJDQEDAQE?=
 =?us-ascii?q?BAQEBAgETAQEBCA0JCCkjDII2JAGCYgMDAQIkGQEBNwEFCQEBUANUBgENBQWDH?=
 =?us-ascii?q?AGCAQWkLoFsM4J2AQEFhxIIh16DD4EcgVc/gRGHVYYWiRuBeIQId06PJAcCghw?=
 =?us-ascii?q?EjwQjkQiVAYMIAgICAgQFAhSBRoINTSODPAmCEoNtinFTgQIDAQEhE4wWAQE?=
X-IPAS-Result: =?us-ascii?q?A0AEAAC0Ovtbh0O0hNFhGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYJpgQInjBFfix+CIZcoFIFiDwEBGAMQAYhaIjQJDQEDAQEBAQEBAgETAQEBC?=
 =?us-ascii?q?A0JCCkjDII2JAGCYgMDAQIkGQEBNwEFCQEBUANUBgENBQWDHAGCAQWkLoFsM4J?=
 =?us-ascii?q?2AQEFhxIIh16DD4EcgVc/gRGHVYYWiRuBeIQId06PJAcCghwEjwQjkQiVAYMIA?=
 =?us-ascii?q?gICAgQFAhSBRoINTSODPAmCEoNtinFTgQIDAQEhE4wWAQE?=
X-IronPort-AV: E=Sophos;i="5.56,280,1539673200"; 
   d="scan'208";a="53251966"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 16:16:39 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726296AbeKZLIY (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Mon, 26 Nov 2018 06:08:24 -0500
Received: from fllv0015.ext.ti.com ([198.47.19.141]:55944 "EHLO
        fllv0015.ext.ti.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726079AbeKZLIX (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 26 Nov 2018 06:08:23 -0500
Received: from fllv0034.itg.ti.com ([10.64.40.246])
        by fllv0015.ext.ti.com (8.15.2/8.15.2) with ESMTP id wAQ0FXJd037340;
        Sun, 25 Nov 2018 18:15:33 -0600
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ti.com;
        s=ti-com-17Q1; t=1543191333;
        bh=l1b+yACLW9JqzrWqtqf61DuKoGa8C8wbmUAZA1SpVnU=;
        h=From:To:CC:Subject:Date:In-Reply-To:References;
        b=eMW51zndS6CSp7EzcG2QL3R8e98u3thORn9utaDO5ksVAgz4SLEx7Xngj+HT67Xur
         RfMOSs5xo8GP2kI+2a8aiGPWr5ckvGzT400Vnr6otj82VKPr02SHodDUzY/nkDume4
         N83Qr8A7ecBl38M2KnrniPMRY73mUIbWh7X3Qne0=
Received: from DLEE102.ent.ti.com (dlee102.ent.ti.com [157.170.170.32])
        by fllv0034.itg.ti.com (8.15.2/8.15.2) with ESMTPS id wAQ0FXqX039051
        (version=TLSv1.2 cipher=AES256-GCM-SHA384 bits=256 verify=FAIL);
        Sun, 25 Nov 2018 18:15:33 -0600
Received: from DLEE107.ent.ti.com (157.170.170.37) by DLEE102.ent.ti.com
 (157.170.170.32) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id 15.1.1591.10; Sun, 25
 Nov 2018 18:15:33 -0600
Received: from dlep33.itg.ti.com (157.170.170.75) by DLEE107.ent.ti.com
 (157.170.170.37) with Microsoft SMTP Server (version=TLS1_0,
 cipher=TLS_RSA_WITH_AES_256_CBC_SHA) id 15.1.1591.10 via Frontend Transport;
 Sun, 25 Nov 2018 18:15:33 -0600
Received: from legion.dal.desgin.ti.com (legion.dal.design.ti.com [128.247.22.53])
        by dlep33.itg.ti.com (8.14.3/8.13.8) with ESMTP id wAQ0FXZc013046;
        Sun, 25 Nov 2018 18:15:33 -0600
Received: from localhost (uda0226610.dhcp.ti.com [128.247.59.147])
        by legion.dal.desgin.ti.com (8.11.7p1+Sun/8.11.7) with ESMTP id wAQ0FXU04342;
        Sun, 25 Nov 2018 18:15:33 -0600 (CST)
From: Grygorii Strashko <grygorii.strashko@ti.com>
To: "David S. Miller" <davem@davemloft.net>,
        Tony Lindgren <tony@atomide.com>,
        Kishon Vijay Abraham I <kishon@ti.com>,
        Rob Herring <robh+dt@kernel.org>
CC: <netdev@vger.kernel.org>, Sekhar Nori <nsekhar@ti.com>,
        <linux-kernel@vger.kernel.org>,
        <linux-arm-kernel@lists.infradead.org>,
        Andrew Lunn <andrew@lunn.ch>, <devicetree@vger.kernel.org>,
        <linux-omap@vger.kernel.org>,
        Grygorii Strashko <grygorii.strashko@ti.com>
Subject: [PATCH linux-next 02/10] phy: ti: introduce phy-gmii-sel driver
Date: Sun, 25 Nov 2018 18:15:23 -0600
Message-ID: <20181126001531.12974-3-grygorii.strashko@ti.com>
X-Mailer: git-send-email 2.10.5
In-Reply-To: <20181126001531.12974-1-grygorii.strashko@ti.com>
References: <20181126001531.12974-1-grygorii.strashko@ti.com>
MIME-Version: 1.0
Content-Type: text/plain
X-EXCLAIMER-MD-CONFIG: e1e8a2fd-e40a-4ac6-ac9b-f7e9cc9ee180
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

TI am335x/am437x/dra7(am5)/dm814x CPSW3G Ethernet Subsystem supports two
10/100/1000 Ethernet ports with selectable G/MII, RMII, and RGMII
interfaces. The interface mode is selected by configuring the MII mode
selection register(s) (GMII_SEL) in the System Control Module chapter
(SCM). GMII_SEL register(s) and bit fields placement in SCM are different
between SoCs while fields meaning is the same.

Historically CPSW external Port's interface mode selection configuration
was introduced using custom API and driver cpsw-phy-sel.c. This leads to
unnecessary driver, DT binding and custom API support effort.

This patch introduces CPSW Port's PHY Interface Mode selection Driver
(phy-gmii-sel) which implements standard Linux PHY interface and used
as a replacement for TI's specific driver cpsw-phy-sel.c and corresponding
custom API.

Cc: Kishon Vijay Abraham I <kishon@ti.com>
Cc: Tony Lindgren <tony@atomide.com>
Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
---
 drivers/phy/ti/Kconfig        |  10 ++
 drivers/phy/ti/Makefile       |   1 +
 drivers/phy/ti/phy-gmii-sel.c | 349 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 360 insertions(+)
 create mode 100644 drivers/phy/ti/phy-gmii-sel.c

diff --git a/drivers/phy/ti/Kconfig b/drivers/phy/ti/Kconfig
index 2050356..f137e01 100644
--- a/drivers/phy/ti/Kconfig
+++ b/drivers/phy/ti/Kconfig
@@ -76,3 +76,13 @@ config TWL4030_USB
 	  family chips (including the TWL5030 and TPS659x0 devices).
 	  This transceiver supports high and full speed devices plus,
 	  in host mode, low speed.
+
+config PHY_TI_GMII_SEL
+	tristate
+	default y if TI_CPSW=y
+	depends on TI_CPSW || COMPILE_TEST
+	select GENERIC_PHY
+	default m
+	help
+	  This driver supports configuring of the TI CPSW Port mode depending on
+	  the Ethernet PHY connected to the CPSW Port.
diff --git a/drivers/phy/ti/Makefile b/drivers/phy/ti/Makefile
index 9f36175..bea8f25 100644
--- a/drivers/phy/ti/Makefile
+++ b/drivers/phy/ti/Makefile
@@ -6,3 +6,4 @@ obj-$(CONFIG_OMAP_USB2)			+= phy-omap-usb2.o
 obj-$(CONFIG_TI_PIPE3)			+= phy-ti-pipe3.o
 obj-$(CONFIG_PHY_TUSB1210)		+= phy-tusb1210.o
 obj-$(CONFIG_TWL4030_USB)		+= phy-twl4030-usb.o
+obj-$(CONFIG_PHY_TI_GMII_SEL)		+= phy-gmii-sel.o
diff --git a/drivers/phy/ti/phy-gmii-sel.c b/drivers/phy/ti/phy-gmii-sel.c
new file mode 100644
index 0000000..04ebf53
--- /dev/null
+++ b/drivers/phy/ti/phy-gmii-sel.c
@@ -0,0 +1,349 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Texas Instruments CPSW Port's PHY Interface Mode selection Driver
+ *
+ * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Based on cpsw-phy-sel.c driver created by Mugunthan V N <mugunthanvnm@ti.com>
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+
+/* AM33xx SoC specific definitions for the CONTROL port */
+#define AM33XX_GMII_SEL_MODE_MII	0
+#define AM33XX_GMII_SEL_MODE_RMII	1
+#define AM33XX_GMII_SEL_MODE_RGMII	2
+
+enum {
+	PHY_GMII_SEL_PORT_MODE,
+	PHY_GMII_SEL_RGMII_ID_MODE,
+	PHY_GMII_SEL_RMII_IO_CLK_EN,
+	PHY_GMII_SEL_LAST,
+};
+
+struct phy_gmii_sel_phy_priv {
+	struct phy_gmii_sel_priv *priv;
+	u32		id;
+	struct phy	*if_phy;
+	int		rmii_clock_external;
+	int		phy_if_mode;
+	struct regmap_field *fields[PHY_GMII_SEL_LAST];
+};
+
+struct phy_gmii_sel_soc_data {
+	u32 num_ports;
+	u32 features;
+	const struct reg_field (*regfields)[PHY_GMII_SEL_LAST];
+};
+
+struct phy_gmii_sel_priv {
+	struct device *dev;
+	const struct phy_gmii_sel_soc_data *soc_data;
+	struct regmap *regmap;
+	struct phy_provider *phy_provider;
+	struct phy_gmii_sel_phy_priv *if_phys;
+};
+
+static int phy_gmii_sel_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	struct phy_gmii_sel_phy_priv *if_phy = phy_get_drvdata(phy);
+	const struct phy_gmii_sel_soc_data *soc_data = if_phy->priv->soc_data;
+	struct device *dev = if_phy->priv->dev;
+	struct regmap_field *regfield;
+	int ret, rgmii_id = 0;
+	u32 gmii_sel_mode = 0;
+
+	if (mode != PHY_MODE_ETHERNET)
+		return -EINVAL;
+
+	switch (submode) {
+	case PHY_INTERFACE_MODE_RMII:
+		gmii_sel_mode = AM33XX_GMII_SEL_MODE_RMII;
+		break;
+
+	case PHY_INTERFACE_MODE_RGMII:
+		gmii_sel_mode = AM33XX_GMII_SEL_MODE_RGMII;
+		break;
+
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		gmii_sel_mode = AM33XX_GMII_SEL_MODE_RGMII;
+		rgmii_id = 1;
+		break;
+
+	case PHY_INTERFACE_MODE_MII:
+		mode = AM33XX_GMII_SEL_MODE_MII;
+		break;
+
+	default:
+		dev_warn(dev,
+			 "port%u: unsupported mode: \"%s\". Defaulting to MII.\n",
+			 if_phy->id, phy_modes(rgmii_id));
+		return -EINVAL;
+	};
+
+	if_phy->phy_if_mode = submode;
+
+	dev_dbg(dev, "%s id:%u mode:%u rgmii_id:%d rmii_clk_ext:%d\n",
+		__func__, if_phy->id, mode, rgmii_id,
+		if_phy->rmii_clock_external);
+
+	regfield = if_phy->fields[PHY_GMII_SEL_PORT_MODE];
+	ret = regmap_field_write(regfield, gmii_sel_mode);
+	if (ret) {
+		dev_err(dev, "port%u: set mode fail %d", if_phy->id, ret);
+		return ret;
+	}
+
+	if (soc_data->features & BIT(PHY_GMII_SEL_RGMII_ID_MODE) &&
+	    if_phy->fields[PHY_GMII_SEL_RGMII_ID_MODE]) {
+		regfield = if_phy->fields[PHY_GMII_SEL_RGMII_ID_MODE];
+		ret = regmap_field_write(regfield, rgmii_id);
+		if (ret)
+			return ret;
+	}
+
+	if (soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN) &&
+	    if_phy->fields[PHY_GMII_SEL_RMII_IO_CLK_EN]) {
+		regfield = if_phy->fields[PHY_GMII_SEL_RMII_IO_CLK_EN];
+		ret = regmap_field_write(regfield,
+					 if_phy->rmii_clock_external);
+	}
+
+	return 0;
+}
+
+static const
+struct reg_field phy_gmii_sel_fields_am33xx[][PHY_GMII_SEL_LAST] = {
+	{
+		[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x650, 0, 1),
+		[PHY_GMII_SEL_RGMII_ID_MODE] = REG_FIELD(0x650, 4, 4),
+		[PHY_GMII_SEL_RMII_IO_CLK_EN] = REG_FIELD(0x650, 6, 6),
+	},
+	{
+		[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x650, 2, 3),
+		[PHY_GMII_SEL_RGMII_ID_MODE] = REG_FIELD(0x650, 5, 5),
+		[PHY_GMII_SEL_RMII_IO_CLK_EN] = REG_FIELD(0x650, 7, 7),
+	},
+};
+
+static const
+struct phy_gmii_sel_soc_data phy_gmii_sel_soc_am33xx = {
+	.num_ports = 2,
+	.features = BIT(PHY_GMII_SEL_RGMII_ID_MODE) |
+		    BIT(PHY_GMII_SEL_RMII_IO_CLK_EN),
+	.regfields = phy_gmii_sel_fields_am33xx,
+};
+
+static const
+struct reg_field phy_gmii_sel_fields_dra7[][PHY_GMII_SEL_LAST] = {
+	{
+		[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x554, 0, 1),
+		[PHY_GMII_SEL_RGMII_ID_MODE] = REG_FIELD((~0), 0, 0),
+		[PHY_GMII_SEL_RMII_IO_CLK_EN] = REG_FIELD((~0), 0, 0),
+	},
+	{
+		[PHY_GMII_SEL_PORT_MODE] = REG_FIELD(0x554, 4, 5),
+		[PHY_GMII_SEL_RGMII_ID_MODE] = REG_FIELD((~0), 0, 0),
+		[PHY_GMII_SEL_RMII_IO_CLK_EN] = REG_FIELD((~0), 0, 0),
+	},
+};
+
+static const
+struct phy_gmii_sel_soc_data phy_gmii_sel_soc_dra7 = {
+	.num_ports = 2,
+	.regfields = phy_gmii_sel_fields_dra7,
+};
+
+static const
+struct phy_gmii_sel_soc_data phy_gmii_sel_soc_dm814 = {
+	.num_ports = 2,
+	.features = BIT(PHY_GMII_SEL_RGMII_ID_MODE),
+	.regfields = phy_gmii_sel_fields_am33xx,
+};
+
+static const struct of_device_id phy_gmii_sel_id_table[] = {
+	{
+		.compatible	= "ti,am3352-phy-gmii-sel",
+		.data		= &phy_gmii_sel_soc_am33xx,
+	},
+	{
+		.compatible	= "ti,dra7xx-phy-gmii-sel",
+		.data		= &phy_gmii_sel_soc_dra7,
+	},
+	{
+		.compatible	= "ti,am43xx-phy-gmii-sel",
+		.data		= &phy_gmii_sel_soc_am33xx,
+	},
+	{
+		.compatible	= "ti,dm814-phy-gmii-sel",
+		.data		= &phy_gmii_sel_soc_dm814,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, phy_gmii_sel_id_table);
+
+static const struct phy_ops phy_gmii_sel_ops = {
+	.set_mode	= phy_gmii_sel_mode,
+	.owner		= THIS_MODULE,
+};
+
+static struct phy *phy_gmii_sel_of_xlate(struct device *dev,
+					 struct of_phandle_args *args)
+{
+	struct phy_gmii_sel_priv *priv = dev_get_drvdata(dev);
+	int phy_id = args->args[0];
+
+	if (args->args_count < 1)
+		return ERR_PTR(-EINVAL);
+	if (priv->soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN) &&
+	    args->args_count < 2)
+		return ERR_PTR(-EINVAL);
+	if (!priv || !priv->if_phys)
+		return ERR_PTR(-ENODEV);
+	if (phy_id > priv->soc_data->num_ports)
+		return ERR_PTR(-EINVAL);
+	if (phy_id != priv->if_phys[phy_id - 1].id)
+		return ERR_PTR(-EINVAL);
+
+	phy_id--;
+	if (priv->soc_data->features & BIT(PHY_GMII_SEL_RMII_IO_CLK_EN))
+		priv->if_phys[phy_id].rmii_clock_external = args->args[1];
+	dev_dbg(dev, "%s id:%u ext:%d\n", __func__,
+		priv->if_phys[phy_id].id, args->args[1]);
+
+	return priv->if_phys[phy_id].if_phy;
+}
+
+static int phy_gmii_sel_init_ports(struct phy_gmii_sel_priv *priv)
+{
+	const struct phy_gmii_sel_soc_data *soc_data = priv->soc_data;
+	struct device *dev = priv->dev;
+	struct phy_gmii_sel_phy_priv *if_phys;
+	int i, num_ports, ret;
+
+	num_ports = priv->soc_data->num_ports;
+
+	if_phys = devm_kcalloc(priv->dev, num_ports,
+			       sizeof(*if_phys), GFP_KERNEL);
+	if (!if_phys)
+		return -ENOMEM;
+	dev_dbg(dev, "%s %d\n", __func__, num_ports);
+
+	for (i = 0; i < num_ports; i++) {
+		const struct reg_field *field;
+		struct regmap_field *regfield;
+
+		if_phys[i].id = i + 1;
+		if_phys[i].priv = priv;
+
+		field = &soc_data->regfields[i][PHY_GMII_SEL_PORT_MODE];
+		dev_dbg(dev, "%s field %x %d %d\n", __func__,
+			field->reg, field->msb, field->lsb);
+
+		regfield = devm_regmap_field_alloc(dev, priv->regmap, *field);
+		if (IS_ERR(regfield))
+			return PTR_ERR(regfield);
+		if_phys[i].fields[PHY_GMII_SEL_PORT_MODE] = regfield;
+
+		field = &soc_data->regfields[i][PHY_GMII_SEL_RGMII_ID_MODE];
+		if (field->reg != (~0)) {
+			regfield = devm_regmap_field_alloc(dev,
+							   priv->regmap,
+							   *field);
+			if (IS_ERR(regfield))
+				return PTR_ERR(regfield);
+			if_phys[i].fields[PHY_GMII_SEL_RGMII_ID_MODE] =
+				regfield;
+		}
+
+		field = &soc_data->regfields[i][PHY_GMII_SEL_RMII_IO_CLK_EN];
+		if (field->reg != (~0)) {
+			regfield = devm_regmap_field_alloc(dev,
+							   priv->regmap,
+							   *field);
+			if (IS_ERR(regfield))
+				return PTR_ERR(regfield);
+			if_phys[i].fields[PHY_GMII_SEL_RMII_IO_CLK_EN] =
+				regfield;
+		}
+
+		if_phys[i].if_phy = devm_phy_create(dev,
+						    priv->dev->of_node,
+						    &phy_gmii_sel_ops);
+		if (IS_ERR(if_phys[i].if_phy)) {
+			ret = PTR_ERR(if_phys[i].if_phy);
+			dev_err(dev, "Failed to create phy%d %d\n", i, ret);
+			return ret;
+		}
+		phy_set_drvdata(if_phys[i].if_phy, &if_phys[i]);
+	}
+
+	priv->if_phys = if_phys;
+	return 0;
+}
+
+static int phy_gmii_sel_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	const struct of_device_id *of_id;
+	struct phy_gmii_sel_priv *priv;
+	int ret;
+
+	of_id = of_match_node(phy_gmii_sel_id_table, pdev->dev.of_node);
+	if (!of_id)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &pdev->dev;
+	priv->soc_data = of_id->data;
+
+	priv->regmap = syscon_node_to_regmap(node->parent);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(dev, "Failed to get syscon %d\n", ret);
+		return ret;
+	}
+
+	ret = phy_gmii_sel_init_ports(priv);
+	if (ret)
+		return ret;
+
+	dev_set_drvdata(&pdev->dev, priv);
+
+	priv->phy_provider =
+		devm_of_phy_provider_register(dev,
+					      phy_gmii_sel_of_xlate);
+	if (IS_ERR(priv->phy_provider)) {
+		ret = PTR_ERR(priv->phy_provider);
+		dev_err(dev, "Failed to create phy provider %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver phy_gmii_sel_driver = {
+	.probe		= phy_gmii_sel_probe,
+	.driver		= {
+		.name	= "phy-gmii-sel",
+		.of_match_table = phy_gmii_sel_id_table,
+	},
+};
+module_platform_driver(phy_gmii_sel_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Grygorii Strashko <grygorii.strashko@ti.com>");
+MODULE_DESCRIPTION("TI CPSW Port's PHY Interface Mode selection Driver");
-- 
2.10.5

