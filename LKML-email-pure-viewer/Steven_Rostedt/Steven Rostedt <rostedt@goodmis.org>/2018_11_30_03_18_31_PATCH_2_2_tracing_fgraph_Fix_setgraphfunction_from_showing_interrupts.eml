Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 30 Nov 2018 14:13:16 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga003.jf.intel.com (orsmga003.jf.intel.com [10.7.209.27])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 991FD58046A;
	Thu, 29 Nov 2018 19:22:20 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga003-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 29 Nov 2018 19:22:19 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AZgzhahwFcXfDQ0nXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0e4SLPad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWlPUchfWSJBHI2y?=
 =?us-ascii?q?coUPAOUdMuZDt4nwpUADrQeiCQSiGO/j1iVFi33w0KYn0+ohCwbG3Ak4EtwTrH?=
 =?us-ascii?q?Tbssv1O7kUUeuo0KfIyi7Db+9I1jjg9IjDbxcsoeuLXbJrbcre11QgFx/eg1Wf?=
 =?us-ascii?q?rozlOC6a1uEMs2iA9eZgUvivi2E+pgx3vzOhxd8sh5HXio4Jzl3I7zh1zYgrKd?=
 =?us-ascii?q?GiVUJ2YsKoHIFRuiyYL4d7Q8IvT3t2tCs10LELuZ+2cDIIxZkkwRPUduaJfJKS?=
 =?us-ascii?q?4h35UeacOTd4i2xheLK4nxuy70egxfPmVsWu01ZFsDBFkt/SuXAJzRDT7dKHSv?=
 =?us-ascii?q?Rl8keg3zaAyRzT5/laLUwokafXMYMtz7AumpYJrEjOHTP6lF/3gaKUbkkk//Kn?=
 =?us-ascii?q?6+XjYrXovJ+cMIp0hxn6MqQvnMy/HOs5PhENX2eF4+S80qPs/UngTLVNgPw2lL?=
 =?us-ascii?q?fWsIrBKMQFqa62HRVV3pwg6xmhFTem1soXnX0dIFJCYhKHgJDlO0vSL/DgEfe/?=
 =?us-ascii?q?n1OsnS9vx/DHPb3uHI/BL3fekLr6ebZ96khcyBc8zNxF5pJUDK0BL+z3WkPrqN?=
 =?us-ascii?q?PYCRo5ORSuw+n7ENV9yp8eWWWXD6+ZKqzSsEOI6fgoI+WWZI8VpSzyK/4q5/P1?=
 =?us-ascii?q?iX85mFkdfbSm3JcNaXC4GOhmLFudYXb2ntgBFmIKtBIkTOP2kF2CTSJTZ3GqUq?=
 =?us-ascii?q?I+4TE0FpiqDYTERoCrhryB2zy2HplXZmBAF1CNHm3kd4SCW/cQdi2SJtVtnSAD?=
 =?us-ascii?q?VbikU4Uhzw2htBfmy7p7KerZ4jcXtYnj1Nhy5O3fjwsy+iZ2D8mG12GNTmd0nn?=
 =?us-ascii?q?4HRjMs3aB/p1B9xUmH0aRin/NYEtlT7etTUggmLZ7c0/B6C9fqVwLCZNiJTkyq?=
 =?us-ascii?q?QtGnAT4rSNIxzMQDY0J8G9WkkxDC0DCmA74Tl7yXGpM09rjQ0GT2J8Z403zGzr?=
 =?us-ascii?q?Uuj0E6QstTMm2rnrNw+BLNB4HXiUmZl7yldaIH3CHT8mePym6OvEJdUA50SqjF?=
 =?us-ascii?q?WXEfZk3LrdX2/E/CTrmuCag5PQtF08KNNqxKatjxh1VcWPjjIMjeY362m2qoGB?=
 =?us-ascii?q?mH3K2MY5Twd2UdxirdDlMEnB4V/XudMQg+ByGho3/RDTB0FFLvZV/s/vd6qH+h?=
 =?us-ascii?q?UkA0yASKZVV717Wp4h4VmeCcS/QL07IYuSchrjJ0HEq939PWEdaAuxBtfKJGYd?=
 =?us-ascii?q?M54VdH023Zuhd5PpyhKaBim1Effx52v0PoyxV4FIFAndI2o3MtyQp4MbiY309Z?=
 =?us-ascii?q?dzOEwZDwPaXaJXP2/B+xZK/ZxFHf3MyN9acS9fs3sVPjvAKuFko86Hhn19hV03?=
 =?us-ascii?q?2B5pTFFgYSUJTxUlop+Bh+vb3Vfi4954bM3312Laa0qiPC284uBOY9yhegYs1T?=
 =?us-ascii?q?P7+eGA7zE80VHc6uKOMxllitbxIEOv1S9aEuM8OncfuGxLCkPOJ6kD26imRH5Z?=
 =?us-ascii?q?h30liQ+CpkVu7Iw5EFzumC3guGSzjzlk2hvd3wmYxeYzEdAHC/ySn9CIFNfKJy?=
 =?us-ascii?q?eZsEBnm0I82wwNVznJrtW39e9F6+CFIKws6peRyOb1Pj2Q1cz1gYoXuimSGg1T?=
 =?us-ascii?q?x7jykprraD3CzJ2+njdBsHNnRLRWV4llfsPI60gsseXEipaQgpiRSk6Vz7x6hd?=
 =?us-ascii?q?uKRwMW3TTV1UcCjxKmFoSrGwuaaaY85T9JMotj1aUOamblCASb79oBwa3zn4H2?=
 =?us-ascii?q?RExzA7dDCqupPnkBx8k2+dKHdzrHzEecB/3xvf5drcReJP0ToCXiV3lT7XBl2k?=
 =?us-ascii?q?Ndmz4dqUj4vDsvy5V2+5Vpxcay7rwZmCtCu6421nGhm/n/G1mt36Hgk2yy7719?=
 =?us-ascii?q?92VSrWqBbweJXk16O/Meh/ZElnGEf869ZmGoF5ioYwh4sf2XkAipWV4HoIi2Hz?=
 =?us-ascii?q?MdpA1KL6bXoNQyMLwtHP7Ajk3k1jMmyGx4bjWnqBxcthYsGwYnkK1SIl88BKFK?=
 =?us-ascii?q?CU4aRBnSt0oVq3txjdYPZjkTcG1fsh9mQajPoXtwo3wSWQGbQSHUhePSzxmBWE?=
 =?us-ascii?q?9dG+rKNLZGmxdbi8zlZxndekDLuauAFTRG75eos+HS939sh/LFXM0Hjp5oDlYt?=
 =?us-ascii?q?bQa88TtgaPkxfBlOVVLJMxlvwXhStoI279vHsly/Ilghxqx521oI+HK2B19qKj?=
 =?us-ascii?q?HhFYLiH1Z98U+jz1lqlRhMGW34SyHpl7HjULQYDlTfapEDIUqPTmOByCEDw6qn?=
 =?us-ascii?q?eHB7XfGRWT51thr3LKC5qrLW2YJGEFzdV+QxmQPE5fjxoRXDokhZ41DByqyNbi?=
 =?us-ascii?q?cEdk5TAR+1j4pQFXyu9zMxn/U2HfpBqnazsuSZifKgZW4R9G50vPLcOe6edzFT?=
 =?us-ascii?q?lC/pK9tAyNNnCbZwNQAGAJXUyEGknjPqS06tnG6eSYHe2+L/3BYbiVrexeVvGI?=
 =?us-ascii?q?xY+g04d8/jaMMNmPMWdmD/EhxkVDWnV5EdzDmzoTUywXiz7Nb8mDqRe85CJ3r8?=
 =?us-ascii?q?O/8PfqWA715ouPEbxSMdpx9BCsnKeDLPWdhCJ4KTZey5MNymXEyLkZ3F4OlS5u?=
 =?us-ascii?q?cyOhHqgHtS7IVKjQgLNYDwYHayNvM8tF97gz3hRWNs7BlNz01qR0jvo0C1peUV?=
 =?us-ascii?q?zhm8epZdEFIm2nNVPHAlqLO6qCJTHR3873Zqa8Q6VKjOpIrx2wpSqbE0j7MzSf?=
 =?us-ascii?q?ljnpUgqjPv1WgC6HPBxRpoe9fw1pCWjiStLmdxK6PMV2jT0w3b07mHfKOXQAPj?=
 =?us-ascii?q?h7dkNHtqeQ4j9AgvVjB2xB6WJoLOmelCaf6unYK5AWvuNqAyR0je1a5ns6xqBR?=
 =?us-ascii?q?7CFFQvx1hSTTosRvo1GgjumA1D5nXABSpTZMgYLY9XllbKHY8IRQHHXJ5hQA6U?=
 =?us-ascii?q?2OBBkQ4dhoENviv+ZX0Necurj0LWJ579/K8M1UPc/PNM+LLDJ1Kx3yBDPYECMK?=
 =?us-ascii?q?SjmnMGDEwUtHn6fBpTWuspEmp820y9I1QbhBWQlwT6tCBw=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AXAADuqwBch0O0hNFkHQEBBQEHBQGBU?=
 =?us-ascii?q?QgBCwGBVYIWJ4N5iBhfiymCDRSSOIR4gXMUGBMBh3QiNAkNAQMBAQEBAQECARM?=
 =?us-ascii?q?BAQEIDQkIKS+CNiQBgmIDAwECIARSBgkBAR8FAgUTDgICAwwtGxkFgxyCAgWoR?=
 =?us-ascii?q?XwMJ4VBhHCBC4sLF4F/jCiCVwKQHpAFCZEnI5EcLJgigUaCDTMaCCgIgyeCJxe?=
 =?us-ascii?q?OOyIygQUBAY00BQEB?=
X-IPAS-Result: =?us-ascii?q?A0AXAADuqwBch0O0hNFkHQEBBQEHBQGBUQgBCwGBVYIWJ4N?=
 =?us-ascii?q?5iBhfiymCDRSSOIR4gXMUGBMBh3QiNAkNAQMBAQEBAQECARMBAQEIDQkIKS+CN?=
 =?us-ascii?q?iQBgmIDAwECIARSBgkBAR8FAgUTDgICAwwtGxkFgxyCAgWoRXwMJ4VBhHCBC4s?=
 =?us-ascii?q?LF4F/jCiCVwKQHpAFCZEnI5EcLJgigUaCDTMaCCgIgyeCJxeOOyIygQUBAY00B?=
 =?us-ascii?q?QEB?=
X-IronPort-AV: E=Sophos;i="5.56,297,1539673200"; 
   d="scan'208";a="53967054"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 29 Nov 2018 19:22:18 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727361AbeK3O05 (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 30 Nov 2018 09:26:57 -0500
Received: from mail.kernel.org ([198.145.29.99]:55598 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726509AbeK3O05 (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 30 Nov 2018 09:26:57 -0500
Received: from gandalf.local.home (cpe-66-24-56-78.stny.res.rr.com [66.24.56.78])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id E2BCC21479;
        Fri, 30 Nov 2018 03:19:08 +0000 (UTC)
Received: from rostedt by gandalf.local.home with local (Exim 4.91)
        (envelope-from <rostedt@goodmis.org>)
        id 1gSZKd-0002lR-UT; Thu, 29 Nov 2018 22:19:07 -0500
Message-Id: <20181130031907.844644427@goodmis.org>
User-Agent: quilt/0.65
Date: Thu, 29 Nov 2018 22:18:31 -0500
From: Steven Rostedt <rostedt@goodmis.org>
To: linux-kernel@vger.kernel.org
Cc: Linus Torvalds <torvalds@linux-foundation.org>,
        Ingo Molnar <mingo@kernel.org>,
        Andrew Morton <akpm@linux-foundation.org>, stable@kernel.org,
        Joe Lawrence <joe.lawrence@redhat.com>
Subject: [PATCH 2/2] tracing/fgraph: Fix set_graph_function from showing interrupts
References: <20181130031829.268422593@goodmis.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: "Steven Rostedt (VMware)" <rostedt@goodmis.org>

The tracefs file set_graph_function is used to only function graph functions
that are listed in that file (or all functions if the file is empty). The
way this is implemented is that the function graph tracer looks at every
function, and if the current depth is zero and the function matches
something in the file then it will trace that function. When other functions
are called, the depth will be greater than zero (because the original
function will be at depth zero), and all functions will be traced where the
depth is greater than zero.

The issue is that when a function is first entered, and the handler that
checks this logic is called, the depth is set to zero. If an interrupt comes
in and a function in the interrupt handler is traced, its depth will be
greater than zero and it will automatically be traced, even if the original
function was not. But because the logic only looks at depth it may trace
interrupts when it should not be.

The recent design change of the function graph tracer to fix other bugs
caused the depth to be zero while the function graph callback handler is
being called for a longer time, widening the race of this happening. This
bug was actually there for a longer time, but because the race window was so
small it seldom happened. The Fixes tag below is for the commit that widen
the race window, because that commit belongs to a series that will also help
fix the original bug.

Cc: stable@kernel.org
Fixes: 39eb456dacb5 ("function_graph: Use new curr_ret_depth to manage depth instead of curr_ret_stack")
Reported-by: Joe Lawrence <joe.lawrence@redhat.com>
Tested-by: Joe Lawrence <joe.lawrence@redhat.com>
Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
---
 kernel/trace/trace.h                 | 57 ++++++++++++++++++++++++++--
 kernel/trace/trace_functions_graph.c |  4 ++
 kernel/trace/trace_irqsoff.c         |  2 +
 kernel/trace/trace_sched_wakeup.c    |  2 +
 4 files changed, 62 insertions(+), 3 deletions(-)

diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 3b8c0e24ab30..447bd96ee658 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -512,12 +512,44 @@ enum {
  * can only be modified by current, we can reuse trace_recursion.
  */
 	TRACE_IRQ_BIT,
+
+	/* Set if the function is in the set_graph_function file */
+	TRACE_GRAPH_BIT,
+
+	/*
+	 * In the very unlikely case that an interrupt came in
+	 * at a start of graph tracing, and we want to trace
+	 * the function in that interrupt, the depth can be greater
+	 * than zero, because of the preempted start of a previous
+	 * trace. In an even more unlikely case, depth could be 2
+	 * if a softirq interrupted the start of graph tracing,
+	 * followed by an interrupt preempting a start of graph
+	 * tracing in the softirq, and depth can even be 3
+	 * if an NMI came in at the start of an interrupt function
+	 * that preempted a softirq start of a function that
+	 * preempted normal context!!!! Luckily, it can't be
+	 * greater than 3, so the next two bits are a mask
+	 * of what the depth is when we set TRACE_GRAPH_BIT
+	 */
+
+	TRACE_GRAPH_DEPTH_START_BIT,
+	TRACE_GRAPH_DEPTH_END_BIT,
 };
 
 #define trace_recursion_set(bit)	do { (current)->trace_recursion |= (1<<(bit)); } while (0)
 #define trace_recursion_clear(bit)	do { (current)->trace_recursion &= ~(1<<(bit)); } while (0)
 #define trace_recursion_test(bit)	((current)->trace_recursion & (1<<(bit)))
 
+#define trace_recursion_depth() \
+	(((current)->trace_recursion >> TRACE_GRAPH_DEPTH_START_BIT) & 3)
+#define trace_recursion_set_depth(depth) \
+	do {								\
+		current->trace_recursion &=				\
+			~(3 << TRACE_GRAPH_DEPTH_START_BIT);		\
+		current->trace_recursion |=				\
+			((depth) & 3) << TRACE_GRAPH_DEPTH_START_BIT;	\
+	} while (0)
+
 #define TRACE_CONTEXT_BITS	4
 
 #define TRACE_FTRACE_START	TRACE_FTRACE_BIT
@@ -843,8 +875,9 @@ extern void __trace_graph_return(struct trace_array *tr,
 extern struct ftrace_hash *ftrace_graph_hash;
 extern struct ftrace_hash *ftrace_graph_notrace_hash;
 
-static inline int ftrace_graph_addr(unsigned long addr)
+static inline int ftrace_graph_addr(struct ftrace_graph_ent *trace)
 {
+	unsigned long addr = trace->func;
 	int ret = 0;
 
 	preempt_disable_notrace();
@@ -855,6 +888,14 @@ static inline int ftrace_graph_addr(unsigned long addr)
 	}
 
 	if (ftrace_lookup_ip(ftrace_graph_hash, addr)) {
+
+		/*
+		 * This needs to be cleared on the return functions
+		 * when the depth is zero.
+		 */
+		trace_recursion_set(TRACE_GRAPH_BIT);
+		trace_recursion_set_depth(trace->depth);
+
 		/*
 		 * If no irqs are to be traced, but a set_graph_function
 		 * is set, and called by an interrupt handler, we still
@@ -872,6 +913,13 @@ static inline int ftrace_graph_addr(unsigned long addr)
 	return ret;
 }
 
+static inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)
+{
+	if (trace_recursion_test(TRACE_GRAPH_BIT) &&
+	    trace->depth == trace_recursion_depth())
+		trace_recursion_clear(TRACE_GRAPH_BIT);
+}
+
 static inline int ftrace_graph_notrace_addr(unsigned long addr)
 {
 	int ret = 0;
@@ -885,7 +933,7 @@ static inline int ftrace_graph_notrace_addr(unsigned long addr)
 	return ret;
 }
 #else
-static inline int ftrace_graph_addr(unsigned long addr)
+static inline int ftrace_graph_addr(struct ftrace_graph_ent *trace)
 {
 	return 1;
 }
@@ -894,6 +942,8 @@ static inline int ftrace_graph_notrace_addr(unsigned long addr)
 {
 	return 0;
 }
+static inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)
+{ }
 #endif /* CONFIG_DYNAMIC_FTRACE */
 
 extern unsigned int fgraph_max_depth;
@@ -901,7 +951,8 @@ extern unsigned int fgraph_max_depth;
 static inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)
 {
 	/* trace it when it is-nested-in or is a function enabled. */
-	return !(trace->depth || ftrace_graph_addr(trace->func)) ||
+	return !(trace_recursion_test(TRACE_GRAPH_BIT) ||
+		 ftrace_graph_addr(trace)) ||
 		(trace->depth < 0) ||
 		(fgraph_max_depth && trace->depth >= fgraph_max_depth);
 }
diff --git a/kernel/trace/trace_functions_graph.c b/kernel/trace/trace_functions_graph.c
index 2561460d7baf..086af4f5c3e8 100644
--- a/kernel/trace/trace_functions_graph.c
+++ b/kernel/trace/trace_functions_graph.c
@@ -509,6 +509,8 @@ void trace_graph_return(struct ftrace_graph_ret *trace)
 	int cpu;
 	int pc;
 
+	ftrace_graph_addr_finish(trace);
+
 	local_irq_save(flags);
 	cpu = raw_smp_processor_id();
 	data = per_cpu_ptr(tr->trace_buffer.data, cpu);
@@ -532,6 +534,8 @@ void set_graph_array(struct trace_array *tr)
 
 static void trace_graph_thresh_return(struct ftrace_graph_ret *trace)
 {
+	ftrace_graph_addr_finish(trace);
+
 	if (tracing_thresh &&
 	    (trace->rettime - trace->calltime < tracing_thresh))
 		return;
diff --git a/kernel/trace/trace_irqsoff.c b/kernel/trace/trace_irqsoff.c
index b7357f9f82a3..98ea6d28df15 100644
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@ -208,6 +208,8 @@ static void irqsoff_graph_return(struct ftrace_graph_ret *trace)
 	unsigned long flags;
 	int pc;
 
+	ftrace_graph_addr_finish(trace);
+
 	if (!func_prolog_dec(tr, &data, &flags))
 		return;
 
diff --git a/kernel/trace/trace_sched_wakeup.c b/kernel/trace/trace_sched_wakeup.c
index a86b303e6c67..7d04b9890755 100644
--- a/kernel/trace/trace_sched_wakeup.c
+++ b/kernel/trace/trace_sched_wakeup.c
@@ -270,6 +270,8 @@ static void wakeup_graph_return(struct ftrace_graph_ret *trace)
 	unsigned long flags;
 	int pc;
 
+	ftrace_graph_addr_finish(trace);
+
 	if (!func_prolog_preempt_disable(tr, &data, &pc))
 		return;
 
-- 
2.19.1


