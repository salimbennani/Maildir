Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 08:29:41 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 57C3D580460;
	Thu, 22 Nov 2018 08:50:15 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 08:50:15 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AmidddBIUDu+5MRg7x9mcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgUL/r6rarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0vRz+s87lkRwPpiC?=
 =?us-ascii?q?cfNj427mfXitBrjKlGpB6tvgFzz5LIbI2QMvdxeb/Tc9MESGZYR8pfVTFOApml?=
 =?us-ascii?q?Y4USEuoBJv5YoJfhqFsStBe+AQ6sBe3ywTNMhnL62Ks33OM9Hw/GwgEsBssCvn?=
 =?us-ascii?q?bJo9XvLascTP21zLLQzTrdc/xWxSr25IzWfhw9pP2BW697f8jMxkk1Dw7Ljkue?=
 =?us-ascii?q?p5HrMT2W0eoCsWab4OhuVeK0k24qqRp8riSzyso2loXEnJ4ZxkzC+C5kwIg1P9?=
 =?us-ascii?q?q4SEtjbNCgDZtQsyCaOJFwQsg/Xm9opDg1xaEFuZ6/fSgKzo4ozAPYZvyFaIiI?=
 =?us-ascii?q?/gzsW/qSITd8hXJoY6iwhxOo/kmhze38UNO430tUoSdclNTHq3MD1wTL58SZVv?=
 =?us-ascii?q?dw+l2t1SuB2gzN8O1IPEM5mbbBJ5MgwLM8joQfvVjBEyPshUn7jrKael859uWr?=
 =?us-ascii?q?5OnreKvqq5+aOoRpkA/xKL4ulda6AekgMggBQWyb+eOk2b398k32Xq9Kguc1kq?=
 =?us-ascii?q?bHqpDaI9oUpqqjDw9SyIYj5A6zDzag0NsGgXkKNExJdA6DgoTzJl3DLu70Ae2i?=
 =?us-ascii?q?j1mvjDtn3fHLM7/5DpXINHfDkbPhfbhn605bzQo+1dRf55NSCrEcL/P/Q0zxu8?=
 =?us-ascii?q?LCDh8/LQO0x//rCNJz14MYR22PGLSUML3dsVCW/OIjOeqMa5EPuDb7Nfcl4+Ti?=
 =?us-ascii?q?jXgjmV8SZaWpx4cYaGikHvR6JEWUeX7sgtYCEWgUpAY/Q/HqhUaGUT5SYXayQq?=
 =?us-ascii?q?096is6CIKgEYfMWIStjKad0ye8G51cfnpGBUyUEXf0a4WEXO8BaCKILc9gjjwL?=
 =?us-ascii?q?T7+hR5Uh1RGzrgD6zbVnI/HQ+i0Zs5Ljydd06/fSlRE06Tx7EcCd33uRQGFzm2?=
 =?us-ascii?q?MCXyU207xnoUxh1leD1rB1g/5fFdNN/f9JUQA6NZjaz+x9EN3yXgPBftGUSFep?=
 =?us-ascii?q?WNmmADcxTs4vzN8KeUpyB9KijhXb1SqwH7AVj6CLBIAz8q/ExXfxPMZ9y3HF1K?=
 =?us-ascii?q?U7lVkpWMlPOHaihq5+8QjTGoHIn1+Yl6asaaQTwirN+H2fwmqJuUFSSBRwXrnd?=
 =?us-ascii?q?XXADekvWqsz05kDYQL+oE7gnNgpBxtSEKqtFcdDpiVRGRPH+ONXReW6xmmGwBQ?=
 =?us-ascii?q?qWybOIdoblZ2Id3CDFAkgejw8T5WqGNRQ5Biq5vm3RFiJuGkz1b0Ps6+Z+rmi7?=
 =?us-ascii?q?QVEyzw2Na01h1L+1+hoOiPyYSvMT2K8EuSg7pzV1Gla9w8zZC96aqwV9e6VcZM?=
 =?us-ascii?q?s34E1b2mLBqwx9IpugIrh/iVEEbQR4oVni1xVtBYVGisglsnUqwRF2KaKZ1lNB?=
 =?us-ascii?q?ajyZ0YrxOr3RNmn94hSvZ7TK1VHZ1dac4r0P5+ggq1X/oAGpEVIv82lm09lQ1H?=
 =?us-ascii?q?uc+pXKDQoIXZLtSEo38AJ6p7XbYik76IPZznlsMaiysj/f1NMlHuolyhC8f9hB?=
 =?us-ascii?q?NKOIDhP9E8ofB8K2Muwlh0Cpbg4YPOBV7KM7JcemeOWJ2aG1POdshimpjXla74?=
 =?us-ascii?q?9n1EKM9C18SvDT0pYBwvGY2BaHVjjmgFegtMD3hZ5LZTUIEmWjzijkAZZbZrdu?=
 =?us-ascii?q?coYTFWeuP8q3y81+hp7wQXJX6ESvBlIG2MCzfxqSYEfw3QlR1UQRvHymljG0zz?=
 =?us-ascii?q?1ykzE1sKWf2DbCzPjldBoCImRLXnVtjU/wIYioiNAXRFKobwk1mxS//0b12q9b?=
 =?us-ascii?q?qL55L2bNW0dIfjH6IH14Xau0q7WNfdRP6JQusShMVOS8YFaaSqPyohcA0iPjGX?=
 =?us-ascii?q?deyy4/dz2wppr5mBl6gnqHLHlvtHrZZd1wxRDH6d3cRP5dxDoHSDNjiTnKAFix?=
 =?us-ascii?q?JN2p/dSSl5feveGyTWOhVptPcSb1yYOMrje05WpvARenhfC8hsXnERQm0S/8z9?=
 =?us-ascii?q?RqVz/HrAz/Yono0KS2K/lncVNrBF//6sp6HJ9xko0riZEU2HgagIiV/HUdnWfy?=
 =?us-ascii?q?N9VbxbzxbH4XSTEXxN7V5RDv2Fd/IXKR24L5SnKdz9NhZtagZWMawCA978FMCK?=
 =?us-ascii?q?qP6LxEnC11oke3rA7LYPh9mCsdxuUq6HIAn+4Jvw8txD2HAr8OBUlYITDslxOQ?=
 =?us-ascii?q?4tC9tqpXZXyjcbit1EVkm9ChA6qPogVdWHb/Z5cjEjV87sR5MFLQznLz7pvod8?=
 =?us-ascii?q?XXbdIWrheUiQvPj/BJKJItkfoHnS9nOWP+vXI/0eI6gwJh3YqmvIeZMWVi57y2?=
 =?us-ascii?q?AgRXNjDuY8MT+zftjbtRn8qM3oCvGIlhFSsPXJfyUf2oFzcSv+z9NwmSCD08tm?=
 =?us-ascii?q?ubGb3HEA+D70dmqmjDEpGxOHGROXkZ1s5iRBiGKUxbgQAUWig6n5EjGgCrwszh?=
 =?us-ascii?q?bFl25jQL6lHkrRtMz/piNwPjXWfHuAeodjA0RYCEIxVM6QFC41rVPdaa7uJuBC?=
 =?us-ascii?q?xY+pyhrAqQKm2UfQhIDGcJWlCaCFDnJLWh+d7A8+2ADOqkM/TOeamOqfBZV/qQ?=
 =?us-ascii?q?x5KgyI5m8CiXNsmVInluFf472ldAXXBkHcTWgS4PRjcTlyLMac6buRi99jd2rs?=
 =?us-ascii?q?C57PTkRgbv6ZGTBLtVNNVl4wq2jrubN+6MmCZ5Li5V15MLxX/V0bgfwUQdiyd0?=
 =?us-ascii?q?ezm2FrQAsyHNQbnUmq9WCR4bdixyONFJ76I6wglCJ8rbhsnp2b5/i/4/E01FWk?=
 =?us-ascii?q?D5msG1ecwKJHmwNFPZC0aKN7SGJjzLz9v0YaOmTr1Qg/tbtwetuTaACELjOjWD?=
 =?us-ascii?q?lz/0VxGgK+1MjSebPABAt4G5aBpiFW/jTNf+YB2hLNB3lSE2waEzhn7SL2EcLC?=
 =?us-ascii?q?Nzc1lTobyQ9y9YhvR/FndF7npkK+mEhimY4/PZKpYQrftkHCB0m/hG73Q9zrtf?=
 =?us-ascii?q?9DtES+BtmCvOst5upEmrkvWOyjpiShZBtixHi56LvUp8P6XU7Z1AWXfC/BIQ4m?=
 =?us-ascii?q?ScERUKp915CtLxv6Bc0MTAlKX2KD1a6dLb4dMcB9TIKMKAKHcgMQDmGDjRDAsE?=
 =?us-ascii?q?Sz6kLWDeh0xHn/GU+X2YtZw6qpnqmJoTRb5XTl01FvUGCkt7GNwOOot4XjQhke?=
 =?us-ascii?q?3TsMld5nekqhTVAcVTpJzKUPOUDt3rKS2Flv9DfxYO3rr8KcIYMYio9VZlbwxY?=
 =?us-ascii?q?gYDLEkyYZsxAqS5lbwk96BFP62RzRW432mrsbwq/53lVGfPizU1+sRd3fel4rG?=
 =?us-ascii?q?Sk2FwwPFef4XRtnQ=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0DYAgC+3fZbh0O0hNFigheDWhInjG+LI?=
 =?us-ascii?q?QGBaDmJBI4igWwZAQEYEwGIUiI2Bw0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiS?=
 =?us-ascii?q?CYwMDAQIOFhkBATcBBQkBAVADVBkFgxyBdQ0FklUBAYkOAYxPgWwzgnYBAQWHG?=
 =?us-ascii?q?giHXoMPgRwXgUA/gREzhXoChzyLE5RxCR10iRiHBhiJUYc3mAkCBAsCEwGBTQG?=
 =?us-ascii?q?CBU0kFIMngicXEoNriiA+AQExgQUBAYxUAQE?=
X-IPAS-Result: =?us-ascii?q?A0DYAgC+3fZbh0O0hNFigheDWhInjG+LIQGBaDmJBI4igWw?=
 =?us-ascii?q?ZAQEYEwGIUiI2Bw0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiSCYwMDAQIOFhkBA?=
 =?us-ascii?q?TcBBQkBAVADVBkFgxyBdQ0FklUBAYkOAYxPgWwzgnYBAQWHGgiHXoMPgRwXgUA?=
 =?us-ascii?q?/gREzhXoChzyLE5RxCR10iRiHBhiJUYc3mAkCBAsCEwGBTQGCBU0kFIMngicXE?=
 =?us-ascii?q?oNriiA+AQExgQUBAYxUAQE?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="53375452"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 08:50:13 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2405617AbeKWDaV (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 22:30:21 -0500
Received: from smtp-fw-9101.amazon.com ([207.171.184.25]:39554 "EHLO
        smtp-fw-9101.amazon.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2404359AbeKWDaT (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 22:30:19 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
  d=amazon.de; i=@amazon.de; q=dns/txt; s=amazon201209;
  t=1542905409; x=1574441409;
  h=from:to:cc:subject:date:message-id;
  bh=uR6OTfqyfPgXr8jCjIYnLfUKlOkELfypdLaRrHbGp7k=;
  b=Jb7U4Vgc2aOiFq1mQt1RwVEePPj5cMccmPF0CKdBLnGH0EFZE7dLTBzI
   lQnCT5ahkSYRUSxiaxSVcvtClGYWOp2tIOEFE/UA+N4OPo5zTX7DDc221
   kGYfCkiCJIrrd3q2KTnQ5ueWRztCefH3zleoRWeTKfmZJbdHxyn0obgxC
   Y=;
X-IronPort-AV: E=Sophos;i="5.56,253,1539648000"; 
   d="scan'208";a="771919559"
Received: from sea3-co-svc-lb6-vlan3.sea.amazon.com (HELO email-inbound-relay-2b-4e24fd92.us-west-2.amazon.com) ([10.47.22.38])
  by smtp-border-fw-out-9101.sea19.amazon.com with ESMTP/TLS/DHE-RSA-AES256-SHA; 22 Nov 2018 16:50:08 +0000
Received: from u54ee758033e858cfa736.ant.amazon.com (pdx2-ws-svc-lb17-vlan3.amazon.com [10.247.140.70])
        by email-inbound-relay-2b-4e24fd92.us-west-2.amazon.com (8.14.7/8.14.7) with ESMTP id wAMGo1Kw110559
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
        Thu, 22 Nov 2018 16:50:03 GMT
Received: from u54ee758033e858cfa736.ant.amazon.com (localhost [127.0.0.1])
        by u54ee758033e858cfa736.ant.amazon.com (8.15.2/8.15.2/Debian-3) with ESMTP id wAMGo0iD008119;
        Thu, 22 Nov 2018 17:50:00 +0100
Received: (from jsteckli@localhost)
        by u54ee758033e858cfa736.ant.amazon.com (8.15.2/8.15.2/Submit) id wAMGnx9l008117;
        Thu, 22 Nov 2018 17:49:59 +0100
From: Julian Stecklina <jsteckli@amazon.de>
To: kernel-hardening@lists.openwall.com
Cc: Julian Stecklina <jsteckli@amazon.de>,
        Liran Alon <liran.alon@oracle.com>,
        Tycho Andersen <tycho@tycho.ws>,
        Jonathan Adams <jwadams@google.com>,
        David Woodhouse <dwmw2@infradead.org>,
        LKML <linux-kernel@vger.kernel.org>
Subject: [RFC RESEND PATCH 4/6] x86/speculation, mm: add process local virtual memory region
Date: Thu, 22 Nov 2018 17:49:37 +0100
Message-Id: <717f82f41dd541512edb0eb60afde8983377340d.1542905228.git.jsteckli@amazon.de>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <cover.1542905228.git.jsteckli@amazon.de>
References: <cover.1542905228.git.jsteckli@amazon.de>
In-Reply-To: <cover.1542905228.git.jsteckli@amazon.de>
References: <cover.1542905228.git.jsteckli@amazon.de>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

The Linux kernel has a global address space that is the same for any
kernel code. This address space becomes a liability in a world with
processor information leak vulnerabilities, such as L1TF. With the right
cache load gadget, an attacker-controlled hyperthread pair can leak
arbitrary data via L1TF. The upstream Linux kernel currently suggests
disabling hyperthread, but this comes with a large performance hit for a
wide range of workloads.

An alternative mitigation is to not make certain data in the kernel
globally visible, but only when the kernel executes in the context of
the process where this data belongs to.

This patch adds the initial plumbing for allocating process-local
memory. By grabbing one entry in the PML4 of each set of page tables and
start treating it as process-local memory. We currently only support 2MB
of process-local allocations, but this is an arbitrary limitation and
can be lifted by working on the page table allocation code.

While memory is used for process-local allocations, it is unmapped from
the linear mapping of physical memory.

The code has some limitations that are spelled out in
arch/x86/mm/proclocal.c.

Signed-off-by: Julian Stecklina <jsteckli@amazon.de>
---
 arch/x86/Kconfig                        |   1 +
 arch/x86/include/asm/pgtable_64_types.h |   6 +
 arch/x86/include/asm/proclocal.h        |  44 ++++
 arch/x86/mm/Makefile                    |   2 +
 arch/x86/mm/dump_pagetables.c           |   3 +
 arch/x86/mm/fault.c                     |  14 ++
 arch/x86/mm/proclocal.c                 | 269 ++++++++++++++++++++++++
 include/linux/mm_types.h                |   7 +
 security/Kconfig                        |  16 ++
 9 files changed, 362 insertions(+)
 create mode 100644 arch/x86/include/asm/proclocal.h
 create mode 100644 arch/x86/mm/proclocal.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 1a0be022f91d..f701e68482a5 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -32,6 +32,7 @@ config X86_64
 	select SWIOTLB
 	select X86_DEV_DMA_OPS
 	select ARCH_HAS_SYSCALL_WRAPPER
+	select ARCH_SUPPORTS_PROCLOCAL
 
 #
 # Arch settings
diff --git a/arch/x86/include/asm/pgtable_64_types.h b/arch/x86/include/asm/pgtable_64_types.h
index 04edd2d58211..6c4912a85cef 100644
--- a/arch/x86/include/asm/pgtable_64_types.h
+++ b/arch/x86/include/asm/pgtable_64_types.h
@@ -138,6 +138,12 @@ extern unsigned int ptrs_per_p4d;
 
 #define VMALLOC_END		(VMALLOC_START + (VMALLOC_SIZE_TB << 40) - 1)
 
+#ifdef CONFIG_PROCLOCAL
+/* TODO: Make this generic instead of hardcoded */
+#define PROCLOCAL_START		_AC(0xffffeb0000000000, UL)
+#define PROCLOCAL_END		_AC(0xffffebffffffffff, UL)
+#endif
+
 #define MODULES_VADDR		(__START_KERNEL_map + KERNEL_IMAGE_SIZE)
 /* The module sections ends with the start of the fixmap */
 #define MODULES_END		_AC(0xffffffffff000000, UL)
diff --git a/arch/x86/include/asm/proclocal.h b/arch/x86/include/asm/proclocal.h
new file mode 100644
index 000000000000..d322ddc42152
--- /dev/null
+++ b/arch/x86/include/asm/proclocal.h
@@ -0,0 +1,44 @@
+#ifndef _ASM_X86_PROCLOCAL_H
+#define _ASM_X86_PROCLOCAL_H
+
+#include <linux/types.h>
+
+#ifdef CONFIG_PROCLOCAL
+
+struct mm_struct;
+
+struct proclocal {
+	void *alloc;
+	struct mm_struct *mm;
+	int order;
+};
+
+int kalloc_proclocal(struct proclocal *pl, size_t len);
+void kfree_proclocal(struct proclocal *pl);
+
+#else  /* !CONFIG_PROCLOCAL */
+
+#include <linux/slab.h>
+
+struct proclocal {
+	void *alloc;
+};
+
+static inline int kalloc_proclocal(struct proclocal *pl, size_t len)
+{
+	pl->alloc = kzalloc(len, GFP_KERNEL);
+
+	return -!pl->alloc;
+}
+
+static inline void kfree_proclocal(struct proclocal *pl)
+{
+	kfree(pl->alloc);
+	pl->alloc = NULL;
+}
+
+#endif
+
+#define proclocal_get(pl, type) ((type *)(pl)->alloc)
+
+#endif	/* _ASM_X86_PROCLOCAL_H */
diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile
index 4b101dd6e52f..94f99494544a 100644
--- a/arch/x86/mm/Makefile
+++ b/arch/x86/mm/Makefile
@@ -53,3 +53,5 @@ obj-$(CONFIG_PAGE_TABLE_ISOLATION)		+= pti.o
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt.o
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_identity.o
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o
+
+obj-$(CONFIG_PROCLOCAL)		+= proclocal.o
diff --git a/arch/x86/mm/dump_pagetables.c b/arch/x86/mm/dump_pagetables.c
index a12afff146d1..64976db507f6 100644
--- a/arch/x86/mm/dump_pagetables.c
+++ b/arch/x86/mm/dump_pagetables.c
@@ -59,6 +59,7 @@ enum address_markers_idx {
 #endif
 	VMALLOC_START_NR,
 	VMEMMAP_START_NR,
+	PROCLOCAL_START_NR,
 #ifdef CONFIG_KASAN
 	KASAN_SHADOW_START_NR,
 	KASAN_SHADOW_END_NR,
@@ -86,6 +87,7 @@ static struct addr_marker address_markers[] = {
 	[LOW_KERNEL_NR]		= { 0UL,		"Low Kernel Mapping" },
 	[VMALLOC_START_NR]	= { 0UL,		"vmalloc() Area" },
 	[VMEMMAP_START_NR]	= { 0UL,		"Vmemmap" },
+	[PROCLOCAL_START_NR]    = { 0UL,                "Process local" },
 #ifdef CONFIG_KASAN
 	/*
 	 * These fields get initialized with the (dynamic)
@@ -606,6 +608,7 @@ static int __init pt_dump_init(void)
 	address_markers[KASAN_SHADOW_START_NR].start_address = KASAN_SHADOW_START;
 	address_markers[KASAN_SHADOW_END_NR].start_address = KASAN_SHADOW_END;
 #endif
+	address_markers[PROCLOCAL_START_NR].start_address = PROCLOCAL_START;
 #endif
 #ifdef CONFIG_X86_32
 	address_markers[VMALLOC_START_NR].start_address = VMALLOC_START;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 47bebfe6efa7..0590eed9941b 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1185,6 +1185,15 @@ static int fault_in_kernel_space(unsigned long address)
 	return address >= TASK_SIZE_MAX;
 }
 
+static int fault_in_process_local(unsigned long address)
+{
+#ifdef CONFIG_PROCLOCAL
+	return address >= PROCLOCAL_START && address <= PROCLOCAL_END;
+#else
+	return false;
+#endif
+}
+
 static inline bool smap_violation(int error_code, struct pt_regs *regs)
 {
 	if (!IS_ENABLED(CONFIG_X86_SMAP))
@@ -1240,6 +1249,11 @@ __do_page_fault(struct pt_regs *regs, unsigned long error_code,
 	 * protection error (error_code & 9) == 0.
 	 */
 	if (unlikely(fault_in_kernel_space(address))) {
+
+		if (unlikely(fault_in_process_local(address))) {
+			BUG();
+		}
+
 		if (!(error_code & (X86_PF_RSVD | X86_PF_USER | X86_PF_PROT))) {
 			if (vmalloc_fault(address) >= 0)
 				return;
diff --git a/arch/x86/mm/proclocal.c b/arch/x86/mm/proclocal.c
new file mode 100644
index 000000000000..5b382796a5bf
--- /dev/null
+++ b/arch/x86/mm/proclocal.c
@@ -0,0 +1,269 @@
+#include <linux/bitmap.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/sched/mm.h>
+
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/tlb.h>
+
+#include <asm/proclocal.h>
+
+/*
+ * The code in this file implements process-local mappings in the Linux kernel
+ * address space. This memory is only usable in the process context. With memory
+ * not globally visible in the kernel, it cannot easily be prefetched and leaked
+ * via L1TF.
+ *
+ * We claim one PGD entry for this purpose, but currently use a single page
+ * table for actual mappings. Metainformation is stored in mm_struct, including
+ * the bitmap to keep track of unused address space.
+ *
+ * Issues:
+ *
+ * - Is holding the write part of mmap_sem the right kind of synchronization?
+ * - Should this code move out of x86?
+ */
+
+#define PRL_DBG(...) do { } while (0);
+//#define PRL_DBG(msg, ...) pr_debug("%s: " msg, __func__, __VA_ARGS__)
+
+/* We only maintain a single page table for now. */
+#define MAX_PROCLOCAL_PAGES 512
+
+/*
+ * Initialize process-local kernel mappings by creating the relevant page
+ * tables.
+ */
+static int proclocal_init_page_tables(struct mm_struct *mm)
+{
+	pgd_t *pgd = pgd_offset(mm, PROCLOCAL_START);
+	p4d_t *p4d;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+
+	PRL_DBG("pgd=%lx %lx\n", (unsigned long)pgd, pgd_val(*pgd));
+
+	BUG_ON(pgd_val(*pgd));
+
+	p4d = p4d_alloc(mm, pgd, PROCLOCAL_START);
+	if (!p4d)
+		goto fail;
+
+	pud = pud_alloc(mm, p4d, PROCLOCAL_START);
+	if (!pud)
+		goto free_p4d;
+
+	pmd = pmd_alloc(mm, pud, PROCLOCAL_START);
+	if (!pmd)
+		goto free_pud;
+
+	pte = pte_alloc_map(mm, pmd, PROCLOCAL_START);
+	if (!pte)
+		goto free_pmd;
+
+	return 0;
+free_pmd:
+	pmd_free(mm, pmd);
+free_pud:
+	pud_free(mm, pud);
+free_p4d:
+	p4d_free(mm, p4d);
+fail:
+	return -1;
+}
+
+/*
+ * Cleanup page table structures previously allocated with
+ * proclocal_init_page_tables.
+ */
+static void proclocal_cleanup_page_tables(struct mm_struct *mm)
+{
+	struct mmu_gather tlb;
+	unsigned long start = PROCLOCAL_START;
+	unsigned long end = PROCLOCAL_END + 1; /* exclusive */
+
+	tlb_gather_mmu(&tlb, mm, start, end);
+	free_pgd_range(&tlb, start, end, start, end);
+	tlb_finish_mmu(&tlb, start, end);
+}
+
+static int proclocal_init(struct mm_struct *mm)
+{
+	int rc;
+
+	rc = proclocal_init_page_tables(mm);
+	if (rc)
+		goto fail;
+
+	mm->proclocal_bitmap = bitmap_zalloc(MAX_PROCLOCAL_PAGES, GFP_KERNEL);
+	if (!mm->proclocal_bitmap) {
+		goto free_page_tables;
+	}
+
+	BUG_ON(mm->proclocal_in_use_pages != 0);
+
+	return 0;
+
+free_page_tables:
+	proclocal_cleanup_page_tables(mm);
+fail:
+	return -1;
+}
+
+static void proclocal_cleanup(struct mm_struct *mm)
+{
+	BUG_ON(mm->proclocal_in_use_pages != 0);
+
+	proclocal_cleanup_page_tables(mm);
+	bitmap_free(mm->proclocal_bitmap);
+}
+
+static pte_t *pte_lookup(struct mm_struct *mm, unsigned long vaddr)
+{
+	pgd_t *pgd = pgd_offset(mm, vaddr);
+	p4d_t *p4d = p4d_offset(pgd, vaddr);
+	pud_t *pud = pud_offset(p4d, vaddr);
+	pmd_t *pmd = pmd_offset(pud, vaddr);
+
+	return pte_offset_map(pmd, vaddr);
+}
+
+static int proclocal_map(struct mm_struct *mm, unsigned long vaddr)
+{
+	struct page *page;
+	pte_t *pte = pte_lookup(mm, vaddr);
+
+	page = alloc_page(GFP_KERNEL | __GFP_ZERO);
+	if (!page)
+		goto fail;
+
+	PRL_DBG("allocated %p\n", page);
+	set_pte(pte, mk_pte(page, kmap_prot));
+
+	/*
+	 * Remove mapping from direct mapping. This also flushes the TLB.
+	 */
+	__kernel_map_pages(page, 1, false);
+
+	return 0;
+fail:
+	return 1;
+}
+
+static int proclocal_unmap(struct mm_struct *mm, unsigned long vaddr)
+{
+	pte_t *ptep = pte_lookup(mm, vaddr);
+	pte_t pte = ptep_get_and_clear(mm, vaddr, ptep);
+	struct page *page = pfn_to_page(pte_pfn(pte));
+
+	/* Restore direct mapping and flush TLB. */
+	__kernel_map_pages(page, 1, true);
+
+	PRL_DBG("freeing %p\n", page);
+	__free_pages(page, 0);
+
+	return 0;
+}
+
+int kalloc_proclocal(struct proclocal *pl, size_t len)
+{
+	struct mm_struct *mm = current->mm;
+	size_t nr_pages = round_up(len, PAGE_SIZE) / PAGE_SIZE;
+	int order, free_page_off;
+	unsigned long vaddr;
+	size_t i;
+	
+	PRL_DBG("%s: mm=%lx len=%zu -> nr_pages=%zu\n",
+		(unsigned long)mm, len, nr_pages);
+
+	might_sleep();
+	BUG_ON(!mm);
+
+	if (len == 0)
+		goto fail;
+
+	down_write(&mm->mmap_sem);
+
+	if (mm->proclocal_in_use_pages == 0 && proclocal_init(mm))
+		goto fail_unlock;
+
+	order = get_count_order(nr_pages);
+	nr_pages = 1U << order;
+
+	free_page_off = bitmap_find_free_region(mm->proclocal_bitmap, MAX_PROCLOCAL_PAGES, order);
+	if (free_page_off < 0) {
+		goto fail_unlock;
+	}
+
+	vaddr = PROCLOCAL_START + free_page_off * PAGE_SIZE;
+
+	for (i = 0; i < nr_pages; i++) {
+		if (proclocal_map(mm, vaddr + i*PAGE_SIZE)) {
+			/* TODO Cleanup */
+			BUG();
+		}
+	}
+
+	up_write(&mm->mmap_sem);
+
+	mm->proclocal_in_use_pages += nr_pages;
+
+	pl->alloc = (void *)vaddr;
+	pl->order = order;
+	pl->mm = mm;
+
+	/* Keep the mm_struct around as long as there are mappings in it. */
+	mmgrab(mm);
+
+	return 0;
+fail_unlock:
+	up_write(&mm->mmap_sem);
+fail:
+	return -1;
+}
+EXPORT_SYMBOL_GPL(kalloc_proclocal);
+
+void kfree_proclocal(struct proclocal *pl)
+{
+	unsigned long vaddr = (unsigned long)pl->alloc;
+	size_t nr_pages = 1U << pl->order;
+	size_t i;
+
+	PRL_DBG("vaddr=%lx mm=%lx nr_pages=%zu\n",
+		vaddr, (unsigned long)pl->mm, nr_pages);
+
+	BUG_ON(!vaddr);
+	BUG_ON(!pl->mm);
+
+	BUG_ON(vaddr < PROCLOCAL_START);
+	BUG_ON(vaddr + nr_pages*PAGE_SIZE >= PROCLOCAL_END);
+
+	might_sleep();
+
+	/*
+	 * TODO mm_users may already be 0 here. Is it still safe to take the
+	 * mmap_sem?
+	 */
+	down_write(&pl->mm->mmap_sem);
+
+	for (i = 0; i < nr_pages; i++) {
+		if (proclocal_unmap(pl->mm, vaddr + i*PAGE_SIZE)) {
+			/* TODO Cleanup */
+			BUG();
+		}
+	}
+
+	bitmap_release_region(pl->mm->proclocal_bitmap,
+			      (vaddr - PROCLOCAL_START) >> PAGE_SHIFT, pl->order);
+	pl->mm->proclocal_in_use_pages -= nr_pages;
+
+	if (pl->mm->proclocal_in_use_pages == 0) {
+		proclocal_cleanup(pl->mm);
+	}
+
+	up_write(&pl->mm->mmap_sem);
+	mmdrop(pl->mm);
+}
+EXPORT_SYMBOL_GPL(kfree_proclocal);
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 5ed8f6292a53..ca92328cd442 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -491,6 +491,13 @@ struct mm_struct {
 		/* HMM needs to track a few things per mm */
 		struct hmm *hmm;
 #endif
+
+#ifdef CONFIG_PROCLOCAL
+		/* Number of pages still in use */
+		size_t proclocal_in_use_pages;
+
+		unsigned long *proclocal_bitmap;
+#endif
 	} __randomize_layout;
 
 	/*
diff --git a/security/Kconfig b/security/Kconfig
index d9aa521b5206..db8149a083e1 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -6,6 +6,22 @@ menu "Security options"
 
 source security/keys/Kconfig
 
+config ARCH_SUPPORTS_PROCLOCAL
+	bool
+
+config PROCLOCAL
+	bool "Support process-local allocations in the kernel"
+	depends on ARCH_SUPPORTS_PROCLOCAL
+	default n
+	help
+	  This feature allows subsystems in the kernel to allocate memory that
+	  is only visible in the context of a specific process. This hardens the
+	  kernel against information leak vulnerabilities.
+
+	  There is a slight performance impact when this option is enabled.
+
+	  If you are unsure how to answer this question, answer N.
+
 config SECURITY_DMESG_RESTRICT
 	bool "Restrict unprivileged access to the kernel syslog"
 	default n
-- 
2.17.1

