Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 08:29:41 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga008.jf.intel.com (orsmga008.jf.intel.com [10.7.209.65])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 580A958037D;
	Thu, 22 Nov 2018 08:50:19 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga008-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 08:50:18 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AY9WkvBQaRQaMS/eJ1R4LROBeXtpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YRKGt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94VQnZPUMZPWiBYG4+y?=
 =?us-ascii?q?bZYAD/AYMehFson9vEMOogWiCgmwHe/vzjhIh3Hr1qE+0+ktFAfL0ws8EdwOrn?=
 =?us-ascii?q?nYtcz5OqUPXuCv1aXG0CjDb+hO2Tjj9IfIbg0qrfWSUb5sdMbcz1QkGQHYgVWK?=
 =?us-ascii?q?sYHrPy2b2PkDvWaY6ORvV+yvhGwpqwFqujiixNwhhpXVio8P1lzJ7zl1zJozKN?=
 =?us-ascii?q?alSEB7e9mkEJ5Iui+eKot2RsIiTHtuuC0n17MGpYC0czQJyJQjxh7fbeaIeJWP?=
 =?us-ascii?q?7xLhT+aRPSl3i25meLK7hha/6lKvyujmWci111ZKqDBJncTSuX0U0RHY98uJSu?=
 =?us-ascii?q?Nl80u/xTqC0xrf5vxKLEwqj6bXNp0szqIqmpcSs0nPBjH6lFn0gaOMa0kp+PWk?=
 =?us-ascii?q?5/76brjlqZKQLZF4hwH4P68zgMKwG/44PRILX2WD+eSzyrnj/UrhTbVUgf05jL?=
 =?us-ascii?q?PZvIrZJcsFvK65BRFa0oI55xa4FTem38wUnXgBLF1bZBKKl5blN03KLfziEPuy?=
 =?us-ascii?q?jUqgnC12y/3FIrHtGJTAI3rbnLfkZ7l96kpcyAQpzdBY4pJZErUBIPP1Wk/su9?=
 =?us-ascii?q?3UFxw5PBKuw+bhFtp90poSWWWBA6+fLqzSq0SF5vwgI+aSfo8ZojX9JOY/5/7o?=
 =?us-ascii?q?k3A5nUURfa6z3ZsYcHy4BOhpI12FYXrwhdcMCWMKvgs9TOP0klGDXiNTam22X6?=
 =?us-ascii?q?I94DE7FY2nAZ3CRoCrnLyOwiO7EodKaWBBD1CGCW3oeJmcW/cQdCKSJddskjwe?=
 =?us-ascii?q?WrigV48uzxauuBX6y7p6NOXU/CIYuInn1Nh04e3TiB4z+SZ1D8Sbz2GCUWV0kn?=
 =?us-ascii?q?kUSD8x2aB1uVZ9xUub0ahkn/xYEsRe5/FOUggkL5LczOt6C9b0WgLGZdqJTFem?=
 =?us-ascii?q?QtO7ATA+VN4xwtkOY1pjFNWmlBzMwy2qA7oNnbyRGJM06r7c32T2J8tl0XnGz6?=
 =?us-ascii?q?khj14lQsdVL22pnKx/+hPXB47IlUWZiqmreb4d3C7L6GeM026OsFtEXw53VKXP?=
 =?us-ascii?q?RWofaVfOrdTl+kPCSKejCbc9PQtH08KCLqpKZcfvjVVJX/rjPNXeY2Ssm2a/Hx?=
 =?us-ascii?q?qIx7WMbJb0dGUZxinSFE8EkwUL93acKQc+Hjuho37ZDDF2CF3geV3s/vdkpHO7?=
 =?us-ascii?q?VEA0yRqKYFNn17ay/h4VhvmcS/cI07IAuSchrSh0HVmn09LXDdqAuxRufKFGbd?=
 =?us-ascii?q?wh51dH0HrTtxZhMZy4M6BimlkefhxqsEz0yRV4FJ9Mkcgwo3Ms1wp9N6SY3UhF?=
 =?us-ascii?q?dzOZ25DwJ7LWJnPz/BCpd67ZxFXe3MyK9acI7fQys0/jsx2xFko+73Vn1MFY02?=
 =?us-ascii?q?ed5pXPCwoSTZLxU0Yt+xhmvb3aZTM954fV1X1qPqm5qTvC29MvBOs4xResZdZf?=
 =?us-ascii?q?MKWYFADsF80WHdShKOsvm1KxdBILIPhS9LIoP8Ohb/aJwqqrM/hvnT24jWVL+p?=
 =?us-ascii?q?ty0l+R+CVmTO7I3JEFw++D0wuDVjf8ikqhs8/tlYBFYzESAnSwySz+CIFNYa1y?=
 =?us-ascii?q?eJ4BCX2yLM2v2tV+m5ntVmZY9V6+HV8JxNWleBuSb1Pn2w1Q2l8aoXimmSu+0j?=
 =?us-ascii?q?x1nCslrquZ3CzS3evicAALNXJMRGlnlV3sO5S7j8gGXEi0aAgkjAGl5UfmyKdB?=
 =?us-ascii?q?vqRwMm7TTV1OfyfoNWFiU7K8uaaYbM5L9Zwnrz9XUOO6YV2BTr79oh0a0z7sHm?=
 =?us-ascii?q?dExTA7cS2qtYv9nxBglG2dK3NzpmLDec5s3Rff+MDcRflJ0zsGRSl0kznWCkKn?=
 =?us-ascii?q?P9m0+9WZjJPDsuG4V2K8WZxfayjrzYWctCSl4W1mGwGwn/e2mtf/Cwg1zTf718?=
 =?us-ascii?q?V2VSXPtBv8YJPk1765MeJkeUlkHkT85NB5GoF9k4swgo8f2X4Bi5WR/HoHl3rz?=
 =?us-ascii?q?MNpB1aL/anoNWSAEw9rP7Af5301jK2qDx5jlWXWF3sthe966b3sW2y0n6MBGEq?=
 =?us-ascii?q?WU7L1CnSZuplq4rATRYeVynzsHyPsu7mIajP8NuAY30iqdBbUSF1FCPSPwjxSI?=
 =?us-ascii?q?88y+rKJPaWasa7ew1VByndC8DL6YpAFcV230epMjHS9288V+P0jA0Hz16oH4Zt?=
 =?us-ascii?q?bQacgfuQGTkxfFl+JVMo4+luIWhSp7PmLwpXgly+84jRN0x527spaIK35x/K2n?=
 =?us-ascii?q?GB5XLSP6Z9kc+jz2iaZen8CW352gH5l7GzULWofoQuysED4IqfvnMAOOGiUmqn?=
 =?us-ascii?q?iHAbrfAROf6EB+onLTFJCrMmubJXgDwtVkWRmdP1dfgAEPUTU+n545EB2qxcP7?=
 =?us-ascii?q?fEd44DAR+kD3qh9Wxu10MBn/V3/VpB20ZTcsVJifMB1W4xlZ6EjPNsye6v9zEz?=
 =?us-ascii?q?tc/p28twGNLm2bZwJVDWAGQECEBlbjPqWw6tnE6eSXGu2+L/7Wa7WUteNeT+uI?=
 =?us-ascii?q?xY6o0oZ+/TaDLMCPMWd5D/EhxkpPR3N5G9namzUSTSwYjTnNYtWfpBe9/C13s8?=
 =?us-ascii?q?++/O7qWALp+YuAFb9SPc9z9BCxhKeJL/SQizphKTZEypMMwmfFybgY3F4PkiFu?=
 =?us-ascii?q?aiOiEbIauS7WS6LQnKBXAgUfayNyMstI8q090hNMOc7dltP6yLp4guQpBFdCUF?=
 =?us-ascii?q?zrgtupatASI2GhKFPHA16GNLSYKj3KwMH3YqK8RadTjOVOsB2wtiiUE1X+PjSY?=
 =?us-ascii?q?jDTpUxGvMedRjCCUJhBeuYe9cgpzBmjnVt7pdhq7MNpvhz0s3bI0nm/KNXIbMT?=
 =?us-ascii?q?VkaUxNs6af7TlGjfR/AWBB6ntlIPKAmyaY6enYN5kXveFqAiRyi+JV/nA6x6FJ?=
 =?us-ascii?q?4yFDQfx/gDHSocJ2o1G6jumPzSJqUAZPqjZOno6EoV9uNrnZ9pZeX3bJ5xYN7W?=
 =?us-ascii?q?SWCxQXqNppENzvu6ZMytfRkKL/MitN89XR/cEEHcjbNNqHMGY9MRruADPVDBEK?=
 =?us-ascii?q?TTiuNWHegUxSiPCT9n2PoZg8pZjhg54OSr5dVFwoGfIWEEVlHNoeIJhpWjMoi6?=
 =?us-ascii?q?KUjMkN5Sn2kB6ER8hAuJ3DE/KbG/niLjefgpFAZgAU2vX/NYkVKYT/3wppbVwp?=
 =?us-ascii?q?sp7NHh/yQNRMqyspVRM5q0ZJ8X53BjkxwF7oYQCp4VcaEPemmRhwhgYoMrdlzy?=
 =?us-ascii?q?vl/1pifgmCnyA3ikRk3Iq4jA=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0BrAwBV3fZbh0O0hNFihQFwEieMb4shA?=
 =?us-ascii?q?YFoOYkEhR6Kew4BARgDEAGIUiI4EgEDAQEBAQEBAgETAQEBCA0JCCkjDII2JIJ?=
 =?us-ascii?q?jAwMBAg4JDRkBATcBBQkBAVADVBkFgxwBgXQNBZJSAQGJDgGMT4FsM4J2AQEFh?=
 =?us-ascii?q?xoIh16DD4EcF4FAP4ERM4V6AoFNhW+JJYFulHEJHXSFa4ozGIFZTYcrNocBmAk?=
 =?us-ascii?q?CBAsCEwGBXYF2TSQUgycJgh4Xg32FWoRGPgEBMYEFAQGKCIJMAQE?=
X-IPAS-Result: =?us-ascii?q?A0BrAwBV3fZbh0O0hNFihQFwEieMb4shAYFoOYkEhR6Kew4?=
 =?us-ascii?q?BARgDEAGIUiI4EgEDAQEBAQEBAgETAQEBCA0JCCkjDII2JIJjAwMBAg4JDRkBA?=
 =?us-ascii?q?TcBBQkBAVADVBkFgxwBgXQNBZJSAQGJDgGMT4FsM4J2AQEFhxoIh16DD4EcF4F?=
 =?us-ascii?q?AP4ERM4V6AoFNhW+JJYFulHEJHXSFa4ozGIFZTYcrNocBmAkCBAsCEwGBXYF2T?=
 =?us-ascii?q?SQUgycJgh4Xg32FWoRGPgEBMYEFAQGKCIJMAQE?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="52996545"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 08:50:16 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2405997AbeKWDaX (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 22:30:23 -0500
Received: from smtp-fw-9101.amazon.com ([207.171.184.25]:39565 "EHLO
        smtp-fw-9101.amazon.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2404359AbeKWDaX (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 22:30:23 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
  d=amazon.de; i=@amazon.de; q=dns/txt; s=amazon201209;
  t=1542905411; x=1574441411;
  h=from:to:cc:subject:date:message-id;
  bh=HPgIZQKZrYaysE0I6hPLeVIB9cTT1aK3/gzMyh66vww=;
  b=nV17SHRiq7uVFr1sjv13soLphsfoxl0tZVaUIpIdmUu+lWcDAGhIVFy7
   GnDW17/Nk45yuAC25Hi+1x5bQsBC8+IzzqLAe7Axwp998ln8kcXZllvQ4
   gsnVM2JrldjETz0QJoNOqE+RiSoa1y2kBOz1Sxy9KUvDe6oD8MX8FfWH2
   0=;
X-IronPort-AV: E=Sophos;i="5.56,253,1539648000"; 
   d="scan'208";a="771919563"
Received: from sea3-co-svc-lb6-vlan3.sea.amazon.com (HELO email-inbound-relay-2a-8549039f.us-west-2.amazon.com) ([10.47.22.38])
  by smtp-border-fw-out-9101.sea19.amazon.com with ESMTP/TLS/DHE-RSA-AES256-SHA; 22 Nov 2018 16:50:11 +0000
Received: from u54ee758033e858cfa736.ant.amazon.com (pdx2-ws-svc-lb17-vlan3.amazon.com [10.247.140.70])
        by email-inbound-relay-2a-8549039f.us-west-2.amazon.com (8.14.7/8.14.7) with ESMTP id wAMGo48P104633
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
        Thu, 22 Nov 2018 16:50:06 GMT
Received: from u54ee758033e858cfa736.ant.amazon.com (localhost [127.0.0.1])
        by u54ee758033e858cfa736.ant.amazon.com (8.15.2/8.15.2/Debian-3) with ESMTP id wAMGo3Rp008148;
        Thu, 22 Nov 2018 17:50:03 +0100
Received: (from jsteckli@localhost)
        by u54ee758033e858cfa736.ant.amazon.com (8.15.2/8.15.2/Submit) id wAMGo2Zr008135;
        Thu, 22 Nov 2018 17:50:02 +0100
From: Julian Stecklina <jsteckli@amazon.de>
To: kernel-hardening@lists.openwall.com
Cc: Julian Stecklina <jsteckli@amazon.de>,
        Liran Alon <liran.alon@oracle.com>,
        Tycho Andersen <tycho@tycho.ws>,
        Jonathan Adams <jwadams@google.com>,
        David Woodhouse <dwmw2@infradead.org>,
        LKML <linux-kernel@vger.kernel.org>
Subject: [RFC RESEND PATCH 6/6] x86/speculation, kvm: move gprs to process local storage
Date: Thu, 22 Nov 2018 17:49:39 +0100
Message-Id: <a262873a233b9918e63d57cf20bd9a303d356add.1542905228.git.jsteckli@amazon.de>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <cover.1542905228.git.jsteckli@amazon.de>
References: <cover.1542905228.git.jsteckli@amazon.de>
In-Reply-To: <cover.1542905228.git.jsteckli@amazon.de>
References: <cover.1542905228.git.jsteckli@amazon.de>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

General-purpose registers (GPRs) contain guest data and must be protected
from information leak vulnerabilities in the kernel.

Move GPRs into process local memory and change the VMX and SVM world
switch and related code accordingly.

Note: Only Intel VMX support is tested.

Signed-off-by: Julian Stecklina <jsteckli@amazon.de>
---
 arch/x86/include/asm/kvm_host.h |  11 +--
 arch/x86/kvm/kvm_cache_regs.h   |   4 +-
 arch/x86/kvm/svm.c              | 132 ++++++++++++++++-------------
 arch/x86/kvm/vmx.c              | 142 ++++++++++++++++++--------------
 arch/x86/kvm/x86.c              |   3 +-
 5 files changed, 164 insertions(+), 128 deletions(-)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 5dd29bfef77f..bffd3e35232c 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -532,17 +532,18 @@ struct kvm_vcpu_hv {
 };
 
 struct kvm_vcpu_arch_hidden {
+	/*
+	 * rip and regs accesses must go through
+	 * kvm_{register,rip}_{read,write} functions.
+	 */
+	unsigned long regs[NR_VCPU_REGS];
+
 	struct fpu guest_fpu;
 };
 
 struct kvm_vcpu_arch {
 	struct proclocal hidden;
 
-	/*
-	 * rip and regs accesses must go through
-	 * kvm_{register,rip}_{read,write} functions.
-	 */
-	unsigned long regs[NR_VCPU_REGS];
 	u32 regs_avail;
 	u32 regs_dirty;
 
diff --git a/arch/x86/kvm/kvm_cache_regs.h b/arch/x86/kvm/kvm_cache_regs.h
index 9619dcc2b325..b270e38abb5f 100644
--- a/arch/x86/kvm/kvm_cache_regs.h
+++ b/arch/x86/kvm/kvm_cache_regs.h
@@ -13,14 +13,14 @@ static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,
 	if (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))
 		kvm_x86_ops->cache_reg(vcpu, reg);
 
-	return vcpu->arch.regs[reg];
+	return kvm_arch_vcpu_hidden_get(vcpu)->regs[reg];
 }
 
 static inline void kvm_register_write(struct kvm_vcpu *vcpu,
 				      enum kvm_reg reg,
 				      unsigned long val)
 {
-	vcpu->arch.regs[reg] = val;
+	kvm_arch_vcpu_hidden_get(vcpu)->regs[reg] = val;
 	__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);
 	__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);
 }
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index f416f5c7f2ae..ca86efcdfc49 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -1568,7 +1568,7 @@ static void init_vmcb(struct vcpu_svm *svm)
 	save->dr6 = 0xffff0ff0;
 	kvm_set_rflags(&svm->vcpu, 2);
 	save->rip = 0x0000fff0;
-	svm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;
+	kvm_arch_vcpu_hidden_get(&svm->vcpu)->regs[VCPU_REGS_RIP] = save->rip;
 
 	/*
 	 * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.
@@ -3094,7 +3094,7 @@ static int nested_svm_exit_handled_msr(struct vcpu_svm *svm)
 	if (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))
 		return NESTED_EXIT_HOST;
 
-	msr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];
+	msr    = kvm_arch_vcpu_hidden_get(&svm->vcpu)->regs[VCPU_REGS_RCX];
 	offset = svm_msrpm_offset(msr);
 	write  = svm->vmcb->control.exit_info_1 & 1;
 	mask   = 1 << ((2 * (msr & 0xf)) + write);
@@ -5548,10 +5548,11 @@ static void svm_cancel_injection(struct kvm_vcpu *vcpu)
 static void svm_vcpu_run(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
+	unsigned long *regs = kvm_arch_vcpu_hidden_get(vcpu)->regs;
 
-	svm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];
-	svm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];
-	svm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];
+	svm->vmcb->save.rax = regs[VCPU_REGS_RAX];
+	svm->vmcb->save.rsp = regs[VCPU_REGS_RSP];
+	svm->vmcb->save.rip = regs[VCPU_REGS_RIP];
 
 	/*
 	 * A vmexit emulation is required before the vcpu can be executed
@@ -5595,23 +5596,24 @@ static void svm_vcpu_run(struct kvm_vcpu *vcpu)
 	local_irq_enable();
 
 	asm volatile (
-		"push %%" _ASM_BP "; \n\t"
-		"mov %c[rbx](%[svm]), %%" _ASM_BX " \n\t"
-		"mov %c[rcx](%[svm]), %%" _ASM_CX " \n\t"
-		"mov %c[rdx](%[svm]), %%" _ASM_DX " \n\t"
-		"mov %c[rsi](%[svm]), %%" _ASM_SI " \n\t"
-		"mov %c[rdi](%[svm]), %%" _ASM_DI " \n\t"
-		"mov %c[rbp](%[svm]), %%" _ASM_BP " \n\t"
+		"push %%" _ASM_BP "; push %%" _ASM_CX "; \n\t"
+		"push $0 \n\t"	/* placeholder for guest rcx */
+		"mov %c[rbx](%[regs]), %%" _ASM_BX " \n\t"
+		"mov %c[rdx](%[regs]), %%" _ASM_DX " \n\t"
+		"mov %c[rsi](%[regs]), %%" _ASM_SI " \n\t"
+		"mov %c[rdi](%[regs]), %%" _ASM_DI " \n\t"
+		"mov %c[rbp](%[regs]), %%" _ASM_BP " \n\t"
 #ifdef CONFIG_X86_64
-		"mov %c[r8](%[svm]),  %%r8  \n\t"
-		"mov %c[r9](%[svm]),  %%r9  \n\t"
-		"mov %c[r10](%[svm]), %%r10 \n\t"
-		"mov %c[r11](%[svm]), %%r11 \n\t"
-		"mov %c[r12](%[svm]), %%r12 \n\t"
-		"mov %c[r13](%[svm]), %%r13 \n\t"
-		"mov %c[r14](%[svm]), %%r14 \n\t"
-		"mov %c[r15](%[svm]), %%r15 \n\t"
+		"mov %c[r8](%[regs]),  %%r8  \n\t"
+		"mov %c[r9](%[regs]),  %%r9  \n\t"
+		"mov %c[r10](%[regs]), %%r10 \n\t"
+		"mov %c[r11](%[regs]), %%r11 \n\t"
+		"mov %c[r12](%[regs]), %%r12 \n\t"
+		"mov %c[r13](%[regs]), %%r13 \n\t"
+		"mov %c[r14](%[regs]), %%r14 \n\t"
+		"mov %c[r15](%[regs]), %%r15 \n\t"
 #endif
+		"mov %c[rcx](%[regs]), %%" _ASM_CX " \n\t" /* destroys %[regs] */
 
 		/* Enter guest mode */
 		"push %%" _ASM_AX " \n\t"
@@ -5621,22 +5623,34 @@ static void svm_vcpu_run(struct kvm_vcpu *vcpu)
 		__ex(SVM_VMSAVE) "\n\t"
 		"pop %%" _ASM_AX " \n\t"
 
+		/*
+		 * Stack layout at this point (x86_64)
+		 *
+		 * [RSP + 16] = RBP
+		 * [RSP +  8] = vcpu_hidden pointer
+		 * [RSP +  0] = Space for guest RCX
+		 */
+
+		"mov %[regs], (%%" _ASM_SP ") \n\t" /* save guest RCX */
+		"mov %c[wordsize](%%" _ASM_SP"), %[regs] \n\t"
+
 		/* Save guest registers, load host registers */
-		"mov %%" _ASM_BX ", %c[rbx](%[svm]) \n\t"
-		"mov %%" _ASM_CX ", %c[rcx](%[svm]) \n\t"
-		"mov %%" _ASM_DX ", %c[rdx](%[svm]) \n\t"
-		"mov %%" _ASM_SI ", %c[rsi](%[svm]) \n\t"
-		"mov %%" _ASM_DI ", %c[rdi](%[svm]) \n\t"
-		"mov %%" _ASM_BP ", %c[rbp](%[svm]) \n\t"
+		"mov %%" _ASM_BX ", %c[rbx](%[regs]) \n\t"
+		__ASM_SIZE(pop)  "  %c[rcx](%[regs]) \n\t"
+		"mov %%" _ASM_CX ", %c[rcx](%[regs]) \n\t"
+		"mov %%" _ASM_DX ", %c[rdx](%[regs]) \n\t"
+		"mov %%" _ASM_SI ", %c[rsi](%[regs]) \n\t"
+		"mov %%" _ASM_DI ", %c[rdi](%[regs]) \n\t"
+		"mov %%" _ASM_BP ", %c[rbp](%[regs]) \n\t"
 #ifdef CONFIG_X86_64
-		"mov %%r8,  %c[r8](%[svm]) \n\t"
-		"mov %%r9,  %c[r9](%[svm]) \n\t"
-		"mov %%r10, %c[r10](%[svm]) \n\t"
-		"mov %%r11, %c[r11](%[svm]) \n\t"
-		"mov %%r12, %c[r12](%[svm]) \n\t"
-		"mov %%r13, %c[r13](%[svm]) \n\t"
-		"mov %%r14, %c[r14](%[svm]) \n\t"
-		"mov %%r15, %c[r15](%[svm]) \n\t"
+		"mov %%r8,  %c[r8](%[regs]) \n\t"
+		"mov %%r9,  %c[r9](%[regs]) \n\t"
+		"mov %%r10, %c[r10](%[regs]) \n\t"
+		"mov %%r11, %c[r11](%[regs]) \n\t"
+		"mov %%r12, %c[r12](%[regs]) \n\t"
+		"mov %%r13, %c[r13](%[regs]) \n\t"
+		"mov %%r14, %c[r14](%[regs]) \n\t"
+		"mov %%r15, %c[r15](%[regs]) \n\t"
 		/*
 		* Clear host registers marked as clobbered to prevent
 		* speculative use.
@@ -5655,29 +5669,31 @@ static void svm_vcpu_run(struct kvm_vcpu *vcpu)
 		"xor %%edx, %%edx \n\t"
 		"xor %%esi, %%esi \n\t"
 		"xor %%edi, %%edi \n\t"
-		"pop %%" _ASM_BP
+		"pop %%" _ASM_CX " \n\t"
+		"pop %%" _ASM_BP " \n\t"
 		:
-		: [svm]"a"(svm),
+		: [svm]"a"(svm), [regs]"c"(regs),
 		  [vmcb]"i"(offsetof(struct vcpu_svm, vmcb_pa)),
-		  [rbx]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),
-		  [rcx]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),
-		  [rdx]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),
-		  [rsi]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),
-		  [rdi]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),
-		  [rbp]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))
+		  [rbx]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RBX])),
+		  [rcx]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RCX])),
+		  [rdx]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RDX])),
+		  [rsi]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RSI])),
+		  [rdi]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RDI])),
+		  [rbp]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RBP]))
 #ifdef CONFIG_X86_64
-		  , [r8]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),
-		  [r9]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),
-		  [r10]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),
-		  [r11]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),
-		  [r12]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),
-		  [r13]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),
-		  [r14]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),
-		  [r15]"i"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))
+		  , [r8]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R8])),
+		  [r9]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R9])),
+		  [r10]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R10])),
+		  [r11]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R11])),
+		  [r12]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R12])),
+		  [r13]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R13])),
+		  [r14]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R14])),
+		  [r15]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R15])),
+		  [wordsize]"i"(sizeof(ulong))
 #endif
 		: "cc", "memory"
 #ifdef CONFIG_X86_64
-		, "rbx", "rcx", "rdx", "rsi", "rdi"
+		, "rbx", "rdx", "rsi", "rdi"
 		, "r8", "r9", "r10", "r11" , "r12", "r13", "r14", "r15"
 #else
 		, "ebx", "ecx", "edx", "esi", "edi"
@@ -5721,9 +5737,9 @@ static void svm_vcpu_run(struct kvm_vcpu *vcpu)
 	x86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);
 
 	vcpu->arch.cr2 = svm->vmcb->save.cr2;
-	vcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;
-	vcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;
-	vcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
+	regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;
+	regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;
+	regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;
 
 	if (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))
 		kvm_before_interrupt(&svm->vcpu);
@@ -6150,14 +6166,16 @@ static int svm_pre_enter_smm(struct kvm_vcpu *vcpu, char *smstate)
 	int ret;
 
 	if (is_guest_mode(vcpu)) {
+		unsigned long *regs = kvm_arch_vcpu_hidden_get(vcpu)->regs;
+
 		/* FED8h - SVM Guest */
 		put_smstate(u64, smstate, 0x7ed8, 1);
 		/* FEE0h - SVM Guest VMCB Physical Address */
 		put_smstate(u64, smstate, 0x7ee0, svm->nested.vmcb);
 
-		svm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];
-		svm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];
-		svm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];
+		svm->vmcb->save.rax = regs[VCPU_REGS_RAX];
+		svm->vmcb->save.rsp = regs[VCPU_REGS_RSP];
+		svm->vmcb->save.rip = regs[VCPU_REGS_RIP];
 
 		ret = nested_svm_vmexit(svm);
 		if (ret)
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 8ebd41d935b8..21959e0a9588 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -4364,10 +4364,10 @@ static void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)
 	__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);
 	switch (reg) {
 	case VCPU_REGS_RSP:
-		vcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);
+		kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);
 		break;
 	case VCPU_REGS_RIP:
-		vcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);
+		kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);
 		break;
 	case VCPU_EXREG_PDPTR:
 		if (enable_ept)
@@ -6704,7 +6704,7 @@ static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 	vmx->spec_ctrl = 0;
 
 	vcpu->arch.microcode_version = 0x100000000ULL;
-	vmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();
+	kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RDX] = get_rdx_init_val();
 	kvm_set_cr8(vcpu, 0);
 
 	if (!init_event) {
@@ -7440,7 +7440,7 @@ static int handle_cpuid(struct kvm_vcpu *vcpu)
 
 static int handle_rdmsr(struct kvm_vcpu *vcpu)
 {
-	u32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];
+	u32 ecx = kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RCX];
 	struct msr_data msr_info;
 
 	msr_info.index = ecx;
@@ -7454,17 +7454,17 @@ static int handle_rdmsr(struct kvm_vcpu *vcpu)
 	trace_kvm_msr_read(ecx, msr_info.data);
 
 	/* FIXME: handling of bits 32:63 of rax, rdx */
-	vcpu->arch.regs[VCPU_REGS_RAX] = msr_info.data & -1u;
-	vcpu->arch.regs[VCPU_REGS_RDX] = (msr_info.data >> 32) & -1u;
+	kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RAX] = msr_info.data & -1u;
+	kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RDX] = (msr_info.data >> 32) & -1u;
 	return kvm_skip_emulated_instruction(vcpu);
 }
 
 static int handle_wrmsr(struct kvm_vcpu *vcpu)
 {
 	struct msr_data msr;
-	u32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];
-	u64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)
-		| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);
+	u32 ecx = kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RCX];
+	u64 data = (kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RAX] & -1u)
+		| ((u64)(kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RDX] & -1u) << 32);
 
 	msr.data = data;
 	msr.index = ecx;
@@ -9735,7 +9735,7 @@ static bool valid_ept_address(struct kvm_vcpu *vcpu, u64 address)
 static int nested_vmx_eptp_switching(struct kvm_vcpu *vcpu,
 				     struct vmcs12 *vmcs12)
 {
-	u32 index = vcpu->arch.regs[VCPU_REGS_RCX];
+	u32 index = kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RCX];
 	u64 address;
 	bool accessed_dirty;
 	struct kvm_mmu *mmu = vcpu->arch.walk_mmu;
@@ -9781,7 +9781,7 @@ static int handle_vmfunc(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	struct vmcs12 *vmcs12;
-	u32 function = vcpu->arch.regs[VCPU_REGS_RAX];
+	u32 function = kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RAX];
 
 	/*
 	 * VMFUNC is only supported for nested guests, but we always enable the
@@ -9940,7 +9940,7 @@ static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,
 static bool nested_vmx_exit_handled_msr(struct kvm_vcpu *vcpu,
 	struct vmcs12 *vmcs12, u32 exit_reason)
 {
-	u32 msr_index = vcpu->arch.regs[VCPU_REGS_RCX];
+	u32 msr_index = kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RCX];
 	gpa_t bitmap;
 
 	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))
@@ -11166,9 +11166,9 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 	}
 
 	if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))
-		vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);
+		vmcs_writel(GUEST_RSP, kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RSP]);
 	if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))
-		vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);
+		vmcs_writel(GUEST_RIP, kvm_arch_vcpu_hidden_get(vcpu)->regs[VCPU_REGS_RIP]);
 
 	cr3 = __get_current_cr3_fast();
 	if (unlikely(cr3 != vmx->loaded_vmcs->host_state.cr3)) {
@@ -11221,7 +11221,9 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 	asm(
 		/* Store host registers */
 		"push %%" _ASM_DX "; push %%" _ASM_BP ";"
-		"push %%" _ASM_CX " \n\t" /* placeholder for guest rcx */
+		"push $0\n\t" /* placeholder for guest rbx */
+		"push $0\n\t" /* placeholder for guest rcx */
+		"push %%" _ASM_BX " \n\t"
 		"push %%" _ASM_CX " \n\t"
 		"cmp %%" _ASM_SP ", %c[host_rsp](%0) \n\t"
 		"je 1f \n\t"
@@ -11237,23 +11239,23 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 		/* Check if vmlaunch of vmresume is needed */
 		"cmpl $0, %c[launched](%0) \n\t"
 		/* Load guest registers.  Don't clobber flags. */
-		"mov %c[rax](%0), %%" _ASM_AX " \n\t"
-		"mov %c[rbx](%0), %%" _ASM_BX " \n\t"
-		"mov %c[rdx](%0), %%" _ASM_DX " \n\t"
-		"mov %c[rsi](%0), %%" _ASM_SI " \n\t"
-		"mov %c[rdi](%0), %%" _ASM_DI " \n\t"
-		"mov %c[rbp](%0), %%" _ASM_BP " \n\t"
+		"mov %c[rax](%1), %%" _ASM_AX " \n\t"
+		"mov %c[rcx](%1), %%" _ASM_CX " \n\t" /* kills %0 (ecx) */
+		"mov %c[rdx](%1), %%" _ASM_DX " \n\t"
+		"mov %c[rsi](%1), %%" _ASM_SI " \n\t"
+		"mov %c[rdi](%1), %%" _ASM_DI " \n\t"
+		"mov %c[rbp](%1), %%" _ASM_BP " \n\t"
 #ifdef CONFIG_X86_64
-		"mov %c[r8](%0),  %%r8  \n\t"
-		"mov %c[r9](%0),  %%r9  \n\t"
-		"mov %c[r10](%0), %%r10 \n\t"
-		"mov %c[r11](%0), %%r11 \n\t"
-		"mov %c[r12](%0), %%r12 \n\t"
-		"mov %c[r13](%0), %%r13 \n\t"
-		"mov %c[r14](%0), %%r14 \n\t"
-		"mov %c[r15](%0), %%r15 \n\t"
+		"mov %c[r8](%1),  %%r8  \n\t"
+		"mov %c[r9](%1),  %%r9  \n\t"
+		"mov %c[r10](%1), %%r10 \n\t"
+		"mov %c[r11](%1), %%r11 \n\t"
+		"mov %c[r12](%1), %%r12 \n\t"
+		"mov %c[r13](%1), %%r13 \n\t"
+		"mov %c[r14](%1), %%r14 \n\t"
+		"mov %c[r15](%1), %%r15 \n\t"
 #endif
-		"mov %c[rcx](%0), %%" _ASM_CX " \n\t" /* kills %0 (ecx) */
+		"mov %c[rbx](%1), %%" _ASM_BX " \n\t" /* kills %1 (ebx) */
 
 		/* Enter guest mode */
 		"jne 1f \n\t"
@@ -11261,57 +11263,71 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 		"jmp 2f \n\t"
 		"1: " __ex("vmresume") "\n\t"
 		"2: "
+
+		/*
+		 * Stack layout at this point (x86_64):
+		 *
+		 * [RSP + 40] = RDX
+		 * [RSP + 32] = RBP
+		 * [RSP + 24] = Space for guest RBX
+		 * [RSP + 16] = Space for guest RCX
+		 * [RSP +  8] = vcpu_hidden pointer
+		 * [RSP +  0] = vmx pointer
+		 */
+
 		/* Save guest registers, load host registers, keep flags */
-		"mov %0, %c[wordsize](%%" _ASM_SP ") \n\t"
+		"mov %0, 2*%c[wordsize](%%" _ASM_SP ") \n\t"
+		"mov %1, 3*%c[wordsize](%%" _ASM_SP ") \n\t"
 		"pop %0 \n\t"
+		"pop %1 \n\t"
 		"setbe %c[fail](%0)\n\t"
-		"mov %%" _ASM_AX ", %c[rax](%0) \n\t"
-		"mov %%" _ASM_BX ", %c[rbx](%0) \n\t"
-		__ASM_SIZE(pop) " %c[rcx](%0) \n\t"
-		"mov %%" _ASM_DX ", %c[rdx](%0) \n\t"
-		"mov %%" _ASM_SI ", %c[rsi](%0) \n\t"
-		"mov %%" _ASM_DI ", %c[rdi](%0) \n\t"
-		"mov %%" _ASM_BP ", %c[rbp](%0) \n\t"
+		"mov %%" _ASM_AX ", %c[rax](%1) \n\t"
+		__ASM_SIZE(pop) " %c[rcx](%1) \n\t"
+		__ASM_SIZE(pop) " %c[rbx](%1) \n\t"
+		"mov %%" _ASM_DX ", %c[rdx](%1) \n\t"
+		"mov %%" _ASM_SI ", %c[rsi](%1) \n\t"
+		"mov %%" _ASM_DI ", %c[rdi](%1) \n\t"
+		"mov %%" _ASM_BP ", %c[rbp](%1) \n\t"
 #ifdef CONFIG_X86_64
-		"mov %%r8,  %c[r8](%0) \n\t"
-		"mov %%r9,  %c[r9](%0) \n\t"
-		"mov %%r10, %c[r10](%0) \n\t"
-		"mov %%r11, %c[r11](%0) \n\t"
-		"mov %%r12, %c[r12](%0) \n\t"
-		"mov %%r13, %c[r13](%0) \n\t"
-		"mov %%r14, %c[r14](%0) \n\t"
-		"mov %%r15, %c[r15](%0) \n\t"
+		"mov %%r8,  %c[r8](%1) \n\t"
+		"mov %%r9,  %c[r9](%1) \n\t"
+		"mov %%r10, %c[r10](%1) \n\t"
+		"mov %%r11, %c[r11](%1) \n\t"
+		"mov %%r12, %c[r12](%1) \n\t"
+		"mov %%r13, %c[r13](%1) \n\t"
+		"mov %%r14, %c[r14](%1) \n\t"
+		"mov %%r15, %c[r15](%1) \n\t"
 #endif
 		"pop  %%" _ASM_BP "; pop  %%" _ASM_DX " \n\t"
 		".pushsection .rodata \n\t"
 		".global vmx_return \n\t"
 		"vmx_return: " _ASM_PTR " 2b \n\t"
 		".popsection"
-	      : : "c"(vmx), "d"((unsigned long)HOST_RSP), "S"(evmcs_rsp),
+		: : "c"(vmx), "b" (kvm_arch_vcpu_hidden_get(vcpu)), "d"((unsigned long)HOST_RSP), "S"(evmcs_rsp),
 		[launched]"i"(offsetof(struct vcpu_vmx, __launched)),
 		[fail]"i"(offsetof(struct vcpu_vmx, fail)),
 		[host_rsp]"i"(offsetof(struct vcpu_vmx, host_rsp)),
-		[rax]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),
-		[rbx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),
-		[rcx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),
-		[rdx]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),
-		[rsi]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),
-		[rdi]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),
-		[rbp]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),
+		[rax]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RAX])),
+		[rbx]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RBX])),
+		[rcx]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RCX])),
+		[rdx]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RDX])),
+		[rsi]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RSI])),
+		[rdi]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RDI])),
+		[rbp]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_RBP])),
 #ifdef CONFIG_X86_64
-		[r8]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),
-		[r9]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),
-		[r10]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),
-		[r11]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),
-		[r12]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),
-		[r13]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),
-		[r14]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),
-		[r15]"i"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),
+		[r8]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R8])),
+		[r9]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R9])),
+		[r10]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R10])),
+		[r11]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R11])),
+		[r12]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R12])),
+		[r13]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R13])),
+		[r14]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R14])),
+		[r15]"i"(offsetof(struct kvm_vcpu_arch_hidden, regs[VCPU_REGS_R15])),
 #endif
 		[wordsize]"i"(sizeof(ulong))
 	      : "cc", "memory"
 #ifdef CONFIG_X86_64
-		, "rax", "rbx", "rdi"
+		, "rax", "rdi"
 		, "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
 #else
 		, "eax", "ebx", "edi"
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 941fa3209607..9c5fc8e13b17 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -8726,7 +8726,8 @@ void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 		vcpu->arch.xcr0 = XFEATURE_MASK_FP;
 	}
 
-	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
+	memset(kvm_arch_vcpu_hidden_get(vcpu)->regs, 0,
+	       sizeof(kvm_arch_vcpu_hidden_get(vcpu)->regs));
 	vcpu->arch.regs_avail = ~0;
 	vcpu->arch.regs_dirty = ~0;
 
-- 
2.17.1

