Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 08:29:42 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id D0B99580460;
	Thu, 22 Nov 2018 08:50:26 -0800 (PST)
Received: from fmsmga101.fm.intel.com ([10.1.193.65])
  by fmsmga006-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 08:50:26 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AmvtuuBJoS8Gyey+EO9mcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgUL/r6rarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0vRz+s87lkRwPpiC?=
 =?us-ascii?q?cfNj427mfXitBrjKlGpB6tvgFzz5LIbI2QMvdxeb/Tc9MESGZYR8pfVTFOApml?=
 =?us-ascii?q?Y4USEuoBJv5YoJfhqFsStBe+AQ6sBe3ywTNMhnL62Ks33OM9Hw/GwgEsBssCvn?=
 =?us-ascii?q?bJo9XvLascTP21zLLQzTrdc/xWxSr25IzWfhw9pP2BW697f8jMxkk1Dw7Ljkue?=
 =?us-ascii?q?p5HrMT2W0eoCsWab4OhuVeK0k24qqRp8riSzyso2loXEnJ4ZxkzC+C5kwIg1P9?=
 =?us-ascii?q?q4SEtjbNCgDZtQsyCaOJFwQsg/Xm9opDg1xaEFuZ6/fSgKzo4ozAPYZvyFaIiI?=
 =?us-ascii?q?/gzsW/qSITd8hXJoY6iwhxOo/kmhze38UNO430tUoSdclNTHq3MD1wTL58SZVv?=
 =?us-ascii?q?dw+l2t1SuB2gzN8O1IPEM5mbbBJ5MgwLM8joQfvVjBEyPshUn7jrKael859uWr?=
 =?us-ascii?q?5OnreKvqq5+aOoRpkA/xKL4ulda6AekgMggBQWyb+eOk2b398k32Xq9Kguc1kq?=
 =?us-ascii?q?bHqpDaI9oUpqqjDw9SyIYj5A6zDzag0NsGgXkKNExJdA6DgoTzJl3DLu70Ae2i?=
 =?us-ascii?q?j1mvjDtn3fHLM7/5DpXINHfDkbPhfbhn605bzQo+1dRf55NSCrEcL/P/Q0zxu8?=
 =?us-ascii?q?LCDh8/LQO0x//rCNJz14MYR22PGLSUML3dsVCW/OIjOeqMa5EPuDb7Nfcl4+Ti?=
 =?us-ascii?q?jXgjmV8SZaWpx4cYaGikHvR6JEWUeX7sgtYCEWgUpAY/Q/HqhUaGUT5SYXayQq?=
 =?us-ascii?q?096is6CIKgEYfMWIStjKad0ye8G51cfnpGBUyUEXf0a4WEXO8BaCKILc9gjjwL?=
 =?us-ascii?q?T7+hR5Uh1RGzrgD6zbVnI/HQ+i0Zs5Ljydd06/fSlRE06Tx7EcCd33uRQGFzm2?=
 =?us-ascii?q?MCXyU207xnoUxh1leD1rB1g/5fFdNN/f9JUQA6NZjaz+x9EN3yXgPBftGUSFep?=
 =?us-ascii?q?WNmmADcxTs4vzN8KeUpyB9KijhXb1SqwH7AVj6CLBIAz8q/ExXfxPMZ9y3HF1K?=
 =?us-ascii?q?U7lVkpWMlPOHaihq5+8QjTGoHIn1+Yl6asaaQTwirN+H2fwmqJuUFSSBRwXrnd?=
 =?us-ascii?q?XXADekvWqsz05kDYQL+oE7gnNgpBxtSEKqtFcdDpiVRGRPH+ONXReW6xmmGwBQ?=
 =?us-ascii?q?qWybOIdoblZ2Id3CDFAkgejw8T5WqGNRQ5Biq5vm3RFiJuGkz1b0Ps6+Z+rmi7?=
 =?us-ascii?q?QVEyzw2Na01h1L+1+hoOiPyYSvMT2K8EuSg7pzV1Gla9w8zZC96aqwV9e6VcZM?=
 =?us-ascii?q?s34E1b2mLBqwx9IpugIrh/iVEEbQR4oVni1xVtBYVGisglsnUqwRF2KaKZ1lNB?=
 =?us-ascii?q?ajyZ0YrxOr3RNmn94hSvZ7TK1VHZ1dac4r0P5+ggq1X/oAGpEVIv82lm09lQ1H?=
 =?us-ascii?q?uc+pXKDQoIXZLtSEo38AJ6p7XbYik76IPZznlsMaiysj/f1NMlHuolyhC8f9hB?=
 =?us-ascii?q?NKOIDhP9E8ofB8K2Muwlh0Cpbg4YPOBV7KM7JcemeOWJ2aG1POdshimpjXla74?=
 =?us-ascii?q?9n1EKM9C18SvDT0pYBwvGY2BaHVjjmgFegtMD3hZ5LZTUIEmWjzijkAZZbZrdu?=
 =?us-ascii?q?coYTFWeuP8q3y81+hp7wQXJX6ESvBlIG2MCzfxqSYEfw3QlR1UQRvHymljG0zz?=
 =?us-ascii?q?1ykzE1sKWf2DbCzPjldBoCImRLXnVtjU/wIYioiNAXRFKobwk1mxS//0b12q9b?=
 =?us-ascii?q?qL55L2bNW0dIfjH6IH14Xau0q7WNfdRP6JQusShMVOS8YFaaSqPyohcA0iPjGX?=
 =?us-ascii?q?deyy4/dz2wppr5mBl6gnqHLHlvtHrZZd1wxRDH6d3cRP5dxDoHSDNjiTnKAFix?=
 =?us-ascii?q?JN2p/dSSl5feveGyTWOhVptPcSb1yYOMrje05WpvARenhfC8hsXnERQm0S/8z9?=
 =?us-ascii?q?RqVz/HrAz/Yono0KS2K/lncVNrBF//6sp6HJ9xko0riZEU2HgagIiV/HUdnWfy?=
 =?us-ascii?q?N9VbxbzxbH4XSTEXxN7V5RDv2Fd/IXKR24L5SnKdz9NhZtagZWMawCA978FMCK?=
 =?us-ascii?q?qP6LxEnC11oke3rA7LYPh9mCsdxuUq6HIAn+4Jvw8txD2HAr8OBUlYITDslxOQ?=
 =?us-ascii?q?4tC9tqpXZXyjcbit1EVkm9ChA6qPogVdWHb/Z5cjEjV87sR5MFLQznLz7pvod8?=
 =?us-ascii?q?XXbdIWrheUiQvPj/BJKJItkfoHnS9nOWP+vXI/0eI6gwJh3YqmvIeZMWVi57y2?=
 =?us-ascii?q?AgRXNjDuY8MT+zftjbtRn8qM3oCvGIlhFSsPXJfyUf2oFzcSv+z9NwmSCD08tm?=
 =?us-ascii?q?ubGb3HEA+D70dmqmjDEpGxOHGROXkZ1s5iRBiGKUxbgQAUWig6n5EjGgCrwszh?=
 =?us-ascii?q?bFl25jQL6lHkrRtMz/piNwPjXWfHuAeodjA0RYCEIxVM6QFC41rVPdaa7uJuBC?=
 =?us-ascii?q?xY+pyhrAqQKm2UfQhIDGcJWlCaCFDnJLWh+d7A8+2ADOqkM/TOeamOqfBZV/qQ?=
 =?us-ascii?q?x5KgyI5m8CiXNsmVInluFf472ldAXXBkHcTWgS4PRjcTlyLMac6buRi99jd2rs?=
 =?us-ascii?q?C57PTkRgbv6ZGTBLtVNNVl4wq2jrubN+6MmCZ5Li5V15MLxX/V0bgfwUQdiyd0?=
 =?us-ascii?q?ezm2FrQAsyHNQbnUmq9WCR4bdixyONFJ76I6wglCJ8rbhsnp2b5/i/4/E01FWk?=
 =?us-ascii?q?D5msG1ecwKJHmwNFPZC0aKN7SGJjzLz9v0YaOmTr1Qg/tbtwetuTaACELjOjWD?=
 =?us-ascii?q?lz/0VxGgK+1MjSebPABAt4G5aBpiFW/jTNf+YB2hLNB3lSE2waEzhn7SL2EcLC?=
 =?us-ascii?q?Nzc1lTobyQ9y9YhvR/FndF7npkK+mEhimY4/PZKpYQrftkHCB0m/hG73Q9zrtf?=
 =?us-ascii?q?9DtES+BtmCvOst5upEmrkvWOyjpiShZBtixHi56LvUp8P6XU7Z1AWXfC/BIQ4m?=
 =?us-ascii?q?ScERUKp915CtLxv6Bc0MTAlKX2KD1a6dLb4dMcB9TIKMKAKHcgMQDmGDjRDAsE?=
 =?us-ascii?q?Sz6kLWDeh0xHn/GU+X2YtZw6qpnqmJoTRb5XTl01FvUGCkt7GNwOOot4XjQhke?=
 =?us-ascii?q?3TsMld5nekqhTVAcVTpJzKUPOUDt3rKS2Flv9DfxYO3rr8KcIYMYio9VZlbwxY?=
 =?us-ascii?q?gYDLEkyYZsxAqS5lbwk96BFP62RzRW432mrsbwq/53lVGfPizU1+sRd3fel4rG?=
 =?us-ascii?q?Sk2FwwPFef4XRtnQ=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AqAgD63fZbh0O0hNFigheDWhInjG+LI?=
 =?us-ascii?q?QGBaDmJBI4igXMSAQEYEwGIUiI0CQ0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiS?=
 =?us-ascii?q?CYwMDAQIOFhkBATcBBQkBAVADVBkFgxyBdQ0FklYBAYkOAYxPgWwzgnYBAQWHG?=
 =?us-ascii?q?giHXoMPgRwXgUA/gREzhXoChzyJJYFulHEJHXSQHhiBWYd4NocBmAkCBAsCEwG?=
 =?us-ascii?q?BRoINTSQUgyeCJxcSg2uKID4BATGBBQEBjFQBAQ?=
X-IPAS-Result: =?us-ascii?q?A0AqAgD63fZbh0O0hNFigheDWhInjG+LIQGBaDmJBI4igXM?=
 =?us-ascii?q?SAQEYEwGIUiI0CQ0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiSCYwMDAQIOFhkBA?=
 =?us-ascii?q?TcBBQkBAVADVBkFgxyBdQ0FklYBAYkOAYxPgWwzgnYBAQWHGgiHXoMPgRwXgUA?=
 =?us-ascii?q?/gREzhXoChzyJJYFulHEJHXSQHhiBWYd4NocBmAkCBAsCEwGBRoINTSQUgyeCJ?=
 =?us-ascii?q?xcSg2uKID4BATGBBQEBjFQBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="63597761"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mga01b.intel.com with ESMTP; 22 Nov 2018 08:50:24 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2404424AbeKWDaU (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 22:30:20 -0500
Received: from smtp-fw-9101.amazon.com ([207.171.184.25]:39541 "EHLO
        smtp-fw-9101.amazon.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2403948AbeKWDaT (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 22:30:19 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
  d=amazon.de; i=@amazon.de; q=dns/txt; s=amazon201209;
  t=1542905408; x=1574441408;
  h=from:to:cc:subject:date:message-id;
  bh=Tu1wFq/IRA6/A/2HiYirBgRoQen9IWAq64v+L2q9MkQ=;
  b=YNSWHkb4bx/6cwZz/OGR2m8mWK3qhS5DhP36N/seEL2gzujONEJ8rzVm
   Mgm61FXtEuztGUNURiZHgeN+lpIxiI/aUR7D/A3XQfu/pLlRyqa/nTxUh
   mlEqPMkrwcbPPaSHa7SK36vvRDCitiSnJdNaVMs5LXxGoCR31oKusoSEE
   Y=;
X-IronPort-AV: E=Sophos;i="5.56,253,1539648000"; 
   d="scan'208";a="771919557"
Received: from sea3-co-svc-lb6-vlan3.sea.amazon.com (HELO email-inbound-relay-2c-1968f9fa.us-west-2.amazon.com) ([10.47.22.38])
  by smtp-border-fw-out-9101.sea19.amazon.com with ESMTP/TLS/DHE-RSA-AES256-SHA; 22 Nov 2018 16:50:07 +0000
Received: from u54ee758033e858cfa736.ant.amazon.com (pdx2-ws-svc-lb17-vlan2.amazon.com [10.247.140.66])
        by email-inbound-relay-2c-1968f9fa.us-west-2.amazon.com (8.14.7/8.14.7) with ESMTP id wAMGo3tR087602
        (version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NO);
        Thu, 22 Nov 2018 16:50:04 GMT
Received: from u54ee758033e858cfa736.ant.amazon.com (localhost [127.0.0.1])
        by u54ee758033e858cfa736.ant.amazon.com (8.15.2/8.15.2/Debian-3) with ESMTP id wAMGo1QL008132;
        Thu, 22 Nov 2018 17:50:02 +0100
Received: (from jsteckli@localhost)
        by u54ee758033e858cfa736.ant.amazon.com (8.15.2/8.15.2/Submit) id wAMGo1al008123;
        Thu, 22 Nov 2018 17:50:01 +0100
From: Julian Stecklina <jsteckli@amazon.de>
To: kernel-hardening@lists.openwall.com
Cc: Julian Stecklina <jsteckli@amazon.de>,
        Liran Alon <liran.alon@oracle.com>,
        Tycho Andersen <tycho@tycho.ws>,
        Jonathan Adams <jwadams@google.com>,
        David Woodhouse <dwmw2@infradead.org>,
        LKML <linux-kernel@vger.kernel.org>
Subject: [RFC RESEND PATCH 5/6] x86/speculation, kvm: move guest FPU state into process local memory
Date: Thu, 22 Nov 2018 17:49:38 +0100
Message-Id: <53daa400d6abd95b18ed660b40ebe5f41ef1dfff.1542905228.git.jsteckli@amazon.de>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <cover.1542905228.git.jsteckli@amazon.de>
References: <cover.1542905228.git.jsteckli@amazon.de>
In-Reply-To: <cover.1542905228.git.jsteckli@amazon.de>
References: <cover.1542905228.git.jsteckli@amazon.de>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

FPU registers contain guest data and must be protected from information
leak vulnerabilities in the kernel.

FPU register state for vCPUs are allocated from the globally-visible
kernel heap. Change this to use process-local memory instead and thus
prevent access (or prefetching) in any other context in the kernel.

Signed-off-by: Julian Stecklina <jsteckli@amazon.de>
---
 arch/x86/include/asm/kvm_host.h | 10 +++++++-
 arch/x86/kvm/x86.c              | 42 ++++++++++++++++++++++-----------
 2 files changed, 37 insertions(+), 15 deletions(-)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 55e51ff7e421..5dd29bfef77f 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -36,6 +36,7 @@
 #include <asm/asm.h>
 #include <asm/kvm_page_track.h>
 #include <asm/hyperv-tlfs.h>
+#include <asm/proclocal.h>
 
 #define KVM_MAX_VCPUS 288
 #define KVM_SOFT_MAX_VCPUS 240
@@ -530,7 +531,13 @@ struct kvm_vcpu_hv {
 	cpumask_t tlb_flush;
 };
 
+struct kvm_vcpu_arch_hidden {
+	struct fpu guest_fpu;
+};
+
 struct kvm_vcpu_arch {
+	struct proclocal hidden;
+
 	/*
 	 * rip and regs accesses must go through
 	 * kvm_{register,rip}_{read,write} functions.
@@ -611,7 +618,6 @@ struct kvm_vcpu_arch {
 	 * host PRKU bits.
 	 */
 	struct fpu user_fpu;
-	struct fpu guest_fpu;
 
 	u64 xcr0;
 	u64 guest_supported_xcr0;
@@ -1580,4 +1586,6 @@ static inline int kvm_cpu_get_apicid(int mps_cpu)
 #define put_smstate(type, buf, offset, val)                      \
 	*(type *)((buf) + (offset) - 0x7e00) = val
 
+struct kvm_vcpu_arch_hidden *kvm_arch_vcpu_hidden_get(struct kvm_vcpu *vcpu);
+
 #endif /* _ASM_X86_KVM_HOST_H */
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 66d66d77caee..941fa3209607 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -37,6 +37,7 @@
 #include <linux/vmalloc.h>
 #include <linux/export.h>
 #include <linux/moduleparam.h>
+#include <linux/mm.h>
 #include <linux/mman.h>
 #include <linux/highmem.h>
 #include <linux/iommu.h>
@@ -69,6 +70,7 @@
 #include <asm/irq_remapping.h>
 #include <asm/mshyperv.h>
 #include <asm/hypervisor.h>
+#include <asm/proclocal.h>
 
 #define CREATE_TRACE_POINTS
 #include "trace.h"
@@ -3630,7 +3632,7 @@ static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,
 
 static void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)
 {
-	struct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;
+	struct xregs_state *xsave = &kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.xsave;
 	u64 xstate_bv = xsave->header.xfeatures;
 	u64 valid;
 
@@ -3672,7 +3674,7 @@ static void fill_xsave(u8 *dest, struct kvm_vcpu *vcpu)
 
 static void load_xsave(struct kvm_vcpu *vcpu, u8 *src)
 {
-	struct xregs_state *xsave = &vcpu->arch.guest_fpu.state.xsave;
+	struct xregs_state *xsave = &kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.xsave;
 	u64 xstate_bv = *(u64 *)(src + XSAVE_HDR_OFFSET);
 	u64 valid;
 
@@ -3720,7 +3722,7 @@ static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
 		fill_xsave((u8 *) guest_xsave->region, vcpu);
 	} else {
 		memcpy(guest_xsave->region,
-			&vcpu->arch.guest_fpu.state.fxsave,
+			&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.fxsave,
 			sizeof(struct fxregs_state));
 		*(u64 *)&guest_xsave->region[XSAVE_HDR_OFFSET / sizeof(u32)] =
 			XFEATURE_MASK_FPSSE;
@@ -3750,7 +3752,7 @@ static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,
 		if (xstate_bv & ~XFEATURE_MASK_FPSSE ||
 			mxcsr & ~mxcsr_feature_mask)
 			return -EINVAL;
-		memcpy(&vcpu->arch.guest_fpu.state.fxsave,
+		memcpy(&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.fxsave,
 			guest_xsave->region, sizeof(struct fxregs_state));
 	}
 	return 0;
@@ -7996,7 +7998,7 @@ static void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)
 	preempt_disable();
 	copy_fpregs_to_fpstate(&vcpu->arch.user_fpu);
 	/* PKRU is separately restored in kvm_x86_ops->run.  */
-	__copy_kernel_to_fpregs(&vcpu->arch.guest_fpu.state,
+	__copy_kernel_to_fpregs(&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state,
 				~XFEATURE_MASK_PKRU);
 	preempt_enable();
 	trace_kvm_fpu(1);
@@ -8006,7 +8008,7 @@ static void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)
 static void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
 {
 	preempt_disable();
-	copy_fpregs_to_fpstate(&vcpu->arch.guest_fpu);
+	copy_fpregs_to_fpstate(&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu);
 	copy_kernel_to_fpregs(&vcpu->arch.user_fpu.state);
 	preempt_enable();
 	++vcpu->stat.fpu_reload;
@@ -8501,7 +8503,7 @@ int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
 
 	vcpu_load(vcpu);
 
-	fxsave = &vcpu->arch.guest_fpu.state.fxsave;
+	fxsave = &kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.fxsave;
 	memcpy(fpu->fpr, fxsave->st_space, 128);
 	fpu->fcw = fxsave->cwd;
 	fpu->fsw = fxsave->swd;
@@ -8521,8 +8523,7 @@ int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
 
 	vcpu_load(vcpu);
 
-	fxsave = &vcpu->arch.guest_fpu.state.fxsave;
-
+	fxsave = &kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.fxsave;
 	memcpy(fxsave->st_space, fpu->fpr, 128);
 	fxsave->cwd = fpu->fcw;
 	fxsave->swd = fpu->fsw;
@@ -8577,9 +8578,9 @@ static int sync_regs(struct kvm_vcpu *vcpu)
 
 static void fx_init(struct kvm_vcpu *vcpu)
 {
-	fpstate_init(&vcpu->arch.guest_fpu.state);
+	fpstate_init(&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state);
 	if (boot_cpu_has(X86_FEATURE_XSAVES))
-		vcpu->arch.guest_fpu.state.xsave.header.xcomp_bv =
+		kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.xsave.header.xcomp_bv =
 			host_xcr0 | XSTATE_COMPACTION_ENABLED;
 
 	/*
@@ -8703,11 +8704,11 @@ void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 		 */
 		if (init_event)
 			kvm_put_guest_fpu(vcpu);
-		mpx_state_buffer = get_xsave_addr(&vcpu->arch.guest_fpu.state.xsave,
+		mpx_state_buffer = get_xsave_addr(&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.xsave,
 					XFEATURE_MASK_BNDREGS);
 		if (mpx_state_buffer)
 			memset(mpx_state_buffer, 0, sizeof(struct mpx_bndreg_state));
-		mpx_state_buffer = get_xsave_addr(&vcpu->arch.guest_fpu.state.xsave,
+		mpx_state_buffer = get_xsave_addr(&kvm_arch_vcpu_hidden_get(vcpu)->guest_fpu.state.xsave,
 					XFEATURE_MASK_BNDCSR);
 		if (mpx_state_buffer)
 			memset(mpx_state_buffer, 0, sizeof(struct mpx_bndcsr));
@@ -8892,11 +8893,21 @@ bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)
 struct static_key kvm_no_apic_vcpu __read_mostly;
 EXPORT_SYMBOL_GPL(kvm_no_apic_vcpu);
 
+struct kvm_vcpu_arch_hidden *kvm_arch_vcpu_hidden_get(struct kvm_vcpu *vcpu)
+{
+	return proclocal_get(&vcpu->arch.hidden, struct kvm_vcpu_arch_hidden);
+}
+EXPORT_SYMBOL_GPL(kvm_arch_vcpu_hidden_get);
+
 int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 {
 	struct page *page;
 	int r;
 
+	r = kalloc_proclocal(&vcpu->arch.hidden, sizeof(struct kvm_vcpu_arch_hidden));
+	if (r)
+		goto fail;
+
 	vcpu->arch.apicv_active = kvm_x86_ops->get_enable_apicv(vcpu);
 	vcpu->arch.emulate_ctxt.ops = &emulate_ops;
 	if (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))
@@ -8907,7 +8918,7 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 	page = alloc_page(GFP_KERNEL | __GFP_ZERO);
 	if (!page) {
 		r = -ENOMEM;
-		goto fail;
+		goto fail_free_hidden;
 	}
 	vcpu->arch.pio_data = page_address(page);
 
@@ -8963,6 +8974,8 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 	kvm_mmu_destroy(vcpu);
 fail_free_pio_data:
 	free_page((unsigned long)vcpu->arch.pio_data);
+fail_free_hidden:
+	kfree_proclocal(&vcpu->arch.hidden);
 fail:
 	return r;
 }
@@ -8981,6 +8994,7 @@ void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)
 	free_page((unsigned long)vcpu->arch.pio_data);
 	if (!lapic_in_kernel(vcpu))
 		static_key_slow_dec(&kvm_no_apic_vcpu);
+	kfree_proclocal(&vcpu->arch.hidden);
 }
 
 void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)
-- 
2.17.1

