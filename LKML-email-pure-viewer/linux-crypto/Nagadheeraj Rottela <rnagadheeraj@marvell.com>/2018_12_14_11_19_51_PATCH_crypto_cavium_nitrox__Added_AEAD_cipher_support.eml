Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  14 Dec 2018 20:27:39 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga004.jf.intel.com (orsmga004.jf.intel.com [10.7.209.38])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 2461F58079D;
	Fri, 14 Dec 2018 03:20:30 -0800 (PST)
Received: from orsmga102-1.jf.intel.com (HELO mga09.intel.com) ([10.7.208.27])
  by orsmga004-1.jf.intel.com with ESMTP; 14 Dec 2018 03:20:29 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AAlj1ExzKtw77E+HXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0ewXKvad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWpPUNhMWSxdDI2y?=
 =?us-ascii?q?bIoPAPYOM+lXtIn9v1kDoACiBQm1Hu7j1iNEimPr0aA8zu8vERvG3AslH98WqH?=
 =?us-ascii?q?rbttr1O70PXuC10qbH0y/DYOlU2Tzg9IbIdQwhoe2SUrJ0a8Xa1E4iFxnDjlqK?=
 =?us-ascii?q?pozqJS6a1uQTvGeF9epvT+CvhnUiqw5ruDiv2Nkjio3Nho4P1l/E8iB5zZ8zKN?=
 =?us-ascii?q?alS0B7ecapHIVMuyyeLYd6X80vT39ytConybAKpYS3cSkIxZg/2hLTdvyKf5KV?=
 =?us-ascii?q?7h7+WuudOyp0iXJkdb6lmRq+6UagxfP/W8Wo1VtHqylIncXSuX0N0hHe6saHR/?=
 =?us-ascii?q?h980qkwjmC1x7c5fxBLE8qmqfUNpwsz7gtnZQJq0vDBDX5mEDuga+WaEok/u+o?=
 =?us-ascii?q?5vz5YrXpuJCcLZV4igLgPaQ0nMywH+A4PhIJX2iB9uSwzLzj/UvnT7VWlvA6jL?=
 =?us-ascii?q?XVvZTAKcgGqKO1HRVZ3psg5hqjFTur0dYVkWECLF1feRKHi4bpO0vJIPD9Ffq/?=
 =?us-ascii?q?h1WskDF2x/HJJ7HhAYvCLmLFkLj/ebZx8klcyQQ1zd9B/ZJZEa8BIP3tVU/rrt?=
 =?us-ascii?q?DYDQE2Mxayw+n5DNVxzIQeWXiAAqOBKqPdrUeI5v4zI+mLfIIVvDf9K/s76PL0?=
 =?us-ascii?q?gn45hEQQfa2o3ZsRdXC5Ee5qI0SfYXrwnNgBFX0GsRY5TOzvkFeCSyJcZ26uX6?=
 =?us-ascii?q?Ig4TE2EIKmAp3CRoCxmrOB2z23Hp1LZm9cDFCMHmzld4GFW/cKdSKTLdVtkj0C?=
 =?us-ascii?q?Vbi9VYAh0QuiuxP9y7piNuDU4DEXtYr/1Nhp4O3ejRMy9TtqAMiH0GGNSGd0nm?=
 =?us-ascii?q?UPRzIt2KB/oEp9ykqM0KRigvxYE8BT6O1NUgsgKZHcyOl6AcjoWg3dZteJVEqm?=
 =?us-ascii?q?QtK+DD4rVdIxw9gOY0VnF9W4lB/D3TGnA7sUl7yNGZw1/bjQ33n3J8Zh1XnG0L?=
 =?us-ascii?q?MtgEUhQstKLWemnLJw9xDPB47VlEWUj6Wqer4a3CLX8GeDzHCBvEdXUANrVaXF?=
 =?us-ascii?q?XHYfZlbZrNjj50PCSaOuBqojMgdb1cGCLa5KYMXzjVpaXPfjJMjeY2WplmitHx?=
 =?us-ascii?q?mI2K2DYJDqe2oH2iXdE1YLkwYU8XaCNgg+AyOhrnnaDDxvE1Lvfkzt/fN/qHO9?=
 =?us-ascii?q?Uk870QWKY1d92Lqy/x4fneacRO8L3rIYpCchrC15E0un0NLIFdWMvQphc79aYd?=
 =?us-ascii?q?Mm/lhH03nUtwh8PpymMqBjiUQScwVxv0PyyRp3Dp9MntQtrHMv1AByM76X0Etd?=
 =?us-ascii?q?dzOE2pD9IqHXKmj3/BCod67W2lHf3MyK+qsV7/Q4sVHjvACvFkot6Hhn19hV03?=
 =?us-ascii?q?2B5pTFFgYSUJTxUlop+Bh+vb3Vfi4954bM3312Laa0qiPC284uBOY90Bmge8lQ?=
 =?us-ascii?q?MayaGw7yCcEVHNWuJ/EwlFivbRIEO/5S+bUwP8OncfuGxaGqMPxhnDKgkWRI/o?=
 =?us-ascii?q?R93liQ+Cp7T+7Cx4wFzO2A3gubSzf8i0+ss8DqmYxeeT4eBGu+ySj+C45Xaa1/?=
 =?us-ascii?q?ZoILCWaoI82qydRynZ/tW3hE9FG9A1MKwtOmeR2Xb1blxw1fyVwXoWC7mSu/1z?=
 =?us-ascii?q?F0iTApobaF0yzU3uvicwALOmhVS2l4jFfgOJS7gMoeXEe1cQcpjhyl5UDhyqhf?=
 =?us-ascii?q?paR/KXTTQEhScyj3KWFiTrW/tr6Yb8FT75MotD1dUP6gblCCVr79vxwa3jvjHm?=
 =?us-ascii?q?tf3jw6dyumuo7knxx8k2+dKHdzrHzEecB/3xvf5drcReJP0ToCXiV3lT7XBl2k?=
 =?us-ascii?q?Ndmz4dqUj4vDsvy5V2+5VJ1cazPrzYCDtCu8/2FqGgewn/Owmt3mFwg1zyn72s?=
 =?us-ascii?q?JuVSXJqhb8f4bq2767MeJhYklnGlv859BmFYF5l4s6nIsQ1mQChpWJ4XoHln/+?=
 =?us-ascii?q?MNVB1qL5dnYNRz8Lw9jO7Qjh2U1jKG+Jxo3jWnWcxMthe8e1YmcM1i0h6MBKDb?=
 =?us-ascii?q?+e7KZYkittvlq4sQXRbOB+njgHyPsi8n4ag/wTtworwSWQGbQSHUhePSzxmBWE?=
 =?us-ascii?q?9dG+rKNLZGmxdbi8zlZxndekDLuauAFTRG75eos+HS939sh/NVPM0H7p5Y3+dt?=
 =?us-ascii?q?jfc8kTtgGKnBfalOdaNogxlvURiCpjOGL9u2AlyuEhgRxv25G6oJaIK2F38K2l?=
 =?us-ascii?q?BR5YMyX/Z9kP9TH1kaZegsGW0pizHpVmHzUHRprpQuiuEDIPrvTnLAeOHSY4qn?=
 =?us-ascii?q?eaH7rfAACe5F1nr3LJD5CkKXWXKGMFwtVlQRmXPFZfjxwMXDUmgp45ERiny9f7?=
 =?us-ascii?q?f0d+4jAR+0T0qh9Ryu9zMxn/U2HfpBqnazsuSZifKgZW4R9G50vPLcOe6edzFT?=
 =?us-ascii?q?lC/pK9tAyNNnCbZwNQAGELQEOEAk7sPqK06dnc6eSYBfe+L/jTYbWIs+NeTOyF?=
 =?us-ascii?q?xZau0otg4jaNOd+DPnhkD/0nxEVDWWp1FNjemzUKUyYXjT7Cb9aHpBeg/S16ts?=
 =?us-ascii?q?C+8PP2WAL2+IuAEb1SPc90+xCxh6eDOPWdhCJ4KTZey5MNymXEyLkZ3F4OlS5u?=
 =?us-ascii?q?cyOhHqgHtS7IVKjQgLNYDwYHayNvM8tF96I80RdMOc7YidP116R0jv0vC1dCWl?=
 =?us-ascii?q?zuhNupZdERI2ymMFPHBUCLNKmJJDHRwsH3Z7+8RqNUjOlOqxKwvjObGVf5Pjuf?=
 =?us-ascii?q?jznpSwyvMeZUgS6BIRxRo5u9fQhtCGT5SNLmawa2MNt2jT0w3L01iWnGNW8aMT?=
 =?us-ascii?q?hgbUxNqqec4j9fgvV6A2ZB9GZqLfGYmyaF6OnVMooWsfpuAihui+1W+mg1y7tL?=
 =?us-ascii?q?4yFCX/F1nCrSrthzo1CpiOWPyzxnUAZQpTZPno6EoUJiOaDB/JlaRXnE5A4N7X?=
 =?us-ascii?q?mXCxkSp9pqENvvu6VRytjJjK3yKTdC/MjS/csTHMXULMOHMHw8MRvmAjLUDQ0F?=
 =?us-ascii?q?TSK1OmHbnUBSjPaS9njG5qQ9/9LslYAER6VHfFMyEP8dEAJsBNUEKdFwRDximK?=
 =?us-ascii?q?PRxJoI6GC0oQPNbMpduJzATLSbGfzpIXCel7YCbgZehfuyIY0NO4jT10V8Z1x+?=
 =?us-ascii?q?m4rWXUzdQZoF9iFocAIxiElE7nV7Smo9xwTjZx/7s1EJEvvhuBc5gwd+bOk3/T?=
 =?us-ascii?q?Wk2VArOlfOrWNkik84ltzpgT2cajfzBKK5R59bDy6yvE80ZMCoCz1pZBG/yBQ3?=
 =?us-ascii?q?fAzPQKhc2v45LThm?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AHAADEkBNch0O0hNFiHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBgTCCLAQLJwqHOQOET1+LGYIhaJZZgSQFTg4BARgTAYdHIjQJDQE?=
 =?us-ascii?q?DAQEBAQEBAgETAQEBCA0JCCkjDII2JAGCZAUCDwgBDBkBATcBBQkCAQFOAy8nB?=
 =?us-ascii?q?AENBQUdgn+BaQMUAQECApptAi6JWgEBAYFqM4J2AQEFhQkYggkIinwPgRUBHRe?=
 =?us-ascii?q?Bf4ERgl2LEYk6CoYKRoEJhFqLIwmRTyOLToV+AYMEhi+PfgIEAgQFAg0BAQWBR?=
 =?us-ascii?q?oIOTSNQgmyCGwkDF4NKilNygQUBASGLFgGBHgEB?=
X-IPAS-Result: =?us-ascii?q?A0AHAADEkBNch0O0hNFiHAEBAQQBAQcEAQGBUQcBAQsBgTC?=
 =?us-ascii?q?CLAQLJwqHOQOET1+LGYIhaJZZgSQFTg4BARgTAYdHIjQJDQEDAQEBAQEBAgETA?=
 =?us-ascii?q?QEBCA0JCCkjDII2JAGCZAUCDwgBDBkBATcBBQkCAQFOAy8nBAENBQUdgn+BaQM?=
 =?us-ascii?q?UAQECApptAi6JWgEBAYFqM4J2AQEFhQkYggkIinwPgRUBHReBf4ERgl2LEYk6C?=
 =?us-ascii?q?oYKRoEJhFqLIwmRTyOLToV+AYMEhi+PfgIEAgQFAg0BAQWBRoIOTSNQgmyCGwk?=
 =?us-ascii?q?DF4NKilNygQUBASGLFgGBHgEB?=
X-IronPort-AV: E=Sophos;i="5.56,352,1539673200"; 
   d="scan'208";a="57473527"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 14 Dec 2018 03:20:27 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1729499AbeLNLUX (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 14 Dec 2018 06:20:23 -0500
Received: from mx0b-0016f401.pphosted.com ([67.231.156.173]:34910 "EHLO
        mx0b-0016f401.pphosted.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S1728415AbeLNLUW (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 14 Dec 2018 06:20:22 -0500
Received: from pps.filterd (m0045851.ppops.net [127.0.0.1])
        by mx0b-0016f401.pphosted.com (8.16.0.27/8.16.0.27) with SMTP id wBEBIDEn011139;
        Fri, 14 Dec 2018 03:19:57 -0800
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=marvell.com; h=from : to : cc :
 subject : date : message-id : content-type : content-transfer-encoding :
 mime-version; s=pfpt0818; bh=DXWbINlAOqLgD3XNRKcndumET5doVZ1qCaeWxsV2Xho=;
 b=iyzM9gd9YV5wTYoNI4gx9bu1GNdlOdpMT4/J1yq5CabNhWNmftMGhm2PDnQjw5UwpdFM
 P/j+cimtb2CZoDwBsMGKOaotl2y/egEozIunpiTgeCt9r4fzD/KjBIAhE7m/YlbZ0Bxe
 ijP99YYspBFYZH8SsHZ6NVN9x1PkJxLYqbNlMuHdhCid7ptpmS0++Xt3/QrH8Sz3+z+T
 Z8DAlZCgcTk7eUWHEX7Absq+Vh0knDl0GrTOIA7gc/SVlbNgyOztilPVrqUUZRUYUt3q
 rDVO7fM7XQSFCkxT0k2N8J8j0PTMoe5G2Gg734g/hK26so1eL2CXo6c3tbBXCeEf+Q79 AQ== 
Received: from sc-exch04.marvell.com ([199.233.58.184])
        by mx0b-0016f401.pphosted.com with ESMTP id 2pc2npsv06-1
        (version=TLSv1.2 cipher=ECDHE-RSA-AES256-SHA384 bits=256 verify=NOT);
        Fri, 14 Dec 2018 03:19:56 -0800
Received: from SC-EXCH04.marvell.com (10.93.176.84) by SC-EXCH04.marvell.com
 (10.93.176.84) with Microsoft SMTP Server (TLS) id 15.0.1367.3; Fri, 14 Dec
 2018 03:19:54 -0800
Received: from NAM01-BN3-obe.outbound.protection.outlook.com (104.47.33.59) by
 SC-EXCH04.marvell.com (10.93.176.84) with Microsoft SMTP Server (TLS) id
 15.0.1367.3 via Frontend Transport; Fri, 14 Dec 2018 03:19:54 -0800
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=marvell.onmicrosoft.com; s=selector1-marvell-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=DXWbINlAOqLgD3XNRKcndumET5doVZ1qCaeWxsV2Xho=;
 b=MuFHtriWe3Q2JGnUdhpfSqKHMMxW60EYqIIjSM1H1RBjR1NIaPCWheLQyFhGscxAf8PVUsU3/XdnbFXzStFuLw8ibBiG154Tg6ySoWJlxPszioOv+6ynFyMIu3RD7Qy4GWrVCZqk1rfZcUGSi/pn2K2wKGKUwBRReLkYuKhxwsA=
Received: from BYAPR18MB2823.namprd18.prod.outlook.com (20.179.57.215) by
 BYAPR18MB2710.namprd18.prod.outlook.com (20.179.56.32) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1425.19; Fri, 14 Dec 2018 11:19:51 +0000
Received: from BYAPR18MB2823.namprd18.prod.outlook.com
 ([fe80::8ce5:5f85:b5ed:e4d7]) by BYAPR18MB2823.namprd18.prod.outlook.com
 ([fe80::8ce5:5f85:b5ed:e4d7%3]) with mapi id 15.20.1425.021; Fri, 14 Dec 2018
 11:19:51 +0000
From: Nagadheeraj Rottela <rnagadheeraj@marvell.com>
To: "herbert@gondor.apana.org.au" <herbert@gondor.apana.org.au>,
        "davem@davemloft.net" <davem@davemloft.net>
CC: "linux-crypto@vger.kernel.org" <linux-crypto@vger.kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
        "Srikanth Jampala" <jsrikanth@marvell.com>,
        Nagadheeraj Rottela <rnagadheeraj@marvell.com>
Subject: [PATCH] crypto: cavium/nitrox - Added AEAD cipher support
Thread-Topic: [PATCH] crypto: cavium/nitrox - Added AEAD cipher support
Thread-Index: AQHUk57ur/yc+CHjjUO7CfydZoE6YA==
Date: Fri, 14 Dec 2018 11:19:51 +0000
Message-ID: <20181214111856.32030-1-rnagadheeraj@marvell.com>
Accept-Language: en-IN, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-clientproxiedby: BM1PR01CA0088.INDPRD01.PROD.OUTLOOK.COM
 (2603:1096:b00:1::28) To BYAPR18MB2823.namprd18.prod.outlook.com
 (2603:10b6:a03:109::23)
x-ms-exchange-messagesentrepresentingtype: 1
x-originating-ip: [115.113.156.2]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1;BYAPR18MB2710;20:DEPicEWimod4oLqsgtlHRkRJYaFHDZytTdYAVea+1wyC9x2aUzDQUGUCFDKrf6rDQ+MoEfjuZYYlyzZFc8+fbdfrwwLihfzJmL6C2E/Z9BFxOGLGJIAnqLc5tisNuVeOSoIavtluyoPdelsPBqtaGfk9B2vbwNo6SASuUd/NZFo=
x-ms-office365-filtering-correlation-id: 61728c62-781c-40c5-0623-08d661b610b8
x-microsoft-antispam: BCL:0;PCL:0;RULEID:(2390118)(7020095)(4652040)(8989299)(4534185)(7168020)(4627221)(201703031133081)(201702281549075)(8990200)(5600074)(711020)(2017052603328)(7153060)(7193020);SRVR:BYAPR18MB2710;
x-ms-traffictypediagnostic: BYAPR18MB2710:
x-microsoft-antispam-prvs: <BYAPR18MB2710CADB0D458A2C74E11494D6A10@BYAPR18MB2710.namprd18.prod.outlook.com>
x-ms-exchange-senderadcheck: 1
x-exchange-antispam-report-cfa-test: BCL:0;PCL:0;RULEID:(8211001083)(3230021)(999002)(6040522)(2401047)(8121501046)(5005006)(93006095)(93001095)(10201501046)(3002001)(3231475)(944501520)(52105112)(148016)(149066)(150057)(6041310)(20161123562045)(20161123560045)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(20161123558120)(20161123564045)(201708071742011)(7699051)(76991095);SRVR:BYAPR18MB2710;BCL:0;PCL:0;RULEID:;SRVR:BYAPR18MB2710;
x-forefront-prvs: 08864C38AC
x-forefront-antispam-report: SFV:NSPM;SFS:(10009020)(39860400002)(396003)(366004)(346002)(376002)(136003)(189003)(199004)(5660300001)(4744004)(2501003)(54906003)(25786009)(4326008)(14454004)(14444005)(110136005)(66066001)(86362001)(575784001)(36756003)(71200400001)(478600001)(71190400001)(256004)(105586002)(26005)(8676002)(186003)(486006)(7736002)(476003)(68736007)(2616005)(6506007)(97736004)(53946003)(81156014)(6512007)(8936002)(3846002)(1076002)(106356001)(6436002)(6486002)(6116002)(99286004)(305945005)(107886003)(102836004)(53936002)(81166006)(316002)(55236004)(386003)(52116002)(2906002)(569006);DIR:OUT;SFP:1101;SCL:1;SRVR:BYAPR18MB2710;H:BYAPR18MB2823.namprd18.prod.outlook.com;FPR:;SPF:None;LANG:en;PTR:InfoNoRecords;MX:1;A:1;
x-microsoft-antispam-message-info: YsJJA04q8eAjL5jUbwuxAnpgM1ddjFTQtgNhk4cQspH6CHZxhSi+JB90WzuvBHsUKatOW4bkGKYqV/ZRhMOf8cO/EY8IkogcOIMSzBjzG87Z8x5KGc7/bZ1lVlhYSMk2MgQvhBjWFBrzxlqAUKO73WfjV5L63GXbiVjIaB7pJDakQJahvIc8Tjn1d77lEiuAaFbJ1VzctnC5iwNwW9574aTX4YxnHGiJCnWfiHto3oZ4hsiu5j+5rasMurEyENIA5uFfOnGpu+0C/QGY2J/seCTHHGS+ilK06ob5tYqMcU1z1c2uBzy/uaZ03lKA9fHw
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-MS-Exchange-CrossTenant-Network-Message-Id: 61728c62-781c-40c5-0623-08d661b610b8
X-MS-Exchange-CrossTenant-originalarrivaltime: 14 Dec 2018 11:19:51.7375
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 70e1fb47-1155-421d-87fc-2e58f638b6e0
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BYAPR18MB2710
X-OriginatorOrg: marvell.com
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10434:,, definitions=2018-12-14_05:,,
 signatures=0
X-Proofpoint-Details: rule=outbound_notspam policy=outbound score=0 priorityscore=1501
 malwarescore=0 suspectscore=0 phishscore=0 bulkscore=0 spamscore=0
 clxscore=1011 lowpriorityscore=0 mlxscore=0 impostorscore=0
 mlxlogscore=999 adultscore=0 classifier=spam adjust=0 reason=mlx
 scancount=1 engine=8.0.1-1810050000 definitions=main-1812140103
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Added support to offload AEAD ciphers to NITROX. Currently supported
AEAD cipher is 'gcm(aes)'.

Signed-off-by: Nagadheeraj Rottela <rnagadheeraj@marvell.com>
Reviewed-by: Srikanth Jampala <jsrikanth@marvell.com>
---
 drivers/crypto/cavium/nitrox/Makefile          |   4 +-
 drivers/crypto/cavium/nitrox/nitrox_aead.c     | 364 ++++++++++++++++
 drivers/crypto/cavium/nitrox/nitrox_algs.c     | 559 +--------------------=
----
 drivers/crypto/cavium/nitrox/nitrox_common.h   |   6 +-
 drivers/crypto/cavium/nitrox/nitrox_req.h      | 239 +++++++++--
 drivers/crypto/cavium/nitrox/nitrox_reqmgr.c   |  38 +-
 drivers/crypto/cavium/nitrox/nitrox_skcipher.c | 498 +++++++++++++++++++++=
+
 7 files changed, 1103 insertions(+), 605 deletions(-)
 create mode 100644 drivers/crypto/cavium/nitrox/nitrox_aead.c
 create mode 100644 drivers/crypto/cavium/nitrox/nitrox_skcipher.c

diff --git a/drivers/crypto/cavium/nitrox/Makefile b/drivers/crypto/cavium/=
nitrox/Makefile
index ad0546630ad8..f83991aaf820 100644
--- a/drivers/crypto/cavium/nitrox/Makefile
+++ b/drivers/crypto/cavium/nitrox/Makefile
@@ -7,7 +7,9 @@ n5pf-objs :=3D nitrox_main.o \
 	nitrox_hal.o \
 	nitrox_reqmgr.o \
 	nitrox_algs.o	\
-	nitrox_mbx.o
+	nitrox_mbx.o	\
+	nitrox_skcipher.o \
+	nitrox_aead.o
=20
 n5pf-$(CONFIG_PCI_IOV) +=3D nitrox_sriov.o
 n5pf-$(CONFIG_DEBUG_FS) +=3D nitrox_debugfs.o
diff --git a/drivers/crypto/cavium/nitrox/nitrox_aead.c b/drivers/crypto/ca=
vium/nitrox/nitrox_aead.c
new file mode 100644
index 000000000000..4f43eacd2557
--- /dev/null
+++ b/drivers/crypto/cavium/nitrox/nitrox_aead.c
@@ -0,0 +1,364 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/crypto.h>
+#include <linux/rtnetlink.h>
+
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+#include <crypto/des.h>
+#include <crypto/sha.h>
+#include <crypto/internal/aead.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/gcm.h>
+
+#include "nitrox_dev.h"
+#include "nitrox_common.h"
+#include "nitrox_req.h"
+
+#define GCM_AES_SALT_SIZE	4
+
+/**
+ * struct nitrox_crypt_params - Params to set nitrox crypto request.
+ * @cryptlen: Encryption/Decryption data length
+ * @authlen: Assoc data length + Cryptlen
+ * @srclen: Input buffer length
+ * @dstlen: Output buffer length
+ * @iv: IV data
+ * @ivsize: IV data length
+ * @ctrl_arg: Identifies the request type (ENCRYPT/DECRYPT)
+ */
+struct nitrox_crypt_params {
+	unsigned int cryptlen;
+	unsigned int authlen;
+	unsigned int srclen;
+	unsigned int dstlen;
+	u8 *iv;
+	int ivsize;
+	u8 ctrl_arg;
+};
+
+union gph_p3 {
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		u16 iv_offset : 8;
+		u16 auth_offset	: 8;
+#else
+		u16 auth_offset	: 8;
+		u16 iv_offset : 8;
+#endif
+	};
+	u16 param;
+};
+
+static int nitrox_aes_gcm_setkey(struct crypto_aead *aead, const u8 *key,
+				 unsigned int keylen)
+{
+	int aes_keylen;
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	struct flexi_crypto_context *fctx;
+	union fc_ctx_flags flags;
+
+	aes_keylen =3D flexi_aes_keylen(keylen);
+	if (aes_keylen < 0) {
+		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	/* fill crypto context */
+	fctx =3D nctx->u.fctx;
+	flags.f =3D be64_to_cpu(fctx->flags.f);
+	flags.w0.aes_keylen =3D aes_keylen;
+	fctx->flags.f =3D cpu_to_be64(flags.f);
+
+	/* copy enc key to context */
+	memset(&fctx->crypto, 0, sizeof(fctx->crypto));
+	memcpy(fctx->crypto.u.key, key, keylen);
+
+	return 0;
+}
+
+static int nitrox_aead_setauthsize(struct crypto_aead *aead,
+				   unsigned int authsize)
+{
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	struct flexi_crypto_context *fctx =3D nctx->u.fctx;
+	union fc_ctx_flags flags;
+
+	flags.f =3D be64_to_cpu(fctx->flags.f);
+	flags.w0.mac_len =3D authsize;
+	fctx->flags.f =3D cpu_to_be64(flags.f);
+
+	aead->authsize =3D authsize;
+
+	return 0;
+}
+
+static int alloc_src_sglist(struct aead_request *areq, char *iv, int ivsiz=
e,
+			    int buflen)
+{
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+	int nents =3D sg_nents_for_len(areq->src, buflen) + 1;
+	int ret;
+
+	if (nents < 0)
+		return nents;
+
+	/* Allocate buffer to hold IV and input scatterlist array */
+	ret =3D alloc_src_req_buf(nkreq, nents, ivsize);
+	if (ret)
+		return ret;
+
+	nitrox_creq_copy_iv(nkreq->src, iv, ivsize);
+	nitrox_creq_set_src_sg(nkreq, nents, ivsize, areq->src, buflen);
+
+	return 0;
+}
+
+static int alloc_dst_sglist(struct aead_request *areq, int ivsize, int buf=
len)
+{
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+	int nents =3D sg_nents_for_len(areq->dst, buflen) + 3;
+	int ret;
+
+	if (nents < 0)
+		return nents;
+
+	/* Allocate buffer to hold ORH, COMPLETION and output scatterlist
+	 * array
+	 */
+	ret =3D alloc_dst_req_buf(nkreq, nents);
+	if (ret)
+		return ret;
+
+	nitrox_creq_set_orh(nkreq);
+	nitrox_creq_set_comp(nkreq);
+	nitrox_creq_set_dst_sg(nkreq, nents, ivsize, areq->dst, buflen);
+
+	return 0;
+}
+
+static void free_src_sglist(struct aead_request *areq)
+{
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+
+	kfree(nkreq->src);
+}
+
+static void free_dst_sglist(struct aead_request *areq)
+{
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+
+	kfree(nkreq->dst);
+}
+
+static int nitrox_set_creq(struct aead_request *areq,
+			   struct nitrox_crypt_params *params)
+{
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+	struct se_crypto_request *creq =3D &nkreq->creq;
+	struct crypto_aead *aead =3D crypto_aead_reqtfm(areq);
+	union gph_p3 param3;
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	int ret;
+
+	creq->flags =3D areq->base.flags;
+	creq->gfp =3D (areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?
+		GFP_KERNEL : GFP_ATOMIC;
+
+	creq->ctrl.value =3D 0;
+	creq->opcode =3D FLEXI_CRYPTO_ENCRYPT_HMAC;
+	creq->ctrl.s.arg =3D params->ctrl_arg;
+
+	creq->gph.param0 =3D cpu_to_be16(params->cryptlen);
+	creq->gph.param1 =3D cpu_to_be16(params->authlen);
+	creq->gph.param2 =3D cpu_to_be16(params->ivsize + areq->assoclen);
+	param3.iv_offset =3D 0;
+	param3.auth_offset =3D params->ivsize;
+	creq->gph.param3 =3D cpu_to_be16(param3.param);
+
+	creq->ctx_handle =3D nctx->u.ctx_handle;
+	creq->ctrl.s.ctxl =3D sizeof(struct flexi_crypto_context);
+
+	ret =3D alloc_src_sglist(areq, params->iv, params->ivsize,
+			       params->srclen);
+	if (ret)
+		return ret;
+
+	ret =3D alloc_dst_sglist(areq, params->ivsize, params->dstlen);
+	if (ret) {
+		free_src_sglist(areq);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void nitrox_aead_callback(void *arg, int err)
+{
+	struct aead_request *areq =3D arg;
+
+	free_src_sglist(areq);
+	free_dst_sglist(areq);
+	if (err) {
+		pr_err_ratelimited("request failed status 0x%0x\n", err);
+		err =3D -EINVAL;
+	}
+
+	areq->base.complete(&areq->base, err);
+}
+
+static int nitrox_aes_gcm_enc(struct aead_request *areq)
+{
+	struct crypto_aead *aead =3D crypto_aead_reqtfm(areq);
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+	struct se_crypto_request *creq =3D &nkreq->creq;
+	struct flexi_crypto_context *fctx =3D nctx->u.fctx;
+	struct nitrox_crypt_params params;
+	int ret;
+
+	memcpy(fctx->crypto.iv, areq->iv, GCM_AES_SALT_SIZE);
+
+	memset(&params, 0, sizeof(params));
+	params.cryptlen =3D areq->cryptlen;
+	params.authlen =3D areq->assoclen + params.cryptlen;
+	params.srclen =3D params.authlen;
+	params.dstlen =3D params.srclen + aead->authsize;
+	params.iv =3D &areq->iv[GCM_AES_SALT_SIZE];
+	params.ivsize =3D GCM_AES_IV_SIZE - GCM_AES_SALT_SIZE;
+	params.ctrl_arg =3D ENCRYPT;
+	ret =3D nitrox_set_creq(areq, &params);
+	if (ret)
+		return ret;
+
+	/* send the crypto request */
+	return nitrox_process_se_request(nctx->ndev, creq, nitrox_aead_callback,
+					 areq);
+}
+
+static int nitrox_aes_gcm_dec(struct aead_request *areq)
+{
+	struct crypto_aead *aead =3D crypto_aead_reqtfm(areq);
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	struct nitrox_kcrypt_request *nkreq =3D aead_request_ctx(areq);
+	struct se_crypto_request *creq =3D &nkreq->creq;
+	struct flexi_crypto_context *fctx =3D nctx->u.fctx;
+	struct nitrox_crypt_params params;
+	int ret;
+
+	memcpy(fctx->crypto.iv, areq->iv, GCM_AES_SALT_SIZE);
+
+	memset(&params, 0, sizeof(params));
+	params.cryptlen =3D areq->cryptlen - aead->authsize;
+	params.authlen =3D areq->assoclen + params.cryptlen;
+	params.srclen =3D areq->cryptlen + areq->assoclen;
+	params.dstlen =3D params.srclen - aead->authsize;
+	params.iv =3D &areq->iv[GCM_AES_SALT_SIZE];
+	params.ivsize =3D GCM_AES_IV_SIZE - GCM_AES_SALT_SIZE;
+	params.ctrl_arg =3D DECRYPT;
+	ret =3D nitrox_set_creq(areq, &params);
+	if (ret)
+		return ret;
+
+	/* send the crypto request */
+	return nitrox_process_se_request(nctx->ndev, creq, nitrox_aead_callback,
+					 areq);
+}
+
+static int nitrox_aead_init(struct crypto_aead *aead)
+{
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	struct crypto_ctx_hdr *chdr;
+
+	/* get the first device */
+	nctx->ndev =3D nitrox_get_first_device();
+	if (!nctx->ndev)
+		return -ENODEV;
+
+	/* allocate nitrox crypto context */
+	chdr =3D crypto_alloc_context(nctx->ndev);
+	if (!chdr) {
+		nitrox_put_device(nctx->ndev);
+		return -ENOMEM;
+	}
+	nctx->chdr =3D chdr;
+	nctx->u.ctx_handle =3D (uintptr_t)((u8 *)chdr->vaddr +
+					 sizeof(struct ctx_hdr));
+	nctx->u.fctx->flags.f =3D 0;
+
+	return 0;
+}
+
+static int nitrox_aes_gcm_init(struct crypto_aead *aead)
+{
+	int ret;
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+	union fc_ctx_flags *flags;
+
+	ret =3D nitrox_aead_init(aead);
+	if (ret)
+		return ret;
+
+	flags =3D &nctx->u.fctx->flags;
+	flags->w0.cipher_type =3D CIPHER_AES_GCM;
+	flags->w0.hash_type =3D AUTH_NULL;
+	flags->w0.iv_source =3D IV_FROM_DPTR;
+	/* ask microcode to calculate ipad/opad */
+	flags->w0.auth_input_type =3D 1;
+	flags->f =3D be64_to_cpu(flags->f);
+
+	crypto_aead_set_reqsize(aead, sizeof(struct aead_request) +
+				sizeof(struct nitrox_kcrypt_request));
+
+	return 0;
+}
+
+static void nitrox_aead_exit(struct crypto_aead *aead)
+{
+	struct nitrox_crypto_ctx *nctx =3D crypto_aead_ctx(aead);
+
+	/* free the nitrox crypto context */
+	if (nctx->u.ctx_handle) {
+		struct flexi_crypto_context *fctx =3D nctx->u.fctx;
+
+		memzero_explicit(&fctx->crypto, sizeof(struct crypto_keys));
+		memzero_explicit(&fctx->auth, sizeof(struct auth_keys));
+		crypto_free_context((void *)nctx->chdr);
+	}
+	nitrox_put_device(nctx->ndev);
+
+	nctx->u.ctx_handle =3D 0;
+	nctx->ndev =3D NULL;
+}
+
+static struct aead_alg nitrox_aeads[] =3D { {
+	.base =3D {
+		.cra_name =3D "gcm(aes)",
+		.cra_driver_name =3D "n5_aes_gcm",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D AES_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.setkey =3D nitrox_aes_gcm_setkey,
+	.setauthsize =3D nitrox_aead_setauthsize,
+	.encrypt =3D nitrox_aes_gcm_enc,
+	.decrypt =3D nitrox_aes_gcm_dec,
+	.init =3D nitrox_aes_gcm_init,
+	.exit =3D nitrox_aead_exit,
+	.ivsize =3D GCM_AES_IV_SIZE,
+	.maxauthsize =3D AES_BLOCK_SIZE,
+} };
+
+int nitrox_register_aeads(void)
+{
+	return crypto_register_aeads(nitrox_aeads, ARRAY_SIZE(nitrox_aeads));
+}
+
+void nitrox_unregister_aeads(void)
+{
+	crypto_unregister_aeads(nitrox_aeads, ARRAY_SIZE(nitrox_aeads));
+}
diff --git a/drivers/crypto/cavium/nitrox/nitrox_algs.c b/drivers/crypto/ca=
vium/nitrox/nitrox_algs.c
index 10075a97ff0d..d646ae5f29b0 100644
--- a/drivers/crypto/cavium/nitrox/nitrox_algs.c
+++ b/drivers/crypto/cavium/nitrox/nitrox_algs.c
@@ -1,561 +1,24 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/crypto.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-
-#include <crypto/aes.h>
-#include <crypto/skcipher.h>
-#include <crypto/ctr.h>
-#include <crypto/des.h>
-#include <crypto/xts.h>
-
-#include "nitrox_dev.h"
 #include "nitrox_common.h"
-#include "nitrox_req.h"
-
-#define PRIO 4001
-
-struct nitrox_cipher {
-	const char *name;
-	enum flexi_cipher value;
-};
-
-/**
- * supported cipher list
- */
-static const struct nitrox_cipher flexi_cipher_table[] =3D {
-	{ "null",		CIPHER_NULL },
-	{ "cbc(des3_ede)",	CIPHER_3DES_CBC },
-	{ "ecb(des3_ede)",	CIPHER_3DES_ECB },
-	{ "cbc(aes)",		CIPHER_AES_CBC },
-	{ "ecb(aes)",		CIPHER_AES_ECB },
-	{ "cfb(aes)",		CIPHER_AES_CFB },
-	{ "rfc3686(ctr(aes))",	CIPHER_AES_CTR },
-	{ "xts(aes)",		CIPHER_AES_XTS },
-	{ "cts(cbc(aes))",	CIPHER_AES_CBC_CTS },
-	{ NULL,			CIPHER_INVALID }
-};
-
-static enum flexi_cipher flexi_cipher_type(const char *name)
-{
-	const struct nitrox_cipher *cipher =3D flexi_cipher_table;
-
-	while (cipher->name) {
-		if (!strcmp(cipher->name, name))
-			break;
-		cipher++;
-	}
-	return cipher->value;
-}
-
-static int flexi_aes_keylen(int keylen)
-{
-	int aes_keylen;
-
-	switch (keylen) {
-	case AES_KEYSIZE_128:
-		aes_keylen =3D 1;
-		break;
-	case AES_KEYSIZE_192:
-		aes_keylen =3D 2;
-		break;
-	case AES_KEYSIZE_256:
-		aes_keylen =3D 3;
-		break;
-	default:
-		aes_keylen =3D -EINVAL;
-		break;
-	}
-	return aes_keylen;
-}
-
-static int nitrox_skcipher_init(struct crypto_skcipher *tfm)
-{
-	struct nitrox_crypto_ctx *nctx =3D crypto_skcipher_ctx(tfm);
-	struct crypto_ctx_hdr *chdr;
-
-	/* get the first device */
-	nctx->ndev =3D nitrox_get_first_device();
-	if (!nctx->ndev)
-		return -ENODEV;
-
-	/* allocate nitrox crypto context */
-	chdr =3D crypto_alloc_context(nctx->ndev);
-	if (!chdr) {
-		nitrox_put_device(nctx->ndev);
-		return -ENOMEM;
-	}
-	nctx->chdr =3D chdr;
-	nctx->u.ctx_handle =3D (uintptr_t)((u8 *)chdr->vaddr +
-					 sizeof(struct ctx_hdr));
-	crypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(tfm) +
-				    sizeof(struct nitrox_kcrypt_request));
-	return 0;
-}
-
-static void nitrox_skcipher_exit(struct crypto_skcipher *tfm)
-{
-	struct nitrox_crypto_ctx *nctx =3D crypto_skcipher_ctx(tfm);
-
-	/* free the nitrox crypto context */
-	if (nctx->u.ctx_handle) {
-		struct flexi_crypto_context *fctx =3D nctx->u.fctx;
-
-		memset(&fctx->crypto, 0, sizeof(struct crypto_keys));
-		memset(&fctx->auth, 0, sizeof(struct auth_keys));
-		crypto_free_context((void *)nctx->chdr);
-	}
-	nitrox_put_device(nctx->ndev);
-
-	nctx->u.ctx_handle =3D 0;
-	nctx->ndev =3D NULL;
-}
-
-static inline int nitrox_skcipher_setkey(struct crypto_skcipher *cipher,
-					 int aes_keylen, const u8 *key,
-					 unsigned int keylen)
-{
-	struct crypto_tfm *tfm =3D crypto_skcipher_tfm(cipher);
-	struct nitrox_crypto_ctx *nctx =3D crypto_tfm_ctx(tfm);
-	struct flexi_crypto_context *fctx;
-	enum flexi_cipher cipher_type;
-	const char *name;
-
-	name =3D crypto_tfm_alg_name(tfm);
-	cipher_type =3D flexi_cipher_type(name);
-	if (unlikely(cipher_type =3D=3D CIPHER_INVALID)) {
-		pr_err("unsupported cipher: %s\n", name);
-		return -EINVAL;
-	}
-
-	/* fill crypto context */
-	fctx =3D nctx->u.fctx;
-	fctx->flags =3D 0;
-	fctx->w0.cipher_type =3D cipher_type;
-	fctx->w0.aes_keylen =3D aes_keylen;
-	fctx->w0.iv_source =3D IV_FROM_DPTR;
-	fctx->flags =3D cpu_to_be64(*(u64 *)&fctx->w0);
-	/* copy the key to context */
-	memcpy(fctx->crypto.u.key, key, keylen);
-
-	return 0;
-}
-
-static int nitrox_aes_setkey(struct crypto_skcipher *cipher, const u8 *key=
,
-			     unsigned int keylen)
-{
-	int aes_keylen;
-
-	aes_keylen =3D flexi_aes_keylen(keylen);
-	if (aes_keylen < 0) {
-		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	}
-	return nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);
-}
-
-static int alloc_src_sglist(struct skcipher_request *skreq, int ivsize)
-{
-	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
-	int nents =3D sg_nents(skreq->src) + 1;
-	struct se_crypto_request *creq =3D &nkreq->creq;
-	char *iv;
-	struct scatterlist *sg;
-
-	/* Allocate buffer to hold IV and input scatterlist array */
-	nkreq->src =3D alloc_req_buf(nents, ivsize, creq->gfp);
-	if (!nkreq->src)
-		return -ENOMEM;
-
-	/* copy iv */
-	iv =3D nkreq->src;
-	memcpy(iv, skreq->iv, ivsize);
-
-	sg =3D (struct scatterlist *)(iv + ivsize);
-	creq->src =3D sg;
-	sg_init_table(sg, nents);
-
-	/* Input format:
-	 * +----+----------------+
-	 * | IV | SRC sg entries |
-	 * +----+----------------+
-	 */
-
-	/* IV */
-	sg =3D create_single_sg(sg, iv, ivsize);
-	/* SRC entries */
-	create_multi_sg(sg, skreq->src);
-
-	return 0;
-}
-
-static int alloc_dst_sglist(struct skcipher_request *skreq, int ivsize)
-{
-	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
-	int nents =3D sg_nents(skreq->dst) + 3;
-	int extralen =3D ORH_HLEN + COMP_HLEN;
-	struct se_crypto_request *creq =3D &nkreq->creq;
-	struct scatterlist *sg;
-	char *iv =3D nkreq->src;
-
-	/* Allocate buffer to hold ORH, COMPLETION and output scatterlist
-	 * array
-	 */
-	nkreq->dst =3D alloc_req_buf(nents, extralen, creq->gfp);
-	if (!nkreq->dst)
-		return -ENOMEM;
-
-	creq->orh =3D (u64 *)(nkreq->dst);
-	set_orh_value(creq->orh);
-
-	creq->comp =3D (u64 *)(nkreq->dst + ORH_HLEN);
-	set_comp_value(creq->comp);
-
-	sg =3D (struct scatterlist *)(nkreq->dst + ORH_HLEN + COMP_HLEN);
-	creq->dst =3D sg;
-	sg_init_table(sg, nents);
-
-	/* Output format:
-	 * +-----+----+----------------+-----------------+
-	 * | ORH | IV | DST sg entries | COMPLETION Bytes|
-	 * +-----+----+----------------+-----------------+
-	 */
-
-	/* ORH */
-	sg =3D create_single_sg(sg, creq->orh, ORH_HLEN);
-	/* IV */
-	sg =3D create_single_sg(sg, iv, ivsize);
-	/* DST entries */
-	sg =3D create_multi_sg(sg, skreq->dst);
-	/* COMPLETION Bytes */
-	create_single_sg(sg, creq->comp, COMP_HLEN);
-
-	return 0;
-}
-
-static void free_src_sglist(struct skcipher_request *skreq)
-{
-	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
-
-	kfree(nkreq->src);
-}
=20
-static void free_dst_sglist(struct skcipher_request *skreq)
+int nitrox_crypto_register(void)
 {
-	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
+	int err;
=20
-	kfree(nkreq->dst);
-}
+	err =3D nitrox_register_skciphers();
+	if (err)
+		return err;
=20
-static void nitrox_skcipher_callback(struct skcipher_request *skreq,
-				     int err)
-{
-	free_src_sglist(skreq);
-	free_dst_sglist(skreq);
+	err =3D nitrox_register_aeads();
 	if (err) {
-		pr_err_ratelimited("request failed status 0x%0x\n", err);
-		err =3D -EINVAL;
-	}
-
-	skcipher_request_complete(skreq, err);
-}
-
-static int nitrox_skcipher_crypt(struct skcipher_request *skreq, bool enc)
-{
-	struct crypto_skcipher *cipher =3D crypto_skcipher_reqtfm(skreq);
-	struct nitrox_crypto_ctx *nctx =3D crypto_skcipher_ctx(cipher);
-	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
-	int ivsize =3D crypto_skcipher_ivsize(cipher);
-	struct se_crypto_request *creq;
-	int ret;
-
-	creq =3D &nkreq->creq;
-	creq->flags =3D skreq->base.flags;
-	creq->gfp =3D (skreq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?
-		     GFP_KERNEL : GFP_ATOMIC;
-
-	/* fill the request */
-	creq->ctrl.value =3D 0;
-	creq->opcode =3D FLEXI_CRYPTO_ENCRYPT_HMAC;
-	creq->ctrl.s.arg =3D (enc ? ENCRYPT : DECRYPT);
-	/* param0: length of the data to be encrypted */
-	creq->gph.param0 =3D cpu_to_be16(skreq->cryptlen);
-	creq->gph.param1 =3D 0;
-	/* param2: encryption data offset */
-	creq->gph.param2 =3D cpu_to_be16(ivsize);
-	creq->gph.param3 =3D 0;
-
-	creq->ctx_handle =3D nctx->u.ctx_handle;
-	creq->ctrl.s.ctxl =3D sizeof(struct flexi_crypto_context);
-
-	ret =3D alloc_src_sglist(skreq, ivsize);
-	if (ret)
-		return ret;
-
-	ret =3D alloc_dst_sglist(skreq, ivsize);
-	if (ret) {
-		free_src_sglist(skreq);
-		return ret;
-	}
-
-	nkreq->nctx =3D nctx;
-	nkreq->skreq =3D skreq;
-
-	/* send the crypto request */
-	return nitrox_process_se_request(nctx->ndev, creq,
-					 nitrox_skcipher_callback, skreq);
-}
-
-static int nitrox_aes_encrypt(struct skcipher_request *skreq)
-{
-	return nitrox_skcipher_crypt(skreq, true);
-}
-
-static int nitrox_aes_decrypt(struct skcipher_request *skreq)
-{
-	return nitrox_skcipher_crypt(skreq, false);
-}
-
-static int nitrox_3des_setkey(struct crypto_skcipher *cipher,
-			      const u8 *key, unsigned int keylen)
-{
-	if (keylen !=3D DES3_EDE_KEY_SIZE) {
-		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	}
-
-	return nitrox_skcipher_setkey(cipher, 0, key, keylen);
-}
-
-static int nitrox_3des_encrypt(struct skcipher_request *skreq)
-{
-	return nitrox_skcipher_crypt(skreq, true);
-}
-
-static int nitrox_3des_decrypt(struct skcipher_request *skreq)
-{
-	return nitrox_skcipher_crypt(skreq, false);
-}
-
-static int nitrox_aes_xts_setkey(struct crypto_skcipher *cipher,
-				 const u8 *key, unsigned int keylen)
-{
-	struct crypto_tfm *tfm =3D crypto_skcipher_tfm(cipher);
-	struct nitrox_crypto_ctx *nctx =3D crypto_tfm_ctx(tfm);
-	struct flexi_crypto_context *fctx;
-	int aes_keylen, ret;
-
-	ret =3D xts_check_key(tfm, key, keylen);
-	if (ret)
-		return ret;
-
-	keylen /=3D 2;
-
-	aes_keylen =3D flexi_aes_keylen(keylen);
-	if (aes_keylen < 0) {
-		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
+		nitrox_unregister_skciphers();
+		return err;
 	}
=20
-	fctx =3D nctx->u.fctx;
-	/* copy KEY2 */
-	memcpy(fctx->auth.u.key2, (key + keylen), keylen);
-
-	return nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);
-}
-
-static int nitrox_aes_ctr_rfc3686_setkey(struct crypto_skcipher *cipher,
-					 const u8 *key, unsigned int keylen)
-{
-	struct crypto_tfm *tfm =3D crypto_skcipher_tfm(cipher);
-	struct nitrox_crypto_ctx *nctx =3D crypto_tfm_ctx(tfm);
-	struct flexi_crypto_context *fctx;
-	int aes_keylen;
-
-	if (keylen < CTR_RFC3686_NONCE_SIZE)
-		return -EINVAL;
-
-	fctx =3D nctx->u.fctx;
-
-	memcpy(fctx->crypto.iv, key + (keylen - CTR_RFC3686_NONCE_SIZE),
-	       CTR_RFC3686_NONCE_SIZE);
-
-	keylen -=3D CTR_RFC3686_NONCE_SIZE;
-
-	aes_keylen =3D flexi_aes_keylen(keylen);
-	if (aes_keylen < 0) {
-		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
-		return -EINVAL;
-	}
-	return nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);
-}
-
-static struct skcipher_alg nitrox_skciphers[] =3D { {
-	.base =3D {
-		.cra_name =3D "cbc(aes)",
-		.cra_driver_name =3D "n5_cbc(aes)",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D AES_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D AES_MIN_KEY_SIZE,
-	.max_keysize =3D AES_MAX_KEY_SIZE,
-	.ivsize =3D AES_BLOCK_SIZE,
-	.setkey =3D nitrox_aes_setkey,
-	.encrypt =3D nitrox_aes_encrypt,
-	.decrypt =3D nitrox_aes_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}, {
-	.base =3D {
-		.cra_name =3D "ecb(aes)",
-		.cra_driver_name =3D "n5_ecb(aes)",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D AES_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D AES_MIN_KEY_SIZE,
-	.max_keysize =3D AES_MAX_KEY_SIZE,
-	.ivsize =3D AES_BLOCK_SIZE,
-	.setkey =3D nitrox_aes_setkey,
-	.encrypt =3D nitrox_aes_encrypt,
-	.decrypt =3D nitrox_aes_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}, {
-	.base =3D {
-		.cra_name =3D "cfb(aes)",
-		.cra_driver_name =3D "n5_cfb(aes)",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D AES_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D AES_MIN_KEY_SIZE,
-	.max_keysize =3D AES_MAX_KEY_SIZE,
-	.ivsize =3D AES_BLOCK_SIZE,
-	.setkey =3D nitrox_aes_setkey,
-	.encrypt =3D nitrox_aes_encrypt,
-	.decrypt =3D nitrox_aes_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}, {
-	.base =3D {
-		.cra_name =3D "xts(aes)",
-		.cra_driver_name =3D "n5_xts(aes)",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D AES_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D 2 * AES_MIN_KEY_SIZE,
-	.max_keysize =3D 2 * AES_MAX_KEY_SIZE,
-	.ivsize =3D AES_BLOCK_SIZE,
-	.setkey =3D nitrox_aes_xts_setkey,
-	.encrypt =3D nitrox_aes_encrypt,
-	.decrypt =3D nitrox_aes_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}, {
-	.base =3D {
-		.cra_name =3D "rfc3686(ctr(aes))",
-		.cra_driver_name =3D "n5_rfc3686(ctr(aes))",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D 1,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
-	.max_keysize =3D AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
-	.ivsize =3D CTR_RFC3686_IV_SIZE,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-	.setkey =3D nitrox_aes_ctr_rfc3686_setkey,
-	.encrypt =3D nitrox_aes_encrypt,
-	.decrypt =3D nitrox_aes_decrypt,
-}, {
-	.base =3D {
-		.cra_name =3D "cts(cbc(aes))",
-		.cra_driver_name =3D "n5_cts(cbc(aes))",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D AES_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_type =3D &crypto_ablkcipher_type,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D AES_MIN_KEY_SIZE,
-	.max_keysize =3D AES_MAX_KEY_SIZE,
-	.ivsize =3D AES_BLOCK_SIZE,
-	.setkey =3D nitrox_aes_setkey,
-	.encrypt =3D nitrox_aes_encrypt,
-	.decrypt =3D nitrox_aes_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}, {
-	.base =3D {
-		.cra_name =3D "cbc(des3_ede)",
-		.cra_driver_name =3D "n5_cbc(des3_ede)",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D DES3_EDE_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D DES3_EDE_KEY_SIZE,
-	.max_keysize =3D DES3_EDE_KEY_SIZE,
-	.ivsize =3D DES3_EDE_BLOCK_SIZE,
-	.setkey =3D nitrox_3des_setkey,
-	.encrypt =3D nitrox_3des_encrypt,
-	.decrypt =3D nitrox_3des_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}, {
-	.base =3D {
-		.cra_name =3D "ecb(des3_ede)",
-		.cra_driver_name =3D "n5_ecb(des3_ede)",
-		.cra_priority =3D PRIO,
-		.cra_flags =3D CRYPTO_ALG_ASYNC,
-		.cra_blocksize =3D DES3_EDE_BLOCK_SIZE,
-		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
-		.cra_alignmask =3D 0,
-		.cra_module =3D THIS_MODULE,
-	},
-	.min_keysize =3D DES3_EDE_KEY_SIZE,
-	.max_keysize =3D DES3_EDE_KEY_SIZE,
-	.ivsize =3D DES3_EDE_BLOCK_SIZE,
-	.setkey =3D nitrox_3des_setkey,
-	.encrypt =3D nitrox_3des_encrypt,
-	.decrypt =3D nitrox_3des_decrypt,
-	.init =3D nitrox_skcipher_init,
-	.exit =3D nitrox_skcipher_exit,
-}
-
-};
-
-int nitrox_crypto_register(void)
-{
-	return crypto_register_skciphers(nitrox_skciphers,
-					 ARRAY_SIZE(nitrox_skciphers));
+	return 0;
 }
=20
 void nitrox_crypto_unregister(void)
 {
-	crypto_unregister_skciphers(nitrox_skciphers,
-				    ARRAY_SIZE(nitrox_skciphers));
+	nitrox_unregister_aeads();
+	nitrox_unregister_skciphers();
 }
diff --git a/drivers/crypto/cavium/nitrox/nitrox_common.h b/drivers/crypto/=
cavium/nitrox/nitrox_common.h
index 863143a8336b..e4be69d7e6e5 100644
--- a/drivers/crypto/cavium/nitrox/nitrox_common.h
+++ b/drivers/crypto/cavium/nitrox/nitrox_common.h
@@ -7,6 +7,10 @@
=20
 int nitrox_crypto_register(void);
 void nitrox_crypto_unregister(void);
+int nitrox_register_aeads(void);
+void nitrox_unregister_aeads(void);
+int nitrox_register_skciphers(void);
+void nitrox_unregister_skciphers(void);
 void *crypto_alloc_context(struct nitrox_device *ndev);
 void crypto_free_context(void *ctx);
 struct nitrox_device *nitrox_get_first_device(void);
@@ -19,7 +23,7 @@ void pkt_slc_resp_tasklet(unsigned long data);
 int nitrox_process_se_request(struct nitrox_device *ndev,
 			      struct se_crypto_request *req,
 			      completion_t cb,
-			      struct skcipher_request *skreq);
+			      void *cb_arg);
 void backlog_qflush_work(struct work_struct *work);
=20
=20
diff --git a/drivers/crypto/cavium/nitrox/nitrox_req.h b/drivers/crypto/cav=
ium/nitrox/nitrox_req.h
index d45ff91c19a9..76c0f0be7233 100644
--- a/drivers/crypto/cavium/nitrox/nitrox_req.h
+++ b/drivers/crypto/cavium/nitrox/nitrox_req.h
@@ -8,6 +8,7 @@
 #include "nitrox_dev.h"
=20
 #define PENDING_SIG	0xFFFFFFFFFFFFFFFFUL
+#define PRIO 4001
=20
 /**
  * struct gphdr - General purpose Header
@@ -106,6 +107,18 @@ enum flexi_cipher {
 	CIPHER_INVALID
 };
=20
+enum flexi_auth {
+	AUTH_NULL =3D 0,
+	AUTH_MD5,
+	AUTH_SHA1,
+	AUTH_SHA2_SHA224,
+	AUTH_SHA2_SHA256,
+	AUTH_SHA2_SHA384,
+	AUTH_SHA2_SHA512,
+	AUTH_GMAC,
+	AUTH_INVALID
+};
+
 /**
  * struct crypto_keys - Crypto keys
  * @key: Encryption key or KEY1 for AES-XTS
@@ -132,6 +145,32 @@ struct auth_keys {
 	u8 opad[64];
 };
=20
+union fc_ctx_flags {
+	__be64 f;
+	struct {
+#if defined(__BIG_ENDIAN_BITFIELD)
+		u64 cipher_type	: 4;
+		u64 reserved_59	: 1;
+		u64 aes_keylen : 2;
+		u64 iv_source : 1;
+		u64 hash_type : 4;
+		u64 reserved_49_51 : 3;
+		u64 auth_input_type: 1;
+		u64 mac_len : 8;
+		u64 reserved_0_39 : 40;
+#else
+		u64 reserved_0_39 : 40;
+		u64 mac_len : 8;
+		u64 auth_input_type: 1;
+		u64 reserved_49_51 : 3;
+		u64 hash_type : 4;
+		u64 iv_source : 1;
+		u64 aes_keylen : 2;
+		u64 reserved_59	: 1;
+		u64 cipher_type	: 4;
+#endif
+	} w0;
+};
 /**
  * struct flexi_crypto_context - Crypto context
  * @cipher_type: Encryption cipher type
@@ -146,33 +185,7 @@ struct auth_keys {
  * @auth: Authentication keys
  */
 struct flexi_crypto_context {
-	union {
-		__be64 flags;
-		struct {
-#if defined(__BIG_ENDIAN_BITFIELD)
-			u64 cipher_type	: 4;
-			u64 reserved_59	: 1;
-			u64 aes_keylen : 2;
-			u64 iv_source : 1;
-			u64 hash_type : 4;
-			u64 reserved_49_51 : 3;
-			u64 auth_input_type: 1;
-			u64 mac_len : 8;
-			u64 reserved_0_39 : 40;
-#else
-			u64 reserved_0_39 : 40;
-			u64 mac_len : 8;
-			u64 auth_input_type: 1;
-			u64 reserved_49_51 : 3;
-			u64 hash_type : 4;
-			u64 iv_source : 1;
-			u64 aes_keylen : 2;
-			u64 reserved_59	: 1;
-			u64 cipher_type	: 4;
-#endif
-		} w0;
-	};
-
+	union fc_ctx_flags flags;
 	struct crypto_keys crypto;
 	struct auth_keys auth;
 };
@@ -194,8 +207,6 @@ struct nitrox_crypto_ctx {
=20
 struct nitrox_kcrypt_request {
 	struct se_crypto_request creq;
-	struct nitrox_crypto_ctx *nctx;
-	struct skcipher_request *skreq;
 	u8 *src;
 	u8 *dst;
 };
@@ -400,7 +411,7 @@ struct resp_hdr {
 	u64 *completion;
 };
=20
-typedef void (*completion_t)(struct skcipher_request *skreq, int err);
+typedef void (*completion_t)(void *arg, int err);
=20
 /**
  * struct nitrox_softreq - Represents the NIROX Request.
@@ -435,9 +446,30 @@ struct nitrox_softreq {
 	unsigned long tstamp;
=20
 	completion_t callback;
-	struct skcipher_request *skreq;
+	void *cb_arg;
 };
=20
+static inline int flexi_aes_keylen(int keylen)
+{
+	int aes_keylen;
+
+	switch (keylen) {
+	case AES_KEYSIZE_128:
+		aes_keylen =3D 1;
+		break;
+	case AES_KEYSIZE_192:
+		aes_keylen =3D 2;
+		break;
+	case AES_KEYSIZE_256:
+		aes_keylen =3D 3;
+		break;
+	default:
+		aes_keylen =3D -EINVAL;
+		break;
+	}
+	return aes_keylen;
+}
+
 static inline void *alloc_req_buf(int nents, int extralen, gfp_t gfp)
 {
 	size_t size;
@@ -448,6 +480,14 @@ static inline void *alloc_req_buf(int nents, int extra=
len, gfp_t gfp)
 	return kzalloc(size, gfp);
 }
=20
+/**
+ * create_single_sg - Point SG entry to the data
+ * @sg:		Destination SG list
+ * @buf:	Data
+ * @buflen:	Data length
+ *
+ * Returns next free entry in the destination SG list
+ **/
 static inline struct scatterlist *create_single_sg(struct scatterlist *sg,
 						   void *buf, int buflen)
 {
@@ -456,18 +496,33 @@ static inline struct scatterlist *create_single_sg(st=
ruct scatterlist *sg,
 	return sg;
 }
=20
+/**
+ * create_multi_sg - Create multiple sg entries with buflen data length fr=
om
+ *		     source sglist
+ * @to_sg:	Destination SG list
+ * @from_sg:	Source SG list
+ * @buflen:	Data length
+ *
+ * Returns next free entry in the destination SG list
+ **/
 static inline struct scatterlist *create_multi_sg(struct scatterlist *to_s=
g,
-						  struct scatterlist *from_sg)
+						  struct scatterlist *from_sg,
+						  int buflen)
 {
-	struct scatterlist *sg;
-	int i;
+	struct scatterlist *sg =3D to_sg;
+	unsigned int sglen;
+
+	for (; buflen; buflen -=3D sglen) {
+		sglen =3D from_sg->length;
+		if (sglen > buflen)
+			sglen =3D buflen;
=20
-	for_each_sg(from_sg, sg, sg_nents(from_sg), i) {
-		sg_set_buf(to_sg, sg_virt(sg), sg->length);
-		to_sg++;
+		sg_set_buf(sg, sg_virt(from_sg), sglen);
+		from_sg =3D sg_next(from_sg);
+		sg++;
 	}
=20
-	return to_sg;
+	return sg;
 }
=20
 static inline void set_orh_value(u64 *orh)
@@ -480,4 +535,112 @@ static inline void set_comp_value(u64 *comp)
 	WRITE_ONCE(*comp, PENDING_SIG);
 }
=20
+static inline int alloc_src_req_buf(struct nitrox_kcrypt_request *nkreq,
+				    int nents, int ivsize)
+{
+	struct se_crypto_request *creq =3D &nkreq->creq;
+
+	nkreq->src =3D alloc_req_buf(nents, ivsize, creq->gfp);
+	if (!nkreq->src)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static inline void nitrox_creq_copy_iv(char *dst, char *src, int size)
+{
+	memcpy(dst, src, size);
+}
+
+static inline struct scatterlist *nitrox_creq_src_sg(char *iv, int ivsize)
+{
+	return (struct scatterlist *)(iv + ivsize);
+}
+
+static inline void nitrox_creq_set_src_sg(struct nitrox_kcrypt_request *nk=
req,
+					  int nents, int ivsize,
+					  struct scatterlist *src, int buflen)
+{
+	char *iv =3D nkreq->src;
+	struct scatterlist *sg;
+	struct se_crypto_request *creq =3D &nkreq->creq;
+
+	creq->src =3D nitrox_creq_src_sg(iv, ivsize);
+	sg =3D creq->src;
+	sg_init_table(sg, nents);
+
+	/* Input format:
+	 * +----+----------------+
+	 * | IV | SRC sg entries |
+	 * +----+----------------+
+	 */
+
+	/* IV */
+	sg =3D create_single_sg(sg, iv, ivsize);
+	/* SRC entries */
+	create_multi_sg(sg, src, buflen);
+}
+
+static inline int alloc_dst_req_buf(struct nitrox_kcrypt_request *nkreq,
+				    int nents)
+{
+	int extralen =3D ORH_HLEN + COMP_HLEN;
+	struct se_crypto_request *creq =3D &nkreq->creq;
+
+	nkreq->dst =3D alloc_req_buf(nents, extralen, creq->gfp);
+	if (!nkreq->dst)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static inline void nitrox_creq_set_orh(struct nitrox_kcrypt_request *nkreq=
)
+{
+	struct se_crypto_request *creq =3D &nkreq->creq;
+
+	creq->orh =3D (u64 *)(nkreq->dst);
+	set_orh_value(creq->orh);
+}
+
+static inline void nitrox_creq_set_comp(struct nitrox_kcrypt_request *nkre=
q)
+{
+	struct se_crypto_request *creq =3D &nkreq->creq;
+
+	creq->comp =3D (u64 *)(nkreq->dst + ORH_HLEN);
+	set_comp_value(creq->comp);
+}
+
+static inline struct scatterlist *nitrox_creq_dst_sg(char *dst)
+{
+	return (struct scatterlist *)(dst + ORH_HLEN + COMP_HLEN);
+}
+
+static inline void nitrox_creq_set_dst_sg(struct nitrox_kcrypt_request *nk=
req,
+					  int nents, int ivsize,
+					  struct scatterlist *dst, int buflen)
+{
+	struct se_crypto_request *creq =3D &nkreq->creq;
+	struct scatterlist *sg;
+	char *iv =3D nkreq->src;
+
+	creq->dst =3D nitrox_creq_dst_sg(nkreq->dst);
+	sg =3D creq->dst;
+	sg_init_table(sg, nents);
+
+	/* Output format:
+	 * +-----+----+----------------+-----------------+
+	 * | ORH | IV | DST sg entries | COMPLETION Bytes|
+	 * +-----+----+----------------+-----------------+
+	 */
+
+	/* ORH */
+	sg =3D create_single_sg(sg, creq->orh, ORH_HLEN);
+	/* IV */
+	sg =3D create_single_sg(sg, iv, ivsize);
+	/* DST entries */
+	sg =3D create_multi_sg(sg, dst, buflen);
+	/* COMPLETION Bytes */
+	create_single_sg(sg, creq->comp, COMP_HLEN);
+}
+
 #endif /* __NITROX_REQ_H */
diff --git a/drivers/crypto/cavium/nitrox/nitrox_reqmgr.c b/drivers/crypto/=
cavium/nitrox/nitrox_reqmgr.c
index d566bb904ec2..e34e4df8fd24 100644
--- a/drivers/crypto/cavium/nitrox/nitrox_reqmgr.c
+++ b/drivers/crypto/cavium/nitrox/nitrox_reqmgr.c
@@ -269,6 +269,8 @@ static inline bool cmdq_full(struct nitrox_cmdq *cmdq, =
int qlen)
 		smp_mb__after_atomic();
 		return true;
 	}
+	/* sync with other cpus */
+	smp_mb__after_atomic();
 	return false;
 }
=20
@@ -324,8 +326,6 @@ static int post_backlog_cmds(struct nitrox_cmdq *cmdq)
 	spin_lock_bh(&cmdq->backlog_qlock);
=20
 	list_for_each_entry_safe(sr, tmp, &cmdq->backlog_head, backlog) {
-		struct skcipher_request *skreq;
-
 		/* submit until space available */
 		if (unlikely(cmdq_full(cmdq, ndev->qlen))) {
 			ret =3D -ENOSPC;
@@ -337,12 +337,8 @@ static int post_backlog_cmds(struct nitrox_cmdq *cmdq)
 		/* sync with other cpus */
 		smp_mb__after_atomic();
=20
-		skreq =3D sr->skreq;
 		/* post the command */
 		post_se_instr(sr, cmdq);
-
-		/* backlog requests are posted, wakeup with -EINPROGRESS */
-		skcipher_request_complete(skreq, -EINPROGRESS);
 	}
 	spin_unlock_bh(&cmdq->backlog_qlock);
=20
@@ -365,7 +361,7 @@ static int nitrox_enqueue_request(struct nitrox_softreq=
 *sr)
 		}
 		/* add to backlog list */
 		backlog_list_add(sr, cmdq);
-		return -EBUSY;
+		return -EINPROGRESS;
 	}
 	post_se_instr(sr, cmdq);
=20
@@ -382,7 +378,7 @@ static int nitrox_enqueue_request(struct nitrox_softreq=
 *sr)
 int nitrox_process_se_request(struct nitrox_device *ndev,
 			      struct se_crypto_request *req,
 			      completion_t callback,
-			      struct skcipher_request *skreq)
+			      void *cb_arg)
 {
 	struct nitrox_softreq *sr;
 	dma_addr_t ctx_handle =3D 0;
@@ -399,7 +395,7 @@ int nitrox_process_se_request(struct nitrox_device *nde=
v,
 	sr->flags =3D req->flags;
 	sr->gfp =3D req->gfp;
 	sr->callback =3D callback;
-	sr->skreq =3D skreq;
+	sr->cb_arg =3D cb_arg;
=20
 	atomic_set(&sr->status, REQ_NOT_POSTED);
=20
@@ -513,7 +509,20 @@ void backlog_qflush_work(struct work_struct *work)
=20
 static bool sr_completed(struct nitrox_softreq *sr)
 {
-	return (READ_ONCE(*sr->resp.orh) !=3D READ_ONCE(*sr->resp.completion));
+	u64 orh =3D READ_ONCE(*sr->resp.orh);
+	unsigned long timeout =3D jiffies + msecs_to_jiffies(1);
+
+	if ((orh !=3D PENDING_SIG) && (orh & 0xff))
+		return true;
+
+	while (READ_ONCE(*sr->resp.completion) =3D=3D PENDING_SIG) {
+		if (time_after(jiffies, timeout)) {
+			pr_err("comp not done\n");
+			return false;
+		}
+	}
+
+	return true;
 }
=20
 /**
@@ -527,8 +536,6 @@ static void process_response_list(struct nitrox_cmdq *c=
mdq)
 {
 	struct nitrox_device *ndev =3D cmdq->ndev;
 	struct nitrox_softreq *sr;
-	struct skcipher_request *skreq;
-	completion_t callback;
 	int req_completed =3D 0, err =3D 0, budget;
=20
 	/* check all pending requests */
@@ -558,15 +565,12 @@ static void process_response_list(struct nitrox_cmdq =
*cmdq)
 		/* remove from response list */
 		response_list_del(sr, cmdq);
=20
-		callback =3D sr->callback;
-		skreq =3D sr->skreq;
-
 		/* ORH error code */
 		err =3D READ_ONCE(*sr->resp.orh) & 0xff;
 		softreq_destroy(sr);
=20
-		if (callback)
-			callback(skreq, err);
+		if (sr->callback)
+			sr->callback(sr->cb_arg, err);
=20
 		req_completed++;
 	}
diff --git a/drivers/crypto/cavium/nitrox/nitrox_skcipher.c b/drivers/crypt=
o/cavium/nitrox/nitrox_skcipher.c
new file mode 100644
index 000000000000..d4935d6cefdd
--- /dev/null
+++ b/drivers/crypto/cavium/nitrox/nitrox_skcipher.c
@@ -0,0 +1,498 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/crypto.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+
+#include <crypto/aes.h>
+#include <crypto/skcipher.h>
+#include <crypto/ctr.h>
+#include <crypto/des.h>
+#include <crypto/xts.h>
+
+#include "nitrox_dev.h"
+#include "nitrox_common.h"
+#include "nitrox_req.h"
+
+struct nitrox_cipher {
+	const char *name;
+	enum flexi_cipher value;
+};
+
+/**
+ * supported cipher list
+ */
+static const struct nitrox_cipher flexi_cipher_table[] =3D {
+	{ "null",		CIPHER_NULL },
+	{ "cbc(des3_ede)",	CIPHER_3DES_CBC },
+	{ "ecb(des3_ede)",	CIPHER_3DES_ECB },
+	{ "cbc(aes)",		CIPHER_AES_CBC },
+	{ "ecb(aes)",		CIPHER_AES_ECB },
+	{ "cfb(aes)",		CIPHER_AES_CFB },
+	{ "rfc3686(ctr(aes))",	CIPHER_AES_CTR },
+	{ "xts(aes)",		CIPHER_AES_XTS },
+	{ "cts(cbc(aes))",	CIPHER_AES_CBC_CTS },
+	{ NULL,			CIPHER_INVALID }
+};
+
+static enum flexi_cipher flexi_cipher_type(const char *name)
+{
+	const struct nitrox_cipher *cipher =3D flexi_cipher_table;
+
+	while (cipher->name) {
+		if (!strcmp(cipher->name, name))
+			break;
+		cipher++;
+	}
+	return cipher->value;
+}
+
+static int nitrox_skcipher_init(struct crypto_skcipher *tfm)
+{
+	struct nitrox_crypto_ctx *nctx =3D crypto_skcipher_ctx(tfm);
+	struct crypto_ctx_hdr *chdr;
+
+	/* get the first device */
+	nctx->ndev =3D nitrox_get_first_device();
+	if (!nctx->ndev)
+		return -ENODEV;
+
+	/* allocate nitrox crypto context */
+	chdr =3D crypto_alloc_context(nctx->ndev);
+	if (!chdr) {
+		nitrox_put_device(nctx->ndev);
+		return -ENOMEM;
+	}
+	nctx->chdr =3D chdr;
+	nctx->u.ctx_handle =3D (uintptr_t)((u8 *)chdr->vaddr +
+					 sizeof(struct ctx_hdr));
+	crypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(tfm) +
+				    sizeof(struct nitrox_kcrypt_request));
+	return 0;
+}
+
+static void nitrox_skcipher_exit(struct crypto_skcipher *tfm)
+{
+	struct nitrox_crypto_ctx *nctx =3D crypto_skcipher_ctx(tfm);
+
+	/* free the nitrox crypto context */
+	if (nctx->u.ctx_handle) {
+		struct flexi_crypto_context *fctx =3D nctx->u.fctx;
+
+		memzero_explicit(&fctx->crypto, sizeof(struct crypto_keys));
+		memzero_explicit(&fctx->auth, sizeof(struct auth_keys));
+		crypto_free_context((void *)nctx->chdr);
+	}
+	nitrox_put_device(nctx->ndev);
+
+	nctx->u.ctx_handle =3D 0;
+	nctx->ndev =3D NULL;
+}
+
+static inline int nitrox_skcipher_setkey(struct crypto_skcipher *cipher,
+					 int aes_keylen, const u8 *key,
+					 unsigned int keylen)
+{
+	struct crypto_tfm *tfm =3D crypto_skcipher_tfm(cipher);
+	struct nitrox_crypto_ctx *nctx =3D crypto_tfm_ctx(tfm);
+	struct flexi_crypto_context *fctx;
+	union fc_ctx_flags *flags;
+	enum flexi_cipher cipher_type;
+	const char *name;
+
+	name =3D crypto_tfm_alg_name(tfm);
+	cipher_type =3D flexi_cipher_type(name);
+	if (unlikely(cipher_type =3D=3D CIPHER_INVALID)) {
+		pr_err("unsupported cipher: %s\n", name);
+		return -EINVAL;
+	}
+
+	/* fill crypto context */
+	fctx =3D nctx->u.fctx;
+	flags =3D &fctx->flags;
+	flags->f =3D 0;
+	flags->w0.cipher_type =3D cipher_type;
+	flags->w0.aes_keylen =3D aes_keylen;
+	flags->w0.iv_source =3D IV_FROM_DPTR;
+	flags->f =3D cpu_to_be64(*(u64 *)&flags->w0);
+	/* copy the key to context */
+	memcpy(fctx->crypto.u.key, key, keylen);
+
+	return 0;
+}
+
+static int nitrox_aes_setkey(struct crypto_skcipher *cipher, const u8 *key=
,
+			     unsigned int keylen)
+{
+	int aes_keylen;
+
+	aes_keylen =3D flexi_aes_keylen(keylen);
+	if (aes_keylen < 0) {
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+	return nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);
+}
+
+static int alloc_src_sglist(struct skcipher_request *skreq, int ivsize)
+{
+	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
+	int nents =3D sg_nents(skreq->src) + 1;
+	int ret;
+
+	/* Allocate buffer to hold IV and input scatterlist array */
+	ret =3D alloc_src_req_buf(nkreq, nents, ivsize);
+	if (ret)
+		return ret;
+
+	nitrox_creq_copy_iv(nkreq->src, skreq->iv, ivsize);
+	nitrox_creq_set_src_sg(nkreq, nents, ivsize, skreq->src,
+			       skreq->cryptlen);
+
+	return 0;
+}
+
+static int alloc_dst_sglist(struct skcipher_request *skreq, int ivsize)
+{
+	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
+	int nents =3D sg_nents(skreq->dst) + 3;
+	int ret;
+
+	/* Allocate buffer to hold ORH, COMPLETION and output scatterlist
+	 * array
+	 */
+	ret =3D alloc_dst_req_buf(nkreq, nents);
+	if (ret)
+		return ret;
+
+	nitrox_creq_set_orh(nkreq);
+	nitrox_creq_set_comp(nkreq);
+	nitrox_creq_set_dst_sg(nkreq, nents, ivsize, skreq->dst,
+			       skreq->cryptlen);
+
+	return 0;
+}
+
+static void free_src_sglist(struct skcipher_request *skreq)
+{
+	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
+
+	kfree(nkreq->src);
+}
+
+static void free_dst_sglist(struct skcipher_request *skreq)
+{
+	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
+
+	kfree(nkreq->dst);
+}
+
+static void nitrox_skcipher_callback(void *arg, int err)
+{
+	struct skcipher_request *skreq =3D arg;
+
+	free_src_sglist(skreq);
+	free_dst_sglist(skreq);
+	if (err) {
+		pr_err_ratelimited("request failed status 0x%0x\n", err);
+		err =3D -EINVAL;
+	}
+
+	skcipher_request_complete(skreq, err);
+}
+
+static int nitrox_skcipher_crypt(struct skcipher_request *skreq, bool enc)
+{
+	struct crypto_skcipher *cipher =3D crypto_skcipher_reqtfm(skreq);
+	struct nitrox_crypto_ctx *nctx =3D crypto_skcipher_ctx(cipher);
+	struct nitrox_kcrypt_request *nkreq =3D skcipher_request_ctx(skreq);
+	int ivsize =3D crypto_skcipher_ivsize(cipher);
+	struct se_crypto_request *creq;
+	int ret;
+
+	creq =3D &nkreq->creq;
+	creq->flags =3D skreq->base.flags;
+	creq->gfp =3D (skreq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?
+		     GFP_KERNEL : GFP_ATOMIC;
+
+	/* fill the request */
+	creq->ctrl.value =3D 0;
+	creq->opcode =3D FLEXI_CRYPTO_ENCRYPT_HMAC;
+	creq->ctrl.s.arg =3D (enc ? ENCRYPT : DECRYPT);
+	/* param0: length of the data to be encrypted */
+	creq->gph.param0 =3D cpu_to_be16(skreq->cryptlen);
+	creq->gph.param1 =3D 0;
+	/* param2: encryption data offset */
+	creq->gph.param2 =3D cpu_to_be16(ivsize);
+	creq->gph.param3 =3D 0;
+
+	creq->ctx_handle =3D nctx->u.ctx_handle;
+	creq->ctrl.s.ctxl =3D sizeof(struct flexi_crypto_context);
+
+	ret =3D alloc_src_sglist(skreq, ivsize);
+	if (ret)
+		return ret;
+
+	ret =3D alloc_dst_sglist(skreq, ivsize);
+	if (ret) {
+		free_src_sglist(skreq);
+		return ret;
+	}
+
+	/* send the crypto request */
+	return nitrox_process_se_request(nctx->ndev, creq,
+					 nitrox_skcipher_callback, skreq);
+}
+
+static int nitrox_aes_encrypt(struct skcipher_request *skreq)
+{
+	return nitrox_skcipher_crypt(skreq, true);
+}
+
+static int nitrox_aes_decrypt(struct skcipher_request *skreq)
+{
+	return nitrox_skcipher_crypt(skreq, false);
+}
+
+static int nitrox_3des_setkey(struct crypto_skcipher *cipher,
+			      const u8 *key, unsigned int keylen)
+{
+	if (keylen !=3D DES3_EDE_KEY_SIZE) {
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	return nitrox_skcipher_setkey(cipher, 0, key, keylen);
+}
+
+static int nitrox_3des_encrypt(struct skcipher_request *skreq)
+{
+	return nitrox_skcipher_crypt(skreq, true);
+}
+
+static int nitrox_3des_decrypt(struct skcipher_request *skreq)
+{
+	return nitrox_skcipher_crypt(skreq, false);
+}
+
+static int nitrox_aes_xts_setkey(struct crypto_skcipher *cipher,
+				 const u8 *key, unsigned int keylen)
+{
+	struct crypto_tfm *tfm =3D crypto_skcipher_tfm(cipher);
+	struct nitrox_crypto_ctx *nctx =3D crypto_tfm_ctx(tfm);
+	struct flexi_crypto_context *fctx;
+	int aes_keylen, ret;
+
+	ret =3D xts_check_key(tfm, key, keylen);
+	if (ret)
+		return ret;
+
+	keylen /=3D 2;
+
+	aes_keylen =3D flexi_aes_keylen(keylen);
+	if (aes_keylen < 0) {
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+
+	fctx =3D nctx->u.fctx;
+	/* copy KEY2 */
+	memcpy(fctx->auth.u.key2, (key + keylen), keylen);
+
+	return nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);
+}
+
+static int nitrox_aes_ctr_rfc3686_setkey(struct crypto_skcipher *cipher,
+					 const u8 *key, unsigned int keylen)
+{
+	struct crypto_tfm *tfm =3D crypto_skcipher_tfm(cipher);
+	struct nitrox_crypto_ctx *nctx =3D crypto_tfm_ctx(tfm);
+	struct flexi_crypto_context *fctx;
+	int aes_keylen;
+
+	if (keylen < CTR_RFC3686_NONCE_SIZE)
+		return -EINVAL;
+
+	fctx =3D nctx->u.fctx;
+
+	memcpy(fctx->crypto.iv, key + (keylen - CTR_RFC3686_NONCE_SIZE),
+	       CTR_RFC3686_NONCE_SIZE);
+
+	keylen -=3D CTR_RFC3686_NONCE_SIZE;
+
+	aes_keylen =3D flexi_aes_keylen(keylen);
+	if (aes_keylen < 0) {
+		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
+		return -EINVAL;
+	}
+	return nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);
+}
+
+static struct skcipher_alg nitrox_skciphers[] =3D { {
+	.base =3D {
+		.cra_name =3D "cbc(aes)",
+		.cra_driver_name =3D "n5_cbc(aes)",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D AES_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D AES_MIN_KEY_SIZE,
+	.max_keysize =3D AES_MAX_KEY_SIZE,
+	.ivsize =3D AES_BLOCK_SIZE,
+	.setkey =3D nitrox_aes_setkey,
+	.encrypt =3D nitrox_aes_encrypt,
+	.decrypt =3D nitrox_aes_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}, {
+	.base =3D {
+		.cra_name =3D "ecb(aes)",
+		.cra_driver_name =3D "n5_ecb(aes)",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D AES_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D AES_MIN_KEY_SIZE,
+	.max_keysize =3D AES_MAX_KEY_SIZE,
+	.ivsize =3D AES_BLOCK_SIZE,
+	.setkey =3D nitrox_aes_setkey,
+	.encrypt =3D nitrox_aes_encrypt,
+	.decrypt =3D nitrox_aes_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}, {
+	.base =3D {
+		.cra_name =3D "cfb(aes)",
+		.cra_driver_name =3D "n5_cfb(aes)",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D AES_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D AES_MIN_KEY_SIZE,
+	.max_keysize =3D AES_MAX_KEY_SIZE,
+	.ivsize =3D AES_BLOCK_SIZE,
+	.setkey =3D nitrox_aes_setkey,
+	.encrypt =3D nitrox_aes_encrypt,
+	.decrypt =3D nitrox_aes_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}, {
+	.base =3D {
+		.cra_name =3D "xts(aes)",
+		.cra_driver_name =3D "n5_xts(aes)",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D AES_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D 2 * AES_MIN_KEY_SIZE,
+	.max_keysize =3D 2 * AES_MAX_KEY_SIZE,
+	.ivsize =3D AES_BLOCK_SIZE,
+	.setkey =3D nitrox_aes_xts_setkey,
+	.encrypt =3D nitrox_aes_encrypt,
+	.decrypt =3D nitrox_aes_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}, {
+	.base =3D {
+		.cra_name =3D "rfc3686(ctr(aes))",
+		.cra_driver_name =3D "n5_rfc3686(ctr(aes))",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D 1,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+	.max_keysize =3D AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+	.ivsize =3D CTR_RFC3686_IV_SIZE,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+	.setkey =3D nitrox_aes_ctr_rfc3686_setkey,
+	.encrypt =3D nitrox_aes_encrypt,
+	.decrypt =3D nitrox_aes_decrypt,
+}, {
+	.base =3D {
+		.cra_name =3D "cts(cbc(aes))",
+		.cra_driver_name =3D "n5_cts(cbc(aes))",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D AES_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_type =3D &crypto_ablkcipher_type,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D AES_MIN_KEY_SIZE,
+	.max_keysize =3D AES_MAX_KEY_SIZE,
+	.ivsize =3D AES_BLOCK_SIZE,
+	.setkey =3D nitrox_aes_setkey,
+	.encrypt =3D nitrox_aes_encrypt,
+	.decrypt =3D nitrox_aes_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}, {
+	.base =3D {
+		.cra_name =3D "cbc(des3_ede)",
+		.cra_driver_name =3D "n5_cbc(des3_ede)",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D DES3_EDE_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D DES3_EDE_KEY_SIZE,
+	.max_keysize =3D DES3_EDE_KEY_SIZE,
+	.ivsize =3D DES3_EDE_BLOCK_SIZE,
+	.setkey =3D nitrox_3des_setkey,
+	.encrypt =3D nitrox_3des_encrypt,
+	.decrypt =3D nitrox_3des_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}, {
+	.base =3D {
+		.cra_name =3D "ecb(des3_ede)",
+		.cra_driver_name =3D "n5_ecb(des3_ede)",
+		.cra_priority =3D PRIO,
+		.cra_flags =3D CRYPTO_ALG_ASYNC,
+		.cra_blocksize =3D DES3_EDE_BLOCK_SIZE,
+		.cra_ctxsize =3D sizeof(struct nitrox_crypto_ctx),
+		.cra_alignmask =3D 0,
+		.cra_module =3D THIS_MODULE,
+	},
+	.min_keysize =3D DES3_EDE_KEY_SIZE,
+	.max_keysize =3D DES3_EDE_KEY_SIZE,
+	.ivsize =3D DES3_EDE_BLOCK_SIZE,
+	.setkey =3D nitrox_3des_setkey,
+	.encrypt =3D nitrox_3des_encrypt,
+	.decrypt =3D nitrox_3des_decrypt,
+	.init =3D nitrox_skcipher_init,
+	.exit =3D nitrox_skcipher_exit,
+}
+
+};
+
+int nitrox_register_skciphers(void)
+{
+	return crypto_register_skciphers(nitrox_skciphers,
+					 ARRAY_SIZE(nitrox_skciphers));
+}
+
+void nitrox_unregister_skciphers(void)
+{
+	crypto_unregister_skciphers(nitrox_skciphers,
+				    ARRAY_SIZE(nitrox_skciphers));
+}
--=20
2.13.6

