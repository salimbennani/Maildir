Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 26 Nov 2018 08:51:19 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga005.jf.intel.com (orsmga005.jf.intel.com [10.7.209.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 867365803C2;
	Sun, 25 Nov 2018 10:09:56 -0800 (PST)
Received: from fmsmga102.fm.intel.com ([10.1.193.69])
  by orsmga005-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 10:09:55 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AmYXgnRQ9xYI+TdDw0R6yPY9aedpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YBeGt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZAo2y?=
 =?us-ascii?q?cZYBAeQCM+hfrYb9qVQBoxSlBQm0Bu7i0SNEi3zs0KEmyektDR3K0Qo9FNwOqn?=
 =?us-ascii?q?TUq9D1Ob8OXO+v1qnIyjPDZO5I1Df67ojIdRQhru+RVr93a8Xe1U4vFwXCjlWU?=
 =?us-ascii?q?t4PoJCia1+QRs2ib8eVvTviji2k9qwF+uzWiwNonhIrRho8N1FzI6SF0zJwoKd?=
 =?us-ascii?q?C2VkJ3e8OoHZhMuy2ANoZ7QNsuTm5qtSog17ELtoS3cSgQxJg6xxPSbeGMfZKS?=
 =?us-ascii?q?7RL5TumRJC91hHJ7d7K7gBa/6VagyuLiWcmuylpKrTRKksPKtn8T0xzf8M+HSu?=
 =?us-ascii?q?Fy/ku52DaP0R7c6v1cLEwqiabWL4QtzqM+m5YNq0jPAyz7lFnsgKKXdEgo4u2o?=
 =?us-ascii?q?5P7mYrXiqJ+cLYh0igTmP6Qqm8y/B/k4MwcXU2iY5+u8zrvj8lP9QLlTif03nK?=
 =?us-ascii?q?/Zv47AJckAuK65DBFa0pw55xa8ETimytIYkmcDLF5ffxKHlYfpN0nUIP/kFfe/?=
 =?us-ascii?q?n0iskDBzyvDCP73hAYvCImLMkbf8Zrt9709cyAwuzdFQ/Z5UC7cBIO7tVU/1rt?=
 =?us-ascii?q?DXEhg5Mwmsyeb9FNp9zp8eWX6IAqKBMKPdq16I5v41LOmLfoMVuCv9JOIj5/7h?=
 =?us-ascii?q?lnI5nV4dfa+03ZoYcny4H/JmI1mHbnromNsODWAKvg8mRuzwlFKCSSJTZ2q1X6?=
 =?us-ascii?q?8k5DE7D5ypAZ3ARoCqhryB2iC7E4ZSZmBHDFCMDHjpe5+FW/cKdCKdPMthniYY?=
 =?us-ascii?q?WrimTo8rzQuuuxPiy7p7MurU/TUVuoj41Nh14O3Tlgs+9SZuAMSfyGyNS2B0nm?=
 =?us-ascii?q?UVRz45xqx/oEp9ykud3qh8mfBXCdtT5/ZRWAcgKZHc1/B6C8z1Wg/ZfdeGUlCm?=
 =?us-ascii?q?Ts+iATEwVN0xxdAObl15G9WjiBDDwiWrD6UUl7yNGJw77Kbc02LtKMZ6znbMzL?=
 =?us-ascii?q?MhgEU+QstTKW2mgbZy+BXJCI7XjUqVjaaqer4a3C7W6miDy22CvEVbUA51VaXI?=
 =?us-ascii?q?RnQfZkrQrdTk6ULOVb6uCbI7MgRfzc6OMLdFatrsjV9eXvfsJMzeY36tm2e3HR?=
 =?us-ascii?q?uH26mDbJT0dGkH3CXSEk4EkxsN8naALgU+Aiaho2TDDD1hD17vYkXs8fVgp3O/?=
 =?us-ascii?q?VEM70waKb0h53bqv5hEVneCcS+8U3r8cpCchqjB0HFGh39LWC9uMvRZhcL9bYd?=
 =?us-ascii?q?Mn5FdH1GTZtwNmM5ykLqBigEMecgtts0Pv0RV3FptPkcwwoHw2ywpyLLqS0Eld?=
 =?us-ascii?q?eDOAwZDwJrrXJ3Ho8xCrdaHX1U/R0daM9qgU9fQ3tk/svAeqFkol7XVqyN1V03?=
 =?us-ascii?q?qa5pXXAwseS5PxUkAr9xdko7HWeDUy54TR1Xd0K6m7rifC2841BOsi0huhf8pf?=
 =?us-ascii?q?PLmYGwPoEswaB9KhKOolm1WyahIEPeZS9LM7Ps+8dvuG3rKrM/hknD68kWtH54?=
 =?us-ascii?q?V92FqW9yVgUu7Iw4oFw/aA0wudVjfzkE2ustrqloBDfz0SGHSwyTLlBIJIeqJ9?=
 =?us-ascii?q?Z4ILBnqwLM2twdV+gYXgW3pZ9F6lGlMH19WleRuUb1zhwwJQ0V4brmCgmSu91z?=
 =?us-ascii?q?Z0iS0mrrKD3CzSxOTvbBoGOm9RSGhil1vsOpW0j9YBUUisbggpkgal5Engy6ha?=
 =?us-ascii?q?oqR/M3fcQUNScyfqKGFiV7O6tqCebM5X9JMorSJXXfy+YV+AUL79oBga0yT5E2?=
 =?us-ascii?q?tF3j87dDKqupT/nxNkjmKQN3JzrHvfecFtyhbT/t3cRfhN3jUYQCl0kyXYBl+5?=
 =?us-ascii?q?P9Ox59Wbi4/DsvyiV2KmTpBScTPkzYSauCu55G1qBwayn/Symt3hDAg73jX319?=
 =?us-ascii?q?hsVSXUshn8ZpPn2Li9MeJiZkNoHkPz69JmGoFilYs9nJIQ1mIbhpmP/XoHjH38?=
 =?us-ascii?q?MdNU2a/laHoNRDgLw8Pa4QT/2U1jKG6JyJz9VnmH3sRhYNy6aHsM2i0h98BKFL?=
 =?us-ascii?q?uU7LtckCtwo1q4rhjebeJznzgD0vsu9GAVg/sStwUz1CWdDasfHU1ZPSzqihSJ?=
 =?us-ascii?q?4MqyrKRRZGazb7ew0FByksymDLGHugtcQmr2eo8+HS9s6cVyKE7M0Hr26o3+ed?=
 =?us-ascii?q?jfd9QTtgCPkxfbjuhYM5YxlvsMhSp6NmPxp3wly+gnjRNw2ZG2ppSIK2Jo/Kih?=
 =?us-ascii?q?GB5XKiX1Z98P+jHqlatRhdyZ34erHpV8ADkLWIboQOmsEDITs/TnKgmPHCc9qn?=
 =?us-ascii?q?edBbrQAwuf5F16oHLIFpChL2uXK2UBzdV+WBmdI1RSgAIOUzU/gJE5DRqmxND7?=
 =?us-ascii?q?fEd6+zAR5UP4qh1WxeJzLBT/VmbfpAG1ajY7UpSfLRxW7h1c6EfRK8CR8uVzHy?=
 =?us-ascii?q?RA9J27sAONMnCbZxhPDWwRWk2EAE3jPqCz5dba9eiUHPG+L/zIYbWBsuFeU/aI?=
 =?us-ascii?q?xZSy0opp5TqMN8OPPmV8AP0/wEZMQXd5G8HBkTUVVyMXjz7Nb9KcpBqk+i14sM?=
 =?us-ascii?q?G/8PfoWALu/4ePCKFSMdJg+x+om6eDKvWQiT19KTZZ0JMM2HDJxKIe3F4UlyFh?=
 =?us-ascii?q?aT2tHa4cui7KSaLagrVXAAIDayNvKMtI6Lox0RNQOcHAkNP6yL55guQxC1dETl?=
 =?us-ascii?q?HhnsCpZcoXI2CyLl/HBUCLNKiYKj3P2c34faS8SbhIhuVOqxKwoSqbE1PkPjmb?=
 =?us-ascii?q?iznpVhWvPftQgy2BIBNeuJ+ychB2BGjnTdLmbAC7MdBtgT03x700mm3FNWoGPT?=
 =?us-ascii?q?dgdENNq6Wa7TlEjfVnB2xB8n1lIPGEmimD6enYL5cWsf1zDSV1l+JV+nI6y7RO?=
 =?us-ascii?q?4SFARfx1njbSr9F0r1GnlOmP1iRoUB5UpjlXg4KLuBYqBaKM8JRcVXva1AwC4H?=
 =?us-ascii?q?/WCBkQodZhTNr1tPN+0N/KwYv6MjBEu/nT+8wYCoCAIcmANn0lPDLjCSLUAQFD?=
 =?us-ascii?q?SiSkYzKMz3dBme2foyXG5qMxrYLhzd9XEudW?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AVAADt5Ppbh0O0hNFhHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBg2snjBFfix+CIZIxhHcUgRADTw8BARgTAYFLhw8iNAkNAQMBAQE?=
 =?us-ascii?q?BAQECARMBAQEIDQkIKSMMgjYkAYJiAwMBAiQLAQ0BATcBBQkBAVADMQEFARwZB?=
 =?us-ascii?q?YMcggIDAppUPIodgWwzgnYBAQWHEggSh0yDD4EcF4FAP4ERh1UUAYYBiROCAIR?=
 =?us-ascii?q?/jyxGCZEkCxiJUYc2ASyXXQYCCQcPIYElgg0zGggoCIMnghsMFxKDOIpwIjIBg?=
 =?us-ascii?q?QQBAYl8AQEkB4IgAQE?=
X-IPAS-Result: =?us-ascii?q?A0AVAADt5Ppbh0O0hNFhHAEBAQQBAQcEAQGBUQcBAQsBg2s?=
 =?us-ascii?q?njBFfix+CIZIxhHcUgRADTw8BARgTAYFLhw8iNAkNAQMBAQEBAQECARMBAQEID?=
 =?us-ascii?q?QkIKSMMgjYkAYJiAwMBAiQLAQ0BATcBBQkBAVADMQEFARwZBYMcggIDAppUPIo?=
 =?us-ascii?q?dgWwzgnYBAQWHEggSh0yDD4EcF4FAP4ERh1UUAYYBiROCAIR/jyxGCZEkCxiJU?=
 =?us-ascii?q?Yc2ASyXXQYCCQcPIYElgg0zGggoCIMnghsMFxKDOIpwIjIBgQQBAYl8AQEkB4I?=
 =?us-ascii?q?gAQE?=
X-IronPort-AV: E=Sophos;i="5.56,278,1539673200"; 
   d="scan'208";a="54214631"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 25 Nov 2018 10:09:54 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726765AbeKZFBV (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Mon, 26 Nov 2018 00:01:21 -0500
Received: from mail-it1-f195.google.com ([209.85.166.195]:38207 "EHLO
        mail-it1-f195.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726537AbeKZFBV (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Mon, 26 Nov 2018 00:01:21 -0500
Received: by mail-it1-f195.google.com with SMTP id h65so24174087ith.3
        for <linux-kernel@vger.kernel.org>; Sun, 25 Nov 2018 10:09:42 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=bytheb-org.20150623.gappssmtp.com; s=20150623;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :mime-version:content-transfer-encoding;
        bh=UhWWASpWuscnRsDFC5DeC96YRbPqtXlv0yit6Esju10=;
        b=pn9O2FAfWBa2/l5ZP5eN3v6aYao+QZYJVFsyWtk1VGD/RNaHkYGgowUZHvwoF1PSI6
         Ya+LOh0y2awr/SH0Lw6Mks8JLYUqgiti7tNmCbzabVQuJvDFYyK1x01Nn1IJOdDanhG+
         9+fk1nf168wVZMl/qcVMLLzTXIYMWBis1GJCAQe7Nuoljuwzaew2PcJOIoyGuEoCl4x3
         o4jT8huOPXBdL749ddS96BHZBBRfXqFtHhaozabLL5UTkPhIfh6YsYgDj7KvdM05YHq+
         RsMs0YCIHFyo9UwFqMXDcJvjtZ9XB/rv0kfozgUtfj/2XoIj+a/YvKMf54fxYBq1TAil
         ZfJQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=UhWWASpWuscnRsDFC5DeC96YRbPqtXlv0yit6Esju10=;
        b=Ym2w2qzVG5ZDAN22j1r4zZKlwqlOrvZDe9OXHvaL5iPAmHI+DeTaKU/L/E7rFx3RPe
         2xNncBb22o9PNtsIIj8DMd9JL6bnMJjTdheNI75pI/tdTdwY0+nJ26oUXaiyZ63rjrM2
         HKIDFwms4wLt430of5HJrZSdzcYhwVzFvJkqanWJSeYqHsPL0QXcqDFeaQLybMtD6JzO
         P+89/KMaIXYWX2g5rN9pzSWseelNtRfZvriPFyWbAmKFNjf/PwhO51LHwAUodSdGkW/D
         NanH6/3JRrhQJJuph2mjc8jCiSFzsNAakRo+lzk/ehxACSuUYV85utzDfQhfD8eAePcv
         OnjQ==
X-Gm-Message-State: AGRZ1gLLzg/fb1ThaANfBf8fmQcPgM7e+il8FmWF/PMZ4tr01qS3LWbR
        lO6p7Qe7OcUp/nFuB1DMclAZxA==
X-Google-Smtp-Source: AFSGD/UywMOP9aEsbkrc8XK2rYa5eLMB5rAsNn8grl3rej/m4gzFMBZA9PFmeWeSIm7pt9nVLsmR/A==
X-Received: by 2002:a24:5284:: with SMTP id d126mr20588190itb.110.1543169382150;
        Sun, 25 Nov 2018 10:09:42 -0800 (PST)
Received: from dhcp-25.97.bos.redhat.com (047-014-005-015.res.spectrum.com. [47.14.5.15])
        by smtp.gmail.com with ESMTPSA id y8sm5959768ita.5.2018.11.25.10.09.40
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Sun, 25 Nov 2018 10:09:41 -0800 (PST)
From: Aaron Conole <aconole@bytheb.org>
To: netdev@vger.kernel.org
Cc: linux-kernel@vger.kernel.org, netfilter-devel@vger.kernel.org,
        coreteam@netfilter.org, Alexei Starovoitov <ast@kernel.org>,
        Daniel Borkmann <daniel@iogearbox.net>,
        Pablo Neira Ayuso <pablo@netfilter.org>,
        Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>,
        Florian Westphal <fw@strlen.de>,
        John Fastabend <john.fastabend@gmail.com>,
        Jesper Brouer <brouer@redhat.com>,
        "David S . Miller" <davem@davemloft.net>,
        Andy Gospodarek <andy@greyhouse.net>,
        Rony Efraim <ronye@mellanox.com>,
        Simon Horman <horms@verge.net>,
        Marcelo Leitner <marcelo.leitner@gmail.com>
Subject: [RFC -next v0 3/3] netfilter: nf_flow_table_bpf_map: introduce new loadable bpf map
Date: Sun, 25 Nov 2018 13:09:19 -0500
Message-Id: <20181125180919.13996-4-aconole@bytheb.org>
X-Mailer: git-send-email 2.19.1
In-Reply-To: <20181125180919.13996-1-aconole@bytheb.org>
References: <20181125180919.13996-1-aconole@bytheb.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

This commit introduces a new loadable map that allows an eBPF program to
query the flow offload tables for specific flow information.  For now,
that information is limited to input and output index information.  Future
enhancements would be to include connection tracking details, such as
state, metadata, and allow for window validation.

Signed-off-by: Aaron Conole <aconole@bytheb.org>
---
 include/linux/bpf_types.h                 |   2 +
 include/uapi/linux/bpf.h                  |   7 +
 net/netfilter/Kconfig                     |   9 +
 net/netfilter/Makefile                    |   1 +
 net/netfilter/nf_flow_table_bpf_flowmap.c | 202 ++++++++++++++++++++++
 5 files changed, 221 insertions(+)
 create mode 100644 net/netfilter/nf_flow_table_bpf_flowmap.c

diff --git a/include/linux/bpf_types.h b/include/linux/bpf_types.h
index 44d9ab4809bd..82d3038cf6c3 100644
--- a/include/linux/bpf_types.h
+++ b/include/linux/bpf_types.h
@@ -71,3 +71,5 @@ BPF_MAP_TYPE(BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, reuseport_array_ops)
 #endif
 BPF_MAP_TYPE(BPF_MAP_TYPE_QUEUE, queue_map_ops)
 BPF_MAP_TYPE(BPF_MAP_TYPE_STACK, stack_map_ops)
+
+BPF_MAP_TYPE(BPF_MAP_TYPE_FLOWMAP, loadable_map)
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index 852dc17ab47a..fb77c8c5c209 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -131,6 +131,7 @@ enum bpf_map_type {
 	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
 	BPF_MAP_TYPE_QUEUE,
 	BPF_MAP_TYPE_STACK,
+	BPF_MAP_TYPE_FLOWMAP,
 };
 
 enum bpf_prog_type {
@@ -2942,4 +2943,10 @@ struct bpf_flow_keys {
 	};
 };
 
+struct bpf_flow_map {
+	struct bpf_flow_keys	flow;
+	__u32			iifindex;
+	__u32			oifindex;
+};
+
 #endif /* _UAPI__LINUX_BPF_H__ */
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index 2ab870ef233a..30f1bc9084be 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -709,6 +709,15 @@ config NF_FLOW_TABLE
 
 	  To compile it as a module, choose M here.
 
+config NF_FLOW_TABLE_BPF
+	tristate "Netfilter flowtable BPF map"
+	depends on NF_FLOW_TABLE
+	depends on BPF_LOADABLE_MAPS
+	help
+	  This option adds support for retrieving flow table entries
+	  via a loadable BPF map.
+	  To compile it as a module, choose M here.
+
 config NETFILTER_XTABLES
 	tristate "Netfilter Xtables support (required for ip_tables)"
 	default m if NETFILTER_ADVANCED=n
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index 4ddf3ef51ece..8dba928a03fd 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_NFT_FWD_NETDEV)	+= nft_fwd_netdev.o
 
 # flow table infrastructure
 obj-$(CONFIG_NF_FLOW_TABLE)	+= nf_flow_table.o
+obj-$(CONFIG_NF_FLOW_TABLE_BPF)	+= nf_flow_table_bpf_flowmap.o
 nf_flow_table-objs := nf_flow_table_core.o nf_flow_table_ip.o
 
 obj-$(CONFIG_NF_FLOW_TABLE_INET) += nf_flow_table_inet.o
diff --git a/net/netfilter/nf_flow_table_bpf_flowmap.c b/net/netfilter/nf_flow_table_bpf_flowmap.c
new file mode 100644
index 000000000000..577985560883
--- /dev/null
+++ b/net/netfilter/nf_flow_table_bpf_flowmap.c
@@ -0,0 +1,202 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2018, Aaron Conole <aconole@bytheb.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/bpf.h>
+#include <net/xdp.h>
+#include <linux/filter.h>
+#include <trace/events/xdp.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_flow_table.h>
+
+struct flow_map_internal {
+	struct bpf_map map;
+	struct nf_flowtable net_flow_table;
+};
+
+static void flow_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)
+{
+	map->map_type = attr->map_type;
+	map->key_size = attr->key_size;
+	map->value_size = attr->value_size;
+	map->max_entries = attr->max_entries;
+	map->map_flags = attr->map_flags;
+	map->numa_node = bpf_map_attr_numa_node(attr);
+}
+
+static struct bpf_map *flow_map_alloc(union bpf_attr *attr)
+{
+	struct flow_map_internal *fmap_ret;
+	u64 cost;
+	int err;
+
+	if (!capable(CAP_NET_ADMIN))
+		return ERR_PTR(-EPERM);
+
+	if (attr->max_entries == 0 ||
+	    attr->key_size != sizeof(struct bpf_flow_map) ||
+	    attr->value_size != sizeof(struct bpf_flow_map))
+		return ERR_PTR(-EINVAL);
+
+	fmap_ret = kzalloc(sizeof(*fmap_ret), GFP_USER);
+	if (!fmap_ret)
+		return ERR_PTR(-ENOMEM);
+
+	flow_map_init_from_attr(&fmap_ret->map, attr);
+	cost = (u64)fmap_ret->map.max_entries * sizeof(struct flow_offload);
+	if (cost >= U32_MAX - PAGE_SIZE) {
+		kfree(&fmap_ret);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	fmap_ret->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;
+
+	/* if map size is larger than memlock limit, reject it early */
+	if ((err = bpf_map_precharge_memlock(fmap_ret->map.pages))) {
+		kfree(&fmap_ret);
+		return ERR_PTR(err);
+	}
+
+	memset(&fmap_ret->net_flow_table, 0, sizeof(fmap_ret->net_flow_table));
+	fmap_ret->net_flow_table.flags |= NF_FLOWTABLE_F_SNOOP;
+	nf_flow_table_init(&fmap_ret->net_flow_table);
+
+	return &fmap_ret->map;
+}
+
+static void flow_map_free(struct bpf_map *map)
+{
+	struct flow_map_internal *fmap = container_of(map,
+						      struct flow_map_internal,
+						      map);
+
+	nf_flow_table_free(&fmap->net_flow_table);
+	synchronize_rcu();
+	kfree(fmap);
+}
+
+static void flow_walk(struct flow_offload *flow, void *data)
+{
+	printk("Flow offload dir0: %x:%d -> %x:%d, %u, %u, %d, %u\n",
+	       flow->tuplehash[0].tuple.src_v4.s_addr,
+	       flow->tuplehash[0].tuple.src_port,
+	       flow->tuplehash[0].tuple.dst_v4.s_addr,
+	       flow->tuplehash[0].tuple.dst_port,
+	       flow->tuplehash[0].tuple.l3proto,
+	       flow->tuplehash[0].tuple.l4proto,
+	       flow->tuplehash[0].tuple.iifidx,
+	       flow->tuplehash[0].tuple.dir
+	       );
+
+	printk("Flow offload dir1: %x:%d -> %x:%d, %u, %u, %d, %u\n",
+	       flow->tuplehash[1].tuple.src_v4.s_addr,
+	       flow->tuplehash[1].tuple.src_port,
+	       flow->tuplehash[1].tuple.dst_v4.s_addr,
+	       flow->tuplehash[1].tuple.dst_port,
+	       flow->tuplehash[1].tuple.l3proto,
+	       flow->tuplehash[1].tuple.l4proto,
+	       flow->tuplehash[1].tuple.iifidx,
+	       flow->tuplehash[1].tuple.dir
+	       );
+}
+
+static void *flow_map_lookup_elem(struct bpf_map *map, void *key)
+{
+	struct flow_map_internal *fmap = container_of(map,
+						      struct flow_map_internal, map);
+	struct bpf_flow_map *internal_key = (struct bpf_flow_map *)key;
+	struct flow_offload_tuple_rhash *hash_ret;
+	struct flow_offload_tuple lookup_key;
+
+	memset(&lookup_key, 0, sizeof(lookup_key));
+	lookup_key.src_port = ntohs(internal_key->flow.sport);
+	lookup_key.dst_port = ntohs(internal_key->flow.dport);
+	lookup_key.dir = 0;
+
+	if (internal_key->flow.addr_proto == htons(ETH_P_IP)) {
+		lookup_key.l3proto = AF_INET;
+		lookup_key.src_v4.s_addr = ntohl(internal_key->flow.ipv4_src);
+		lookup_key.dst_v4.s_addr = ntohl(internal_key->flow.ipv4_dst);
+	} else if (internal_key->flow.addr_proto == htons(ETH_P_IPV6)) {
+		lookup_key.l3proto = AF_INET6;
+		memcpy(&lookup_key.src_v6,
+		       internal_key->flow.ipv6_src,
+		       sizeof(lookup_key.src_v6));
+		memcpy(&lookup_key.dst_v6,
+		       internal_key->flow.ipv6_dst,
+		       sizeof(lookup_key.dst_v6));
+	} else
+		return NULL;
+
+	lookup_key.l4proto = (u8)internal_key->flow.ip_proto;
+	lookup_key.iifidx = internal_key->iifindex;
+
+	printk("Flow offload lookup: %x:%d -> %x:%d, %u, %u, %d, %u\n",
+	       lookup_key.src_v4.s_addr, lookup_key.src_port,
+	       lookup_key.dst_v4.s_addr, lookup_key.dst_port,
+	       lookup_key.l3proto, lookup_key.l4proto,
+	       lookup_key.iifidx, lookup_key.dir);
+	hash_ret = flow_offload_lookup(&fmap->net_flow_table, &lookup_key);
+	if (!hash_ret) {
+		memcpy(&lookup_key.src_v6, internal_key->flow.ipv6_src,
+		       sizeof(lookup_key.src_v6));
+		memcpy(&lookup_key.dst_v6, internal_key->flow.ipv6_dst,
+		       sizeof(lookup_key.dst_v6));
+		lookup_key.src_port = internal_key->flow.dport;
+		lookup_key.dst_port = internal_key->flow.sport;
+		lookup_key.dir = 1;
+		hash_ret = flow_offload_lookup(&fmap->net_flow_table,
+					       &lookup_key);
+	}
+
+	if (!hash_ret) {
+		printk("No flow found, but table is: %d\n",
+		       atomic_read(&fmap->net_flow_table.rhashtable.nelems));
+		nf_flow_table_iterate(&fmap->net_flow_table, flow_walk, NULL);
+		return NULL;
+	}
+
+	printk("Flow matched!\n");
+	return key;
+}
+
+static int flow_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
+{
+	return 0;
+}
+
+static int flow_map_check_no_btf(const struct bpf_map *map,
+				 const struct btf_type *key_type,
+				 const struct btf_type *value_type)
+{
+	return -ENOTSUPP;
+}
+
+const struct bpf_map_ops flow_map_ops = {
+	.map_alloc = flow_map_alloc,
+	.map_free = flow_map_free,
+	.map_get_next_key = flow_map_get_next_key,
+	.map_lookup_elem = flow_map_lookup_elem,
+	.map_check_btf = flow_map_check_no_btf,
+};
+
+static int __init flow_map_init(void)
+{
+	bpf_map_insert_ops(BPF_MAP_TYPE_FLOWMAP, &flow_map_ops);
+	return 0;
+}
+
+module_init(flow_map_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Aaron Conole <aconole@bytheb.org>");
-- 
2.19.1

