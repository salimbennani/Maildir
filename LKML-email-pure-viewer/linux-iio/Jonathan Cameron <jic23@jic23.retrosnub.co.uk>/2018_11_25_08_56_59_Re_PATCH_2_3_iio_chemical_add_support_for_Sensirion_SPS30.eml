Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 22:12:48 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga004.fm.intel.com (fmsmga004.fm.intel.com [10.253.24.48])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id C0D7D580478;
	Sun, 25 Nov 2018 00:57:14 -0800 (PST)
Received: from fmsmga101.fm.intel.com ([10.1.193.65])
  by fmsmga004-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 00:57:14 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3A2BeF8R8yYOrJ2f9uRHKM819IXTAuvvDOBiVQ1KB9?=
 =?us-ascii?q?1+MVIJqq85mqBkHD//Il1AaPAd2Lraocw8Pt8InYEVQa5piAtH1QOLdtbDQizf?=
 =?us-ascii?q?ssogo7HcSeAlf6JvO5JwYzHcBFSUM3tyrjaRsdF8nxfUDdrWOv5jAOBBr/KRB1?=
 =?us-ascii?q?JuPoEYLOksi7ze+/94HQbglSmDaxfa55IQmrownWqsQYm5ZpJLwryhvOrHtIeu?=
 =?us-ascii?q?BWyn1tKFmOgRvy5dq+8YB6/ShItP0v68BPUaPhf6QlVrNYFygpM3o05MLwqxbO?=
 =?us-ascii?q?SxaE62YGXWUXlhpIBBXF7A3/U5zsvCb2qvZx1S+HNsDtU7s6RSqt4LtqSB/wiS?=
 =?us-ascii?q?cIKTg58H3MisdtiK5XuQ+tqwBjz4LRZoyeKfhwcb7Hfd4CS2RPXthfWTFCDIy+?=
 =?us-ascii?q?YYsBCOUOMvpXoYnmv1sDrwCzBRWuCu711jNFnGP60bM83u88EQ/GxgsgH9cWvX?=
 =?us-ascii?q?rQq9X1Mr0dUfy1zKbSyzXIcu1b1i346IfWaBAhpveMVq93fMrTyEkgCx3Jg1uL?=
 =?us-ascii?q?pIznPjOayvoBvmaB4+p6S+2vl3QnqwZqojip28cjkZPFiZ4Sylze6CV5w584KN?=
 =?us-ascii?q?ulQ0B4ed6pCIVcuz2eOodsX88vTX9ktDwnxrAFpZK3ZikHxZY/yxPcdvCLaYyF?=
 =?us-ascii?q?7xP5WOqPLzp1i2hpdK+wihux90Wr1/fyWdOu0FlQqypIitnMuW4J1xzU8sWHVP?=
 =?us-ascii?q?R98Vm72TqV1ADc9PtEIUYqmqrfMZIhxaQwlpULvUTCGC/5hln2gbeIekk4/uWk?=
 =?us-ascii?q?8fnrb7v4qpOGKoN5iR3yPr4vl8G9Geg4NxIBX2mf+eSyzr3j+kj5Ta1Ojv03lK?=
 =?us-ascii?q?nZrZ/bKd0YpqGnGQ9V1Jgs6xKmAzeh3tUYm2cILEhedRKZgIjmJUvOLOr7Dfih?=
 =?us-ascii?q?mVSslilkx/TcMr3mGJXNIWDPkK39crZl905c1A0zwMhb55JVCbEOPuj/W0DstN?=
 =?us-ascii?q?HDCh85Mgq0w/voCdln14MeX36PDbGdMK/IrVCI4ecvKfGWZIAJoDb9N+Ql5/n2?=
 =?us-ascii?q?gH85g1AdfLWp0oEQaHyiHvRmPl+WYXzjgtoaFWcKvww+TPHliVGYUD5TYWqyUL?=
 =?us-ascii?q?w45j0hFI2mCoLDTJi3gLOdxCe7AoFWZmdeB1COFnfnaZ+IW/QLaCKUJM9hlScJ?=
 =?us-ascii?q?VbygS48nyBGvuxX2y7thLurI5CIYsYjv28Ry5+3WjRsy7yB7D9yB02GRSGF5hn?=
 =?us-ascii?q?kHRyQ23KB4okxx0E2D3rJ6g/FDEdxT5vVJUho1NJLGzux6DczyVRzFftuTVFmm?=
 =?us-ascii?q?RdCmCykrTt0t298Of1p9G9K6gxDAxSWqBaUZl7iKBJMu9KLc0GP8J8J8y3bAya?=
 =?us-ascii?q?kggEMqQspJNW26mKF/8xLfCJLOk0Wcj6yqb7gT3DbR9GefymqDpFxXXxRuUarb?=
 =?us-ascii?q?R3wfZlHZrdLi5kzcSb+iDrAnMghEyc6GMaZKbtzpjVNbRPbsItjeYmSxm3uuCh?=
 =?us-ascii?q?aM3L+DcI3qe2AF1iXHFEcEixwT/WqBNQUmGyiuuXzeAyJ0GVLveUzs9/J+p229?=
 =?us-ascii?q?TkIvywGKbkth16e6+xIPhPycTe8T0awAuCs7tzp0G1O91crMC9WcvwphYLlcYd?=
 =?us-ascii?q?Ql7Vdb1GLZsgt9PoCgL6FinFIebx57v0T01xVzC4VAl8cqoWguzApzL6KYzVxA?=
 =?us-ascii?q?eymZ3ZD2Jr3YNG3y8AqzZK7R31HUyMyW9bsX6PQkt1XjuxmkGVAm83p53NhazX?=
 =?us-ascii?q?ud6o/RAwoPTJ3+SEA39xt9p7HEeSQ944LU1XtxMai7qDPC2tQpBPc7xRakZdtQ?=
 =?us-ascii?q?LKSEFArqGc0AG8euMPAqm0Subh8cPOFS6bQ4MN+8e/qH2K6kJuBgnD29gGRD4Y?=
 =?us-ascii?q?B91F+M9iVmRu7J2ZYF3++X3g+dWzjgi1eht9j9mZpYajEKAmq/1S/kCZZLZq1z?=
 =?us-ascii?q?YYkEE32uLNCwxtlkgZ7iRWRY9F+6C1wawsCpfQedYELn3Q1X00QauninmSq+zz?=
 =?us-ascii?q?xpnDAltKuf3CrSw+v8cBoLIHJERG5njV30O4i7k8gaXFS0bwgujBak5Uf6y7Jb?=
 =?us-ascii?q?pahlNGnTXEFIcjPyL2FjVKuwq7WDb9RO6JMurSVYTuC8bUqGRb76phsQyznjEH?=
 =?us-ascii?q?dGxDAnazGqvY30nx5gh2KHL3Zzr33ZddtrxRjF59zcRv9R3jwYSyl+kjTXAlm8?=
 =?us-ascii?q?P9+0/dSbjZvDs+a+V36/WZ1XayXk0YSAtC6j721wHRK/h+yzmsHgEQUi0S70zd?=
 =?us-ascii?q?5qWT/KrBb9ZInmzKC6MeNhfkl1C17w8ct6GodikoQugJEcw2QVhpKQ/XAfi2f8?=
 =?us-ascii?q?Lc1b2b7ibHoKXTMLwMTa4An/1E1jM3KG3YT5VnqGz8tlZtm6ZH4W2y0n48BLDq?=
 =?us-ascii?q?eU8KJLnS9vrlWkqgLRZOB3ni0Bxvs29H4an+YJtRIoziWcAbAdB1NUPCLymBST?=
 =?us-ascii?q?89Cxsr9Xa32xfriq20pzhtShDLCEogFBV3f1YJYiHSls7sphNFLAymH86obheN?=
 =?us-ascii?q?PId9IcqgWUkwvcj+hSMJ8xiv0KhS99NWP8p3IlzfM7jQd13ZG7p4WHL2Rt/KSk?=
 =?us-ascii?q?Ah9XLDH1ZsUT+i3zgqZahMqZw4evHpB5EDURQJToVe6oEC4Vtfn/LAmBCjo8qn?=
 =?us-ascii?q?OGGbbFGQ+f9Vxrr3bOE5CtKnGWK2MVzdRkRBmBOkNfhBoYUyk9np48Dgqq3tDu?=
 =?us-ascii?q?cF9l5jAN4V71shlMxfhtNxbhSWfTvhuoZi03SJiCLxpW8wdC6F3OMcGF6uJzHi?=
 =?us-ascii?q?dY/oCurQCXK2ybYRhIAn8NWkCeG1/jObyu78Ha8+eEHuq+M+fOYbKWpO1eUPeI?=
 =?us-ascii?q?2Iuv0pZ88DaKLMmPJX5iD/s02kdYWXB5GsLZmygASiANliLNadKbqwm4+iFtss?=
 =?us-ascii?q?+/9/HrUhr15YSTE7tSLclv+xeujKeDKeGQhSV5KTVZ1p8Wxn/I0r8f3FEMhCF0?=
 =?us-ascii?q?ajmtCq8NtSrMTKLWh69WAAQXayJ1NMtU8a082hNBNtLcitPwzrR4lOI6C09ZVV?=
 =?us-ascii?q?z9ncGkfdYFI3ymO1PdGkmKNK6KJTnKw8zsZaO8SLtQjPhbthGquDabFVPjMSqH?=
 =?us-ascii?q?lzXzSx+vNuRMhjmBPBNCoIG9bgptCW/7QdL6ax27NcV7giEszbIohnPFK2gcPC?=
 =?us-ascii?q?N4c0NMqL2Q8CxZju9+G2xH8npqM+2ElzyF4OnfL5YcqeFrDThsl+JG/HQ6zKNY?=
 =?us-ascii?q?7SFeS/xznSvSr9hurEmnk+mP0DVnVhVOpy1PhIKKu0ViJKrY+oNBWXbC4BIC82?=
 =?us-ascii?q?GQBw4WqNtiD92885xXn+TIkavoOn9u7snG7M0HBMmcfN6LLWEzIBzyMDHRBQoB?=
 =?us-ascii?q?CzWsMDeMqVZalaSw8XucspgzrNDHkZ8DULhdHAg3F/hAUWxnHddYe9FtUy8+lq?=
 =?us-ascii?q?WdkcRO7n34sRqHF5YShYzOSv/HWaanEz2el7QRIkJQmb4=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AGAABtY/pbh0O0hNFcBhsBAQEBAwEBA?=
 =?us-ascii?q?QcDAQEBgVEGAQEBCwGBWoIRJ4wRX4sgUgaBNRSIeA6EahGJJxSBWDMTAYhaIjQ?=
 =?us-ascii?q?JDQEDAQEBAQEBAgETAQEBCA0JCCkvgjYkAYJiAQICAQECJAwHPwUBCQEBCg4TJ?=
 =?us-ascii?q?QMMEjYGEwWDHIFqAwgFCAQBpw8zh3INghmMCYEPgQeBEYMSglaBbR8EAQmFaQK?=
 =?us-ascii?q?BKgEBh22GAIFFjnYtAQYCAY4EgyAjCoFPiC6HAY5NiymCDTMaNIFdgU6CJAMXf?=
 =?us-ascii?q?wECjRpAMoECAwEBIROMNwEB?=
X-IPAS-Result: =?us-ascii?q?A0AGAABtY/pbh0O0hNFcBhsBAQEBAwEBAQcDAQEBgVEGAQE?=
 =?us-ascii?q?BCwGBWoIRJ4wRX4sgUgaBNRSIeA6EahGJJxSBWDMTAYhaIjQJDQEDAQEBAQEBA?=
 =?us-ascii?q?gETAQEBCA0JCCkvgjYkAYJiAQICAQECJAwHPwUBCQEBCg4TJQMMEjYGEwWDHIF?=
 =?us-ascii?q?qAwgFCAQBpw8zh3INghmMCYEPgQeBEYMSglaBbR8EAQmFaQKBKgEBh22GAIFFj?=
 =?us-ascii?q?nYtAQYCAY4EgyAjCoFPiC6HAY5NiymCDTMaNIFdgU6CJAMXfwECjRpAMoECAwE?=
 =?us-ascii?q?BIROMNwEB?=
X-IronPort-AV: E=Sophos;i="5.56,277,1539673200"; 
   d="scan'208";a="63827642"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mga01b.intel.com with ESMTP; 25 Nov 2018 00:57:13 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727412AbeKYTri convert rfc822-to-8bit (ORCPT
        <rfc822;like.xu@linux.intel.com> + 23 others);
        Sun, 25 Nov 2018 14:47:38 -0500
Received: from saturn.retrosnub.co.uk ([46.235.226.198]:34496 "EHLO
        saturn.retrosnub.co.uk" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726030AbeKYTri (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 25 Nov 2018 14:47:38 -0500
Received: from archlinux (cpc91196-cmbg18-2-0-cust659.5-4.cable.virginm.net [81.96.234.148])
        by saturn.retrosnub.co.uk (Postfix; Retrosnub mail submission) with ESMTPSA id E51D69E7848;
        Sun, 25 Nov 2018 08:57:00 +0000 (GMT)
Date: Sun, 25 Nov 2018 08:56:59 +0000
From: Jonathan Cameron <jic23@jic23.retrosnub.co.uk>
To: Tomasz Duszynski <tduszyns@gmail.com>
Cc: linux-iio@vger.kernel.org, linux-kernel@vger.kernel.org,
        devicetree@vger.kernel.org
Subject: Re: [PATCH 2/3] iio: chemical: add support for Sensirion SPS30
 sensor
Message-ID: <20181125085659.114b0950@archlinux>
In-Reply-To: <20181124221415.10081-3-tduszyns@gmail.com>
References: <20181124221415.10081-1-tduszyns@gmail.com>
        <20181124221415.10081-3-tduszyns@gmail.com>
X-Mailer: Claws Mail 3.17.1 (GTK+ 2.24.32; x86_64-pc-linux-gnu)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 8BIT
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Sat, 24 Nov 2018 23:14:14 +0100
Tomasz Duszynski <tduszyns@gmail.com> wrote:

> Add support for Sensirion SPS30 particulate matter sensor.
> 
> Signed-off-by: Tomasz Duszynski <tduszyns@gmail.com>
A few things inline.

I'm particularly curious as to why we are ignoring two of the particle
sizes that the sensor seems to capture?

Also, a 'potential' race in remove that I'd like us to make
'obviously' correct rather than requiring hard thought on whether
it would be a problem.

Thanks,

Jonathan

> ---
>  drivers/iio/chemical/Kconfig  |  11 ++
>  drivers/iio/chemical/Makefile |   1 +
>  drivers/iio/chemical/sps30.c  | 359 ++++++++++++++++++++++++++++++++++
>  3 files changed, 371 insertions(+)
>  create mode 100644 drivers/iio/chemical/sps30.c
> 
> diff --git a/drivers/iio/chemical/Kconfig b/drivers/iio/chemical/Kconfig
> index b8e005be4f87..40057ecf8130 100644
> --- a/drivers/iio/chemical/Kconfig
> +++ b/drivers/iio/chemical/Kconfig
> @@ -61,6 +61,17 @@ config IAQCORE
>  	  iAQ-Core Continuous/Pulsed VOC (Volatile Organic Compounds)
>  	  sensors
>  
> +config SPS30
> +	tristate "SPS30 Particulate Matter sensor"
> +	depends on I2C
> +	select CRC8
> +	help
> +	  Say Y here to build support for the Sensirion SPS30 Particulate
> +	  Matter sensor.
> +
> +	  To compile this driver as a module, choose M here: the module will
> +	  be called sps30.
> +
>  config VZ89X
>  	tristate "SGX Sensortech MiCS VZ89X VOC sensor"
>  	depends on I2C
> diff --git a/drivers/iio/chemical/Makefile b/drivers/iio/chemical/Makefile
> index 2f4c4ba4d781..9f42f4252151 100644
> --- a/drivers/iio/chemical/Makefile
> +++ b/drivers/iio/chemical/Makefile
> @@ -9,4 +9,5 @@ obj-$(CONFIG_BME680_I2C) += bme680_i2c.o
>  obj-$(CONFIG_BME680_SPI) += bme680_spi.o
>  obj-$(CONFIG_CCS811)		+= ccs811.o
>  obj-$(CONFIG_IAQCORE)		+= ams-iaq-core.o
> +obj-$(CONFIG_SPS30) += sps30.o
>  obj-$(CONFIG_VZ89X)		+= vz89x.o
> diff --git a/drivers/iio/chemical/sps30.c b/drivers/iio/chemical/sps30.c
> new file mode 100644
> index 000000000000..bf802621ae7f
> --- /dev/null
> +++ b/drivers/iio/chemical/sps30.c
> @@ -0,0 +1,359 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Sensirion SPS30 Particulate Matter sensor driver
> + *
> + * Copyright (c) Tomasz Duszynski <tduszyns@gmail.com>
> + *
> + * I2C slave address: 0x69
> + *
> + * TODO:
> + *  - support for turning on fan cleaning
> + *  - support for reading/setting auto cleaning interval
> + */
> +
> +#define pr_fmt(fmt) "sps30: " fmt
> +
> +#include <linux/crc8.h>
> +#include <linux/delay.h>
> +#include <linux/i2c.h>
> +#include <linux/iio/buffer.h>
> +#include <linux/iio/iio.h>
> +#include <linux/iio/sysfs.h>
> +#include <linux/iio/trigger_consumer.h>
> +#include <linux/iio/triggered_buffer.h>
> +#include <linux/module.h>
> +
> +#define SPS30_CRC8_POLYNOMIAL 0x31
> +
> +/* SPS30 commands */
> +#define SPS30_START_MEAS 0x0010
> +#define SPS30_STOP_MEAS 0x0104
> +#define SPS30_RESET 0xd304
> +#define SPS30_READ_DATA_READY_FLAG 0x0202
> +#define SPS30_READ_DATA 0x0300
> +#define SPS30_READ_SERIAL 0xD033
> +
> +#define SPS30_CHAN(_index, _mod) { \
> +	.type = IIO_MASSCONCENTRATION, \
> +	.modified = 1, \
> +	.channel2 = IIO_MOD_ ## _mod, \
> +	.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \
> +	.scan_index = _index, \
> +	.scan_type = { \
> +		.sign = 'u', \
> +		.realbits = 12, \
> +		.storagebits = 32, \

That is unusual.  Why do we need 32 bits to store a 12 bit value?
16 should be plenty.  It'll make a difference to the buffer
sizes if people just want to stream data and don't care about
timestamps as it'll halve the memory usage.

Also, convention has always been to got for next 8,16,32,64 above
the realbits if there isn't a reason not to (shifting etc)

How did we end up with 12 bits off the floating point conversion
anyway?  Needs some docs.


> +		.endianness = IIO_CPU, \
> +	}, \
> +}
> +
> +enum {
> +	PM1p0, /* just a placeholder */
> +	PM2p5,
> +	PM4p0, /* just a placeholder */
> +	PM10,
> +};
> +
> +struct sps30_state {
> +	struct i2c_client *client;
> +	/* guards against concurrent access to sensor registers */
> +	struct mutex lock;
> +};
> +
> +DECLARE_CRC8_TABLE(sps30_crc8_table);
> +

I think you are fine locking wise, but it would be good to add a note
on what locks are expected to be held on entering this function.

Without locks it's obviously very racey!

> +static int sps30_write_then_read(struct sps30_state *state, u8 *buf,
> +				 int buf_size, u8 *data, int data_size)
> +{
> +	/* every two received data bytes are checksummed */
> +	u8 tmp[data_size + data_size / 2];
> +	int ret, i;
> +
> +	/*
> +	 * Sensor does not support repeated start so instead of
> +	 * sending two i2c messages in a row we just send one by one.
> +	 */
> +	ret = i2c_master_send(state->client, buf, buf_size);
> +	if (ret != buf_size)
> +		return ret < 0 ? ret : -EIO;
> +
> +	if (!data)
> +		return 0;
> +
> +	ret = i2c_master_recv(state->client, tmp, sizeof(tmp));
> +	if (ret != sizeof(tmp))
> +		return ret < 0 ? ret : -EIO;
> +
> +	for (i = 0; i < sizeof(tmp); i += 3) {
> +		u8 crc = crc8(sps30_crc8_table, &tmp[i], 2, CRC8_INIT_VALUE);
> +
> +		if (crc != tmp[i + 2]) {
> +			dev_err(&state->client->dev,
> +				"data integrity check failed\n");
> +			return -EIO;
> +		}
> +
> +		*data++ = tmp[i];
> +		*data++ = tmp[i + 1];
> +	}
> +
> +	return 0;
> +}
> +
> +static int sps30_do_cmd(struct sps30_state *state, u16 cmd, u8 *data, int size)
> +{
> +	/* depending on the command up to 3 bytes may be needed for argument */
> +	u8 buf[sizeof(cmd) + 3] = { cmd >> 8, cmd };
> +
> +	switch (cmd) {
> +	case SPS30_START_MEAS:
> +		buf[2] = 0x03;
> +		buf[3] = 0x00;
> +		buf[4] = 0xac; /* precomputed crc */

Could you put that in code and let the compiler do the pre compute?
Might be a little more elegant.

> +		return sps30_write_then_read(state, buf, 5, NULL, 0);
> +	case SPS30_STOP_MEAS:
> +	case SPS30_RESET:
> +		return sps30_write_then_read(state, buf, 2, NULL, 0);
> +	case SPS30_READ_DATA_READY_FLAG:
> +	case SPS30_READ_DATA:
> +	case SPS30_READ_SERIAL:
> +		return sps30_write_then_read(state, buf, 2, data, size);
> +	default:
> +		return -EINVAL;
> +	};
> +}
> +
> +static int sps30_ieee754_to_int(const u8 *data)
> +{
> +	u32 val = ((u32)data[0] << 24) | ((u32)data[1] << 16) |
> +		  ((u32)data[2] << 8) | (u32)data[3],
Have a separate
u32 mantissa = (val << 9) >> 9 line.
What is this next line actually doing?  Kind of looks like
a mask?  If so just mask it with & as more readable.

> +	    mantissa = (val << 9) >> 9;
> +	int exp = (val >> 23) - 127;
> +
> +	if (!exp && !mantissa)
> +		return 0;
> +
> +	if (exp < 0)
> +		return 0;
> +
> +	return (1 << exp) + (mantissa >> (23 - exp));
> +}
> +
> +static int sps30_do_meas(struct sps30_state *state, int *pm2p5, int *pm10)
> +{
> +	/*
> +	 * Internally sensor stores measurements in a following manner:
> +	 *
> +	 * PM1p0: upper two bytes, crc8, lower two bytes, crc8

So there are other particle sizes that this sensor reads?  Why
are we mapping them down to just the two channel types?

> +	 * PM2p5: upper two bytes, crc8, lower two bytes, crc8
> +	 * PM4p0: upper two bytes, crc8, lower two bytes, crc8
> +	 * PM10:  upper two bytes, crc8, lower two bytes, crc8
> +	 *
> +	 * What follows next are number concentration measurements and
> +	 * typical particle size measurement.
> +	 *
> +	 * Once data is read from sensor crc bytes are stripped off
> +	 * hence we need 16 bytes of buffer space.
> +	 */
> +	int ret, tries = 5;
> +	u8 buf[16];
> +
> +	while (tries--) {
> +		ret = sps30_do_cmd(state, SPS30_READ_DATA_READY_FLAG, buf, 2);
> +		if (ret)
> +			return -EIO;
> +
> +		/* new measurements ready to be read */
> +		if (buf[1] == 1)
> +			break;
> +
> +		usleep_range(300000, 400000);
> +	}
> +
> +	if (!tries)
> +		return -ETIMEDOUT;
> +
> +	ret = sps30_do_cmd(state, SPS30_READ_DATA, buf, sizeof(buf));
> +	if (ret)
> +		return ret;
> +
> +	/*
> +	 * All measurements come in IEEE754 single precision floating point
> +	 * format but sensor itself is not precise enough (-+ 10% error)
> +	 * to take full advantage of it. Hence converting result to int
> +	 * to keep things simple.

Interesting.  We have talked about allowing floating point formats for
sensors the provide them.  Would that be beneficial here?

> +	 */
> +	*pm2p5 = sps30_ieee754_to_int(&buf[PM2p5 * 4]);
> +	*pm10 = sps30_ieee754_to_int(&buf[PM10 * 4]);
> +
> +	return 0;
> +}
> +
> +static irqreturn_t sps30_trigger_handler(int irq, void *p)
> +{
> +	struct iio_poll_func *pf = p;
> +	struct iio_dev *indio_dev = pf->indio_dev;
> +	struct sps30_state *state = iio_priv(indio_dev);
> +	u32 buf[4]; /* PM2p5, PM10, timestamp */
> +	int ret;
> +
> +	mutex_lock(&state->lock);
> +	ret = sps30_do_meas(state, &buf[0], &buf[1]);
> +	mutex_unlock(&state->lock);
> +	if (ret < 0)
> +		goto err;
> +
> +	iio_push_to_buffers_with_timestamp(indio_dev, buf,
> +					   iio_get_time_ns(indio_dev));
> +err:
> +	iio_trigger_notify_done(indio_dev->trig);
> +
> +	return IRQ_HANDLED;
> +}
> +
> +static int sps30_read_raw(struct iio_dev *indio_dev,
> +			  struct iio_chan_spec const *chan,
> +			  int *val, int *val2, long mask)
> +{
> +	struct sps30_state *state = iio_priv(indio_dev);
> +	int ret;
> +
> +	switch (mask) {
> +	case IIO_CHAN_INFO_PROCESSED:
> +		switch (chan->type) {
> +		case IIO_MASSCONCENTRATION:
> +			mutex_lock(&state->lock);
> +			switch (chan->channel2) {
> +			case IIO_MOD_PM2p5:
> +				ret = sps30_do_meas(state, val, val2);
> +				break;
> +			case IIO_MOD_PM10:
> +				ret = sps30_do_meas(state, val2, val);
> +				break;
> +			default:
> +				break;
> +			}
> +			mutex_unlock(&state->lock);
> +			if (ret)
> +				return ret;
> +
> +			return IIO_VAL_INT;
> +		default:
> +			return -EINVAL;
> +		}
> +		break;
> +	default:
You can't get here.  Is this a warning suppression?
If so just add a comment saying so to prevent it being removed
by someone else later.

> +		return -EINVAL;
> +	}
> +}
> +
> +static const struct iio_info sps30_info = {
> +	.read_raw = sps30_read_raw,
> +};
> +
From a readability point of view, it would be helpful to pull
the macro SPS30_CHAN down here in the code so we don't
need to go jumping around to check what it is doing.

> +static const struct iio_chan_spec sps30_channels[] = {
> +	SPS30_CHAN(0, PM2p5),
> +	SPS30_CHAN(1, PM10),
> +	IIO_CHAN_SOFT_TIMESTAMP(2),
> +};
> +
> +static const unsigned long sps30_scan_masks[] = { 0x03, 0x00 };
> +
> +static int sps30_probe(struct i2c_client *client)
> +{
> +	struct iio_dev *indio_dev;
> +	struct sps30_state *state;
> +	u8 buf[32] = { };
> +	int ret;
> +
> +	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
> +		return -EOPNOTSUPP;
> +
> +	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*state));
> +	if (!indio_dev)
> +		return -ENOMEM;
> +
> +	state = iio_priv(indio_dev);
> +	i2c_set_clientdata(client, indio_dev);
> +	state->client = client;
> +	indio_dev->dev.parent = &client->dev;
> +	indio_dev->info = &sps30_info;
> +	indio_dev->name = client->name;
> +	indio_dev->channels = sps30_channels;
> +	indio_dev->num_channels = ARRAY_SIZE(sps30_channels);
> +	indio_dev->modes = INDIO_DIRECT_MODE;
> +	indio_dev->available_scan_masks = sps30_scan_masks;
> +
> +	mutex_init(&state->lock);
> +	crc8_populate_msb(sps30_crc8_table, SPS30_CRC8_POLYNOMIAL);
> +
> +	/*
> +	 * Power-on-reset causes sensor to produce some glitch on i2c bus
> +	 * and some controllers end up in error state. Recover simply
> +	 * by placing something on the bus.
> +	 */
> +	ret = sps30_do_cmd(state, SPS30_RESET, NULL, 0);
> +	if (ret) {
> +		dev_err(&client->dev, "failed to reset device\n");
> +		return ret;
> +	}
> +	usleep_range(2500000, 3500000);
> +	sps30_do_cmd(state, SPS30_STOP_MEAS, NULL, 0);

Talk me through this logic.  We stop it then pretty much immediately
start it again?  Needs a comment.

> +
> +	ret = sps30_do_cmd(state, SPS30_READ_SERIAL, buf, sizeof(buf));
> +	if (ret) {
> +		dev_err(&client->dev, "failed to read serial number\n");
> +		return ret;
> +	}
> +	dev_info(&client->dev, "serial number: %s\n", buf);
> +
> +	ret = sps30_do_cmd(state, SPS30_START_MEAS, NULL, 0);
> +	if (ret) {

This is not unwound on error.   See comment on remove race below.

> +		dev_err(&client->dev, "failed to start measurement\n");
> +		return ret;
> +	}
> +
> +	ret = devm_iio_triggered_buffer_setup(&client->dev, indio_dev, NULL,
> +					      sps30_trigger_handler, NULL);
> +	if (ret)
> +		return ret;
> +
> +	return devm_iio_device_register(&client->dev, indio_dev);
> +}
> +
> +static int sps30_remove(struct i2c_client *client)
> +{
> +	struct iio_dev *indio_dev = i2c_get_clientdata(client);
> +	struct sps30_state *state = iio_priv(indio_dev);
> +
> +	sps30_do_cmd(state, SPS30_STOP_MEAS, NULL, 0);
This looks like a race to me.

You turn off the measurements before removing the interface to them.
It's certainly not in the 'obviously' right category.

As such I would either use a devm action to do this stop,
or not use the managed interfaces for everything in probe
after the equivalent start.
The devm_add_action_or_reset would be the cleanest option I think..
Will also fix the cleanup on error in probe.

> +
> +	return 0;
> +}
> +
> +static const struct i2c_device_id sps30_id[] = {
> +	{ "sps30" },
> +	{ }
> +};
> +MODULE_DEVICE_TABLE(i2c, sps30_id);
> +
> +static const struct of_device_id sps30_of_match[] = {
> +	{ .compatible = "sensirion,sps30" },
> +	{ }
> +};
> +MODULE_DEVICE_TABLE(of, sps30_of_match);
> +
> +static struct i2c_driver sps30_driver = {
> +	.driver = {
> +		.name = "sps30",
> +		.of_match_table = sps30_of_match,
> +	},
> +	.id_table = sps30_id,
> +	.probe_new = sps30_probe,
> +	.remove = sps30_remove,
> +};
> +module_i2c_driver(sps30_driver);
> +
> +MODULE_AUTHOR("Tomasz Duszynski <tduszyns@gmail.com>");
> +MODULE_DESCRIPTION("Sensirion SPS30 particulate matter sensor driver");
> +MODULE_LICENSE("GPL v2");

