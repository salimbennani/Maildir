Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 10:36:17 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id D6700580460;
	Thu, 22 Nov 2018 18:34:26 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 18:34:26 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ApR2+Hhya0vFxjqbXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0ewUKfad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWVOXshTWCJBDI2y?=
 =?us-ascii?q?bJYBAfQdMuZDt4nwpUADrQeiCQS2GO/j1iNEi33w0KYn0+ohCwbG3Ak4EtwQt3?=
 =?us-ascii?q?TUqc/6NLwTUOuozKfIzDrDYOlL0jr69IjIfBEhof6WUr9rbcXRyVMvFwTAjlWR?=
 =?us-ascii?q?tIzlOimZ1uMXs2iU9udtU/+khWAgqwF0uDevx8Esh5HSiYISzVDE6SF5wIczJd?=
 =?us-ascii?q?GiVEF7ZtukHINetyGAKYR5XN4tTH9zuCY51r0Gvoa7cDINyJQ9yB7Tc+CIc4+M?=
 =?us-ascii?q?4hLnTumeOjB4hGh/d76lmxmy9k2gxvXzVsmz11ZKoS5FncfXtnAKyhzT8NSIRe?=
 =?us-ascii?q?Vn8ki93jaP0gbe4fxHL0AsjafXNYItz7oqmpYOv0nPADX6lFj1gaOKbEkp++ql?=
 =?us-ascii?q?5/z5brn6opKQLYx5hwHkPqgwh8CyBf40PhUMUmWU/+m3yaft8lfjQLpQi/07iq?=
 =?us-ascii?q?nZv47eJcQcvqO5HQBV3Zg56xqlDDepzs4YnX8ZI1JBYh6HiJLpO17WLPD5C/ew?=
 =?us-ascii?q?nUisnS91y/zaOrDtGIjBI3bdnLv7YLpw6FJQxBAywN1d/55UD6sOIPP3Wk//rt?=
 =?us-ascii?q?zYCRo5PhSww+bmDtV9y4wfVXuMAqCHKqPSt0GH5uY2L+mLao4VvijyK+I+6v7w?=
 =?us-ascii?q?gn82h0UdcbOq3ZQJcnC4GOppI0GDbXrrmNcBHn8GvhAiQ+zylF2CTTlTam62X6?=
 =?us-ascii?q?I95TE0FpiqDIjeRo22hLyB3SG7HoBZZ2xcC1CMF2voeJuAW/sWdC2SJcphmCQe?=
 =?us-ascii?q?Vbe9U48hyQ2utAjixrpnNOXU+zEYuojk1NRv5+3TiAs99Tp7D8mG12GNTmd0nn?=
 =?us-ascii?q?4HRjMs3aB/p1B9xUmH0aRin/NYEtlT7etTUggmLZ7c0/B6C9fqVwLDedeGVkyq?=
 =?us-ascii?q?QtahATE3SNIxxMQDY0J8G9WkkxDC0DCmA74Tl7yXGpM09rjQ0GT2J8Z403zGzr?=
 =?us-ascii?q?Uuj0E6QstTMm2rnrRw9xPTB47OkEWVjbyqer4e3CPW8GeDzGyOvFxXUQJqUKXF?=
 =?us-ascii?q?W2wfaVXSrdjj+kzCSLquA6w9MgRd0c6CNrdKatrxgFVFXvjjPs7SY2awm2iqAx?=
 =?us-ascii?q?aIyaiBbI7re2UbwSXcB1IIkwEV/XaaKwc+Aj2trH7ZDDxrDVjveV/j8fFiqHOn?=
 =?us-ascii?q?SU851xyFYFd/17Wr4BIVheaTS/UI3r0avictrDF0HFW439LSENeAowthfKNBYd?=
 =?us-ascii?q?Iy+ltH1GTZtxBjMZykNaxtmlkecwFvtUP0yxp3EplAkdQtrH4y0QV9M7yY301b?=
 =?us-ascii?q?ezOYx5/wPKbXJXf0/B20b67W21fe0MuZ+6sV6fQ4rUnjsx+tFkY473pn1NxV2W?=
 =?us-ascii?q?OG5prWFAoSTY7xUkEv+hhmprHaZy4955/U1XxsK6W0riXO29UzBOshyxagedhf?=
 =?us-ascii?q?PbiAFA/zFc0aGsevJPYrm1ivchILIuRS+LQoMMOhcvuMwLSrM/p4nDK6kWRH55?=
 =?us-ascii?q?hw3ViI9yViRe/HwZYEz+uD0QuaSjjzllGhssPwmYBafjwSGmu/yS75BI9efKFy?=
 =?us-ascii?q?fIALCXuwLM2z3Nlxm5ntW3tA/l65G1wGwNOpeQaVb1Hl3QxQyF4brmC9lSq5zz?=
 =?us-ascii?q?x7iTcprqWE0SzKwuTicgcHO2FRSGlji1fsPZa7j9QAUEe0aAgpkQOv5VzmyKhD?=
 =?us-ascii?q?uKR/M27TTF9Sfyj3M25tSLGwuaeFY8JV7pMnrz9XUOWlbV+GULH9pwYV3D35H2?=
 =?us-ascii?q?tZwjA2bDWqupT/nxxnh2ORNndzrHzFec5uwRfT/sDTRflU3jAeXil3lSHXBkSg?=
 =?us-ascii?q?P9mu5diVl5bDvvq+Vm67TZ1TbC/rwJiEtCu6421qHBK+k+qymt3hDQg1zyv728?=
 =?us-ascii?q?N2WiXPqRb2epPr2LiiMeJ7YkloA0fx68hgFYFkkYswh5YQ1WIBhpqP/noHkmbz?=
 =?us-ascii?q?MdNF1qL4d3cNQT8Lw9jI4AnqwkFjL3SJx57nWXWZ2Mdue966YmYO0CIn889KEL?=
 =?us-ascii?q?uU7KBDnSZtolu3twXRbeJ/njccz/sj83oag+APuAowwSSRGLESHU9EPSPykxSE?=
 =?us-ascii?q?9cyxrKJSZGy3a7i/yFJ+ncy9DLGFugxcW2z2epY4ES9w88VwKlTM0HLo54Hged?=
 =?us-ascii?q?nQa88TtxKOnxfBiehVNIw+lv4QiSV7PmL9uGUvy/Qnghx2wZG6oI+HJn1o/KK4?=
 =?us-ascii?q?AR5XLCf5Zs0N9TH2kaZRgNyW0JuxEZV7FTUGR5/oTfOuEDIPuvXrLQeOEDsgqn?=
 =?us-ascii?q?iFHbrTBxOQ6EBjr3jXCZCkK2mXJGUFzdVlXBSdOEtfgAUOUDQ7hJE5EB2qxNf6?=
 =?us-ascii?q?cEd4/T0R4l/4qh1RyuNnLRX/U2HfpBu2ZTcwUpSQMB1W7gRa7UfPLcOe9v5zHz?=
 =?us-ascii?q?1f/pC5twOCMGubZwBVDW0TXkyEGkvuPr2v5dnG7uiZCfCyL/rIYbWSt+NeU+2E?=
 =?us-ascii?q?yo6o0otj5zyMLNmAPmF+D/0n3UpORXJ5FN7cmzoRUCwbjT7NY9SYpBeh+S13s8?=
 =?us-ascii?q?a//+7wWA/04YuPCr1SMchg+hysgKeDMfKQizh9KTpCypwMwnrIwqAF3FEOkyFu?=
 =?us-ascii?q?ayWtEbMYuC/NS6LQh7ZXDwMBZCN1LsdI9KU83g9COcPAjtP117h4juM6CltfVF?=
 =?us-ascii?q?zhnN2patIOI22nKFzHA0OLPqycJTLX28H3fb+8SbpIgeVUqRKwuDWbE0ziPjiZ?=
 =?us-ascii?q?lDnpTRevMe5SgyGBIRxeo5qwchJsCWjlUdLnZQe3MN5xjT0q37I0gmnGOnIbMT?=
 =?us-ascii?q?h5a0lNtKGf7TtEgvVjHGxM9mBqLfSflCaD8ebZKowasf9qAilvk+Ja4XI6y6Za?=
 =?us-ascii?q?7S1eRfx1njfSocBqo128juaPzT9nWgJUqjlXnIKLoVliOaLB+5lcWHbE+QgB4n?=
 =?us-ascii?q?mKBxsWp9tqFNvvtrtUytjOkqLzNThD/8jV/csaG8jbNsaHPGA9PhruHT7eFBEF?=
 =?us-ascii?q?QiKzNWHDm0xdl+mf932PoZg8r5jsmZwORadaVVw1DPwaDEtlEccGIJd2WDMkjL?=
 =?us-ascii?q?GagNQJ5Xq4sBneWsFasorbWfKVBPW8YAqe2LlJYxYOh7D/LIceHob830hrYF5g?=
 =?us-ascii?q?lcLBHE+UFdVfpTdoaCc/ukJS/nVlUis11l6hIi634XRbPPi0mRoqwl9ze+Um3D?=
 =?us-ascii?q?7q41AzOhzMqTdmw2crntCwvTeUeSXjZImxUogeXzb6tkc4Gpj7WQFwbBC320t+?=
 =?us-ascii?q?O2GXFPpqk7J8eDUz20fnspxVFKsZFPUcbQ=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ATAADTZfdbh0O0hNFiFgcCBQgFgVIID?=
 =?us-ascii?q?AGBWoEPgQIng3mIGF+NLRRmlkGBbxcBGAYNAYhSIjQJDQEDAQEBAQEBAgETAQE?=
 =?us-ascii?q?BCA0JCCkjDII2JAGCYQEBAQECAQECIAQZAQE3AQUJAQEKCwoDAgImAgIDHxIBB?=
 =?us-ascii?q?QEcBgESBRYDgjhLAYF5CAUKm348ih1wfDOCdgEBBYEwAQsBhVcDBRJ5in4XgUA?=
 =?us-ascii?q?/gRGCFEk1gxsBA4EZg0qCV4h+HYF4hH5PjyQJhnyKMxiBWYULgm2ERYJyiW2DV?=
 =?us-ascii?q?opGAgQCBAUCBQ8hgSWCDTMaCCgIbAaCAQEzgicXfwECBoJChRSFTTEyAQEIewE?=
 =?us-ascii?q?BiheCPgEB?=
X-IPAS-Result: =?us-ascii?q?A0ATAADTZfdbh0O0hNFiFgcCBQgFgVIIDAGBWoEPgQIng3m?=
 =?us-ascii?q?IGF+NLRRmlkGBbxcBGAYNAYhSIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjDII2J?=
 =?us-ascii?q?AGCYQEBAQECAQECIAQZAQE3AQUJAQEKCwoDAgImAgIDHxIBBQEcBgESBRYDgjh?=
 =?us-ascii?q?LAYF5CAUKm348ih1wfDOCdgEBBYEwAQsBhVcDBRJ5in4XgUA/gRGCFEk1gxsBA?=
 =?us-ascii?q?4EZg0qCV4h+HYF4hH5PjyQJhnyKMxiBWYULgm2ERYJyiW2DVopGAgQCBAUCBQ8?=
 =?us-ascii?q?hgSWCDTMaCCgIbAaCAQEzgicXfwECBoJChRSFTTEyAQEIewEBiheCPgEB?=
X-IronPort-AV: E=Sophos;i="5.56,268,1539673200"; 
   d="scan'208";a="53411852"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 18:34:24 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2439462AbeKWNQg (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 08:16:36 -0500
Received: from mail-yb1-f193.google.com ([209.85.219.193]:41871 "EHLO
        mail-yb1-f193.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727343AbeKWNQg (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 08:16:36 -0500
Received: by mail-yb1-f193.google.com with SMTP id t13-v6so4214702ybb.8
        for <linux-kernel@vger.kernel.org>; Thu, 22 Nov 2018 18:34:19 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=chromium.org; s=google;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc;
        bh=Ry4qdc4++suHeiyd5U0+QMB+KoUiBT4z0hC5Ig+/Jfw=;
        b=ULwQM3AejfaPFEeaM6i/5e+fqt6L/FUwX7/ftWZJmm7b4bFDPv9i++CciDqUoQr9dy
         SdQFG2CG7rCimUgY4ieFbcwXz5W7ZTT8H7LSPgSfSR8LRK/ABTASwnAYB9eBOBGj4XJw
         +VlyuQe/pVC8XB86GumG26GWdzheg/zzRlBvE=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc;
        bh=Ry4qdc4++suHeiyd5U0+QMB+KoUiBT4z0hC5Ig+/Jfw=;
        b=tn+FeOfYv7XiLshSRnHh7q9mostu6knDSiMdNRirVEAgCvkXjnuD4aRc/sQyFcKBex
         cRniY8z34s3D5CFSKS95CkD5hTJJE2ub0tCGt4/vYRlDSI4LhDQG9icjNt0BXx3/mmt8
         ZC21ms3BJEcH0T8oHUkFEM4+D39ZRbX1+P0PPqXWhUwgOT/aQwzuUTpFP7mUwvL4wdwS
         4T6aM9K2wNnDE+x3Xw6MVG8TT4ayQxJV8OfjQzzb6vDm55Lhru2HtL0AVAm1w78V75Kp
         6vSAGnx9cF1783/xkZN/5fKIXw+afKdrJnhGHckQEVx7/wu2rnxhWT3i7PB7cHf4tPyP
         /xLQ==
X-Gm-Message-State: AA+aEWbaUjC0fKg3vxL7CzXDeoFScFo7aed8+nLJ/7L1xRyOV+K62zKQ
        OISLVCN0JegIBUVRlwUOSUCW6P0ekp4=
X-Google-Smtp-Source: AFSGD/Xc/TGx75gRi844LFNXExFWgiUF5PlkMLgnDRPM8ITIhTfcLiiLcxk8LcRZEiq8U4jwfCV2Hw==
X-Received: by 2002:a25:7ec4:: with SMTP id z187-v6mr13524628ybc.373.1542940458945;
        Thu, 22 Nov 2018 18:34:18 -0800 (PST)
Received: from mail-yb1-f174.google.com (mail-yb1-f174.google.com. [209.85.219.174])
        by smtp.gmail.com with ESMTPSA id 207-v6sm15920427ywo.87.2018.11.22.18.34.18
        for <linux-kernel@vger.kernel.org>
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Thu, 22 Nov 2018 18:34:18 -0800 (PST)
Received: by mail-yb1-f174.google.com with SMTP id w17-v6so4216189ybl.6
        for <linux-kernel@vger.kernel.org>; Thu, 22 Nov 2018 18:34:18 -0800 (PST)
X-Received: by 2002:a25:618a:: with SMTP id v132-v6mr13663926ybb.293.1542940078849;
 Thu, 22 Nov 2018 18:27:58 -0800 (PST)
MIME-Version: 1.0
References: <20181119190805.19139-1-helen.koike@collabora.com>
 <CAAFQd5DDZwhdMDbrHthQwm2bQ3+NoZNcemAktVTxkR3=LfnnTg@mail.gmail.com> <d3fb3b21-6c3d-6b01-727b-dbd66540ce92@collabora.com>
In-Reply-To: <d3fb3b21-6c3d-6b01-727b-dbd66540ce92@collabora.com>
From: Tomasz Figa <tfiga@chromium.org>
Date: Fri, 23 Nov 2018 11:27:46 +0900
X-Gmail-Original-Message-ID: <CAAFQd5Afa9ndmU0=q5Kjv-BY+0qpvOdq2+eOTO6OebX4-2NENA@mail.gmail.com>
Message-ID: <CAAFQd5Afa9ndmU0=q5Kjv-BY+0qpvOdq2+eOTO6OebX4-2NENA@mail.gmail.com>
Subject: Re: [PATCH v3] drm/rockchip: update cursors asynchronously through atomic.
To: helen.koike@collabora.com, mzoran@crowfest.net,
        Eric Anholt <eric@anholt.net>
Cc: Sandy Huang <hjc@rock-chips.com>,
        =?UTF-8?Q?Heiko_St=C3=BCbner?= <heiko@sntech.de>,
        David Airlie <airlied@linux.ie>,
        "list@263.net:IOMMU DRIVERS <iommu@lists.linux-foundation.org>, Joerg
        Roedel <joro@8bytes.org>," <iommu@lists.linux-foundation.org>,
        "list@263.net:IOMMU DRIVERS <iommu@lists.linux-foundation.org>, Joerg
        Roedel <joro@8bytes.org>," <joro@8bytes.org>,
        "list@263.net:IOMMU DRIVERS <iommu@lists.linux-foundation.org>, Joerg
        Roedel <joro@8bytes.org>," <linux-arm-kernel@lists.infradead.org>,
        Enric Balletbo i Serra <enric.balletbo@collabora.com>,
        Linux Kernel Mailing List <linux-kernel@vger.kernel.org>,
        dri-devel <dri-devel@lists.freedesktop.org>,
        "open list:ARM/Rockchip SoC..." <linux-rockchip@lists.infradead.org>,
        Gustavo Padovan <gustavo.padovan@collabora.com>,
        Sean Paul <seanpaul@google.com>, kernel@collabora.com,
        =?UTF-8?Q?St=C3=A9phane_Marchesin?= <marcheu@google.com>
Content-Type: text/plain; charset="UTF-8"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Hi Helen,

On Fri, Nov 23, 2018 at 8:31 AM Helen Koike <helen.koike@collabora.com> wrote:
>
> Hi Tomasz,
>
> On 11/20/18 4:48 AM, Tomasz Figa wrote:
> > Hi Helen,
> >
> > On Tue, Nov 20, 2018 at 4:08 AM Helen Koike <helen.koike@collabora.com> wrote:
> >>
> >> From: Enric Balletbo i Serra <enric.balletbo@collabora.com>
> >>
> >> Add support to async updates of cursors by using the new atomic
> >> interface for that.
> >>
> >> Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
> >> [updated for upstream]
> >> Signed-off-by: Helen Koike <helen.koike@collabora.com>
> >>
> >> ---
> >> Hello,
> >>
> >> This is the third version of the async-plane update suport to the
> >> Rockchip driver.
> >>
> >
> > Thanks for a quick respin. Please see my comments inline. (I'll try to
> > be better at responding from now on...)
> >
> >> I tested running igt kms_cursor_legacy and kms_atomic tests using a 96Boards Ficus.
> >>
> >> Note that before the patch, the following igt tests failed:
> >>
> >>         basic-flip-before-cursor-atomic
> >>         basic-flip-before-cursor-legacy
> >>         cursor-vs-flip-atomic
> >>         cursor-vs-flip-legacy
> >>         cursor-vs-flip-toggle
> >>         flip-vs-cursor-atomic
> >>         flip-vs-cursor-busy-crc-atomic
> >>         flip-vs-cursor-busy-crc-legacy
> >>         flip-vs-cursor-crc-atomic
> >>         flip-vs-cursor-crc-legacy
> >>         flip-vs-cursor-legacy
> >>
> >> Full log: https://people.collabora.com/~koike/results-4.20/html/
> >>
> >> Now with the patch applied the following were fixed:
> >>         basic-flip-before-cursor-atomic
> >>         basic-flip-before-cursor-legacy
> >>         flip-vs-cursor-atomic
> >>         flip-vs-cursor-legacy
> >>
> >> Full log: https://people.collabora.com/~koike/results-4.20-async/html/
> >
> > Could you also test modetest, with the -C switch to test the legacy
> > cursor API? I remember it triggering crashes due to synchronization
> > issues easily.
>
> Sure. I tested with
> $ modetest -M rockchip -s 37:1920x1080 -C
>
> I also vary the mode but I couldn't trigger any crashes.
>
> >
> >>
> >> Tomasz, as you mentined in v2 about waiting the hardware before updating
> >> the framebuffer, now I call the loop you pointed out in the async path,
> >> was that what you had in mind? Or do you think I would make sense to
> >> call the vop_crtc_atomic_flush() instead of just exposing that loop?
> >>
> >> Thanks
> >> Helen
> >>
> >> Changes in v3:
> >> - Rebased on top of drm-misc
> >> - Fix missing include in rockchip_drm_vop.c
> >> - New function vop_crtc_atomic_commit_flush
> >>
> >> Changes in v2:
> >> - v2: https://patchwork.freedesktop.org/patch/254180/
> >> - Change the framebuffer as well to cover jumpy cursor when hovering
> >>   text boxes or hyperlink. (Tomasz)
> >> - Use the PSR inhibit mechanism when accessing VOP hardware instead of
> >>   PSR flushing (Tomasz)
> >>
> >> Changes in v1:
> >> - Rebased on top of drm-misc
> >> - In async_check call drm_atomic_helper_check_plane_state to check that
> >>   the desired plane is valid and update various bits of derived state
> >>   (clipped coordinates etc.)
> >> - In async_check allow to configure new scaling in the fast path.
> >> - In async_update force to flush all registered PSR encoders.
> >> - In async_update call atomic_update directly.
> >> - In async_update call vop_cfg_done needed to set the vop registers and take effect.
> >>
> >>  drivers/gpu/drm/rockchip/rockchip_drm_fb.c  |  36 -------
> >>  drivers/gpu/drm/rockchip/rockchip_drm_psr.c |  37 +++++++
> >>  drivers/gpu/drm/rockchip/rockchip_drm_psr.h |   3 +
> >>  drivers/gpu/drm/rockchip/rockchip_drm_vop.c | 108 +++++++++++++++++---
> >>  4 files changed, 131 insertions(+), 53 deletions(-)
> >>
> >> diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_fb.c b/drivers/gpu/drm/rockchip/rockchip_drm_fb.c
> >> index ea18cb2a76c0..08bec50d9c5d 100644
> >> --- a/drivers/gpu/drm/rockchip/rockchip_drm_fb.c
> >> +++ b/drivers/gpu/drm/rockchip/rockchip_drm_fb.c
> >> @@ -127,42 +127,6 @@ rockchip_user_fb_create(struct drm_device *dev, struct drm_file *file_priv,
> >>         return ERR_PTR(ret);
> >>  }
> >>
> >> -static void
> >> -rockchip_drm_psr_inhibit_get_state(struct drm_atomic_state *state)
> >> -{
> >> -       struct drm_crtc *crtc;
> >> -       struct drm_crtc_state *crtc_state;
> >> -       struct drm_encoder *encoder;
> >> -       u32 encoder_mask = 0;
> >> -       int i;
> >> -
> >> -       for_each_old_crtc_in_state(state, crtc, crtc_state, i) {
> >> -               encoder_mask |= crtc_state->encoder_mask;
> >> -               encoder_mask |= crtc->state->encoder_mask;
> >> -       }
> >> -
> >> -       drm_for_each_encoder_mask(encoder, state->dev, encoder_mask)
> >> -               rockchip_drm_psr_inhibit_get(encoder);
> >> -}
> >> -
> >> -static void
> >> -rockchip_drm_psr_inhibit_put_state(struct drm_atomic_state *state)
> >> -{
> >> -       struct drm_crtc *crtc;
> >> -       struct drm_crtc_state *crtc_state;
> >> -       struct drm_encoder *encoder;
> >> -       u32 encoder_mask = 0;
> >> -       int i;
> >> -
> >> -       for_each_old_crtc_in_state(state, crtc, crtc_state, i) {
> >> -               encoder_mask |= crtc_state->encoder_mask;
> >> -               encoder_mask |= crtc->state->encoder_mask;
> >> -       }
> >> -
> >> -       drm_for_each_encoder_mask(encoder, state->dev, encoder_mask)
> >> -               rockchip_drm_psr_inhibit_put(encoder);
> >> -}
> >> -
> >>  static void
> >>  rockchip_atomic_helper_commit_tail_rpm(struct drm_atomic_state *old_state)
> >>  {
> >> diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_psr.c b/drivers/gpu/drm/rockchip/rockchip_drm_psr.c
> >> index 01ff3c858875..22a70ab6e214 100644
> >> --- a/drivers/gpu/drm/rockchip/rockchip_drm_psr.c
> >> +++ b/drivers/gpu/drm/rockchip/rockchip_drm_psr.c
> >> @@ -13,6 +13,7 @@
> >>   */
> >>
> >>  #include <drm/drmP.h>
> >> +#include <drm/drm_atomic.h>
> >>  #include <drm/drm_crtc_helper.h>
> >>
> >>  #include "rockchip_drm_drv.h"
> >> @@ -109,6 +110,42 @@ int rockchip_drm_psr_inhibit_put(struct drm_encoder *encoder)
> >>  }
> >>  EXPORT_SYMBOL(rockchip_drm_psr_inhibit_put);
> >>
> >> +void rockchip_drm_psr_inhibit_get_state(struct drm_atomic_state *state)
> >> +{
> >> +       struct drm_crtc *crtc;
> >> +       struct drm_crtc_state *crtc_state;
> >> +       struct drm_encoder *encoder;
> >> +       u32 encoder_mask = 0;
> >> +       int i;
> >> +
> >> +       for_each_old_crtc_in_state(state, crtc, crtc_state, i) {
> >> +               encoder_mask |= crtc_state->encoder_mask;
> >> +               encoder_mask |= crtc->state->encoder_mask;
> >> +       }
> >> +
> >> +       drm_for_each_encoder_mask(encoder, state->dev, encoder_mask)
> >> +               rockchip_drm_psr_inhibit_get(encoder);
> >> +}
> >> +EXPORT_SYMBOL(rockchip_drm_psr_inhibit_get_state);
> >> +
> >> +void rockchip_drm_psr_inhibit_put_state(struct drm_atomic_state *state)
> >> +{
> >> +       struct drm_crtc *crtc;
> >> +       struct drm_crtc_state *crtc_state;
> >> +       struct drm_encoder *encoder;
> >> +       u32 encoder_mask = 0;
> >> +       int i;
> >> +
> >> +       for_each_old_crtc_in_state(state, crtc, crtc_state, i) {
> >> +               encoder_mask |= crtc_state->encoder_mask;
> >> +               encoder_mask |= crtc->state->encoder_mask;
> >> +       }
> >> +
> >> +       drm_for_each_encoder_mask(encoder, state->dev, encoder_mask)
> >> +               rockchip_drm_psr_inhibit_put(encoder);
> >> +}
> >> +EXPORT_SYMBOL(rockchip_drm_psr_inhibit_put_state);
> >> +
> >>  /**
> >>   * rockchip_drm_psr_inhibit_get - acquire PSR inhibit on given encoder
> >>   * @encoder: encoder to obtain the PSR encoder
> >> diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_psr.h b/drivers/gpu/drm/rockchip/rockchip_drm_psr.h
> >> index 860c62494496..25350ba3237b 100644
> >> --- a/drivers/gpu/drm/rockchip/rockchip_drm_psr.h
> >> +++ b/drivers/gpu/drm/rockchip/rockchip_drm_psr.h
> >> @@ -20,6 +20,9 @@ void rockchip_drm_psr_flush_all(struct drm_device *dev);
> >>  int rockchip_drm_psr_inhibit_put(struct drm_encoder *encoder);
> >>  int rockchip_drm_psr_inhibit_get(struct drm_encoder *encoder);
> >>
> >> +void rockchip_drm_psr_inhibit_get_state(struct drm_atomic_state *state);
> >> +void rockchip_drm_psr_inhibit_put_state(struct drm_atomic_state *state);
> >> +
> >>  int rockchip_drm_psr_register(struct drm_encoder *encoder,
> >>                         int (*psr_set)(struct drm_encoder *, bool enable));
> >>  void rockchip_drm_psr_unregister(struct drm_encoder *encoder);
> >> diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
> >> index fb70fb486fbf..176d6e8207ed 100644
> >> --- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
> >> +++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
> >> @@ -15,6 +15,7 @@
> >>  #include <drm/drm.h>
> >>  #include <drm/drmP.h>
> >>  #include <drm/drm_atomic.h>
> >> +#include <drm/drm_atomic_uapi.h>
> >>  #include <drm/drm_crtc.h>
> >>  #include <drm/drm_crtc_helper.h>
> >>  #include <drm/drm_flip_work.h>
> >> @@ -819,10 +820,99 @@ static void vop_plane_atomic_update(struct drm_plane *plane,
> >>         spin_unlock(&vop->reg_lock);
> >>  }
> >>
> >> +static int vop_plane_atomic_async_check(struct drm_plane *plane,
> >> +                                       struct drm_plane_state *state)
> >> +{
> >> +       struct vop_win *vop_win = to_vop_win(plane);
> >> +       const struct vop_win_data *win = vop_win->data;
> >> +       int min_scale = win->phy->scl ? FRAC_16_16(1, 8) :
> >> +                                       DRM_PLANE_HELPER_NO_SCALING;
> >> +       int max_scale = win->phy->scl ? FRAC_16_16(8, 1) :
> >> +                                       DRM_PLANE_HELPER_NO_SCALING;
> >> +       struct drm_crtc_state *crtc_state;
> >> +       int ret;
> >> +
> >> +       if (plane != state->crtc->cursor)
> >> +               return -EINVAL;
> >> +
> >> +       if (!plane->state)
> >> +               return -EINVAL;
> >> +
> >> +       if (!plane->state->fb)
> >> +               return -EINVAL;
> >> +
> >> +       if (state->state)
> >> +               crtc_state = drm_atomic_get_existing_crtc_state(state->state,
> >> +                                                               state->crtc);
> >> +       else /* Special case for asynchronous cursor updates. */
> >> +               crtc_state = plane->crtc->state;
> >> +
> >> +       ret = drm_atomic_helper_check_plane_state(plane->state,
> >> +                                                 crtc_state,
> >> +                                                 min_scale, max_scale,
> >> +                                                 true, true);
> >> +       return ret;
> >> +}
> >> +
> >> +static void vop_crtc_atomic_commit_flush(struct drm_crtc *crtc,
> >> +                                        struct drm_crtc_state *old_crtc_state)
> >> +{
> >> +       struct drm_atomic_state *old_state = old_crtc_state->state;
> >> +       struct drm_plane_state *old_plane_state, *new_plane_state;
> >> +       struct vop *vop = to_vop(crtc);
> >> +       struct drm_plane *plane;
> >> +       int i;
> >> +
> >> +       for_each_oldnew_plane_in_state(old_state, plane, old_plane_state,
> >> +                                      new_plane_state, i) {
> >
> > Hmm, from what I can see, we're not going through the full atomic
> > commit sequence, with state flip, so I'm not sure where we would get
> > the new state here from.
> >
> >> +               if (!old_plane_state->fb)
> >> +                       continue;
> >> +
> >> +               if (old_plane_state->fb == new_plane_state->fb)
> >> +                       continue;
> >> +
> >> +               drm_framebuffer_get(old_plane_state->fb);
> >> +               WARN_ON(drm_crtc_vblank_get(crtc) != 0);
> >> +               drm_flip_work_queue(&vop->fb_unref_work, old_plane_state->fb);
> >> +               set_bit(VOP_PENDING_FB_UNREF, &vop->pending);
> >> +       }
> >> +}
> >> +
> >> +static void vop_plane_atomic_async_update(struct drm_plane *plane,
> >> +                                         struct drm_plane_state *new_state)
> >> +{
> >> +       struct vop *vop = to_vop(plane->state->crtc);
> >> +
> >> +       if (vop->crtc.state->state)
> >> +               vop_crtc_atomic_commit_flush(&vop->crtc, vop->crtc.state);
> >
> > Since we just operate on one plane here, we could just do like this:
> >
> > if (plane->state->fb && plane->state->fb != new_state->fb) {
> >                drm_framebuffer_get(plane->state->fb);
> >                WARN_ON(drm_crtc_vblank_get(crtc) != 0);
> >                drm_flip_work_queue(&vop->fb_unref_work, plane->state->fb);
> >                set_bit(VOP_PENDING_FB_UNREF, &vop->pending);
> > }
> >
> > However, we cannot simply to this here, because it races with the
> > vblank interrupt. We need to program the hw plane with the new fb
> > first and trigger the update. This needs all the careful handling that
> > is done in vop_crtc_atomic_flush() and so my original suggestion to
> > just call it.
>
> vop_crtc_atomic_flush() also updates the crtc->state->event, I don't
> think we want that.

Good point, we don't want to touch the event.

>
> And actually I don't think we have this race condition, please see below
>

Just to clarify, the race conditions I'm talking here are not anything
new to this patch alone. I had actually observed those when
implementing the Chrome OS downstream async cursor code before:

https://chromium.googlesource.com/chromiumos/third_party/kernel/+/65d4ff0af3f8c7ebecad8f3b402b546f277d9225/drivers/gpu/drm/rockchip/rockchip_drm_vop.c#1015

Note that the code there actually duplicates the current plane state,
updates the copy, swaps both states and then update the hardware based
on both new and old states, as the regular atomic commit flow would
do. With that, no reference counts are dropped until the old state
gets destroyed at the end of the function. Also note the if block that
handles the condition of (plane_state->fb && plane_state->fb !=
plane->state->fb) (plane_state is the old state after the swap).

> >
> > Of course to call it in its current shape, one needs to have a full
> > atomic state from a commit, after a flip, but we only have the new
> > plane state here. Perhaps you could duplicate existing state, update
> > the desired plane state, flip and then call vop_crtc_atomic_flush()?
>
> Could you please clarify your proposal? You mean duplicating
> plane->state ? I'm trying to see how this would fit it in the code.
> The drm_atomic_state structure at plate->state->state is actually always
> NULL (as an async update is applied right away).
>
>
> >
> > Best regards,
> > Tomasz
> >
>
> From your comment in v2:
>
> > Isn't this going to drop the old fb reference on the floor without
> > waiting for the hardware to actually stop scanning out from it?
>
> I've been trying to analyze this better, I also got some help from
> Gustavo Padovan, and I think there is no problem here as the
> configuration we are doing here will just be taken into consideration by
> the hardware in the next vblank, so I guess we can set and re-set
> plane->fb as much as we want.

The point here is not about setting and resetting the plane->fb
pointer. It's about what happens inside drm_atomic_set_fb_for_plane().

It calls drm_framebuffer_get() for the new fb and
drm_framebuffer_put() for the old fb. In result, if the fb changes,
the old fb, which had its reference count incremented in the atomic
commit that set it to the plane before, has its reference count
decremented. Moreover, if the new reference count becomes 0,
drm_framebuffer_put() will immediately free the buffer.

Freeing a buffer when the hardware is still scanning out of it isn't a
good idea, is it?

>
> From the async_update docs:
>
>      *  - Some hw might still scan out the old buffer until the next
>      *    vblank, however we let go of the fb references as soon as
>      *    we run this hook. For now drivers must implement their own workers
>      *    for deferring if needed, until a common solution is created.
>
> So the idea is to let the reference go asap, then we shouldn't need an
> extra drm_framebuffer_get() as done by vop_crtc_atomic_flush().

The comment above says exactly what I said. The driver must implement
a worker to keep the reference until the hardware stops using the
buffer.

>
> Does it make sense to you?
>
> Unless I am missing something, the patch v2 is essentially correct, if
> not, then vc4 driver is also broken.
>
> Please, let me know what you think and I'll send the v4.

The vc4 driver seems to be able to program the hardware to switch the
scanout to the new buffer immediately:

https://elixir.bootlin.com/linux/v4.20-rc3/source/drivers/gpu/drm/vc4/vc4_plane.c#L794

Although I wonder if there isn't still a tiny race there - the
hardware may have just started refilling the FIFO from the old
address. Still, if the FIFO is small, the FIFO refill operation may be
much shorter than it takes for the kernel code to actually free the
buffer. Eric and Michael, could you confirm?

Best regards,
Tomasz
