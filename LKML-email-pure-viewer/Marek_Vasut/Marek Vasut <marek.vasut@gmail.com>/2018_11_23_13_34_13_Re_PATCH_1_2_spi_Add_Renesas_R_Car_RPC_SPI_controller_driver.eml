Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:35:34 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga008.jf.intel.com (orsmga008.jf.intel.com [10.7.209.65])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id AB15258037D;
	Fri, 23 Nov 2018 05:35:55 -0800 (PST)
Received: from fmsmga101.fm.intel.com ([10.1.193.65])
  by orsmga008-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 05:35:54 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Ab9h/YBA3DQnG0qDTQDu7UyQJP3N1i/DPJgcQr6Af?=
 =?us-ascii?q?oPdwSP7/oMiwAkXT6L1XgUPTWs2DsrQY07qQ6/iocFdDyK7JiGoFfp1IWk1Nou?=
 =?us-ascii?q?QttCtkPvS4D1bmJuXhdS0wEZcKflZk+3amLRodQ56mNBXdrXKo8DEdBAj0OxZr?=
 =?us-ascii?q?KeTpAI7SiNm82/yv95HJbAhEmDmwbaluIBmqsA7cqtQYjYx+J6gr1xDHuGFIe+?=
 =?us-ascii?q?NYxWNpIVKcgRPx7dqu8ZBg7ipdpesv+9ZPXqvmcas4S6dYDCk9PGAu+MLrrxjD?=
 =?us-ascii?q?QhCR6XYaT24bjwBHAwnB7BH9Q5fxri73vfdz1SWGIcH7S60/VC+85Kl3VhDnlC?=
 =?us-ascii?q?YHNyY48G7JjMxwkLlbqw+lqxBm3oLYfJ2ZOP94c6jAf90VWHBBU95MWSJfDIOy?=
 =?us-ascii?q?b4gBAeQPMulXrYbyu1QArQCmBQSuH+7v1jxFi2Xq0aEm3eksEQfL1xEgEdIUt3?=
 =?us-ascii?q?TUqc34OqAIXuCv0qbIzijIYPxM1jfm9YjIbg0qrPaJXb1qa8re10ovGxnbjlqK?=
 =?us-ascii?q?sozlIi+V2/8Cs2ie9eVgVOavh3Q7pAF2pzii38EhgZTHiIISz1DL7yR5wIAtKN?=
 =?us-ascii?q?KjVU57b8SoEJpWtyycKoB4QdsiTnl2tComzrAKo4O3cSYUxJg92hLSaOCLf5KJ?=
 =?us-ascii?q?7x/hTOqcIjZ1iGhqdb+7nRq+7FWsxvHmWsS2zFpHqDdOnMPWuXAXzRPT79CKSv?=
 =?us-ascii?q?tj8Uel3jaCzx7T6u5aLkAuj6bbKIAuwqQ2lpUNtUTPBCj2mF/5jKOOd0Uk/Pan?=
 =?us-ascii?q?6/j/b7n4upORM5V4hhzwP6gwgMCzHOc1PhQUU2Wa++mwzLjj8lf4QLVOgP02iK?=
 =?us-ascii?q?7ZsJXCKMQfp665BRJV04k65xa8ETimytIYkmcDLF5cfxKGgY7pNE/UIP3jE/e/?=
 =?us-ascii?q?jEqjkC1xy/DFILLhGJPNIWbHkLv7erZ98UFcxBIpzd9D/5JUFq0BIPXrV0/1td?=
 =?us-ascii?q?zYDQE2Pxa7wub6E9h90oIeWWSSAq6WKq/SsFmI5v4xLOmIfoMapDH9K/097f70?=
 =?us-ascii?q?kXA5gUMdfbWu3ZYPaHC3BPVmI1mDbnrrmNsBEXoKsRA4TOzlk1CCVT9TZ3CvX6?=
 =?us-ascii?q?Mz/D07CYSmDZvdSYCpmrCOwCC7HphObGBcFl+MCWvod5mDW/oUaiKSJdFuniYH?=
 =?us-ascii?q?VbimTY8h0xauuRT+y7pmKOrU5yIZuYji1Nhz++3cixUy+SZoAMSa1mGHV3t0kX?=
 =?us-ascii?q?8QRz8qwKB/plRwxU2Y0ah4hPxYFsZf5+lTXQc4LpPcy+16C9bvWgPOZNuJSVCm?=
 =?us-ascii?q?Qsm4DjE1VN4+39gOY0NlEdW4kh/DxzaqA6MSl7GTB5w76KTc02L1J8Z80XnG0q?=
 =?us-ascii?q?YhgkIiQstOM22mm6F++xLSB47Pj0WWiaKqeb4A0y7K8WeJ1XCOs11AUA5sTaXF?=
 =?us-ascii?q?WmgSaVbMotTn+EzOVb+uBq4hMgta18GCLKxGatnqjVVDQPfuI9DeY2O3m2etCh?=
 =?us-ascii?q?eE3LKMbIz2e2oD2CXRElQLkwcW/XyeLwgxGj+ho37CDDxpDV/gflnj8fdgp3+h?=
 =?us-ascii?q?Tk871QeKb1Z/2Lqz4RMVgf2cS/UO3rMLoishqjN0HEqj0NLSEdaPuw1hfKBEa9?=
 =?us-ascii?q?Mn/FhHzX7ZtxB6PpG4M6Bih1secwNrv0Pu1xR7EJlAndItrHMwyApyKKSY0Fxa?=
 =?us-ascii?q?ejOc3JDwPKDXK2bo8BCuba7Wxk/R0NKM9qgT7/Q4rk3pvBu1GUo673Vnz95V3m?=
 =?us-ascii?q?OG6ZXOEgUTXoz+U0Yt+xdhurHVfzMy54XX1X1rL6m5qTvC29MvBOs4xResZdZf?=
 =?us-ascii?q?MKWYFADsF80WHdShKOsvm1KxdBILIPhS9LIoP8Ohb/aH2LOrMPx8kz68jGVH4J?=
 =?us-ascii?q?py0kSD9ydnTu7I3pAFw+yX3wedVjf8ikuhvd7zmYxeeT4SGW+/wzD+BIFNfq1y?=
 =?us-ascii?q?YZoLCWC2Ls2tx9Vxm4TiW2RF+16kHV8G3tGmeQCTb1DkwQJfz0AXrmG5liuiyD?=
 =?us-ascii?q?x0lSokrq6e3CzI3uTjewALOm9NRGl+k1jsJZK4gMwdXEitdwIpjgeq5V7mx6hH?=
 =?us-ascii?q?o6RyN2nSQUZScyn2NW1iSbawtryZbs5L6ZMotzhXUeumbVCbTL79vwUV0yf5E2?=
 =?us-ascii?q?RCwzA7cimguo/lkBxilGKdMHFzoWLbec5q3xff59/cRflL0jodXiZ4ijrXBlm6?=
 =?us-ascii?q?P9a3+9WZjJPDsuG4V2K8WZxfayjrzYWctCSl4W1mGwGwn/e2mtf/Cwg1zTf718?=
 =?us-ascii?q?V2VSXPtBv9YpPk16OgPeJlf0loAkTx6857GoF4j4sxi4sc2XkchpWJ43UHlX3/?=
 =?us-ascii?q?Pslc2aL7dHANXyIEw8bJ4Aj5301uNnGJyJj4VnmHwsthesO1YmUZ2i8m68BKCa?=
 =?us-ascii?q?GU7KFLnCdvo1q4qx7RbuZ5njsH1fQu73saifkTuAUx1iWdHqwSHU5AMCzplhSI?=
 =?us-ascii?q?7MqxoL9ZZWmxariwyFRxncq6A76cuAFcV230epMjHS9288V+P0jA0Hz16oH4Zt?=
 =?us-ascii?q?bQacgfuQGTkxfFl+JVMo4+luIWhSp7PmLwpWEly+k+jRB03JC1po6HK3h2/KKi?=
 =?us-ascii?q?Ax5VLTn1Z8IV+jHwgqdShMeW34azHpp/HjUHRofnTfWtEDgKr/ToKx6OECEgqn?=
 =?us-ascii?q?ecAbfQBhWQ6EBir3LSCZyrM2yXKWIdzdVjQhmdOUNejBoVXDU8gp42CASqyNb9?=
 =?us-ascii?q?f0d+4zAb/kT4pQdUyuJ0Kxn/VX/SpAWyZTcxVpefNwBa7h1Y60fWLMye7f9zHy?=
 =?us-ascii?q?dC8Z26twGNLm2bZwJVDWAGQECEBlbjPqWw6tnE6eSXGu2+L/7Wa7WUteNeT+uI?=
 =?us-ascii?q?xY6o0oZ+/zeMMdiPPmB/D/Ih3EpPR2t5G8PfmzUAUCEXkyPNb8iGpBaz4CF3r8?=
 =?us-ascii?q?a/8Oj1VwLr/4eAF7xSMdB38RCsnaiDL/KQhDp+KTtA1pMD237IyLsc3F4TkS1u?=
 =?us-ascii?q?dCOtEbMPtSHTVqLQh7RXAgUfayNyMstI8q090hNMOc7dltP6yLp4guQpBFdCUF?=
 =?us-ascii?q?zrgtupatASI2GhKFPHA16GO66bJTLQ2cH4f6O9RadUjOVVrBCwvTebE0n+PjWM?=
 =?us-ascii?q?jTXpVhavMf1SgyGfJhBRpIa9chN1A2j5UN3mcgG7MMNwjTAu3b00h3bKOXQAPj?=
 =?us-ascii?q?Rmb0xNrqOf7SVDj/V7GmxB6GdlLOaelyaY6enYNogZsf9xDitokOJa5Wwwy6FJ?=
 =?us-ascii?q?4yFcWPx1hCzSo8Zuol68lOmPzztnUBxWpTdKhIKEp0NiOarC+5lEWHbE+g8N7G?=
 =?us-ascii?q?qKBxQLodtlFsPgu6RKxtfTk6LzLWQKz9WB+MIHAM7fI9OONnUJNAroE3jfCw5D?=
 =?us-ascii?q?USH4G3vYghl4meuf9TWrp4MnttC4nZMUR7wdSlUuC+8yBUFsHdhEK5ByCGB32Y?=
 =?us-ascii?q?WHhdIFsCLt5CLaQ99X69WeDqqf?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0A7AAAVAfhbh0O0hNFjHgEGBwaBUQkLA?=
 =?us-ascii?q?YJpA38nh3SQHIFgCCUUiXaNMRSBYg8BARgDEAGEQIQXIjQJDQEDAQEBAQEBAgE?=
 =?us-ascii?q?TAQEBCA0JCCkjDII2JAGCYgECAwECJAsBDQEbHQEDAgkBAQUFCw0uAyARAQUBH?=
 =?us-ascii?q?BADBgIBAQGDHAGBaAEDFQQBmy48jAkWBQEXgncFgkSBaQoZJw1agTcCBhKKW4E?=
 =?us-ascii?q?cgVc/gREnDIFhUC6EZxeFWwKJH4wcikcHAoIcBIRcii0GGIFZTYcrECaHAYlti?=
 =?us-ascii?q?xGDCwIEAgQFAgUPIYElX4EuMxojgQGCOwmCEgwXg0qCVod9PzKBBQEBjCEBAQ?=
X-IPAS-Result: =?us-ascii?q?A0A7AAAVAfhbh0O0hNFjHgEGBwaBUQkLAYJpA38nh3SQHIF?=
 =?us-ascii?q?gCCUUiXaNMRSBYg8BARgDEAGEQIQXIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjD?=
 =?us-ascii?q?II2JAGCYgECAwECJAsBDQEbHQEDAgkBAQUFCw0uAyARAQUBHBADBgIBAQGDHAG?=
 =?us-ascii?q?BaAEDFQQBmy48jAkWBQEXgncFgkSBaQoZJw1agTcCBhKKW4EcgVc/gREnDIFhU?=
 =?us-ascii?q?C6EZxeFWwKJH4wcikcHAoIcBIRcii0GGIFZTYcrECaHAYltixGDCwIEAgQFAgU?=
 =?us-ascii?q?PIYElX4EuMxojgQGCOwmCEgwXg0qCVod9PzKBBQEBjCEBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,269,1539673200"; 
   d="scan'208";a="63687522"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mga01b.intel.com with ESMTP; 23 Nov 2018 05:35:53 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2439811AbeKXAUD (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 19:20:03 -0500
Received: from mail-wr1-f67.google.com ([209.85.221.67]:39268 "EHLO
        mail-wr1-f67.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2394868AbeKXAUD (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 19:20:03 -0500
Received: by mail-wr1-f67.google.com with SMTP id t27so4419078wra.6;
        Fri, 23 Nov 2018 05:35:48 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=subject:to:cc:references:from:message-id:date:user-agent
         :mime-version:in-reply-to:content-language:content-transfer-encoding;
        bh=DHyl/xvHJeBmB7zNcOR0SFgj3Cyjc0HjVsJfUJR1Kis=;
        b=qBJy1U7euv9Kpq2WAArhoeDljBIZqVniPecLmTAZDX3joBcwtbVYQBbIxfPuRTUPMS
         M+a1MIURM5vLdGIDKLFfVnebcHOR+aB07vc5V0gXQADOeaEnRS0sZ09BLCJZjPBoQit7
         xGF9b5PJfW0MLl8oSp6OvgQiMXw3uuebrxMvuj9xTvVRKnxwHhM7qtdGWHK2m+Vj1U6v
         leVPv3R8X6A34ylMzEJ2gmEMDBToMKxENtLExqLlTz8aAijSuQ5B6o17F9kt6FCK/406
         QZX/rk9Df9WGy/xILcsQYRjqleQRszNWtFk2IG+Nc7G6zGVia9sEt7szt3BotSfSnUgp
         ReWA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:subject:to:cc:references:from:message-id:date
         :user-agent:mime-version:in-reply-to:content-language
         :content-transfer-encoding;
        bh=DHyl/xvHJeBmB7zNcOR0SFgj3Cyjc0HjVsJfUJR1Kis=;
        b=GDABKyrW4n3RLVsTifwRgtY68JdFDyecbyJWKSONF0GrkrtpBFWjpN7DTdvWyZ2MW1
         7EQ6t7oPSXAztYGPp6eyGetbK3gJ8RUOh3B8XgG8nNJapi3qvfdTTDUgs51gyGsZUgKb
         ONtdInEpJKF0HHx5wWl+4XLb4hA9vjefyefhh0fF3aIht887yO5HU5MRMCLrySin7TfM
         BOBmQ4LpW+27yOlNVHUCH6mgYD8a8Mgfa8QsPjAFACqWZgci0XhT+IFIRUinpPnSq5nu
         WucaUjE8aKrwhIBAbVor2Et0g/Lb+TzfzJkjdzNTEzKcp9/BZdKyGZO0+lJXvE6gQ3Lw
         VxCQ==
X-Gm-Message-State: AA+aEWa1v/XSU4AafME+xJCtMw4cF2wzSzB6Dnsu1oX/0hDhS/IKLE6p
        QutmWwytEW34ku+ShUt63wg=
X-Google-Smtp-Source: AFSGD/VL4HfFYL6N5pG37qPJKCzVPvVYXZo4GHcd328w0W4PoFH6SqFj7aZWDBiM2gYrVQ+0qt6h1g==
X-Received: by 2002:adf:83e7:: with SMTP id 94mr14127956wre.278.1542980147286;
        Fri, 23 Nov 2018 05:35:47 -0800 (PST)
Received: from [192.168.1.4] (ip-86-49-110-70.net.upcbroadband.cz. [86.49.110.70])
        by smtp.gmail.com with ESMTPSA id a18sm25535268wrp.13.2018.11.23.05.35.45
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 23 Nov 2018 05:35:46 -0800 (PST)
Subject: Re: [PATCH 1/2] spi: Add Renesas R-Car RPC SPI controller driver
To: masonccyang@mxic.com.tw
Cc: boris.brezillon@bootlin.com, broonie@kernel.org,
        Geert Uytterhoeven <geert+renesas@glider.be>,
        Simon Horman <horms@verge.net.au>, juliensu@mxic.com.tw,
        linux-kernel@vger.kernel.org, linux-renesas-soc@vger.kernel.org,
        linux-spi@vger.kernel.org, tpiepho@impinj.com,
        zhengxunli@mxic.com.tw
References: <1542621690-10229-1-git-send-email-masonccyang@mxic.com.tw>
 <1542621690-10229-2-git-send-email-masonccyang@mxic.com.tw>
 <0223f43b-c6a6-eade-49af-4e7b7ef7f022@gmail.com>
 <OF5B1A3AE4.2DEECF37-ON4825834E.00031E97-4825834E.00042D72@mxic.com.tw>
From: Marek Vasut <marek.vasut@gmail.com>
Message-ID: <3b639470-2351-5fff-6121-e400eb0a1493@gmail.com>
Date: Fri, 23 Nov 2018 14:34:13 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101
 Thunderbird/52.8.0
MIME-Version: 1.0
In-Reply-To: <OF5B1A3AE4.2DEECF37-ON4825834E.00031E97-4825834E.00042D72@mxic.com.tw>
Content-Type: text/plain; charset=windows-1252
Content-Language: en-US
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On 11/23/2018 01:45 AM, masonccyang@mxic.com.tw wrote:
> Hi Marek,

Hi,

>> > +
>> > +struct rpc_spi {
>> > +   struct clk *clk_rpc;
>> > +   void __iomem *regs;
>> > +   struct {
>> > +      void __iomem *map;
>> > +      dma_addr_t dma;
>> > +      size_t size;
>> > +   } linear;
>>
>> Does this need it's own struct ?
>>
> 
> yup, I think it's better.
> In case no "dirmap" in dtb and no direct mapping mode implemented.
> 
> 
>> > +   u32 cur_speed_hz;
>> > +   u32 cmd;
>> > +   u32 addr;
>> > +   u32 dummy;
>> > +   u32 smcr;
>> > +   u32 smenr;
>> > +   u32 xferlen;
>> > +   u32 totalxferlen;
>>
>> This register cache might be a good candidate for regmap ?
> 
> I don't know what does it mean ?
> Could you give me more information!

See include/linux/regmap.h and git grep regmap drivers/ for examples.

>> > +   enum spi_mem_data_dir xfer_dir;
>> > +};
>> > +
>> > +static int rpc_spi_set_freq(struct rpc_spi *rpc, unsigned long freq)
>> > +{
>> > +   int ret;
>> > +
>> > +   if (rpc->cur_speed_hz == freq)
>> > +      return 0;
>> > +
>> > +   clk_disable_unprepare(rpc->clk_rpc);
>> > +   ret = clk_set_rate(rpc->clk_rpc, freq);
>> > +   if (ret)
>> > +      return ret;
>> > +
>> > +   ret = clk_prepare_enable(rpc->clk_rpc);
>> > +   if (ret)
>> > +      return ret;
>>
>> Is this clock disable/update/enable really needed ? I'd think that
>> clk_set_rate() would handle the rate update correctly.
> 
> As Gerrt mentioned, I will remove them.
> 
> 
>> > +static int wait_msg_xfer_end(struct rpc_spi *rpc)
>> > +{
>> > +   u32 sts;
>> > +
>> > +   return readl_poll_timeout(rpc->regs + RPC_CMNSR, sts,
>> > +              sts & RPC_CMNSR_TEND, 0, USEC_PER_SEC);
>> > +}
>> > +
>> > +static u8 rpc_bits_xfer(u32 nbytes)
>> > +{
>> > +   u8 databyte;
>> > +
>> > +   switch (nbytes) {
>>
>> Did you ever test unaligned writes and reads ? There are some nasty edge
>> cases in those.
>>
>> Also, I think you can calculate the number of set bits using a simple
>> function, so the switch-case might not even be needed.
>>
> 
> Any example function ?

Nope, you'd have to think of one. You need to fill $nbytes bits from top
down. I think you can somehow use GENMASK() .

>> > +   case 1:
>> > +      databyte = 0x8;
>> > +      break;
>> > +   case 2:
>> > +      databyte = 0xc;
>> > +      break;
>> > +   default:
>> > +      databyte = 0xf;
>> > +      break;
>> > +   }
>> > +
>> > +   return databyte;
>> > +}
>> > +
>> > +static int rpc_spi_io_xfer(struct rpc_spi *rpc,
>> > +            const void *tx_buf, void *rx_buf)
>> > +{
>> > +   u32 smenr, smcr, data, pos = 0;
>> > +   int ret = 0;
>> > +
>> > +   writel(RPC_CMNCR_MD | RPC_CMNCR_SFDE | RPC_CMNCR_MOIIO_HIZ |
>> > +          RPC_CMNCR_IOFV_HIZ | RPC_CMNCR_BSZ(0), rpc->regs +
> RPC_CMNCR);
>> > +   writel(0x0, rpc->regs + RPC_SMDRENR);
>> > +
>> > +   if (tx_buf) {
>> > +      writel(rpc->cmd, rpc->regs + RPC_SMCMR);
>> > +      writel(rpc->dummy, rpc->regs + RPC_SMDMCR);
>> > +      writel(rpc->addr, rpc->regs + RPC_SMADR);
>> > +      smenr = rpc->smenr;
>> > +
>> > +      while (pos < rpc->xferlen) {
>> > +         u32 nbytes = rpc->xferlen  - pos;
>> > +
>> > +         writel(*(u32 *)(tx_buf + pos), rpc->regs + RPC_SMWDR0);
>> > +
>> > +         if (nbytes > 4) {
>> > +            nbytes = 4;
>> > +            smcr = rpc->smcr |
>> > +                   RPC_SMCR_SPIE | RPC_SMCR_SSLKP;
>> > +         } else {
>> > +            smcr = rpc->smcr | RPC_SMCR_SPIE;
>> > +         }
>> > +
>> > +         writel(smenr, rpc->regs + RPC_SMENR);
>> > +         writel(smcr, rpc->regs + RPC_SMCR);
>> > +         ret = wait_msg_xfer_end(rpc);
>> > +         if (ret)
>> > +            goto out;
>> > +
>> > +         pos += nbytes;
>> > +         smenr = rpc->smenr & ~RPC_SMENR_CDE &
>> > +                    ~RPC_SMENR_ADE(0xf);
>> > +      }
>> > +   } else if (rx_buf) {
>> > +      while (pos < rpc->xferlen) {
>> > +         u32 nbytes = rpc->xferlen  - pos;
>> > +
>> > +         if (nbytes > 4)
>> > +            nbytes = 4;
>> > +
>> > +         writel(rpc->cmd, rpc->regs + RPC_SMCMR);
>> > +         writel(rpc->dummy, rpc->regs + RPC_SMDMCR);
>> > +         writel(rpc->addr + pos, rpc->regs + RPC_SMADR);
>> > +         writel(rpc->smenr, rpc->regs + RPC_SMENR);
>> > +         writel(rpc->smcr | RPC_SMCR_SPIE, rpc->regs + RPC_SMCR);
>> > +         ret = wait_msg_xfer_end(rpc);
>> > +         if (ret)
>> > +            goto out;
>> > +
>> > +         data = readl(rpc->regs + RPC_SMRDR0);
>> > +         memcpy_fromio(rx_buf + pos, (void *)&data, nbytes);
>> > +         pos += nbytes;
>> > +      }
>> > +   } else {
>> > +      writel(rpc->cmd, rpc->regs + RPC_SMCMR);
>> > +      writel(rpc->dummy, rpc->regs + RPC_SMDMCR);
>> > +      writel(rpc->addr + pos, rpc->regs + RPC_SMADR);
>> > +      writel(rpc->smenr, rpc->regs + RPC_SMENR);
>> > +      writel(rpc->smcr | RPC_SMCR_SPIE, rpc->regs + RPC_SMCR);
>> > +      ret = wait_msg_xfer_end(rpc);
>> > +   }
>> > +out:
>>
>> Dont you need to stop the RPC somehow in case the transmission fails ?
>>
> 
> I can't find any RPC registers can do this !
> 
> Do you know how to do this ?

It should be in the RPC datasheet ? It's likely going to involve SMCR,
possibly clear SPIE bit and maybe some more.

>> > +   writel(rpc->cmd, rpc->regs + RPC_SMCMR);
>> > +   writel(offs, rpc->regs + RPC_SMADR);
>> > +   writel(rpc->smenr, rpc->regs + RPC_SMENR);
>> > +   writel(rpc->smcr | RPC_SMCR_SPIE, rpc->regs + RPC_SMCR);
>> > +   ret = wait_msg_xfer_end(rpc);
>> > +   if (ret)
>> > +      goto out;
>> > +
>> > +   writel(RPC_DRCR_RCF, rpc->regs + RPC_DRCR);
>> > +   writel(RPC_PHYCNT_CAL | RPC_PHYCNT_STRTIM(0) | 0x260,
>> > +          rpc->regs + RPC_PHYCNT);
>> > +
>> > +   return len;
>> > +out:
>>
>> Shouldn't you shut the controller down if the xfer fails ?
> 
> Any registers can shut down RPC controller ?
> SW reset ?

Possibly, can you research it ?

>> > +   return ret;
>> > +}
>> > +
>> > +static int rpc_spi_mem_dirmap_create(struct spi_mem_dirmap_desc *desc)
>> > +{
>> > +   struct rpc_spi *rpc =
> spi_master_get_devdata(desc->mem->spi->master);
>> > +
>> > +   if (desc->info.offset + desc->info.length > U32_MAX)
>> > +      return -ENOTSUPP;
>> > +
>> > +   if (!rpc_spi_mem_supports_op(desc->mem, &desc->info.op_tmpl))
>> > +      return -ENOTSUPP;
>> > +
>> > +   if (!rpc->linear.map &&
>> > +       desc->info.op_tmpl.data.dir == SPI_MEM_DATA_IN)
>> > +      return -ENOTSUPP;
>> > +
>> > +   return 0;
>> > +}
>> > +
>> > +static int rpc_spi_mem_exec_op(struct spi_mem *mem,
>> > +                const struct spi_mem_op *op)
>> > +{
>> > +   struct rpc_spi *rpc = spi_master_get_devdata(mem->spi->master);
>> > +   int ret;
>> > +
>> > +   ret = rpc_spi_set_freq(rpc, mem->spi->max_speed_hz);
>> > +   if (ret)
>> > +      return ret;
>> > +
>> > +   rpc_spi_mem_set_prep_op_cfg(mem->spi, op, NULL, NULL);
>> > +
>> > +   ret = rpc_spi_io_xfer(rpc,
>> > +               op->data.dir == SPI_MEM_DATA_OUT ?
>> > +               op->data.buf.out : NULL,
>> > +               op->data.dir == SPI_MEM_DATA_IN ?
>> > +               op->data.buf.in : NULL);
>> > +
>> > +   return ret;
>> > +}
>> > +
>> > +static const struct spi_controller_mem_ops rpc_spi_mem_ops = {
>> > +   .supports_op = rpc_spi_mem_supports_op,
>> > +   .exec_op = rpc_spi_mem_exec_op,
>> > +   .dirmap_create = rpc_spi_mem_dirmap_create,
>> > +   .dirmap_read = rpc_spi_mem_dirmap_read,
>> > +   .dirmap_write = rpc_spi_mem_dirmap_write,
>> > +};
>> > +
>> > +static void rpc_spi_transfer_setup(struct rpc_spi *rpc,
>> > +               struct spi_message *msg)
>> > +{
>> > +   struct spi_transfer *t, xfer[4] = { };
>> > +   u32 i, xfercnt, xferpos = 0;
>> > +
>> > +   rpc->totalxferlen = 0;
>> > +   list_for_each_entry(t, &msg->transfers, transfer_list) {
>> > +      if (t->tx_buf) {
>> > +         xfer[xferpos].tx_buf = t->tx_buf;
>> > +         xfer[xferpos].tx_nbits = t->tx_nbits;
>> > +      }
>> > +
>> > +      if (t->rx_buf) {
>> > +         xfer[xferpos].rx_buf = t->rx_buf;
>> > +         xfer[xferpos].rx_nbits = t->rx_nbits;
>> > +      }
>> > +
>> > +      if (t->len) {
>> > +         xfer[xferpos++].len = t->len;
>> > +         rpc->totalxferlen += t->len;
>> > +      }
>> > +   }
>> > +
>> > +   xfercnt = xferpos;
>> > +   rpc->xferlen = xfer[--xferpos].len;
>> > +   rpc->cmd = RPC_SMCMR_CMD(((u8 *)xfer[0].tx_buf)[0]);
>>
>> Is the cast needed ?
> 
> ?

Sorry, I don't understand your question.
To rephrase my original question, is the (u8 *) cast needed ?

>> > +   rpc->smenr = RPC_SMENR_CDE | RPC_SMENR_CDB(fls(xfer[0].tx_nbits
>>> 1));
>> > +   rpc->addr = 0;
>> > +
>> > +   if (xfercnt > 2 && xfer[1].len && xfer[1].tx_buf) {
>> > +      rpc->smenr |= RPC_SMENR_ADB(fls(xfer[1].tx_nbits >> 1));
>> > +      for (i = 0; i < xfer[1].len; i++)
>> > +         rpc->addr |= (u32)((u8 *)xfer[1].tx_buf)[i]
>> > +               << (8 * (xfer[1].len - i - 1));
>> > +
>> > +      if (xfer[1].len == 4)
>> > +         rpc->smenr |= RPC_SMENR_ADE(0xf);
>> > +      else
>> > +         rpc->smenr |= RPC_SMENR_ADE(0x7);
>> > +   }
>> > +
>> > +   switch (xfercnt) {
>> > +   case 2:
>> > +      if (xfer[1].rx_buf) {
>> > +         rpc->smenr |= RPC_SMENR_SPIDE(rpc_bits_xfer
>> > +                  (xfer[1].len)) | RPC_SMENR_SPIDB(fls
>> > +                  (xfer[1].rx_nbits >> 1));
>>
>> How much of this register value calculation could be somehow
>> deduplicated ? It seems to be almost the same thing copied thrice here.
> 
> I don't get your point!
> 
> The 2'nd transfer may be
> 1) spi-address
> 2) tx_buf[] for write registers.
> 3) rx_buf[] for read status.
> 
> parse them and write to rpc->addr and so on.
> Or you have a better way to do this ?

Each of the case statement options has almost the same stuff in it. Can
this be somehow reworked so that it wouldn't be three copies of almost
the same ?

[...]

-- 
Best regards,
Marek Vasut
