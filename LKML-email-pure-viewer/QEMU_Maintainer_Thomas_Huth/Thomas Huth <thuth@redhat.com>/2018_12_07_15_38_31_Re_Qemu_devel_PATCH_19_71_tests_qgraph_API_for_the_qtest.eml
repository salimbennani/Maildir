Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 09 Dec 2018 18:50:27 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga005.jf.intel.com (orsmga005.jf.intel.com [10.7.209.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 5E3365804F7
	for <like.xu@linux.intel.com>; Fri,  7 Dec 2018 07:39:13 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga005-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 07 Dec 2018 07:39:12 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3Au8KyrRGjgQUyzFvqQYF3nZ1GYnF86YWxBRYc798d?=
 =?us-ascii?q?s5kLTJ76p829bnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjm58axlVAHnhz?=
 =?us-ascii?q?sGNz4h8WHYlMpwjL5AoBm8oxBz2pPYbJ2JOPZ7eK7WYNEUSndbXstJSSJBDIOy?=
 =?us-ascii?q?b4wMAeQPM+lXoIvyqEcBoxWjHQmhBuHhxzBVinL4waE1zf8hHBra3Aw5Bd8CrG?=
 =?us-ascii?q?jYodv3OaoUTOu7zLPIzTLGb/5Oxzn96I/IchU7rvGXQLl+c9fRyVUvFwjYiViQ?=
 =?us-ascii?q?tYzlPy6J1uQNqGWb9fRvWv+vi2E9twF9uCSgxsApioTQgI8e117K9SJ8wIkvJN?=
 =?us-ascii?q?24TlZ2YdGiEJtNrS2aMJF2QswkTmp1uyg60qULtYCncCUJ0pgr2gPTZv+df4SW?=
 =?us-ascii?q?7B/uVPydLSp6iX59Zr6zmxK//VK9xuDySMW4yktGoylLn9XWqHwA1Bre4dWdRP?=
 =?us-ascii?q?Rn5EeuwzOP2hjT6u5aJUA0krLWK5ogwr4ripoTql7PHiDwmEXrlqOWcV8k+uew?=
 =?us-ascii?q?5+TmZLXpuIOcOpdqhg3iMakigNGzDfk7PwQUQWSW9+Sx2Kf+8UD7WLlKi+c5kq?=
 =?us-ascii?q?jdsJDUP8Qboau5DhdM0ok97ha/Ei6q38kGknkZMl1FfAuLgJPuO1HTJvD3Eemw?=
 =?us-ascii?q?g0+rnDdvxvDGPaPuDo/CL3jeiLrhebd960hByAs819xf5pRUCq0fL/L3QEP+qN?=
 =?us-ascii?q?vYDhoiPgyyxObnDtp91oUDWW6VBa+ZKqzSvUeS5u0zO+mMeJMVuDHlJvgh5v7u?=
 =?us-ascii?q?jmE2lUUSfKm0xpYXbHG4HvJ7I0SWe3bsg9EBEXsUsQo6VuDllFqCUTsAL0u0RL?=
 =?us-ascii?q?82szEnFJq9X8CEQoG2nKfH2iC9EZtLIGdcBReJGHbscoyCHPAUdCOVJNQmizEB?=
 =?us-ascii?q?SP2tRpEs0UKTshTnwe9iJ+vQ5ipKrJ/myZ156vPekVQo+CVpAt+B+2eKSW5ygy?=
 =?us-ascii?q?UPXTBhx711o0F21gKe17NliedTD91Z6qB1VVICPJnYyKRQDNbgWwTANoORQlGg?=
 =?us-ascii?q?UNSgABkrQ94xysNIaEF4TZHqlx3Gwm+mDqEYk5SNA5o79L+a2GL+dOhnzHOT6K?=
 =?us-ascii?q?kmilA9CutSKW3u0rJ/6hTTL5TEn0WQi+ChcqFKj32Fz3uK0Wfb5BIQawV3S6iQ?=
 =?us-ascii?q?GClHPkY=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ARAACOkwpcmBHrdtBZChsBAQEBAwEBA?=
 =?us-ascii?q?QcDAQEBgVMEAQEBCwGBMCqBD4EWE4N6gzyFPIsygWAIJXyIFo49FIFjEBgHDYE?=
 =?us-ascii?q?qIYJ1gx0iNgcNAQMBAQEBAQECARMBAQEBAQgLCwYbDiMMgjYFAgMaAQaCWwEBA?=
 =?us-ascii?q?QEDAQIXAQgEHwoiAgUDAwECBgEBCg4EAwMCAiIEAgIDAR0oDgYBDAYCAQEBBIM?=
 =?us-ascii?q?YAYFpAxUBBKVDfDOIBQ2CHIELhy2DaheBQD+BEScMgio1glc8gTMQEwEXgwSCV?=
 =?us-ascii?q?wKJJYYWhjWKIg8YLgmKP4NdgykGGIljhF2CeIkQhX+BXIgwgU0KW4EhMxoIGxU?=
 =?us-ascii?q?aIYJsCYIdARd/AQiHVoVAQDGBBxyIUoF3AQE?=
X-IPAS-Result: =?us-ascii?q?A0ARAACOkwpcmBHrdtBZChsBAQEBAwEBAQcDAQEBgVMEAQE?=
 =?us-ascii?q?BCwGBMCqBD4EWE4N6gzyFPIsygWAIJXyIFo49FIFjEBgHDYEqIYJ1gx0iNgcNA?=
 =?us-ascii?q?QMBAQEBAQECARMBAQEBAQgLCwYbDiMMgjYFAgMaAQaCWwEBAQEDAQIXAQgEHwo?=
 =?us-ascii?q?iAgUDAwECBgEBCg4EAwMCAiIEAgIDAR0oDgYBDAYCAQEBBIMYAYFpAxUBBKVDf?=
 =?us-ascii?q?DOIBQ2CHIELhy2DaheBQD+BEScMgio1glc8gTMQEwEXgwSCVwKJJYYWhjWKIg8?=
 =?us-ascii?q?YLgmKP4NdgykGGIljhF2CeIkQhX+BXIgwgU0KW4EhMxoIGxUaIYJsCYIdARd/A?=
 =?us-ascii?q?QiHVoVAQDGBBxyIUoF3AQE?=
X-IronPort-AV: E=Sophos;i="5.56,326,1539673200"; 
   d="scan'208";a="54986243"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 07 Dec 2018 07:39:10 -0800
Received: from localhost ([::1]:46778 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gVIDd-0006qK-UZ
	for like.xu@linux.intel.com; Fri, 07 Dec 2018 10:39:10 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:58897)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <thuth@redhat.com>) id 1gVIDC-0006HJ-4I
	for qemu-devel@nongnu.org; Fri, 07 Dec 2018 10:38:48 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <thuth@redhat.com>) id 1gVID5-0004J1-L4
	for qemu-devel@nongnu.org; Fri, 07 Dec 2018 10:38:42 -0500
Received: from mx1.redhat.com ([209.132.183.28]:34916)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <thuth@redhat.com>) id 1gVID5-0004Df-6o
	for qemu-devel@nongnu.org; Fri, 07 Dec 2018 10:38:35 -0500
Received: from smtp.corp.redhat.com (int-mx04.intmail.prod.int.phx2.redhat.com
	[10.5.11.14])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id 75843307D943;
	Fri,  7 Dec 2018 15:38:34 +0000 (UTC)
Received: from thuth.remote.csb (ovpn-116-106.ams2.redhat.com [10.36.116.106])
	by smtp.corp.redhat.com (Postfix) with ESMTP id BFD815DD8D;
	Fri,  7 Dec 2018 15:38:32 +0000 (UTC)
To: Paolo Bonzini <pbonzini@redhat.com>, qemu-devel@nongnu.org
References: <1543851204-41186-1-git-send-email-pbonzini@redhat.com>
	<1543851204-41186-20-git-send-email-pbonzini@redhat.com>
From: Thomas Huth <thuth@redhat.com>
Openpgp: preference=signencrypt
Autocrypt: addr=thuth@redhat.com; keydata=
	xsFNBFH7eUwBEACzyOXKU+5Pcs6wNpKzrlJwzRl3VGZt95VCdb+FgoU9g11m7FWcOafrVRwU
	yYkTm9+7zBUc0sW5AuPGR/dp3pSLX/yFWsA/UB4nJsHqgDvDU7BImSeiTrnpMOTXb7Arw2a2
	4CflIyFqjCpfDM4MuTmzTjXq4Uov1giGE9X6viNo1pxyEpd7PanlKNnf4PqEQp06X4IgUacW
	tSGj6Gcns1bCuHV8OPWLkf4hkRnu8hdL6i60Yxz4E6TqlrpxsfYwLXgEeswPHOA6Mn4Cso9O
	0lewVYfFfsmokfAVMKWzOl1Sr0KGI5T9CpmRfAiSHpthhHWnECcJFwl72NTi6kUcUzG4se81
	O6n9d/kTj7pzTmBdfwuOZ0YUSqcqs0W+l1NcASSYZQaDoD3/SLk+nqVeCBB4OnYOGhgmIHNW
	0CwMRO/GK+20alxzk//V9GmIM2ACElbfF8+Uug3pqiHkVnKqM7W9/S1NH2qmxB6zMiJUHlTH
	gnVeZX0dgH27mzstcF786uPcdEqS0KJuxh2kk5IvUSL3Qn3ZgmgdxBMyCPciD/1cb7/Ahazr
	3ThHQXSHXkH/aDXdfLsKVuwDzHLVSkdSnZdt5HHh75/NFHxwaTlydgfHmFFwodK8y/TjyiGZ
	zg2Kje38xnz8zKn9iesFBCcONXS7txENTzX0z80WKBhK+XSFJwARAQABzRxUaG9tYXMgSHV0
	aCA8dGguaHV0aEBnbXguZGU+wsF7BBMBAgAlAhsDBgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIX
	gAUCUfuWKwIZAQAKCRAu2dd0/nAttbe/EACb9hafyOb2FmhUqeAiBORSsUifFacQ7laVjcgR
	I4um8CSHvxijYftpkM2EdAtmXIKgbNDpQoXcWLXB9lu9mLgTO4DVT00TRR65ikn3FCWcyT74
	ENTOzRKyKLsDCjhXKPblTPIQbYAUCOWElcyAPm0ERd62fA/rKNxgIiNo/l4UODOMoOJm2/Ox
	ZoTckW68Eqv7k9L7m7j+Hn3hoDTjAmcCBJt+j7pOhzWvCbqoNOIH8C8qvPaNlrba+R/K6jkO
	6jZkTbYQpGIofEQJ/TNn38IsNGpI1ALTHWFtoMxp3j2Imz0REO6dRE2fHRN8sVlHgkoeGhmY
	NbDsDE1jFQOEObFnu0euk//7BXU7tGOHckVAZ8T1smiRPHfQU7UEH2a/grndxJ+PNeM5w7n2
	l+FN3cf2KgPotCK2s9MjSdZA7C5e3rFYO8lqiqTJKvc62vqp3e7B0Kjyy5/QtzSOejBij2QL
	xkKSFNtxIz4MtuxN8e3IDQNxsKry3nF7R4MDvouXlMo6wP9KuyNWb+vFJt9GtbgfDMIFVamp
	ZfhEWzWRJH4VgksENA4K/BzjEHCcbTUb1TFsiB1VRnBPJ0SqlvifnfKk6HcpkDk6Pg8Q5FOJ
	gbNHrdgXsm+m/9GF2zUUr+rOlhVbK23TUqKqPfwnD7uxjpakVcJnsVCFqJpZi1F/ga9IN87B
	TQRR+3lMARAAtp831HniPHb9AuKq3wj83ujZK8lH5RLrfVsB4X1wi47bwo56BqhXpR/zxPTR
	eOFT0gnbw9UkphVc7uk/alnXMDEmgvnuxv89PwIQX6k3qLABeV7ykJQG/WT5HQ6+2DdGtVw3
	2vjYAPiWQeETsgWRRQMDR0/hwp8s8tL/UodwYCScH6Vxx9pdy353L1fK4Bb9G73a+9FPjp9l
	x+WwKTsltVqSBuSjyZQ3c3EE8qbTidXZxB38JwARH8yN3TX+t65cbBqLl/zRUUUTapHQpUEd
	yoAsHIml32e4q+3xdLtTdlLi7FgPBItSazcqZPjEcYW73UAuLcmQmfJlQ5PkDiuqcitn+KzH
	/1pqsTU7QFZjbmSMJyXY0TDErOFuMOjf20b6arcpEqse1V3IKrb+nqqA2azboRm3pEANLAJw
	iVTwK3qwGRgK5ut6N/Znv20VEHkFUsRAZoOusrIRfR5HFDxlXguAdEz8M/hxXFYYXqOoaCYy
	6pJxTjy0Y/tIfmS/g9Bnp8qg9wsrsnk0+XRnDVPak++G3Uq9tJPwpJbyO0vcqEI3vAXkAB7X
	VXLzvFwi66RrsPUoDkuzj+aCNumtOePDOCpXQGPpKl+l1aYRMN/+lNSk3+1sVuc2C07WnYyE
	gV/cbEVklPmKrNwu6DeUyD0qI/bVzKMWZAiB1r56hsGeyYcAEQEAAcLBXwQYAQIACQUCUft5
	TAIbDAAKCRAu2dd0/nAttYTwEACLAS/THRqXRKb17PQmKwZHerUvZm2klo+lwQ3wNQBHUJAT
	p2R9ULexyXrJPqjUpy7+voz+FcKiuQBTKyieiIxO46oMxsbXGZ70o3gxjxdYdgimUD6U8PPd
	JH8tfAL4BR5FZNjspcnscN2jgbF4OrpDeOLyBaj6HPmElNPtECHWCaf1xbIFsZxSDGMA6cUh
	0uX3Q8VI7JN1AR2cfiIRY7NrIlWYucJxyKjO3ivWm69nCtsHiJ0wcF8KlVo7F2eLaufo0K8A
	ynL8SHMF3VEyxsXOP2f1UR9T2Ur30MXcTBpjUxml1TX3RWY5uH89Js/jlIugBwuAmacJ7JYh
	lTg6sF/GNc4nPb4kk2yktNWTade+TzsllYlJPaorD2Qe8qX0iFUhFC6y9+O6mP4ZvWoYapp9
	ezYNuebMgEr93ob1+4sFg3812wNP01WqsGtWCJHnPv/JoonFdMzD/bIkXGEJMk6ks2kxQQZq
	g6Ik/s/vxOfao/xCn8nHt7GwvVy41795hzK6tbSl+BuyCRp0vfPRP34OnK7+jR2nvQpJu/pU
	rCELuGwT9hsYkUPjVd4lfylN3mzEc6iAv/wwjsc0DRTSQCpXT3v2ymTAsRKrVaEZLibTXaf+
	WslxWek3xNYRiqwwWAJuL652eAlxUgQ5ZS+fXBRTiQpJ+F26I/2lccScRd9G5w==
Organization: Red Hat
Message-ID: <f525819f-816c-da64-0871-6921996b28fb@redhat.com>
Date: Fri, 7 Dec 2018 16:38:31 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101
	Thunderbird/52.9.1
MIME-Version: 1.0
In-Reply-To: <1543851204-41186-20-git-send-email-pbonzini@redhat.com>
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.14
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.48]);
	Fri, 07 Dec 2018 15:38:34 +0000 (UTC)
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 209.132.183.28
Subject: Re: [Qemu-devel] [PATCH 19/71] tests: qgraph API for the qtest
 driver framework
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Emanuele Giuseppe Esposito <e.emanuelegiuseppe@gmail.com>,
	Laurent Vivier <laurent@vivier.eu>
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On 2018-12-03 16:32, Paolo Bonzini wrote:
> From: Emanuele Giuseppe Esposito <e.emanuelegiuseppe@gmail.com>
>=20
> Add qgraph API that allows to add/remove nodes and edges from the graph=
,
> implementation of Depth First Search to discover the paths and basic un=
it
> test to check correctness of the API.
> Included also a main executable that takes care of starting the framewo=
rk,
> create the nodes, set the available drivers/machines, discover the path=
 and
> run tests.
>=20
> graph.h provides the public API to manage the graph nodes/edges
> graph_extra.h provides a more private API used successively by the gtes=
t integration part
> qos-test.c provides the main executable
>=20
> Signed-off-by: Emanuele Giuseppe Esposito <e.emanuelegiuseppe@gmail.com=
>
> [Paolo's changes compared to the Google Summer of Code submission:
>  * added subprocess to test options
>  * refactored object creation to support live migration tests
>  * removed driver .before callback (unused)
>  * removed test .after callbacks (replaced by GTest destruction queue)]
[...]
> diff --git a/tests/libqos/qgraph.c b/tests/libqos/qgraph.c
> new file mode 100644
> index 0000000..03783f5
> --- /dev/null
> +++ b/tests/libqos/qgraph.c
> @@ -0,0 +1,760 @@
> +/*
> + * libqos driver framework
> + *
> + * Copyright (c) 2018 Emanuele Giuseppe Esposito <e.emanuelegiuseppe@g=
mail.com>
> + *
> + * This library is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU Lesser General Public
> + * License version 2 as published by the Free Software Foundation.
> + *
> + * This library is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> + * Lesser General Public License for more details.
> + *
> + * You should have received a copy of the GNU Lesser General Public
> + * License along with this library; if not, see <http://www.gnu.org/li=
censes/>
> + */
> +
> +#include "qemu/osdep.h"
> +#include "libqtest.h"
> +#include "qemu/queue.h"
> +#include "libqos/qgraph_internal.h"
> +#include "libqos/qgraph.h"
> +
> +#define QGRAPH_PRINT_DEBUG 0
> +#define QOS_ROOT ""
> +typedef struct QOSStackElement QOSStackElement;
> +
> +/* Graph Edge.*/
> +struct QOSGraphEdge {
> +    QOSEdgeType type;
> +    char *dest;
> +    void *arg;                /* just for QEDGE_CONTAINS
> +                               * and QEDGE_CONSUMED_BY */
> +    char *extra_device_opts;  /* added to -device option, "," is
> +                               * automatically added
> +                               */
> +    char *before_cmd_line;    /* added before node cmd_line */
> +    char *after_cmd_line;     /* added after -device options */
> +    char *edge_name;          /* used by QEDGE_CONTAINS */
> +    QSLIST_ENTRY(QOSGraphEdge) edge_list;
> +};
> +
> +/* Linked list grouping all edges with the same source node */
> +QSLIST_HEAD(QOSGraphEdgeList, QOSGraphEdge);
> +
> +
> +/**
> + * Stack used to keep track of the discovered path when using
> + * the DFS algorithm
> + */
> +struct QOSStackElement {
> +    QOSGraphNode *node;
> +    QOSStackElement *parent;
> +    QOSGraphEdge *parent_edge;
> +    int length;
> +};
> +
> +/* Each enty in these hash table will consist of <string, node/edge> p=
air. */
> +static GHashTable *edge_table;
> +static GHashTable *node_table;
> +
> +/* stack used by the DFS algorithm to store the path from machine to t=
est */
> +static QOSStackElement qos_node_stack[QOS_PATH_MAX_ELEMENT_SIZE];
> +static int qos_node_tos;
> +
> +/**
> + * add_edge(): creates an edge of type @type
> + * from @source to @dest node, and inserts it in the
> + * edges hash table
> + *
> + * Nodes @source and @dest do not necessarily need to exist.
> + * Possibility to add also options (see #QOSGraphEdgeOptions)
> + * edge->edge_name is used as identifier for get_device relationships,
> + * so by default is equal to @dest.
> + */
> +static void add_edge(const char *source, const char *dest,
> +                     QOSEdgeType type, QOSGraphEdgeOptions *opts)
> +{
> +    char *key;
> +    QOSGraphEdgeList *list =3D g_hash_table_lookup(edge_table, source)=
;
> +
> +    if (!list) {
> +        list =3D g_new0(QOSGraphEdgeList, 1);
> +        key =3D g_strdup(source);
> +        g_hash_table_insert(edge_table, key, list);
> +    }
> +
> +    if (!opts) {
> +        opts =3D &(QOSGraphEdgeOptions) { };
> +    }
> +
> +    QOSGraphEdge *edge =3D g_new0(QOSGraphEdge, 1);
> +    edge->type =3D type;
> +    edge->dest =3D g_strdup(dest);
> +    edge->edge_name =3D g_strdup(opts->edge_name ? : dest);
> +    edge->arg =3D g_memdup(opts->arg, opts->size_arg);
> +
> +    edge->before_cmd_line =3D
> +        opts->before_cmd_line ? g_strconcat(" ", opts->before_cmd_line=
, NULL) : NULL;
> +    edge->extra_device_opts =3D
> +        opts->extra_device_opts ? g_strconcat(",", opts->extra_device_=
opts, NULL) : NULL;
> +    edge->after_cmd_line =3D
> +        opts->after_cmd_line ? g_strconcat(" ", opts->after_cmd_line, =
NULL) : NULL;
> +
> +    QSLIST_INSERT_HEAD(list, edge, edge_list);
> +}
> +
> +/* destroy_edges(): frees all edges inside a given @list */
> +static void destroy_edges(void *list)
> +{
> +    QOSGraphEdge *temp;
> +    QOSGraphEdgeList *elist =3D list;
> +
> +    while (!QSLIST_EMPTY(elist)) {
> +        temp =3D QSLIST_FIRST(elist);
> +        QSLIST_REMOVE_HEAD(elist, edge_list);
> +        g_free(temp->dest);
> +        g_free(temp->before_cmd_line);
> +        g_free(temp->after_cmd_line);
> +        g_free(temp->extra_device_opts);
> +        g_free(temp->edge_name);
> +        g_free(temp->arg);
> +        g_free(temp);
> +    }
> +    g_free(elist);
> +}
> +
> +/**
> + * create_node(): creates a node @name of type @type
> + * and inserts it to the nodes hash table.
> + * By default, node is not available.
> + */
> +static QOSGraphNode *create_node(const char *name, QOSNodeType type)
> +{
> +    if (g_hash_table_lookup(node_table, name)) {
> +        g_printerr("Node %s already created\n", name);
> +        abort();
> +    }
> +
> +    QOSGraphNode *node =3D g_new0(QOSGraphNode, 1);
> +    node->type =3D type;
> +    node->available =3D FALSE;
> +    node->name =3D g_strdup(name);
> +    g_hash_table_insert(node_table, node->name, node);
> +    return node;
> +}
> +
> +/**
> + * destroy_node(): frees a node @val from the nodes hash table.
> + * Note that node->name is not free'd since it will represent the
> + * hash table key
> + */
> +static void destroy_node(void *val)
> +{
> +    QOSGraphNode *node =3D val;
> +    g_free(node->command_line);
> +    g_free(node);
> +}
> +
> +/**
> + * destroy_string(): frees @key from the nodes hash table.
> + * Actually frees the node->name
> + */
> +static void destroy_string(void *key)
> +{
> +    g_free(key);
> +}
> +
> +/**
> + * search_node(): search for a node @key in the nodes hash table
> + * Returns the QOSGraphNode if found, #NULL otherwise
> + */
> +static QOSGraphNode *search_node(const char *key)
> +{
> +    return g_hash_table_lookup(node_table, key);
> +}
> +
> +/**
> + * get_edgelist(): returns the edge list (value) assigned to
> + * the @key in the edge hash table.
> + * This list will contain all edges with source equal to @key
> + *
> + * Returns: on success: the %QOSGraphEdgeList
> + *          otherwise: abort()
> + */
> +static QOSGraphEdgeList *get_edgelist(const char *key)
> +{
> +    return g_hash_table_lookup(edge_table, key);
> +}
> +
> +/**
> + * search_list_edges(): search for an edge with destination @dest
> + * in the given @edgelist.
> + *
> + * Returns: on success: the %QOSGraphEdge
> + *          otherwise: #NULL
> + */
> +static QOSGraphEdge *search_list_edges(QOSGraphEdgeList *edgelist,
> +                                       const char *dest)
> +{
> +    QOSGraphEdge *tmp, *next;
> +    if (!edgelist) {
> +        return NULL;
> +    }
> +    QSLIST_FOREACH_SAFE(tmp, edgelist, edge_list, next) {
> +        if (g_strcmp0(tmp->dest, dest) =3D=3D 0) {
> +            break;
> +        }
> +    }
> +    return tmp;
> +}
> +
> +/**
> + * search_machine(): search for a machine @name in the node hash
> + * table. A machine is the child of the root node.
> + * This function forces the research in the childs of the root,
> + * to check the node is a proper machine
> + *
> + * Returns: on success: the %QOSGraphNode
> + *          otherwise: #NULL
> + */
> +static QOSGraphNode *search_machine(const char *name)
> +{
> +    QOSGraphNode *n;
> +    QOSGraphEdgeList *root_list =3D get_edgelist(QOS_ROOT);
> +    QOSGraphEdge *e =3D search_list_edges(root_list, name);
> +    if (!e) {
> +        return NULL;
> +    }
> +    n =3D search_node(e->dest);
> +    if (n->type =3D=3D QNODE_MACHINE) {
> +        return n;
> +    }
> +    return NULL;
> +}
> +
> +/**
> + * create_interface(): checks if there is already
> + * a node @node in the node hash table, if not
> + * creates a node @node of type #QNODE_INTERFACE
> + * and inserts it. If there is one, check it's
> + * a #QNODE_INTERFACE and abort() if it's not.
> + */
> +static void create_interface(const char *node)
> +{
> +    QOSGraphNode *interface;
> +    interface =3D search_node(node);
> +    if (!interface) {
> +        create_node(node, QNODE_INTERFACE);
> +    } else if (interface->type !=3D QNODE_INTERFACE) {
> +        printf("Error: Node %s is not an interface\n", node);

fprintf to stderr? Or g_printerr() ?

> +        abort();
> +    }
> +}
> +
> +/**
> + * build_machine_cmd_line(): builds the command line for the machine
> + * @node. The node name must be a valid qemu identifier, since it
> + * will be used to build the command line.
> + *
> + * It is also possible to pass an optional @args that will be
> + * concatenated to the command line.
> + *
> + * For machines, prepend -M to the machine name. ", @rgs" is added
> + * after the -M <machine> command.
> + */
> +static void build_machine_cmd_line(QOSGraphNode *node, const char *arg=
s)
> +{
> +    char *arch, *machine;
> +    qos_separate_arch_machine(node->name, &arch, &machine);
> +    if (args) {
> +        node->command_line =3D g_strconcat("-M ", machine, ",", args, =
NULL);
> +    } else {
> +        node->command_line =3D g_strconcat("-M ", machine, " ", NULL);
> +    }
> +}
> +
> +/**
> + * build_driver_cmd_line(): builds the command line for the driver
> + * @node. The node name must be a valid qemu identifier, since it
> + * will be used to build the command line.
> + *
> + * Driver do not need additional command line, since it will be
> + * provided by the edge options.
> + *
> + * For drivers, prepend -device to the node name.
> + */
> +static void build_driver_cmd_line(QOSGraphNode *node)
> +{
> +    node->command_line =3D g_strconcat(" -device ", node->name, NULL);
> +}
> +
> +/* qos_print_cb(): callback prints all path found by the DFS algorithm=
. */
> +static void qos_print_cb(QOSGraphNode *path, int length)
> +{
> +    #if QGRAPH_PRINT_DEBUG
> +        printf("%d elements\n", length);
> +
> +        if (!path) {
> +            return;
> +        }
> +
> +        while (path->path_edge) {
> +            printf("%s ", path->name);
> +            switch (path->path_edge->type) {
> +            case QEDGE_PRODUCES:
> +                printf("--PRODUCES--> ");
> +                break;
> +            case QEDGE_CONSUMED_BY:
> +                printf("--CONSUMED_BY--> ");
> +                break;
> +            case QEDGE_CONTAINS:
> +                printf("--CONTAINS--> ");
> +                break;
> +            }
> +            path =3D search_node(path->path_edge->dest);
> +        }
> +
> +        printf("%s\n\n", path->name);
> +    #endif
> +}
> +
> +/* qos_push(): push a node @el and edge @e in the qos_node_stack */
> +static void qos_push(QOSGraphNode *el, QOSStackElement *parent,
> +                     QOSGraphEdge *e)
> +{
> +    int len =3D 0; /* root is not counted */
> +    if (qos_node_tos =3D=3D QOS_PATH_MAX_ELEMENT_SIZE) {
> +        g_printerr("QOSStack: full stack, cannot push");
> +        abort();
> +    }
> +
> +    if (parent) {
> +        len =3D parent->length + 1;
> +    }
> +    qos_node_stack[qos_node_tos++] =3D (QOSStackElement) {
> +        .node =3D el,
> +        .parent =3D parent,
> +        .parent_edge =3D e,
> +        .length =3D len,
> +    };
> +}
> +
> +/* qos_tos(): returns the top of stack, without popping */
> +static QOSStackElement *qos_tos(void)
> +{
> +    return &qos_node_stack[(qos_node_tos - 1)];

No need for the round brackets here.

> +}
> +
> +/* qos_pop(): pops an element from the tos, setting it unvisited*/
> +static QOSStackElement *qos_pop(void)
> +{
> +    if (qos_node_tos =3D=3D 0) {
> +        g_printerr("QOSStack: empty stack, cannot pop");
> +        abort();
> +    }
> +    QOSStackElement *e =3D qos_tos();
> +    e->node->visited =3D FALSE;
> +    qos_node_tos--;
> +    return e;
> +}
> +
> +/**
> + * qos_reverse_path(): reverses the found path, going from
> + * test-to-machine to machine-to-test
> + */
> +static QOSGraphNode *qos_reverse_path(QOSStackElement *el)
> +{
> +    if (!el) {
> +        return NULL;
> +    }
> +
> +    el->node->path_edge =3D NULL;
> +
> +    while (el->parent) {
> +        el->parent->node->path_edge =3D el->parent_edge;
> +        el =3D el->parent;
> +    }
> +
> +    return el->node;
> +}
> +
> +/**
> + * qos_traverse_graph(): graph-walking algorithm, using Depth First Se=
arch it
> + * starts from the root @machine and walks all possible path until it
> + * reaches a test node.
> + * At that point, it reverses the path found and invokes the @callback=
.
> + *
> + * Being Depth First Search, time complexity is O(|V| + |E|), while
> + * space is O(|V|). In this case, the maximum stack size is set by
> + * QOS_PATH_MAX_ELEMENT_SIZE.
> + */
> +static void qos_traverse_graph(QOSGraphNode *root, QOSTestCallback cal=
lback)
> +{
> +    QOSGraphNode *v, *dest_node, *path;
> +    QOSStackElement *s_el;
> +    QOSGraphEdge *e, *next;
> +    QOSGraphEdgeList *list;
> +
> +    qos_push(root, NULL, NULL);
> +
> +    while (qos_node_tos > 0) {
> +        s_el =3D qos_tos();
> +        v =3D s_el->node;
> +        if (v->visited) {
> +            qos_pop();
> +            continue;
> +        }
> +        v->visited =3D TRUE;
> +        list =3D get_edgelist(v->name);
> +        if (!list) {
> +            qos_pop();
> +            if (v->type =3D=3D QNODE_TEST) {
> +                v->visited =3D FALSE;
> +                path =3D qos_reverse_path(s_el);
> +                callback(path, s_el->length);
> +            }
> +        } else {
> +            QSLIST_FOREACH_SAFE(e, list, edge_list, next) {
> +                dest_node =3D search_node(e->dest);
> +
> +                if (!dest_node) {
> +                    printf("node %s in %s -> %s does not exist\n",
> +                            e->dest, v->name, e->dest);

fprintf to stderr? Or g_printerr() ?

> +                    abort();
> +                }
> +
> +                if (!dest_node->visited && dest_node->available) {
> +                    qos_push(dest_node, s_el, e);
> +                }
> +            }
> +        }
> +    }
> +}
> +
> +/* QGRAPH API*/
> +
> +QOSGraphNode *qos_graph_get_node(const char *key)
> +{
> +    return search_node(key);
> +}
> +
> +bool qos_graph_has_node(const char *node)
> +{
> +    QOSGraphNode *n =3D search_node(node);
> +    return n !=3D NULL;
> +}
> +
> +QOSNodeType qos_graph_get_node_type(const char *node)
> +{
> +    QOSGraphNode *n =3D search_node(node);
> +    if (n) {
> +        return n->type;
> +    }
> +    return -1;
> +}
> +
> +bool qos_graph_get_node_availability(const char *node)
> +{
> +    QOSGraphNode *n =3D search_node(node);
> +    if (n) {
> +        return n->available;
> +    }
> +    return FALSE;
> +}
> +
> +QOSGraphEdge *qos_graph_get_edge(const char *node, const char *dest)
> +{
> +    QOSGraphEdgeList *list =3D get_edgelist(node);
> +    return search_list_edges(list, dest);
> +}
> +
> +QOSEdgeType qos_graph_edge_get_type(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return -1;
> +    }
> +    return edge->type;;
> +}
> +
> +char *qos_graph_edge_get_dest(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return NULL;
> +    }
> +    return edge->dest;
> +}
> +
> +void *qos_graph_edge_get_arg(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return NULL;
> +    }
> +    return edge->arg;
> +}
> +
> +char *qos_graph_edge_get_after_cmd_line(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return NULL;
> +    }
> +    return edge->after_cmd_line;
> +}
> +
> +char *qos_graph_edge_get_before_cmd_line(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return NULL;
> +    }
> +    return edge->before_cmd_line;
> +}
> +
> +char *qos_graph_edge_get_extra_device_opts(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return NULL;
> +    }
> +    return edge->extra_device_opts;
> +}
> +
> +char *qos_graph_edge_get_name(QOSGraphEdge *edge)
> +{
> +    if (!edge) {
> +        return NULL;
> +    }
> +    return edge->edge_name;
> +}
> +
> +bool qos_graph_has_edge(const char *start, const char *dest)
> +{
> +    QOSGraphEdgeList *list =3D get_edgelist(start);
> +    QOSGraphEdge *e =3D search_list_edges(list, dest);
> +    if (e) {
> +        return TRUE;
> +    }
> +    return FALSE;
> +}
> +
> +QOSGraphNode *qos_graph_get_machine(const char *node)
> +{
> +    return search_machine(node);
> +}
> +
> +bool qos_graph_has_machine(const char *node)
> +{
> +    QOSGraphNode *m =3D search_machine(node);
> +    return m !=3D NULL;
> +}
> +
> +void qos_print_graph(void)
> +{
> +    qos_graph_foreach_test_path(qos_print_cb);
> +}
> +
> +void qos_graph_init(void)
> +{
> +    if (!node_table) {
> +        node_table =3D g_hash_table_new_full(g_str_hash, g_str_equal,
> +                                           destroy_string, destroy_nod=
e);
> +        create_node(QOS_ROOT, QNODE_DRIVER);
> +    }
> +
> +    if (!edge_table) {
> +        edge_table =3D g_hash_table_new_full(g_str_hash, g_str_equal,
> +                                           destroy_string, destroy_edg=
es);
> +    }
> +}
> +
> +void qos_graph_destroy(void)
> +{
> +    if (node_table) {
> +        g_hash_table_destroy(node_table);
> +    }
> +
> +    if (edge_table) {
> +        g_hash_table_destroy(edge_table);
> +    }
> +
> +    node_table =3D NULL;
> +    edge_table =3D NULL;
> +}
> +
> +void qos_node_destroy(void *key)
> +{
> +    g_hash_table_remove(node_table, key);
> +}
> +
> +void qos_edge_destroy(void *key)
> +{
> +    g_hash_table_remove(edge_table, key);
> +}
> +
> +void qos_add_test(const char *name, const char *interface,
> +                  QOSTestFunc test_func, QOSGraphTestOptions *opts)
> +{
> +    QOSGraphNode *node;
> +    char *test_name =3D g_strdup_printf("%s-tests/%s", interface, name=
);;
> +
> +    if (!opts) {
> +        opts =3D &(QOSGraphTestOptions) { };
> +    }
> +    node =3D create_node(test_name, QNODE_TEST);
> +    node->u.test.function =3D test_func;
> +    node->u.test.arg =3D opts->arg;
> +    assert(!opts->edge.arg);
> +    assert(!opts->edge.size_arg);
> +
> +    node->u.test.before =3D opts->before;
> +    node->u.test.subprocess =3D opts->subprocess;
> +    node->available =3D TRUE;
> +    add_edge(interface, test_name, QEDGE_CONSUMED_BY, &opts->edge);
> +    g_free(test_name);
> +}
> +
> +void qos_node_create_machine(const char *name, QOSCreateMachineFunc fu=
nction)
> +{
> +    qos_node_create_machine_args(name, function, NULL);
> +}
> +
> +void qos_node_create_machine_args(const char *name,
> +                                  QOSCreateMachineFunc function,
> +                                  const char *opts)
> +{
> +    QOSGraphNode *node =3D create_node(name, QNODE_MACHINE);
> +    build_machine_cmd_line(node, opts);
> +    node->u.machine.constructor =3D function;
> +    add_edge(QOS_ROOT, name, QEDGE_CONTAINS, NULL);
> +}
> +
> +void qos_node_create_driver(const char *name, QOSCreateDriverFunc func=
tion)
> +{
> +    QOSGraphNode *node =3D create_node(name, QNODE_DRIVER);
> +    build_driver_cmd_line(node);
> +    node->u.driver.constructor =3D function;
> +}
> +
> +void qos_node_contains(const char *container, const char *contained,
> +                       ...)
> +{
> +    va_list va;
> +    va_start(va, contained);
> +    QOSGraphEdgeOptions *opts;
> +
> +    do {
> +        opts =3D va_arg(va, QOSGraphEdgeOptions *);
> +        add_edge(container, contained, QEDGE_CONTAINS, opts);
> +    } while (opts !=3D NULL);
> +
> +    va_end(va);
> +}
> +
> +void qos_node_produces(const char *producer, const char *interface)
> +{
> +    create_interface(interface);
> +    add_edge(producer, interface, QEDGE_PRODUCES, NULL);
> +}
> +
> +void qos_node_consumes(const char *consumer, const char *interface,
> +                       QOSGraphEdgeOptions *opts)
> +{
> +    create_interface(interface);
> +    add_edge(interface, consumer, QEDGE_CONSUMED_BY, opts);
> +}
> +
> +void qos_graph_node_set_availability(const char *node, bool av)
> +{
> +    QOSGraphEdgeList *elist;
> +    QOSGraphNode *n =3D search_node(node);
> +    QOSGraphEdge *e, *next;
> +    if (!n) {
> +        return;
> +    }
> +    n->available =3D av;
> +    elist =3D get_edgelist(node);
> +    if (!elist) {
> +        return;
> +    }
> +    QSLIST_FOREACH_SAFE(e, elist, edge_list, next) {
> +        if (e->type =3D=3D QEDGE_CONTAINS || e->type =3D=3D QEDGE_PROD=
UCES) {
> +            qos_graph_node_set_availability(e->dest, av);
> +        }
> +    }
> +}
> +
> +void qos_graph_foreach_test_path(QOSTestCallback fn)
> +{
> +    QOSGraphNode *root =3D qos_graph_get_node(QOS_ROOT);
> +    qos_traverse_graph(root, fn);
> +}
> +
> +QOSGraphObject *qos_machine_new(QOSGraphNode *node, QTestState *qts)
> +{
> +    QOSGraphObject *obj;
> +
> +    g_assert(node->type =3D=3D QNODE_MACHINE);
> +    obj =3D node->u.machine.constructor(qts);
> +    obj->free =3D g_free;
> +    return obj;
> +}
> +
> +QOSGraphObject *qos_driver_new(QOSGraphNode *node, QOSGraphObject *par=
ent,
> +                               QGuestAllocator *alloc, void *arg)
> +{
> +    QOSGraphObject *obj;
> +
> +    g_assert(node->type =3D=3D QNODE_DRIVER);
> +    obj =3D node->u.driver.constructor(parent, alloc, arg);
> +    obj->free =3D g_free;
> +    return obj;
> +}
> +
> +void qos_object_destroy(QOSGraphObject *obj)
> +{
> +    if (!obj) {
> +        return;
> +    }
> +    if (obj->destructor) {
> +        obj->destructor(obj);
> +    }
> +    if (obj->free) {
> +        obj->free(obj);
> +    }
> +}
> +
> +void qos_object_queue_destroy(QOSGraphObject *obj)
> +{
> +    g_test_queue_destroy((GDestroyNotify) qos_object_destroy, obj);
> +}
> +
> +void qos_object_start_hw(QOSGraphObject *obj)
> +{
> +    if (obj->start_hw) {
> +        obj->start_hw(obj);
> +    }
> +}
> +
> +void qos_separate_arch_machine(char *name, char **arch, char **machine=
)
> +{
> +    *arch =3D name;
> +    while (*name !=3D '\0' && *name !=3D '/') {
> +        name++;
> +    }
> +
> +    if (*name =3D=3D '/' && (*name + 1) !=3D '\0') {

Shouldn't that rather be *(name + 1) instead? Or rather use name[1] ?

> +        *machine =3D name + 1;
> +    } else {
> +        printf("Machine name has to be of the form <arch>/<machine>\n"=
);

fprintf to stderr? Or g_printerr()?

> +        abort();
> +    }
> +}
> +
> +void qos_delete_abstract_cmd_line(const char *name, bool abstract)
> +{
> +    QOSGraphNode *node =3D search_node(name);
> +    if (node && abstract) {
> +        g_free(node->command_line);
> +        node->command_line =3D NULL;
> +    }
> +}
> diff --git a/tests/libqos/qgraph.h b/tests/libqos/qgraph.h
> new file mode 100644
> index 0000000..6ebb2e6
> --- /dev/null
> +++ b/tests/libqos/qgraph.h
> @@ -0,0 +1,575 @@
> +/*
> + * libqos driver framework
> + *
> + * Copyright (c) 2018 Emanuele Giuseppe Esposito <e.emanuelegiuseppe@g=
mail.com>
> + *
> + * This library is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU Lesser General Public
> + * License version 2 as published by the Free Software Foundation.
> + *
> + * This library is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> + * Lesser General Public License for more details.
> + *
> + * You should have received a copy of the GNU Lesser General Public
> + * License along with this library; if not, see <http://www.gnu.org/li=
censes/>
> + */
> +
> +#ifndef QGRAPH_H
> +#define QGRAPH_H
> +
> +#include <stdio.h>
> +#include <stdlib.h>
> +#include <stdbool.h>
> +#include <gmodule.h>
> +#include <glib.h>
> +#include "qemu/module.h"
> +#include "malloc.h"
> +
> +/* maximum path length */
> +#define QOS_PATH_MAX_ELEMENT_SIZE 50
> +
> +typedef struct QOSGraphObject QOSGraphObject;
> +typedef struct QOSGraphNode QOSGraphNode;
> +typedef struct QOSGraphEdge QOSGraphEdge;
> +typedef struct QOSGraphNodeOptions QOSGraphNodeOptions;
> +typedef struct QOSGraphEdgeOptions QOSGraphEdgeOptions;
> +typedef struct QOSGraphTestOptions QOSGraphTestOptions;
> +
> +/* Constructor for drivers, machines and test */
> +typedef void *(*QOSCreateDriverFunc) (void *parent, QGuestAllocator *a=
lloc,
> +                                      void *addr);
> +typedef void *(*QOSCreateMachineFunc) (QTestState *qts);
> +typedef void (*QOSTestFunc) (void *parent, void *arg, QGuestAllocator =
*alloc);
> +
> +/* QOSGraphObject functions */
> +typedef void *(*QOSGetDriver) (void *object, const char *interface);
> +typedef QOSGraphObject *(*QOSGetDevice) (void *object, const char *nam=
e);
> +typedef void (*QOSDestructorFunc) (QOSGraphObject *object);
> +typedef void (*QOSStartFunct) (QOSGraphObject *object);
> +
> +/* Test options functions */
> +typedef void *(*QOSBeforeTest) (GString *cmd_line, void *arg);
> +
> +/**
> + * SECTION: qgraph.h
> + * @title: Qtest Driver Framework
> + * @short_description: interfaces to organize drivers and tests
> + *                     as nodes in a graph
> + *
> + * This Qgraph API provides all basic functions to create a graph
> + * and instantiate nodes representing machines, drivers and tests
> + * representing their relations with CONSUMES, PRODUCES, and CONTAINS
> + * edges.
> + *
> + * The idea is to have a framework where each test asks for a specific
> + * driver, and the framework takes care of allocating the proper devic=
es
> + * required and passing the correct command line arguments to QEMU.
> + *
> + * A node can be of four types:
> + * - QNODE_MACHINE:   for example "arm/raspi2"
> + * - QNODE_DRIVER:    for example "generic-sdhci"
> + * - QNODE_INTERFACE: for example "sdhci" (interface for all "-sdhci" =
drivers)
> + *                     an interface is not explicitly created, it will=
 be auto-
> + *                     matically instantiated when a node consumes or =
produces
> + *                     it.
> + * - QNODE_TEST:      for example "sdhci-test", consumes an interface =
and tests
> + *                    the functions provided
> + *
> + * Notes for the nodes:
> + * - QNODE_MACHINE: each machine struct must have a QGuestAllocator an=
d
> + *                  implement get_driver to return the allocator passi=
ng
> + *                  "memory". The function can also return NULL if the
> + *                  allocator is not set.
> + * - QNODE_DRIVER:  driver names must be unique, and machines and node=
s
> + *                  planned to be "consumed" by other nodes must match=
 QEMU
> + *                  drivers name, otherwise they won't be discovered
> + *
> + * An edge relation between two nodes (drivers or machines) X and Y ca=
n be:
> + * - X CONSUMES Y: Y can be plugged into X
> + * - X PRODUCES Y: X provides the interface Y
> + * - X CONTAINS Y: Y is part of X component
> + *
> + * Basic framework steps are the following:
> + * - All nodes and edges are created in their respective
> + *   machine/driver/test files
> + * - The framework starts QEMU and asks for a list of available device=
s
> + *   and machines (note that only machines and "consumed" nodes are ma=
pped
> + *   1:1 with QEMU devices)
> + * - The framework walks the graph starting from the available machine=
s and
> + *   performs a Depth First Search for tests
> + * - Once a test is found, the path is walked again and all drivers ar=
e
> + *   allocated accordingly and the final interface is passed to the te=
st
> + * - The test is executed
> + * - Unused objects are cleaned and the path discovery is continued
> + *
> + * Depending on the QEMU binary used, only some drivers/machines will =
be
> + * available and only test that are reached by them will be executed.
> + *
> + * <example>
> + *   <title>Creating new driver an its interface</title>
> + *   <programlisting>
> + #include "libqos/qgraph.h"
> +
> + struct My_driver {
> +     QOSGraphObject obj;
> +     Node_produced prod;
> +     Node_contained cont;
> + }
> +
> + static void my_destructor(QOSGraphObject *obj)
> + {
> +    g_free(obj);
> + }
> +
> + static void my_get_driver(void *object, const char *interface) {
> +    My_driver *dev =3D object;
> +    if (!g_strcmp0(interface, "my_interface")) {
> +        return &dev->prod;
> +    }
> +    abort();
> + }

I'd rather write that as:

   My_driver *dev =3D object;
   g_assert(g_str_equal((interface, "my_interface"));
   return &dev->prod;

> + static void my_get_device(void *object, const char *device) {
> +    My_driver *dev =3D object;
> +    if (!g_strcmp0(device, "my_driver_contained")) {
> +        return &dev->cont;
> +    }
> +    abort();
> + }

dito.


> + static void *my_driver_constructor(void *node_consumed,
> +                                    QOSGraphObject *alloc)
> + {
> +    My_driver dev =3D g_new(My_driver, 1);
> +    // get the node pointed by the produce edge
> +    dev->obj.get_driver =3D my_get_driver;
> +    // get the node pointed by the contains
> +    dev->obj.get_device =3D my_get_device;
> +    // free the object
> +    dev->obj.destructor =3D my_destructor;
> +    do_something_with_node_consumed(node_consumed);
> +    // set all fields of contained device
> +    init_contained_device(&dev->cont);
> +    return &dev->obj;
> + }
> +
> + static void register_my_driver(void)
> + {
> +     qos_node_create_driver("my_driver", my_driver_constructor);
> +     // contained drivers don't need a constructor,
> +     // they will be init by the parent.
> +     qos_node_create_driver("my_driver_contained", NULL);
> +
> +    // For the sake of this example, assume machine x86_64/pc contains
> +    // "other_node".
> +    // This relation, along with the machine and "other_node" creation=
,
> +    // should be defined in the x86_64_pc-machine.c file.
> +    // "my_driver" will then consume "other_node"
> +    qos_node_contains("my_driver", "my_driver_contained");
> +    qos_node_produces("my_driver", "my_interface");
> +    qos_node_consumes("my_driver", "other_node");
> + }
> + *   </programlisting>
> + * </example>
> + *
> + * In the above example, all possible types of relations are created:
> + * node "my_driver" consumes, contains and produces other nodes.
> + * more specifically:
> + * x86_64/pc -->contains--> other_node <--consumes-- my_driver
> + *                                                       |
> + *                      my_driver_contained <--contains--+
> + *                                                       |
> + *                             my_interface <--produces--+
> + *
> + * or inverting the consumes edge in consumed_by:
> + *
> + * x86_64/pc -->contains--> other_node --consumed_by--> my_driver
> + *                                                           |
> + *                          my_driver_contained <--contains--+
> + *                                                           |
> + *                                 my_interface <--produces--+
> + *
> + * <example>
> + *   <title>Creating new test</title>
> + *   <programlisting>
> + * #include "libqos/qgraph.h"
> + *
> + * static void my_test_function(void *obj, void *data)
> + * {
> + *    Node_produced *interface_to_test =3D obj;
> + *    // test interface_to_test
> + * }
> + *
> + * static void register_my_test(void)
> + * {
> + *    qos_add_test("my_interface", "my_test", my_test_function);
> + * }
> + *
> + * libqos_init(register_my_test);
> + *
> + *   </programlisting>
> + * </example>
> + *
> + * Here a new test is created, consuming "my_interface" node
> + * and creating a valid path from a machine to a test.
> + * Final graph will be like this:
> + * x86_64/pc -->contains--> other_node <--consumes-- my_driver
> + *                                                        |
> + *                       my_driver_contained <--contains--+
> + *                                                        |
> + *        my_test --consumes--> my_interface <--produces--+
> + *
> + * or inverting the consumes edge in consumed_by:
> + *
> + * x86_64/pc -->contains--> other_node --consumed_by--> my_driver
> + *                                                           |
> + *                          my_driver_contained <--contains--+
> + *                                                           |
> + *        my_test <--consumed_by-- my_interface <--produces--+
> + *
> + * Assuming there the binary is
> + * QTEST_QEMU_BINARY=3Dx86_64-softmmu/qemu-system-x86_64
> + * a valid test path will be:
> + * "/x86_64/pc/other_node/my_driver/my_interface/my_test".
> + *
> + * Additional examples are also in libqos/test-qgraph.c
> + *
> + * Command line:
> + * Command line is built by using node names and optional arguments
> + * passed by the user when building the edges.
> + *
> + * There are three types of command line arguments:
> + * - in node      : created from the node name. For example, machines =
will
> + *                  have "-M <machine>" to its command line, while dev=
ices
> + *                  "- device <device>". It is automatically done by t=
he

s/- device/-device/


> + *                   framework.
> + * - after node   : added as additional argument to the node name.
> + *                  This argument is added optionally when creating ed=
ges,
> + *                  by setting the parameter @after_cmd_line and
> + *                  @extra_edge_opts in #QOSGraphEdgeOptions.
> + *                  The framework automatically adds
> + *                  a comma before @extra_edge_opts,
> + *                  because it is going to add attibutes
> + *                  after the destination node pointed by
> + *                  the edge containing these options, and automatical=
ly
> + *                  adds a space before @after_cmd_line, because it
> + *                  adds an additional device, not an attribute.
> + * - before node  : added as additional argument to the node name.
> + *                  This argument is added optionally when creating ed=
ges,
> + *                  by setting the parameter @before_cmd_line in
> + *                  #QOSGraphEdgeOptions. This attribute
> + *                  is going to add attibutes before the destination n=
ode
> + *                  pointed by the edge containing these options. It i=
s
> + *                  helpful to commands that are not node-representabl=
e,
> + *                  such as "-fdsev" or "-netdev".
> + *
> + * While adding command line in edges is always used, not all nodes na=
mes are
> + * used in every path walk: this is because the contained or produced =
ones
> + * are already added by QEMU, so only nodes that "consumes" will be us=
ed to
> + * build the command line. Also, nodes that will have { "abstract" : t=
rue }
> + * as QMP attribute will loose their command line, since they are not =
proper
> + * devices to be added in QEMU.
> + *
> + * Example:
> + *
> + QOSGraphEdgeOptions opts =3D {
> +     .arg =3D NULL,
> +     .size_arg =3D 0,
> +     .after_cmd_line =3D "-device other",
> +     .before_cmd_line =3D "-netdev something",
> +     .extra_edge_opts =3D "addr=3D04.0",
> + };
> + QOSGraphNode * node =3D qos_node_create_driver("my_node", constructor=
);
> + qos_node_consumes_args("my_node", "interface", &opts);
> + *
> + * Will produce the following command line:
> + * "-netdev something -device my_node,addr=3D04.0 -device other"
> + */
> +
> +/**
> + * Edge options to be passed to the contains/consumes *_args function.
> + */
> +struct QOSGraphEdgeOptions {
> +    void *arg;                    /*
> +                                   * optional arg that will be used by
> +                                   * dest edge
> +                                   */
> +    uint32_t size_arg;            /*
> +                                   * optional arg size that will be us=
ed by
> +                                   * dest edge
> +                                   */
> +    const char *extra_device_opts;/*
> +                                   *optional additional command line f=
or dest
> +                                   * edge, used to add additional attr=
ibutes
> +                                   * *after* the node command line, th=
e
> +                                   * framework automatically prepends =
","
> +                                   * to this argument.
> +                                   */
> +    const char *before_cmd_line;  /*
> +                                   * optional additional command line =
for dest
> +                                   * edge, used to add additional attr=
ibutes
> +                                   * *before* the node command line, u=
sually
> +                                   * other non-node represented comman=
ds,
> +                                   * like "-fdsev synt"
> +                                   */
> +    const char *after_cmd_line;   /*
> +                                   * optional extra command line to be=
 added
> +                                   * after the device command. This op=
tion
> +                                   * is used to add other devices
> +                                   * command line that depend on curre=
nt node.
> +                                   * Automatically prepends " " to thi=
s
> +                                   * argument
> +                                   */
> +    const char *edge_name;        /*
> +                                   * optional edge to differentiate mu=
ltiple
> +                                   * devices with same node name
> +                                   */
> +};
> +
> +/**
> + * Test options to be passed to the test functions.
> + */
> +struct QOSGraphTestOptions {
> +    QOSGraphEdgeOptions edge;   /* edge arguments that will be used by=
 test.
> +                                 * Note that test *does not* use edge_=
name,
> +                                 * and uses instead arg and size_arg a=
s
> +                                 * data arg for its test function.
> +                                 */
> +    void *arg;                  /* passed to the .before function, or =
to the
> +                                 * test function if there is no .befor=
e
> +                                 * function
> +                                 */
> +    QOSBeforeTest before;       /* executed before the test. Can add
> +                                 * additional parameters to the comman=
d line
> +				 * and modify the argument to the test function.
> +                                 */
> +    bool subprocess;            /* run the test in a subprocess */
> +};
> +
> +/**
> + * Each driver, test or machine of this framework will have a
> + * QOSGraphObject as first field.
> + *
> + * This set of functions offered by QOSGraphObject are executed
> + * in different stages of the framework:
> + * - get_driver / get_device : Once a machine-to-test path has been
> + * found, the framework traverses it again and allocates all the
> + * nodes, using the provided constructor. To satisfy their relations,
> + * i.e. for produces or contains, where a struct constructor needs
> + * an external parameter represented by the previous node,
> + * the framework will call get_device (for contains) or
> + * get_driver (for produces), depending on the edge type, passing
> + * them the name of the next node to be taken and getting from them
> + * the corresponding pointer to the actual structure of the next node =
to
> + * be used in the path.
> + *
> + * - start_hw: This function is executed after all the path objects
> + * have been allocated, but before the test is run. It starts the hw, =
setting
> + * the initial configurations (*_device_enable) and making it ready fo=
r the
> + * test.
> + *
> + * - destructor: Opposite to the node constructor, destroys the object=
.
> + * This function is called after the test has been executed, and perfo=
rms
> + * a complete cleanup of each node allocated field. In case no constuc=
tor
> + * is provided, no destructor will be called.
> + *
> + */
> +struct QOSGraphObject {
> +    /* for produces edges, returns void * */
> +    QOSGetDriver get_driver;
> +    /* for contains edges, returns a QOSGraphObject * */
> +    QOSGetDevice get_device;
> +    /* start the hw, get ready for the test */
> +    QOSStartFunct start_hw;
> +    /* destroy this QOSGraphObject */
> +    QOSDestructorFunc destructor;
> +    /* free the memory associated to the QOSGraphObject and its contai=
ned
> +     * children */
> +    GDestroyNotify free;
> +};
> +
> +/**
> + * qos_graph_init(): initialize the framework, creates two hash
> + * tables: one for the nodes and another for the edges.
> + */
> +void qos_graph_init(void);
> +
> +/**
> + * qos_graph_destroy(): deallocates all the hash tables,
> + * freeing all nodes and edges.
> + */
> +void qos_graph_destroy(void);
> +
> +/**
> + * qos_node_destroy(): removes and frees a node from the,
> + * nodes hash table.
> + */
> +void qos_node_destroy(void *key);
> +
> +/**
> + * qos_edge_destroy(): removes and frees an edge from the,
> + * edges hash table.
> + */
> +void qos_edge_destroy(void *key);
> +
> +/**
> + * qos_add_test(): adds a test node @name to the nodes hash table.
> + *
> + * The test will consume a @interface node, and once the
> + * graph walking algorithm has found it, the @test_func will be
> + * executed. It also has the possibility to
> + * add an optional @opts (see %QOSGraphNodeOptions).
> + *
> + * For tests, opts->edge.arg and size_arg represent the arg to pass
> + * to @test_func
> + */
> +void qos_add_test(const char *name, const char *interface,
> +                  QOSTestFunc test_func,
> +                  QOSGraphTestOptions *opts);
> +
> +/**
> + * qos_node_create_machine(): creates the machine @name and
> + * adds it to the node hash table.
> + *
> + * This node will be of type QNODE_MACHINE and have @function
> + * as constructor
> + */
> +void qos_node_create_machine(const char *name, QOSCreateMachineFunc fu=
nction);
> +
> +/**
> + * qos_node_create_machine_args(): same as qos_node_create_machine,
> + * but with the possibility to add an optional ", @opts" after -M mach=
ine
> + * command line.
> + */
> +void qos_node_create_machine_args(const char *name,
> +                                  QOSCreateMachineFunc function,
> +                                  const char *opts);
> +
> +/**
> + * qos_node_create_driver(): creates the driver @name and
> + * adds it to the node hash table.
> + *
> + * This node will be of type QNODE_DRIVER and have @function
> + * as constructor
> + */
> +void qos_node_create_driver(const char *name, QOSCreateDriverFunc func=
tion);
> +
> +/**
> + * qos_node_contains(): creates an edge of type QEDGE_CONTAINS and
> + * adds it to the edge list mapped to @container in the
> + * edge hash table.
> + *
> + * This edge will have @container as source and @contained as destinat=
ion.
> + *
> + * It also has the possibility to add optional NULL-terminated
> + * @opts parameters (see %QOSGraphEdgeOptions)
> + *
> + * This function can be useful whrn there are multiple devices

s/whrn/when/


> + * with the same node name contained in a machine/other node
> + *
> + * For example, if "arm/raspi2" contains 2 "generic-sdhci"
> + * devices, the right commands will be:
> + * qos_node_create_machine("arm/raspi2");
> + * qos_node_create_driver("generic-sdhci", constructor);
> + * //assume rest of the fields are set NULL
> + * QOSGraphEdgeOptions op1 =3D { .edge_name =3D "emmc" };
> + * QOSGraphEdgeOptions op2 =3D { .edge_name =3D "sdcard" };
> + * qos_node_contains("arm/raspi2", "generic-sdhci", &op1, &op2, NULL);
> + *
> + * Of course this also requires that the @container's get_device funct=
ion
> + * should implement a case for "emmc" and "sdcard".
> + *
> + * For contains, op1.arg and op1.size_arg represent the arg to pass
> + * to @contained constructor to properly initialize it.
> + */
> +void qos_node_contains(const char *container, const char *contained, .=
..);
> +
> +/**
> + * qos_node_produces(): creates an edge of type QEDGE_PRODUCES and
> + * adds it to the edge list mapped to @producer in the
> + * edge hash table.
> + *
> + * This edge will have @producer as source and @interface as destinati=
on.
> + */
> +void qos_node_produces(const char *producer, const char *interface);
> +
> +/**
> + * qos_node_consumes():  creates an edge of type QEDGE_CONSUMED_BY and
> + * adds it to the edge list mapped to @interface in the
> + * edge hash table.
> + *
> + * This edge will have @interface as source and @consumer as destinati=
on.
> + * It also has the possibility to add an optional @opts
> + * (see %QOSGraphEdgeOptions)
> + */
> +void qos_node_consumes(const char *consumer, const char *interface,
> +                       QOSGraphEdgeOptions *opts);
> +
> +/**
> + * qos_invalidate_command_line(): invalidates current command line, so=
 that
> + * qgraph framework cannot try to cache the current command line and
> + * forces QEMU to restart.
> + */
> +void qos_invalidate_command_line(void);
> +
> +/**
> + * qos_get_current_command_line(): return the command line required by=
 the
> + * machine and driver objects.  This is the same string that was passe=
d to
> + * the test's "before" callback, if any.
> + */
> +const char *qos_get_current_command_line(void);
> +
> +/**
> + * qos_allocate_objects():
> + * @qts: The #QTestState that will be referred to by the machine objec=
t.
> + * @alloc: Where to store the allocator for the machine object, or %NU=
LL.
> + *
> + * Allocate driver objects for the current test
> + * path, but relative to the QTestState @qts.
> + *
> + * Returns a test object just like the one that was passed to
> + * the test function, but relative to @qts.
> + */
> +void *qos_allocate_objects(QTestState *qts, QGuestAllocator **p_alloc)=
;
> +
> +/**
> + * qos_object_destroy(): calls the destructor for @obj
> + */
> +void qos_object_destroy(QOSGraphObject *obj);
> +
> +/**
> + * qos_object_queue_destroy(): queue the destructor for @obj so that i=
t is
> + * called at the end of the test
> + */
> +void qos_object_queue_destroy(QOSGraphObject *obj);
> +
> +/**
> + * qos_object_start_hw(): calls the start_hw function for @obj
> + */
> +void qos_object_start_hw(QOSGraphObject *obj);
> +
> +/**
> + * qos_machine_new(): instantiate a new machine node
> + * @node: A machine node to be instantiated
> + * @qts: The #QTestState that will be referred to by the machine objec=
t.
> + *
> + * Returns a machine object.
> + */
> +QOSGraphObject *qos_machine_new(QOSGraphNode *node, QTestState *qts);
> +
> +/**
> + * qos_machine_new(): instantiate a new driver node
> + * @node: A driver node to be instantiated
> + * @parent: A #QOSGraphObject to be consumed by the new driver node
> + * @alloc: An allocator to be used by the new driver node.
> + * @arg: The argument for the consumed-by edge to @node.
> + *
> + * Calls the constructor for the driver object.
> + */
> +QOSGraphObject *qos_driver_new(QOSGraphNode *node, QOSGraphObject *par=
ent,
> +                               QGuestAllocator *alloc, void *arg);
> +
> +
> +#endif
> diff --git a/tests/libqos/qgraph_internal.h b/tests/libqos/qgraph_inter=
nal.h
> new file mode 100644
> index 0000000..bb4d82c
> --- /dev/null
> +++ b/tests/libqos/qgraph_internal.h
> @@ -0,0 +1,264 @@
> +/*
> + * libqos driver framework
> + *
> + * Copyright (c) 2018 Emanuele Giuseppe Esposito <e.emanuelegiuseppe@g=
mail.com>
> + *
> + * This library is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU Lesser General Public
> + * License version 2 as published by the Free Software Foundation.
> + *
> + * This library is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> + * Lesser General Public License for more details.
> + *
> + * You should have received a copy of the GNU Lesser General Public
> + * License along with this library; if not, see <http://www.gnu.org/li=
censes/>
> + */
> +
> +#ifndef QGRAPH_EXTRA_H
> +#define QGRAPH_EXTRA_H
> +
> +/* This header is declaring additional helper functions defined in
> + * libqos/qgraph.c
> + * It should not be included in tests
> + */
> +
> +#include "libqos/qgraph.h"
> +
> +typedef struct QOSGraphMachine QOSGraphMachine;
> +typedef struct QOSGraphEdgeList QOSGraphEdgeList;
> +typedef enum QOSEdgeType QOSEdgeType;
> +typedef enum QOSNodeType QOSNodeType;
> +
> +/* callback called when the walk path algorithm found a
> + * valid path
> + */
> +typedef void (*QOSTestCallback) (QOSGraphNode *path, int len);
> +
> +/* edge types*/
> +enum QOSEdgeType {
> +    QEDGE_CONTAINS,
> +    QEDGE_PRODUCES,
> +    QEDGE_CONSUMED_BY
> +};
> +
> +/* node types*/
> +enum QOSNodeType {
> +    QNODE_MACHINE,
> +    QNODE_DRIVER,
> +    QNODE_INTERFACE,
> +    QNODE_TEST
> +};
> +
> +/* Graph Node */
> +struct QOSGraphNode {
> +    QOSNodeType type;
> +    bool available;     /* set by QEMU via QMP, used during graph walk=
 */
> +    bool visited;       /* used during graph walk */
> +    char *name;         /* used to identify the node */
> +    char *command_line; /* used to start QEMU at test execution */
> +    union {
> +        struct {
> +            QOSCreateDriverFunc constructor;
> +        } driver;
> +        struct {
> +            QOSCreateMachineFunc constructor;
> +        } machine;
> +        struct {
> +            QOSTestFunc function;
> +            void *arg;
> +            QOSBeforeTest before;
> +            bool subprocess;
> +        } test;
> +    } u;
> +
> +    /**
> +     * only used when traversing the path, never rely on that except i=
n the
> +     * qos_traverse_graph callback function
> +     */
> +    QOSGraphEdge *path_edge;
> +};
> +
> +/**
> + * qos_graph_get_node(): returns the node mapped to that @key.
> + * It performs an hash map search O(1)
> + *
> + * Returns: on success: the %QOSGraphNode
> + *          otherwise: #NULL
> + */
> +QOSGraphNode *qos_graph_get_node(const char *key);
> +
> +/**
> + * qos_graph_has_node(): returns #TRUE if the node
> + * has map has a node mapped to that @key.
> + */
> +bool qos_graph_has_node(const char *node);
> +
> +/**
> + * qos_graph_get_node_type(): returns the %QOSNodeType
> + * of the node @node.
> + * It performs an hash map search O(1)
> + * Returns: on success: the %QOSNodeType
> + *          otherwise: #-1
> + */
> +QOSNodeType qos_graph_get_node_type(const char *node);
> +
> +/**
> + * qos_graph_get_node_availability(): returns the availability (boolea=
n)
> + * of the node @node.
> + */
> +bool qos_graph_get_node_availability(const char *node);
> +
> +/**
> + * qos_graph_get_edge(): returns the edge
> + * linking of the node @node with @dest.
> + *
> + * Returns: on success: the %QOSGraphEdge
> + *          otherwise: #NULL
> + */
> +QOSGraphEdge *qos_graph_get_edge(const char *node, const char *dest);
> +
> +/**
> + * qos_graph_edge_get_type(): returns the edge type
> + * of the edge @edge.
> + *
> + * Returns: on success: the %QOSEdgeType
> + *          otherwise: #-1
> + */
> +QOSEdgeType qos_graph_edge_get_type(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_edge_get_dest(): returns the name of the node
> + * pointed as destination of edge @edge.
> + *
> + * Returns: on success: the destination
> + *          otherwise: #NULL
> + */
> +char *qos_graph_edge_get_dest(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_has_edge(): returns #TRUE if there
> + * exists an edge from @start to @dest.
> + */
> +bool qos_graph_has_edge(const char *start, const char *dest);
> +
> +/**
> + * qos_graph_edge_get_arg(): returns the args assigned
> + * to that @edge.
> + *
> + * Returns: on success: the arg
> + *          otherwise: #NULL
> + */
> +void *qos_graph_edge_get_arg(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_edge_get_after_cmd_line(): returns the edge
> + * command line that will be added after all the node arguments
> + * and all the before_cmd_line arguments.
> + *
> + * Returns: on success: the char* arg
> + *          otherwise: #NULL
> + */
> +char *qos_graph_edge_get_after_cmd_line(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_edge_get_before_cmd_line(): returns the edge
> + * command line that will be added before the node command
> + * line argument.
> + *
> + * Returns: on success: the char* arg
> + *          otherwise: #NULL
> + */
> +char *qos_graph_edge_get_before_cmd_line(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_edge_get_extra_device_opts(): returns the arg
> + * command line that will be added to the node command
> + * line argument.
> + *
> + * Returns: on success: the char* arg
> + *          otherwise: #NULL
> + */
> +char *qos_graph_edge_get_extra_device_opts(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_edge_get_name(): returns the name
> + * assigned to the destination node (different only)
> + * if there are multiple devices with the same node name
> + * e.g. a node has two "generic-sdhci", "emmc" and "sdcard"
> + * there will be two edges with edge_name =3D"emmc" and "sdcard"
> + *
> + * Returns always the char* edge_name
> + */
> +char *qos_graph_edge_get_name(QOSGraphEdge *edge);
> +
> +/**
> + * qos_graph_get_machine(): returns the machine assigned
> + * to that @node name.
> + *
> + * It performs a search only trough the list of machines
> + * (i.e. the QOS_ROOT child).
> + *
> + * Returns: on success: the %QOSGraphNode
> + *          otherwise: #NULL
> + */
> +QOSGraphNode *qos_graph_get_machine(const char *node);
> +
> +/**
> + * qos_graph_has_machine(): returns #TRUE if the node
> + * has map has a node mapped to that @node.
> + */
> +bool qos_graph_has_machine(const char *node);
> +
> +
> +/**
> + * qos_print_graph(): walks the graph and prints
> + * all machine-to-test paths.
> + */
> +void qos_print_graph(void);
> +
> +/**
> + * qos_graph_foreach_test_path(): executes the Depth First search
> + * algorithm and applies @fn to all discovered paths.
> + *
> + * See qos_traverse_graph() in qgraph.c for more info on
> + * how it works.
> + */
> +void qos_graph_foreach_test_path(QOSTestCallback fn);
> +
> +/**
> + * qos_separate_arch_machine(): separate arch from machine.
> + * This function requires every machine @name to be in the form
> + * <arch>/<machine_name>, like "arm/raspi2" or "x86_64/pc".
> + *
> + * The function will split then the string in two parts,
> + * assigning @arch to point to <arch>/<machine_name>, and
> + * @machine to <machine_name>.
> + *
> + * For example, "x86_64/pc" will be split in this way:
> + * *arch =3D "x86_64/pc"
> + * *machine =3D "pc"
> + *
> + * Note that this function *does not* allocate any new string,
> + * but just sets the pointer *arch and *machine to the respective
> + * part of the string.
> + */
> +void qos_separate_arch_machine(char *name, char **arch, char **machine=
);

The arch parameter looks unnecessary to me, since it will be the same
pointer like "name" afterwards, and the callers already know that one,
don't they?


> +/**
> + * qos_delete_abstract_cmd_line(): if @abstract is #TRUE, delete the
> + * command line present in node mapped with key @name.
> + *
> + * This function is called when the QMP query returns a node with
> + * { "abstract" : <boolean> } attribute.
> + */
> +void qos_delete_abstract_cmd_line(const char *name, bool abstract);
> +
> +/**
> + * qos_graph_node_set_availability(): sets the node identified
> + * by @node with availability @av.
> + */
> +void qos_graph_node_set_availability(const char *node, bool av);
> +
> +#endif
> diff --git a/tests/libqtest.h b/tests/libqtest.h
> index ed88ff9..2fd1e51 100644
> --- a/tests/libqtest.h
> +++ b/tests/libqtest.h
> @@ -576,6 +576,9 @@ static inline QTestState *qtest_start(const char *a=
rgs)
>   */
>  static inline void qtest_end(void)
>  {
> +    if (!global_qtest) {
> +        return;
> +    }
>      qtest_quit(global_qtest);
>      global_qtest =3D NULL;
>  }
> diff --git a/tests/qos-test.c b/tests/qos-test.c
> new file mode 100644
> index 0000000..d85ed71
> --- /dev/null
> +++ b/tests/qos-test.c
> @@ -0,0 +1,470 @@
> +/*
> + * libqos driver framework
> + *
> + * Copyright (c) 2018 Emanuele Giuseppe Esposito <e.emanuelegiuseppe@g=
mail.com>
> + *
> + * This library is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU Lesser General Public
> + * License version 2 as published by the Free Software Foundation.
> + *
> + * This library is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> + * Lesser General Public License for more details.
> + *
> + * You should have received a copy of the GNU Lesser General Public
> + * License along with this library; if not, see <http://www.gnu.org/li=
censes/>
> + */
> +
> +#include <getopt.h>
> +#include "qemu/osdep.h"
> +#include "libqtest.h"
> +#include "qapi/qmp/qdict.h"
> +#include "qapi/qmp/qbool.h"
> +#include "qapi/qmp/qstring.h"
> +#include "qapi/qmp/qlist.h"
> +#include "libqos/malloc.h"
> +#include "libqos/qgraph.h"
> +#include "libqos/qgraph_internal.h"
> +
> +static char *old_path;
> +
> +/**
> + * create_machine_name(): appends the architecture to @name if
> + * @is_machine is valid.
> + */
> +static void create_machine_name(const char **name, bool is_machine)
> +{
> +    const char *arch;
> +    if (!is_machine) {
> +        return;
> +    }
> +    arch =3D qtest_get_arch();
> +    *name =3D g_strconcat(arch, "/", *name, NULL);
> +}

A void function which is returning a value via a char ** ? ... well, I'd
rather write that as:

static const char *create_machine_name(const char *name, bool is_machine)
{
    if (!is_machine) {
        return name;
    }
    return g_strconcat(qtest_get_arch(), "/", *name, NULL);
}


> +/**
> + * destroy_machine_name(): frees the given @name if
> + * @is_machine is valid.
> + */
> +static void destroy_machine_name(const char *name, bool is_machine)
> +{
> +    if (!is_machine) {
> +        return;
> +    }
> +    g_free((char *)name);
> +}
> +
> +/**
> + * apply_to_qlist(): using QMP queries QEMU for a list of
> + * machines and devices available, and sets the respective node
> + * as TRUE. If a node is found, also all its produced and contained
> + * child are marked available.
> + *
> + * See qos_graph_node_set_availability() for more info
> + */
> +static void apply_to_qlist(QList *list, bool is_machine)
> +{
> +    const QListEntry *p;
> +    const char *name;
> +    bool abstract;
> +    QDict *minfo;
> +    QObject *qobj;
> +    QString *qstr;
> +    QBool *qbol;
> +
> +    for (p =3D qlist_first(list); p; p =3D qlist_next(p)) {
> +        minfo =3D qobject_to(QDict, qlist_entry_obj(p));
> +        qobj =3D qdict_get(minfo, "name");
> +        qstr =3D qobject_to(QString, qobj);
> +        name =3D qstring_get_str(qstr);
> +
> +        create_machine_name(&name, is_machine);
> +        qos_graph_node_set_availability(name, TRUE);
> +
> +        qobj =3D qdict_get(minfo, "alias");
> +        if (qobj) {
> +            qstr =3D qobject_to(QString, qobj);
> +
> +            destroy_machine_name(name, is_machine);
> +            name =3D qstring_get_str(qstr);
> +
> +            create_machine_name(&name, is_machine);
> +            qos_graph_node_set_availability(name, TRUE);
> +        }
> +
> +        qobj =3D qdict_get(minfo, "abstract");
> +        if (qobj) {
> +            qbol =3D qobject_to(QBool, qobj);
> +            abstract =3D qbool_get_bool(qbol);
> +            qos_delete_abstract_cmd_line(name, abstract);
> +        }
> +
> +        destroy_machine_name(name, is_machine);
> +    }
> +}
> +
> +/**
> + * qos_set_machines_devices_available(): sets availability of qgraph
> + * machines and devices.
> + *
> + * This function firstly starts QEMU with "-machine none" option,
> + * and then executes the QMP protocol asking for the list of devices
> + * and machines available.
> + *
> + * for each of these items, it looks up the corresponding qgraph node,
> + * setting it as available. The list currently returns all devices tha=
t
> + * are either machines or QEDGE_CONSUMED_BY other nodes.
> + * Therefore, in order to mark all other nodes, it recursively sets
> + * all its QEDGE_CONTAINS and QEDGE_PRODUCES child as available too.
> + */
> +static void qos_set_machines_devices_available(void)
> +{
> +    QDict *response;
> +    QDict *args =3D qdict_new();
> +    QList *list;
> +
> +    qtest_start("-machine none");
> +    response =3D qmp("{ 'execute': 'query-machines' }");
> +    list =3D qdict_get_qlist(response, "return");
> +
> +    apply_to_qlist(list, TRUE);
> +
> +    qobject_unref(response);
> +
> +    qdict_put_bool(args, "abstract", TRUE);
> +    qdict_put_str(args, "implements", "device");
> +
> +    response =3D qmp("{'execute': 'qom-list-types',"
> +                   " 'arguments': %p }", args);
> +    g_assert(qdict_haskey(response, "return"));
> +    list =3D qdict_get_qlist(response, "return");
> +
> +    apply_to_qlist(list, FALSE);
> +
> +    qtest_end();
> +    qobject_unref(response);
> +
> +}
> +
> +static QGuestAllocator *get_machine_allocator(QOSGraphObject *obj)
> +{
> +    if (obj->get_driver) {
> +        return obj->get_driver(obj, "memory");
> +    } else {
> +        return NULL;
> +    }
> +}
> +
> +static void restart_qemu_or_continue(char *path)
> +{
> +    /* compares the current command line with the
> +     * one previously executed: if they are the same,
> +     * don't restart QEMU, if they differ, stop previous
> +     * QEMU subprocess (if active) and start over with
> +     * the new command line
> +     */
> +    if (g_strcmp0(old_path, path)) {
> +        qtest_end();
> +        qos_invalidate_command_line();
> +        old_path =3D g_strdup(path);
> +        qtest_start(path);
> +    } else { /* if cmd line is the same, reset the guest */
> +        qobject_unref(qmp("{ 'execute': 'system_reset' }"));
> +        qmp_eventwait("RESET");
> +    }
> +}
> +
> +void qos_invalidate_command_line(void)
> +{
> +    g_free(old_path);
> +    old_path =3D NULL;
> +}
> +
> +/**
> + * allocate_objects(): given an array of nodes @arg,
> + * walks the path invoking all constructors and
> + * passing the corresponding parameter in order to
> + * continue the objects allocation.
> + * Once the test is reached, return the object it consumes.
> + *
> + * Since the machine and QEDGE_CONSUMED_BY nodes allocate
> + * memory in the constructor, g_test_queue_destroy is used so
> + * that after execution they can be safely free'd.  (The test's
> + * ->before callback is also welcome to use g_test_queue_destroy).
> + *
> + * Note: as specified in walk_path() too, @arg is an array of
> + * char *, where arg[0] is a pointer to the command line
> + * string that will be used to properly start QEMU when executing
> + * the test, and the remaining elements represent the actual objects
> + * that will be allocated.
> + */
> +static void *allocate_objects(QTestState *qts, char **path, QGuestAllo=
cator **p_alloc)
> +{
> +    int current =3D 0;
> +    QGuestAllocator *alloc;
> +    QOSGraphObject *parent =3D NULL;
> +    QOSGraphEdge *edge;
> +    QOSGraphNode *node;
> +    void *edge_arg;
> +    void *obj;
> +
> +    node =3D qos_graph_get_node(path[current]);
> +    g_assert(node->type =3D=3D QNODE_MACHINE);
> +
> +    obj =3D qos_machine_new(node, qts);
> +    qos_object_queue_destroy(obj);
> +
> +    alloc =3D get_machine_allocator(obj);
> +    if (p_alloc) {
> +        *p_alloc =3D alloc;
> +    }
> +
> +    for (;;) {
> +        if (node->type !=3D QNODE_INTERFACE) {
> +            qos_object_start_hw(obj);
> +            parent =3D obj;
> +        }
> +
> +        /* follow edge and get object for next node constructor */
> +        current++;
> +        edge =3D qos_graph_get_edge(path[current - 1], path[current]);
> +        node =3D qos_graph_get_node(path[current]);
> +
> +        if (node->type =3D=3D QNODE_TEST) {
> +            g_assert(qos_graph_edge_get_type(edge) =3D=3D QEDGE_CONSUM=
ED_BY);
> +            return obj;
> +        }
> +
> +        switch (qos_graph_edge_get_type(edge)) {
> +        case QEDGE_PRODUCES:
> +            obj =3D parent->get_driver(parent, path[current]);
> +            break;
> +
> +        case QEDGE_CONSUMED_BY:
> +            edge_arg =3D qos_graph_edge_get_arg(edge);
> +            obj =3D qos_driver_new(node, obj, alloc, edge_arg);
> +            qos_object_queue_destroy(obj);
> +            break;
> +
> +        case QEDGE_CONTAINS:
> +            obj =3D parent->get_device(parent, path[current]);
> +            break;
> +        }
> +    }
> +}
> +
> +/* The argument to run_one_test, which is the test function that is re=
gistered
> + * with GTest, is a vector of strings.  The first item is the initial =
command
> + * line (before it is modified by the test's "before" function), the r=
emaining
> + * items are node names forming the path to the test node.
> + */
> +static char **current_path;
> +
> +const char *qos_get_current_command_line(void)
> +{
> +    return current_path[0];
> +}
> +
> +void *qos_allocate_objects(QTestState *qts, QGuestAllocator **p_alloc)
> +{
> +    return allocate_objects(qts, current_path + 1, p_alloc);
> +}
> +
> +/**
> + * run_one_test(): given an array of nodes @arg,
> + * walks the path invoking all constructors and
> + * passing the corresponding parameter in order to
> + * continue the objects allocation.
> + * Once the test is reached, its function is executed.
> + *
> + * Since the machine and QEDGE_CONSUMED_BY nodes allocate
> + * memory in the constructor, g_test_queue_destroy is used so
> + * that after execution they can be safely free'd.  The test's
> + * ->before callback is also welcome to use g_test_queue_destroy.
> + *
> + * Note: as specified in walk_path() too, @arg is an array of
> + * char *, where arg[0] is a pointer to the command line
> + * string that will be used to properly start QEMU when executing
> + * the test, and the remaining elements represent the actual objects
> + * that will be allocated.
> + *
> + * The order of execution is the following:
> + * 1) @before test function as defined in the given QOSGraphTestOption=
s
> + * 2) start QEMU
> + * 3) call all nodes constructor and get_driver/get_device depending o=
n edge,
> + *    start the hardware (*_device_enable functions)
> + * 4) start test
> + */
> +static void run_one_test(const void *arg)
> +{
> +    QOSGraphNode *test_node;
> +    QGuestAllocator *alloc =3D NULL;
> +    void *obj;
> +    char **path =3D (char **) arg;
> +    GString *cmd_line =3D g_string_new(path[0]);
> +    void *test_arg;
> +
> +    /* Before test */
> +    current_path =3D path;
> +    test_node =3D qos_graph_get_node(path[(g_strv_length(path) - 1)]);
> +    test_arg =3D test_node->u.test.arg;
> +    if (test_node->u.test.before) {
> +        test_arg =3D test_node->u.test.before(cmd_line, test_arg);
> +    }
> +
> +    restart_qemu_or_continue(cmd_line->str);
> +    g_string_free(cmd_line, TRUE);
> +
> +    obj =3D qos_allocate_objects(global_qtest, &alloc);
> +    test_node->u.test.function(obj, test_arg, alloc);
> +}
> +
> +static void subprocess_run_one_test(const void *arg)
> +{
> +    const gchar *path =3D arg;
> +    g_test_trap_subprocess(path, 0, 0);
> +    g_test_trap_assert_passed();
> +}
> +
> +/*
> + * in this function, 2 path will be built:
> + * path_str, a one-string path (ex "pc/i440FX-pcihost/...")
> + * path_vec, a string-array path (ex [0] =3D "pc", [1] =3D "i440FX-pci=
host").
> + *
> + * path_str will be only used to build the test name, and won't need t=
he
> + * architecture name at beginning, since it will be added by qtest_add=
_func().
> + *
> + * path_vec is used to allocate all constructors of the path nodes.
> + * Each name in this array except position 0 must correspond to a vali=
d
> + * QOSGraphNode name.
> + * Position 0 is special, initially contains just the <machine> name o=
f
> + * the node, (ex for "x86_64/pc" it will be "pc"), used to build the t=
est
> + * path (see below). After it will contain the command line used to st=
art
> + * qemu with all required devices.
> + *
> + * Note that the machine node name must be with format <arch>/<machine=
>
> + * (ex "x86_64/pc"), because it will identify the node "x86_64/pc"
> + * and start QEMU with "-M pc". For this reason,
> + * when building path_str, path_vec
> + * initially contains the <machine> at position 0 ("pc"),
> + * and the node name at position 1 (<arch>/<machine>)
> + * ("x86_64/pc"), followed by the rest of the nodes.
> + */
> +static void walk_path(QOSGraphNode *orig_path, int len)
> +{
> +    QOSGraphNode *path;
> +    QOSGraphEdge *edge;
> +
> +    /* etype set to QEDGE_CONSUMED_BY so that machine can add to the c=
ommand line */
> +    QOSEdgeType etype =3D QEDGE_CONSUMED_BY;
> +
> +    /* twice QOS_PATH_MAX_ELEMENT_SIZE since each edge can have its ar=
g */
> +    char **path_vec =3D g_new0(char *, (QOS_PATH_MAX_ELEMENT_SIZE * 2)=
);
> +    int path_vec_size =3D 0;
> +
> +    char *machine =3D NULL, *arch =3D NULL;
> +    char *after_cmd =3D NULL, *before_cmd =3D NULL, *after_device =3D =
NULL;
> +    char *node_name =3D orig_path->name, *path_str;
> +
> +    GString *cmd_line =3D g_string_new("");
> +    GString *cmd_line2 =3D g_string_new("");
> +
> +    path =3D qos_graph_get_node(node_name); /* root */
> +    node_name =3D qos_graph_edge_get_dest(path->path_edge); /* machine=
 name */
> +
> +    qos_separate_arch_machine(node_name, &arch, &machine);
> +    path_vec[path_vec_size++] =3D arch;
> +    path_vec[path_vec_size++] =3D machine;
> +
> +    for (;;) {
> +        path =3D qos_graph_get_node(node_name);
> +        if (!path->path_edge) {
> +            break;
> +        }
> +
> +        node_name =3D qos_graph_edge_get_dest(path->path_edge);
> +
> +        /* append node command line + previous edge command line */
> +        if (path->command_line && etype =3D=3D QEDGE_CONSUMED_BY) {
> +            g_string_append(cmd_line, path->command_line);
> +            if (after_device) {
> +                g_string_append(cmd_line, after_device);
> +            }
> +        }
> +
> +        path_vec[path_vec_size++] =3D qos_graph_edge_get_name(path->pa=
th_edge);
> +        /* detect if edge has command line args */
> +        after_cmd =3D qos_graph_edge_get_after_cmd_line(path->path_edg=
e);
> +        after_device =3D qos_graph_edge_get_extra_device_opts(path->pa=
th_edge);
> +        before_cmd =3D qos_graph_edge_get_before_cmd_line(path->path_e=
dge);
> +        edge =3D qos_graph_get_edge(path->name, node_name);
> +        etype =3D qos_graph_edge_get_type(edge);
> +
> +        if (before_cmd) {
> +            g_string_append(cmd_line, before_cmd);
> +        }
> +        if (after_cmd) {
> +            g_string_append(cmd_line2, after_cmd);
> +        }
> +    }
> +
> +    path_vec[path_vec_size++] =3D NULL;
> +    if (after_device) {
> +        g_string_append(cmd_line, after_device);
> +    }
> +    g_string_append(cmd_line, cmd_line2->str);
> +    g_string_free(cmd_line2, TRUE);
> +
> +    /* here position 0 has <arch>/<machine>, position 1 has <machine>.
> +     * The path must not have the <arch>
> +     */
> +    path_str =3D g_strjoinv("/", path_vec + 1);
> +
> +    /* put arch/machine in position 1 so run_one_test can do its work
> +     * and add the command line at position 0.
> +     */
> +    path_vec[0] =3D g_string_free(cmd_line, FALSE);
> +    path_vec[1] =3D arch;
> +
> +    if (path->u.test.subprocess) {
> +        gchar *subprocess_path =3D g_strdup_printf("/%s/%s/subprocess"=
,
> +                                                 qtest_get_arch(), pat=
h_str);
> +        qtest_add_data_func(path_str, subprocess_path, subprocess_run_=
one_test);
> +        g_test_add_data_func(subprocess_path, path_vec, run_one_test);
> +    } else {
> +        qtest_add_data_func(path_str, path_vec, run_one_test);
> +    }
> +
> +    g_free(path_str);
> +}
> +
> +
> +
> +/**
> + * main(): heart of the qgraph framework.
> + *
> + * - Initializes the glib test framework
> + * - Creates the graph by invoking the various _init constructors
> + * - Starts QEMU to mark the available devices
> + * - Walks the graph, and each path is added to
> + *   the glib test framework (walk_path)
> + * - Runs the tests, calling allocate_object() and allocating the
> + *   machine/drivers/test objects
> + * - Cleans up everything
> + */
> +int main(int argc, char **argv)
> +{
> +    g_test_init(&argc, &argv, NULL);
> +    qos_graph_init();
> +    module_call_init(MODULE_INIT_QOM);
> +    module_call_init(MODULE_INIT_LIBQOS);
> +    qos_set_machines_devices_available();
> +
> +    qos_graph_foreach_test_path(walk_path);
> +    g_test_run();
> +    qtest_end();
> +    qos_graph_destroy();
> +    g_free(old_path);
> +    return 0;
> +}
[...]

I did not do a very detailed review, but from a quick glance, this looks
quite good to me already (apart from the few minor issues that I've
mentioned above)

 Thomas

