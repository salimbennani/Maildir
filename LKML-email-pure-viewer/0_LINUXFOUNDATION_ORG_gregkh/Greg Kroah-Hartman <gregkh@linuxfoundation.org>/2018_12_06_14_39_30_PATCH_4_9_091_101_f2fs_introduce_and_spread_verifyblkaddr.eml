Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 07 Dec 2018 08:48:02 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 6A13458042F;
	Thu,  6 Dec 2018 06:48:25 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 06 Dec 2018 06:48:25 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ApyXkUhRn24hQvYP882qvNxd6sNpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YByAt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZAo2y?=
 =?us-ascii?q?cZYBAeQCM+hfrYb9qVUBohSiCgejH+Pv0j1Fi2Tq3aA53ektDRvL0RYiEt8IrX?=
 =?us-ascii?q?/arM/1NKAXUe2tzafI1yvMb/xL0jn48ojIdQouofGVUbxya8XR01UvFwbfgVWW?=
 =?us-ascii?q?tIfoODyV1v4TvGiU7OpgVfmii2omqwF3vziuycksio7UhoIT11/L7zl5wIcyJd?=
 =?us-ascii?q?2+UkJ7ZsSkEJRJuiycKoB4QdsiTnl2tComzrAKo4O3cSYUxJg92hLSaOCLf5KJ?=
 =?us-ascii?q?7x/hTOqcIjl1iGhmdb++nRq/8kytxvfhWsWo0ltHqDdOnMPWuXAXzRPT79CKSv?=
 =?us-ascii?q?tj8Uel3jaCzx7T6u5aLkAuj6bbKIAuwqQ2lpUNtUTPBCj2mF/5jKOOd0Uk/Pan?=
 =?us-ascii?q?6/j/b7n4upORM5V4hhzwP6gwgMCzHOc1PhQUU2Wa++mwzLjj8lf4QLVOgP02iK?=
 =?us-ascii?q?7ZsJXCKMQfp665BRJV04k65xa8ETimytIYkmcDLF5cfxKGgY7pNE/UIP3jE/e/?=
 =?us-ascii?q?jEqjkC1xy/DFILLhGJPNIWbHkLv7erZ98UFcxBIpzd9D/5JUFq0BIPXrV0/1td?=
 =?us-ascii?q?zYDQE2Pxa7wub6E9h90oIeWWSSAq6WKq/SsFmI5v4xLOmIfoMapDH9K/097f70?=
 =?us-ascii?q?kXA5gUMdfbWu3ZYPaHC3BPVmI1mDbnrrmNsBEXoKsRA4TOzlk1CCVT9TZ3CvX6?=
 =?us-ascii?q?Mz/D07CYSmDZvdSYCpmrCOwCC7HphObGBcFl+MCWvod5mDW/oUaiKSJdFuniYH?=
 =?us-ascii?q?VbimTY8h0xauuRT+y7pmKOrU5yIZuYji1Nhz++3cixUy+SZoAMSa1mGHV3t0kX?=
 =?us-ascii?q?8QRz8qwKB/plRwxU2Y0ah4hPxYFsZf5+lTXQc4LpPcy+16C9bvWgPOZNuJSVCm?=
 =?us-ascii?q?Qsm4DjE1VN4+39gOY0NlEdW4kh/DxzaqA6MSl7GTB5w76KTc02L1J8Z80XnG0q?=
 =?us-ascii?q?YhgkIiQstOM22mm6F++xLSB47Pj0WWiaKqeb4A0y7K8WeJ1XCOs11AUA5sTaXF?=
 =?us-ascii?q?WmgSaVbMotTn+EzOVb+uBq4hMgta18GCLKxGatnqjVVDQPfuI9DeY2O3m2etCh?=
 =?us-ascii?q?eE3LKMbIz2e2oD2CXRElQLkwcW/XyeLwgxGj+ho37CDDxpDV/gflnj8fdgp3+h?=
 =?us-ascii?q?Tk871QeKb1Z/2Lqz4RMVgf2cS/UO3rMLoishqjN0HEqj0NLSEdaPuw1hfKBEa9?=
 =?us-ascii?q?Mn/FhHzX7ZtxB6PpG4M6Bih1secwNrv0Pu1xR7EJlAndItrHMwyApyKKSY0Fxa?=
 =?us-ascii?q?ejOc3JDwPKDXK2bo8BCuba7Wxk/R0NKM9qgT7/Q4rk3pvBu1GUo673Vnz95V3m?=
 =?us-ascii?q?OG6ZXOEgUTXoz+U0Yt+xdhurHVfzMy54XX1X1rL6m5qTvC29MvBOs4xResZdZf?=
 =?us-ascii?q?MKWYFADsF80WHdShKOsvm1KxdBILIPhS9LIoP8Ohb/aH2LOrMPx8kz68jGVH4J?=
 =?us-ascii?q?py0kSD9ydnTu7I3pAFw+yX3wedVjf8ikuhvd7zmYxeeT4SGW+/wzD+BIFNfq1y?=
 =?us-ascii?q?YZoLCWC2Ls2tx9Vxm4TiW2RF+16kHV8G3tGmeQCTb1DkwQJfz0AXrmG5liuiyD?=
 =?us-ascii?q?x0lSokrq6e3CzI3uTjewALOm9NRGl+k1jsJZK4gMwdXEitdwIpjgeq5V7mx6hH?=
 =?us-ascii?q?o6RyN2nSQUZScyn2NW1iSbawtryZbs5L6ZMotzhXUeumbVCbTL79vwUV0yf5E2?=
 =?us-ascii?q?RCwzA7cimguo/lkBxilGKdMHFzoWLbec5q3xff59/cRflL0jodXiZ4ijrXBlm6?=
 =?us-ascii?q?P9a3+9WZjJPDsuG4V2K8WZxfayjrzYWctCSl4W1mGwGwn/e2mtf/Cwg1zTf718?=
 =?us-ascii?q?V2VSXPtBv9YpPk16OgPeJlf0loAkTx6857GoF4j4sxi4sc2XkchpWJ43UHlX3/?=
 =?us-ascii?q?Pslc2aL7dHANXyIEw8bJ4Aj5301uNnGJyJj4VnmHwsthesO1YmUZ2i8m68BKCa?=
 =?us-ascii?q?GU7KFLnCdvo1q4qx7RbuZ5njsH1fQu73saifkTuAUx1iWdHqwSHU5AMCzplhSI?=
 =?us-ascii?q?7MqxoL9ZZWmxariwyFRxncq6A76cuAFcV230epMjHS9288V+P0jA0Hz16oH4Zt?=
 =?us-ascii?q?bQacgfuQGTkxfFl+JVMo4+luIWhSp7PmLwpWEly+k+jRB03JC1po6HK3h2/KKi?=
 =?us-ascii?q?Ax5VLTn1Z8IV+jHwgqdShMeW34azHpp/HjUHRofnTfWtEDgKr/ToKx6OECEgqn?=
 =?us-ascii?q?ecAbfQBhWQ6EBir3LSCZyrM2yXKWIdzdVjQhmdOUNejBoVXDU8gp42CASqyNb9?=
 =?us-ascii?q?f0d+4zAb/kT4pQdUyuJ0Kxn/VX/SpAWyZTcxVpefNwBa7h1Y60fWLMye7f9zHy?=
 =?us-ascii?q?dC8Z26twGNLm2bZwJVDWAGQECEBlbjPqWw6tnE6eSXGu2+L/7Wa7WUteNeT+uI?=
 =?us-ascii?q?xY6o0oZ+/zeMMdiPPmB/D/Ih3EpPR2t5G8PfmzUAUCEXkyPNb8iGpBaz4CF3r8?=
 =?us-ascii?q?a/8Oj1VwLr/4eAF7xSMdB38RCsnaiDL/KQhDp+KTtA1pMD237IyLsc3F4TkS1u?=
 =?us-ascii?q?dCOtEbMPtSHTVqLQh7RXAgUfayNyMstI8q090hNMOc7dltP6yLp4guQpBFdCUF?=
 =?us-ascii?q?zrgtupatASI2GhKFPHA16GO66bJTLQ2cH4f6O9RadUjOVVrBCwvTebE0n+PjWM?=
 =?us-ascii?q?jTXpVhavMf1SgyGfJhBRpIa9chN1A2j5UN3mcgG7MMNwjTAu3b00h3bKOXQAPj?=
 =?us-ascii?q?Rmb0xNrqOf7SVDj/V7GmxB6GdlLOaelyaY6enYNogZsf9xDitokOJa5Wwwy6FJ?=
 =?us-ascii?q?4yFcWPx1hCzSo8Zuol68lOmPzztnUBxWpTdKhIKEp0NiOarC+5lEWHbE+g8N7G?=
 =?us-ascii?q?qKBxQLodtlFsPgu6RKxtfTk6LzLWQKz9WB+coaGtiRK8+dNnclGQTmFSSSDwYf?=
 =?us-ascii?q?SzOvc2bFiB9zivaXo1KPo5dyiYLrkZpLarZBSFk8ELtOBV5oE98CCJN2WC40n7?=
 =?us-ascii?q?mGisIB+Xu5ql/WXsoM7cOPbe6bHfi6cGXRtrJDfRZdhOqgdYk=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ANAAAXNglch0O0hNFkHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBg2sng3qIGV+LL4INFJc6FIFiERgTAYdXIjQJDQEDAQEBAQEBAgE?=
 =?us-ascii?q?TAQEBCA0JCCkjDII2JAGCYgMDAQIgBAsBDQEBNwEFCQEBHwUCBSECAgMMSBkFg?=
 =?us-ascii?q?xyCAgQBpHBwfAwngnYBAQWHJAiBC4ZlgxOBHBeBf4ERh3uDHIJXiTeXKgmNW4N?=
 =?us-ascii?q?gI4FcI4RyikUslS+DMYFGgg0zGggoCDuCbIIbDBeIXoVAPzKBAgMBASETigYBA?=
 =?us-ascii?q?Q?=
X-IPAS-Result: =?us-ascii?q?A0ANAAAXNglch0O0hNFkHAEBAQQBAQcEAQGBUQcBAQsBg2s?=
 =?us-ascii?q?ng3qIGV+LL4INFJc6FIFiERgTAYdXIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjD?=
 =?us-ascii?q?II2JAGCYgMDAQIgBAsBDQEBNwEFCQEBHwUCBSECAgMMSBkFgxyCAgQBpHBwfAw?=
 =?us-ascii?q?ngnYBAQWHJAiBC4ZlgxOBHBeBf4ERh3uDHIJXiTeXKgmNW4NgI4FcI4RyikUsl?=
 =?us-ascii?q?S+DMYFGgg0zGggoCDuCbIIbDBeIXoVAPzKBAgMBASETigYBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,322,1539673200"; 
   d="scan'208";a="43839165"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 06 Dec 2018 06:48:23 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1731488AbeLFOrn (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 6 Dec 2018 09:47:43 -0500
Received: from mail.kernel.org ([198.145.29.99]:52750 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1731476AbeLFOrl (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 6 Dec 2018 09:47:41 -0500
Received: from localhost (5356596B.cm-6-7b.dynamic.ziggo.nl [83.86.89.107])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 5B0AC20661;
        Thu,  6 Dec 2018 14:47:39 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1544107659;
        bh=XgwXtl0LqdCGh1fKT4jAoywiy6ItGx59N8Ue09RnVnE=;
        h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
        b=Z8D2B36+BoVryUW0hd/BIr0OxAAHcJWCgj3MMSERUDI6+i8T7l1qC/SwJsYa/YJgw
         vRYOQZOJKN2olnOf3VemxN+FG6cBze9XLnUshH5jQKf5itTSOEsqZgoX6vFIAnLsoG
         XhMS0EGrzXKEAooT5yqfkmO+2L1JO3snSKCoGAts=
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
To: linux-kernel@vger.kernel.org
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        stable@vger.kernel.org, Chao Yu <yuchao0@huawei.com>,
        Jaegeuk Kim <jaegeuk@kernel.org>,
        Ben Hutchings <ben.hutchings@codethink.co.uk>
Subject: [PATCH 4.9 091/101] f2fs: introduce and spread verify_blkaddr
Date: Thu,  6 Dec 2018 15:39:30 +0100
Message-Id: <20181206143018.111333050@linuxfoundation.org>
X-Mailer: git-send-email 2.19.2
In-Reply-To: <20181206143011.174892052@linuxfoundation.org>
References: <20181206143011.174892052@linuxfoundation.org>
User-Agent: quilt/0.65
X-stable: review
X-Patchwork-Hint: ignore
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

4.9-stable review patch.  If anyone has any objections, please let me know.

------------------

From: Chao Yu <yuchao0@huawei.com>

commit e1da7872f6eda977bd812346bf588c35e4495a1e upstream.

This patch introduces verify_blkaddr to check meta/data block address
with valid range to detect bug earlier.

In addition, once we encounter an invalid blkaddr, notice user to run
fsck to fix, and let the kernel panic.

Signed-off-by: Chao Yu <yuchao0@huawei.com>
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>
[bwh: Backported to 4.9:
 - I skipped an earlier renaming of is_valid_meta_blkaddr() to
   f2fs_is_valid_meta_blkaddr()
 - Adjust context]
Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 fs/f2fs/checkpoint.c |   11 +++++++++--
 fs/f2fs/data.c       |    6 +++---
 fs/f2fs/f2fs.h       |   32 +++++++++++++++++++++++++++++---
 fs/f2fs/file.c       |    9 +++++----
 fs/f2fs/inode.c      |    7 ++++---
 fs/f2fs/node.c       |    4 ++--
 fs/f2fs/recovery.c   |    6 +++---
 fs/f2fs/segment.c    |    4 ++--
 fs/f2fs/segment.h    |    8 +++-----
 9 files changed, 60 insertions(+), 27 deletions(-)

--- a/fs/f2fs/checkpoint.c
+++ b/fs/f2fs/checkpoint.c
@@ -118,7 +118,8 @@ struct page *get_tmp_page(struct f2fs_sb
 	return __get_meta_page(sbi, index, false);
 }
 
-bool is_valid_meta_blkaddr(struct f2fs_sb_info *sbi, block_t blkaddr, int type)
+bool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,
+					block_t blkaddr, int type)
 {
 	switch (type) {
 	case META_NAT:
@@ -138,10 +139,16 @@ bool is_valid_meta_blkaddr(struct f2fs_s
 			return false;
 		break;
 	case META_POR:
+	case DATA_GENERIC:
 		if (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||
 			blkaddr < MAIN_BLKADDR(sbi)))
 			return false;
 		break;
+	case META_GENERIC:
+		if (unlikely(blkaddr < SEG0_BLKADDR(sbi) ||
+			blkaddr >= MAIN_BLKADDR(sbi)))
+			return false;
+		break;
 	default:
 		BUG();
 	}
@@ -173,7 +180,7 @@ int ra_meta_pages(struct f2fs_sb_info *s
 	blk_start_plug(&plug);
 	for (; nrpages-- > 0; blkno++) {
 
-		if (!is_valid_meta_blkaddr(sbi, blkno, type))
+		if (!f2fs_is_valid_blkaddr(sbi, blkno, type))
 			goto out;
 
 		switch (type) {
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@ -267,7 +267,7 @@ void f2fs_submit_page_mbio(struct f2fs_i
 
 	io = is_read ? &sbi->read_io : &sbi->write_io[btype];
 
-	if (is_valid_blkaddr(fio->old_blkaddr))
+	if (__is_valid_data_blkaddr(fio->old_blkaddr))
 		verify_block_addr(fio, fio->old_blkaddr);
 	verify_block_addr(fio, fio->new_blkaddr);
 
@@ -723,7 +723,7 @@ next_dnode:
 next_block:
 	blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);
 
-	if (!is_valid_blkaddr(blkaddr)) {
+	if (!is_valid_data_blkaddr(sbi, blkaddr)) {
 		if (create) {
 			if (unlikely(f2fs_cp_error(sbi))) {
 				err = -EIO;
@@ -1217,7 +1217,7 @@ retry_encrypt:
 	 * If current allocation needs SSR,
 	 * it had better in-place writes for updated data.
 	 */
-	if (unlikely(is_valid_blkaddr(fio->old_blkaddr) &&
+	if (unlikely(is_valid_data_blkaddr(fio->sbi, fio->old_blkaddr) &&
 			!is_cold_data(page) &&
 			!IS_ATOMIC_WRITTEN_PAGE(page) &&
 			need_inplace_update(inode))) {
--- a/fs/f2fs/f2fs.h
+++ b/fs/f2fs/f2fs.h
@@ -145,7 +145,7 @@ struct cp_control {
 };
 
 /*
- * For CP/NAT/SIT/SSA readahead
+ * indicate meta/data type
  */
 enum {
 	META_CP,
@@ -153,6 +153,8 @@ enum {
 	META_SIT,
 	META_SSA,
 	META_POR,
+	DATA_GENERIC,
+	META_GENERIC,
 };
 
 /* for the list of ino */
@@ -1930,13 +1932,36 @@ static inline void *f2fs_kvzalloc(size_t
 	(pgofs - ADDRS_PER_INODE(inode) + ADDRS_PER_BLOCK) /	\
 	ADDRS_PER_BLOCK * ADDRS_PER_BLOCK + ADDRS_PER_INODE(inode))
 
-static inline bool is_valid_blkaddr(block_t blkaddr)
+bool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,
+					block_t blkaddr, int type);
+void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...);
+static inline void verify_blkaddr(struct f2fs_sb_info *sbi,
+					block_t blkaddr, int type)
+{
+	if (!f2fs_is_valid_blkaddr(sbi, blkaddr, type)) {
+		f2fs_msg(sbi->sb, KERN_ERR,
+			"invalid blkaddr: %u, type: %d, run fsck to fix.",
+			blkaddr, type);
+		f2fs_bug_on(sbi, 1);
+	}
+}
+
+static inline bool __is_valid_data_blkaddr(block_t blkaddr)
 {
 	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
 		return false;
 	return true;
 }
 
+static inline bool is_valid_data_blkaddr(struct f2fs_sb_info *sbi,
+						block_t blkaddr)
+{
+	if (!__is_valid_data_blkaddr(blkaddr))
+		return false;
+	verify_blkaddr(sbi, blkaddr, DATA_GENERIC);
+	return true;
+}
+
 /*
  * file.c
  */
@@ -2122,7 +2147,8 @@ void f2fs_stop_checkpoint(struct f2fs_sb
 struct page *grab_meta_page(struct f2fs_sb_info *, pgoff_t);
 struct page *get_meta_page(struct f2fs_sb_info *, pgoff_t);
 struct page *get_tmp_page(struct f2fs_sb_info *, pgoff_t);
-bool is_valid_meta_blkaddr(struct f2fs_sb_info *sbi, block_t blkaddr, int type);
+bool f2fs_is_valid_blkaddr(struct f2fs_sb_info *sbi,
+					block_t blkaddr, int type);
 int ra_meta_pages(struct f2fs_sb_info *, block_t, int, int, bool);
 void ra_meta_pages_cond(struct f2fs_sb_info *, pgoff_t);
 long sync_meta_pages(struct f2fs_sb_info *, enum page_type, long);
--- a/fs/f2fs/file.c
+++ b/fs/f2fs/file.c
@@ -310,13 +310,13 @@ static pgoff_t __get_first_dirty_index(s
 	return pgofs;
 }
 
-static bool __found_offset(block_t blkaddr, pgoff_t dirty, pgoff_t pgofs,
-							int whence)
+static bool __found_offset(struct f2fs_sb_info *sbi, block_t blkaddr,
+				pgoff_t dirty, pgoff_t pgofs, int whence)
 {
 	switch (whence) {
 	case SEEK_DATA:
 		if ((blkaddr == NEW_ADDR && dirty == pgofs) ||
-			is_valid_blkaddr(blkaddr))
+			is_valid_data_blkaddr(sbi, blkaddr))
 			return true;
 		break;
 	case SEEK_HOLE:
@@ -378,7 +378,8 @@ static loff_t f2fs_seek_block(struct fil
 			block_t blkaddr;
 			blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);
 
-			if (__found_offset(blkaddr, dirty, pgofs, whence)) {
+			if (__found_offset(F2FS_I_SB(inode), blkaddr, dirty,
+							pgofs, whence)) {
 				f2fs_put_dnode(&dn);
 				goto found;
 			}
--- a/fs/f2fs/inode.c
+++ b/fs/f2fs/inode.c
@@ -59,11 +59,12 @@ static void __get_inode_rdev(struct inod
 	}
 }
 
-static bool __written_first_block(struct f2fs_inode *ri)
+static bool __written_first_block(struct f2fs_sb_info *sbi,
+					struct f2fs_inode *ri)
 {
 	block_t addr = le32_to_cpu(ri->i_addr[0]);
 
-	if (is_valid_blkaddr(addr))
+	if (is_valid_data_blkaddr(sbi, addr))
 		return true;
 	return false;
 }
@@ -159,7 +160,7 @@ static int do_read_inode(struct inode *i
 	/* get rdev by using inline_info */
 	__get_inode_rdev(inode, ri);
 
-	if (__written_first_block(ri))
+	if (__written_first_block(sbi, ri))
 		set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);
 
 	if (!need_inode_block_update(sbi, inode->i_ino))
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@ -304,7 +304,7 @@ static void set_node_addr(struct f2fs_sb
 			new_blkaddr == NULL_ADDR);
 	f2fs_bug_on(sbi, nat_get_blkaddr(e) == NEW_ADDR &&
 			new_blkaddr == NEW_ADDR);
-	f2fs_bug_on(sbi, is_valid_blkaddr(nat_get_blkaddr(e)) &&
+	f2fs_bug_on(sbi, is_valid_data_blkaddr(sbi, nat_get_blkaddr(e)) &&
 			new_blkaddr == NEW_ADDR);
 
 	/* increment version no as node is removed */
@@ -319,7 +319,7 @@ static void set_node_addr(struct f2fs_sb
 
 	/* change address */
 	nat_set_blkaddr(e, new_blkaddr);
-	if (!is_valid_blkaddr(new_blkaddr))
+	if (!is_valid_data_blkaddr(sbi, new_blkaddr))
 		set_nat_flag(e, IS_CHECKPOINTED, false);
 	__set_nat_cache_dirty(nm_i, e);
 
--- a/fs/f2fs/recovery.c
+++ b/fs/f2fs/recovery.c
@@ -236,7 +236,7 @@ static int find_fsync_dnodes(struct f2fs
 	while (1) {
 		struct fsync_inode_entry *entry;
 
-		if (!is_valid_meta_blkaddr(sbi, blkaddr, META_POR))
+		if (!f2fs_is_valid_blkaddr(sbi, blkaddr, META_POR))
 			return 0;
 
 		page = get_tmp_page(sbi, blkaddr);
@@ -468,7 +468,7 @@ retry_dn:
 		}
 
 		/* dest is valid block, try to recover from src to dest */
-		if (is_valid_meta_blkaddr(sbi, dest, META_POR)) {
+		if (f2fs_is_valid_blkaddr(sbi, dest, META_POR)) {
 
 			if (src == NULL_ADDR) {
 				err = reserve_new_block(&dn);
@@ -527,7 +527,7 @@ static int recover_data(struct f2fs_sb_i
 	while (1) {
 		struct fsync_inode_entry *entry;
 
-		if (!is_valid_meta_blkaddr(sbi, blkaddr, META_POR))
+		if (!f2fs_is_valid_blkaddr(sbi, blkaddr, META_POR))
 			break;
 
 		ra_meta_pages_cond(sbi, blkaddr);
--- a/fs/f2fs/segment.c
+++ b/fs/f2fs/segment.c
@@ -944,7 +944,7 @@ bool is_checkpointed_data(struct f2fs_sb
 	struct seg_entry *se;
 	bool is_cp = false;
 
-	if (!is_valid_blkaddr(blkaddr))
+	if (!is_valid_data_blkaddr(sbi, blkaddr))
 		return true;
 
 	mutex_lock(&sit_i->sentry_lock);
@@ -1668,7 +1668,7 @@ void f2fs_wait_on_encrypted_page_writeba
 {
 	struct page *cpage;
 
-	if (!is_valid_blkaddr(blkaddr))
+	if (!is_valid_data_blkaddr(sbi, blkaddr))
 		return;
 
 	cpage = find_lock_page(META_MAPPING(sbi), blkaddr);
--- a/fs/f2fs/segment.h
+++ b/fs/f2fs/segment.h
@@ -81,7 +81,7 @@
 	(GET_SEGOFF_FROM_SEG0(sbi, blk_addr) & (sbi->blocks_per_seg - 1))
 
 #define GET_SEGNO(sbi, blk_addr)					\
-	((!is_valid_blkaddr(blk_addr)) ?			\
+	((!is_valid_data_blkaddr(sbi, blk_addr)) ?			\
 	NULL_SEGNO : GET_L2R_SEGNO(FREE_I(sbi),			\
 		GET_SEGNO_FROM_SEG0(sbi, blk_addr)))
 #define GET_SECNO(sbi, segno)					\
@@ -603,11 +603,9 @@ static inline void verify_block_addr(str
 
 	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
 				(!is_read_io(fio->op) || fio->is_meta))
-		BUG_ON(blk_addr < SEG0_BLKADDR(sbi) ||
-				blk_addr >= MAIN_BLKADDR(sbi));
+		verify_blkaddr(sbi, blk_addr, META_GENERIC);
 	else
-		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
-				blk_addr >= MAX_BLKADDR(sbi));
+		verify_blkaddr(sbi, blk_addr, DATA_GENERIC);
 }
 
 /*


