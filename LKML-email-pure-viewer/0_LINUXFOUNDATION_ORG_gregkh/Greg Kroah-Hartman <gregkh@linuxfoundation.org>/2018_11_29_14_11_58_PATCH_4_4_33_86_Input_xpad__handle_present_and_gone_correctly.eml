Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 30 Nov 2018 08:43:24 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga007.fm.intel.com (fmsmga007.fm.intel.com [10.253.24.52])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 9FD6D5802E4;
	Thu, 29 Nov 2018 06:20:09 -0800 (PST)
Received: from fmsmga102.fm.intel.com ([10.1.193.69])
  by fmsmga007-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 29 Nov 2018 06:20:09 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ARjYDNh8vc3ZiM/9uRHKM819IXTAuvvDOBiVQ1KB9?=
 =?us-ascii?q?1ugTIJqq85mqBkHD//Il1AaPAd2Lraocw8Pt8InYEVQa5piAtH1QOLdtbDQizf?=
 =?us-ascii?q?ssogo7HcSeAlf6JvO5JwYzHcBFSUM3tyrjaRsdF8nxfUDdrWOv5jAOBBr/KRB1?=
 =?us-ascii?q?JuPoEYLOksi7ze+/94HQbglSmDaxfa55IQmrownWqsQYm5ZpJLwryhvOrHtIeu?=
 =?us-ascii?q?BWyn1tKFmOgRvy5dq+8YB6/ShItP0v68BPUaPhf6QlVrNYFygpM3o05MLwqxbO?=
 =?us-ascii?q?SxaE62YGXWUXlhpIBBXF7A3/U5zsvCb2qvZx1S+HNsDtU7s6RSqt4LtqSB/wiS?=
 =?us-ascii?q?cIKTg58H3MisdtiK5XuQ+tqwBjz4LRZoyeKfhwcb7Hfd4CRWRPQNtfWSJCDI27?=
 =?us-ascii?q?bYQPAeQOMulEoIfyvFsOtRmzCBKwBO7sxDJEmmX70Lc43uknDArI3BYgH9ULsH?=
 =?us-ascii?q?nMrdv1LrkdUe+ox6fN1zXDaOlZ2Tfk5IbKaB8hu+2MXbdqfsrX1EIiEAzFjk+O?=
 =?us-ascii?q?pozqPDOV1v8As2ya7+pmSOKuhGAnqwZsojip28gjkJXJhoMSylDC7yl5x5w1Jd?=
 =?us-ascii?q?KhRUN9fNWqHpxQtySAOIt3RMMvW29ouDwkxbIYuJO3YDIGyJM9xx7QbfGMbouG?=
 =?us-ascii?q?4gr7WeqPPTt1gGhpdK+xihqs60Ss1+7xWtWu3FtLrCdJitrBu34X2xHQ68WLUP?=
 =?us-ascii?q?hw80O71TqSywze6OdJKl0um6XBMZ4u2Lswm4ITsUvdGi/2n137jLGZdko64Oik?=
 =?us-ascii?q?8efnbav8pp+aKYB0jhvyMqM0msywGeg4Mw4OUHaH+emkyrHv4Un0TK9XgvA4jK?=
 =?us-ascii?q?XVqo3WKMcHqqKjAgJY0J4v6xOlADen1NQYk2MHLFVAeB+fi4jpOlfOIO33DPum?=
 =?us-ascii?q?gFSjji1rx/bYMb3lG5nNKXbCkLH/crZn8ENc1gUzws5F555OCbEOPujzWknvu9?=
 =?us-ascii?q?zcFBM5NBa0w+n/BNVnyoweQX6PArOeMK7KtV+I5+EvLPeWaI4apTbwMPwl5//o?=
 =?us-ascii?q?jX8kll4RZ6ip3Z0LaH+mGvRqOVmWYX3pgt0ZC2cFohI+TPD2iF2FSTNTZ2y9X6?=
 =?us-ascii?q?Mg5j4hD4KqF4fDRp23j7yH0ye2BZlWZmFAClCRHnbkbYSEW/EQaC2MJs9tiCAL?=
 =?us-ascii?q?Vb+kS4U5zxGhqBf6y6Z7LurT4iAYt5Xj28Zv6+3QkhEy8zp0D8OG3mGJTmF0mH?=
 =?us-ascii?q?4IRjAs0KB+p0x91kmM0axij/NEEtxT4utDUh0mOp7E0+x6F9fyVxrbcdeSSFam?=
 =?us-ascii?q?RdamDSsrTt0rwd8DeEJ9G9SkjhDe0CumGb4Vl7qXBJMq9qLQxWT+J8F4y3zezq?=
 =?us-ascii?q?kuk0EmQtdTNW2hnqN/9BLcB4jTn0Wdlqalb6Ic3CHW+WeHzGqOulxYUQFqXaXE?=
 =?us-ascii?q?W3AfelXZrdDj6kzeSL+uDKwtMhFdxs6aNqtKdtrpgE1bS/j5JtTRfXi9m2eqCh?=
 =?us-ascii?q?aO3bODcozqd2IZ3CXeDUgElxse/XKHNQg4GyegrHjSDD1oFVLzfUzs9fNyp2+8?=
 =?us-ascii?q?Tk8x1wuKdVFu16Kp+h4JgvyRU+4c0agauCg/sTl0HEyy39TNC9WeoQpsZ6FcYd?=
 =?us-ascii?q?I74Fda2mPVrQ19Ppq8L698gl4SaRh4v0Tr1x9vEIVPjdAqrG82zAp1Ma+YzFJB?=
 =?us-ascii?q?dzaf3ZDsOr3WKnP+/Ay1Z67RwFHe1NeW+qEA6Pkjr1XjvQepFlct8nl90tlV1W?=
 =?us-ascii?q?ec6YvODAYITZ3xVUM3/QBgp77Geik9+5/U1Xp0PKautj/Nxd0oC/Ulyxq6ZNhf?=
 =?us-ascii?q?Lb6LGxX0E80ZAMiuNvcnm1yobhICIeBT+7Q4P8Kgd/uaxqGrOPxsky6hjWRC+I?=
 =?us-ascii?q?p9yF6D9zJgSu7U2JYI2/GZ3hadWzjgllugs8D3lppCZTEdBWe/zSnkBIhMZqx9?=
 =?us-ascii?q?Z4oLCGGuI9GpydV6nZLiR3lY9Fu7DVMcxMCpYQaSb0D63QBIz0QXoGColjGizz?=
 =?us-ascii?q?NplDEltKyf0zLUw+TjbRYIJnRERG1/gljyO4i0iNYaUVOsbwgokhul+En7y7Ja?=
 =?us-ascii?q?pKR5M2ncX0NIczLqIGFlV6u6rqCCbNJX6JM0rSVXV/yxYFCbSrLnoxoWyTjjH3?=
 =?us-ascii?q?ZYxD0gczGqu5P5nwF1iW6HLXZzqmbZdt90xRvF+NPcQvtR1CIcRCZkkTnXGkS8?=
 =?us-ascii?q?P96x8NWWjZjDqOO+V2GmVpFJaink14CAtCi65W1sHxK/meu+mtnmEQg8zC/62M?=
 =?us-ascii?q?NmVSTOrBbgfIbr0762Pv5gfkltHFX88dZ1Gplikossg5EdwXgbiY+S/XYdk2fz?=
 =?us-ascii?q?MNNb1Ln6bHoMQz4L3tHU7BLk2E1lMnKG2Yb5Wm+BzctmYtmwenkW1T4l78BWFK?=
 =?us-ascii?q?eU66RJnShvrVq5tw7RYeV9kS0byfsh83Mah+AJuAwwziSSGLwSHE9YPTDymBSM?=
 =?us-ascii?q?9dyxsKJXZGO3e7iqyEV+hcyhDK2FogxEXXb5e5QiEjVq4sRxLl3My2Hz5Z/+eN?=
 =?us-ascii?q?bLc90TrBKUngzEj+hULpIxi/ULiTBmOWL7oX0q1eo7gQZy0pG9uYiNM39t876h?=
 =?us-ascii?q?Ah5EKj31YNse+i3qjaZbhMqX3pqgHpN8GjUQR5voTOmlEDYTtfThKgaPHycwqn?=
 =?us-ascii?q?adGbrDAwCf7F1qoG7IE5CuL3uXPmUWzc1+RBmBI0xSmBsbUy89np49CwCm3sjh?=
 =?us-ascii?q?cFpi6zAV5174rAZMy+1yOxn+VGffuBmnajMuRJeDKxpW6xlI513JPsyG8uJzAy?=
 =?us-ascii?q?ZY84WjrAOXL2yUeR9IAXsVWkCeBFDjI7qu5cTG8+eCHeqzNP/OYbSIqexDWPaE?=
 =?us-ascii?q?35Ov0o16/zmSMsWDJGVtD/o+2kBbR3B2B9zZmykTSywQjy/Mb8mbpAql+i1qtM?=
 =?us-ascii?q?+/9u7nWBno5YuJBLtfKtFv+xGwgaeeOO+cnid5KTBE1pwSwX/E0qQQ3FkXiyt2?=
 =?us-ascii?q?bTmiDawAtTLRTKLXgqJXDwAUayJwNMtL7qIwxApNOdTcitP6yLF4lOM1C0xeWF?=
 =?us-ascii?q?zlm8GpY9EKIm6nOFPGAkaLKKqJJTnRz87rZqO8TKVajP9IuB2opTabD0jjMyyZ?=
 =?us-ascii?q?mDn0TB+vK/9DjSGBMBxauYGwaRJtCWnlTNL7ZRy3Kt53jTsqwbIqgnPGL3ITMT?=
 =?us-ascii?q?95c0lVtL2f8TtYguljG2xG9ndlMeiEmyOD4+bEMJoZrftrDTpyl+9B5HQ6yr1V?=
 =?us-ascii?q?7DxLRfBvmSvSqMJurE+ikuWV1jVnVx9OoC5RhI2XpUViJbnZ9p5YVHfE5h0N62?=
 =?us-ascii?q?CQCxUMp9R9C9zvu7pfyt7AlK/oLDdC8tTU/dYTBsTOKcKHNmYhPgTtGDLOEAQF?=
 =?us-ascii?q?SjurZinjgBlZkfeP5jiWo4I8p5zEhpUDUPlYWUYzG/dcDV5qT/IYJ5IicSkpnv?=
 =?us-ascii?q?a4lskB5T+epQPNQcxc9sTITP+dAvXHLDefkKlKYAYOzbrkLIMVcIrh1BoxORFB?=
 =?us-ascii?q?gI3WFh+IDph2qSp7Y1px+R0V/Q=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ANAACK9P9bh0O0hNFkHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBgVqBD4ECJ4N5iBhfinQ1giGIfI40FIFfFBgHDAGHdCI0CQ0BAwE?=
 =?us-ascii?q?BAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmIDAwECIAQLAQ0BATcBBQkBASQCBSECA?=
 =?us-ascii?q?gMMEiURGQWDHAGBaQMVBAEKpRVwfAwngnYBAQWFBw2CFAiBC4Zggw+BHBeBf4E?=
 =?us-ascii?q?RhWk8gVaDHIJXiSkEgW6EDZBPLgmKK4NbgyEjgVqFEIoygnmLaolrgUaCDTMaC?=
 =?us-ascii?q?CgIgycJghIMF38BAodchUA/MoECAwEBIROKOQSCSQEB?=
X-IPAS-Result: =?us-ascii?q?A0ANAACK9P9bh0O0hNFkHAEBAQQBAQcEAQGBUQcBAQsBgVq?=
 =?us-ascii?q?BD4ECJ4N5iBhfinQ1giGIfI40FIFfFBgHDAGHdCI0CQ0BAwEBAQEBAQIBEwEBA?=
 =?us-ascii?q?QgNCQgpIwyCNiQBgmIDAwECIAQLAQ0BATcBBQkBASQCBSECAgMMEiURGQWDHAG?=
 =?us-ascii?q?BaQMVBAEKpRVwfAwngnYBAQWFBw2CFAiBC4Zggw+BHBeBf4ERhWk8gVaDHIJXi?=
 =?us-ascii?q?SkEgW6EDZBPLgmKK4NbgyEjgVqFEIoygnmLaolrgUaCDTMaCCgIgycJghIMF38?=
 =?us-ascii?q?BAodchUA/MoECAwEBIROKOQSCSQEB?=
X-IronPort-AV: E=Sophos;i="5.56,294,1539673200"; 
   d="scan'208";a="54846111"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 29 Nov 2018 06:20:07 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1731219AbeK3BZU (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 29 Nov 2018 20:25:20 -0500
Received: from mail.kernel.org ([198.145.29.99]:48706 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1729806AbeK3BZU (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 29 Nov 2018 20:25:20 -0500
Received: from localhost (5356596B.cm-6-7b.dynamic.ziggo.nl [83.86.89.107])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 6F03D21104;
        Thu, 29 Nov 2018 14:19:48 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1543501188;
        bh=grb06WQifOamFrts22Mt+PXi86axAfRWluDnmcs3hDo=;
        h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
        b=uL7ytdf7Vq+S/h7xlGl7HWlzDFHB3a62jjJTaaT2HRMt7NllmU+eYB5gPVmFUdMLO
         STIWy/BlXe8mu1Ci1y/bswT97smSqaafbAKw5aQZYor+BOJ/W8S+vqCPFvluUlXQb2
         FwU3NhoWYhKKZhY1MXh0GVsojU3rqAtHLgJELPRs=
From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
To: linux-kernel@vger.kernel.org
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        stable@vger.kernel.org,
        "Pierre-Loup A. Griffais" <pgriffais@valvesoftware.com>,
        Pavel Rojtberg <rojtberg@gmail.com>,
        Dmitry Torokhov <dmitry.torokhov@gmail.com>,
        Sasha Levin <sashal@kernel.org>
Subject: [PATCH 4.4 33/86] Input: xpad - handle "present" and "gone" correctly
Date: Thu, 29 Nov 2018 15:11:58 +0100
Message-Id: <20181129140112.841771750@linuxfoundation.org>
X-Mailer: git-send-email 2.19.2
In-Reply-To: <20181129140109.832117862@linuxfoundation.org>
References: <20181129140109.832117862@linuxfoundation.org>
User-Agent: quilt/0.65
X-stable: review
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

4.4-stable review patch.  If anyone has any objections, please let me know.

------------------

[ Upstream commit 09c8b00ae3e16c8d0fd4beb2ca064502a76c0f17 ]

Handle the "a new device is present" message properly by dynamically
creating the input device at this point in time. This means we now do not
"preallocate" all 4 devices when a single wireless base station is seen.
This requires a workqueue as we are in interrupt context when we learn
about this.

Also properly disconnect any devices that we are told are removed.

Signed-off-by: "Pierre-Loup A. Griffais" <pgriffais@valvesoftware.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Pavel Rojtberg <rojtberg@gmail.com>
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 drivers/input/joystick/xpad.c | 107 ++++++++++++++++++++++------------
 1 file changed, 69 insertions(+), 38 deletions(-)

diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index 2f16d07db8ef..88de7b17bf7d 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -76,6 +76,8 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/input.h>
+#include <linux/rcupdate.h>
 #include <linux/slab.h>
 #include <linux/stat.h>
 #include <linux/module.h>
@@ -334,10 +336,12 @@ struct xpad_output_packet {
 
 struct usb_xpad {
 	struct input_dev *dev;		/* input device interface */
+	struct input_dev __rcu *x360w_dev;
 	struct usb_device *udev;	/* usb device */
 	struct usb_interface *intf;	/* usb interface */
 
-	int pad_present;
+	bool pad_present;
+	bool input_created;
 
 	struct urb *irq_in;		/* urb for interrupt in report */
 	unsigned char *idata;		/* input data */
@@ -362,8 +366,12 @@ struct usb_xpad {
 	int xtype;			/* type of xbox device */
 	int pad_nr;			/* the order x360 pads were attached */
 	const char *name;		/* name of the device */
+	struct work_struct work;	/* init/remove device from callback */
 };
 
+static int xpad_init_input(struct usb_xpad *xpad);
+static void xpad_deinit_input(struct usb_xpad *xpad);
+
 /*
  *	xpad_process_packet
  *
@@ -443,11 +451,9 @@ static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *d
  *		http://www.free60.org/wiki/Gamepad
  */
 
-static void xpad360_process_packet(struct usb_xpad *xpad,
+static void xpad360_process_packet(struct usb_xpad *xpad, struct input_dev *dev,
 				   u16 cmd, unsigned char *data)
 {
-	struct input_dev *dev = xpad->dev;
-
 	/* digital pad */
 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
 		/* dpad as buttons (left, right, up, down) */
@@ -514,7 +520,30 @@ static void xpad360_process_packet(struct usb_xpad *xpad,
 	input_sync(dev);
 }
 
-static void xpad_identify_controller(struct usb_xpad *xpad);
+static void xpad_presence_work(struct work_struct *work)
+{
+	struct usb_xpad *xpad = container_of(work, struct usb_xpad, work);
+	int error;
+
+	if (xpad->pad_present) {
+		error = xpad_init_input(xpad);
+		if (error) {
+			/* complain only, not much else we can do here */
+			dev_err(&xpad->dev->dev,
+				"unable to init device: %d\n", error);
+		} else {
+			rcu_assign_pointer(xpad->x360w_dev, xpad->dev);
+		}
+	} else {
+		RCU_INIT_POINTER(xpad->x360w_dev, NULL);
+		synchronize_rcu();
+		/*
+		 * Now that we are sure xpad360w_process_packet is not
+		 * using input device we can get rid of it.
+		 */
+		xpad_deinit_input(xpad);
+	}
+}
 
 /*
  * xpad360w_process_packet
@@ -532,24 +561,28 @@ static void xpad_identify_controller(struct usb_xpad *xpad);
  */
 static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
 {
+	struct input_dev *dev;
+	bool present;
+
 	/* Presence change */
 	if (data[0] & 0x08) {
-		if (data[1] & 0x80) {
-			xpad->pad_present = 1;
-			/*
-			 * Light up the segment corresponding to
-			 * controller number.
-			 */
-			xpad_identify_controller(xpad);
-		} else
-			xpad->pad_present = 0;
+		present = (data[1] & 0x80) != 0;
+
+		if (xpad->pad_present != present) {
+			xpad->pad_present = present;
+			schedule_work(&xpad->work);
+		}
 	}
 
 	/* Valid pad data */
 	if (data[1] != 0x1)
 		return;
 
-	xpad360_process_packet(xpad, cmd, &data[4]);
+	rcu_read_lock();
+	dev = rcu_dereference(xpad->x360w_dev);
+	if (dev)
+		xpad360_process_packet(xpad, dev, cmd, &data[4]);
+	rcu_read_unlock();
 }
 
 /*
@@ -678,7 +711,7 @@ static void xpad_irq_in(struct urb *urb)
 
 	switch (xpad->xtype) {
 	case XTYPE_XBOX360:
-		xpad360_process_packet(xpad, 0, xpad->idata);
+		xpad360_process_packet(xpad, xpad->dev, 0, xpad->idata);
 		break;
 	case XTYPE_XBOX360W:
 		xpad360w_process_packet(xpad, 0, xpad->idata);
@@ -1132,14 +1165,7 @@ static int xpad_led_probe(struct usb_xpad *xpad)
 	if (error)
 		goto err_free_id;
 
-	if (xpad->xtype == XTYPE_XBOX360) {
-		/*
-		 * Light up the segment corresponding to controller
-		 * number on wired devices. On wireless we'll do that
-		 * when they respond to "presence" packet.
-		 */
-		xpad_identify_controller(xpad);
-	}
+	xpad_identify_controller(xpad);
 
 	return 0;
 
@@ -1223,8 +1249,11 @@ static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
 
 static void xpad_deinit_input(struct usb_xpad *xpad)
 {
-	xpad_led_disconnect(xpad);
-	input_unregister_device(xpad->dev);
+	if (xpad->input_created) {
+		xpad->input_created = false;
+		xpad_led_disconnect(xpad);
+		input_unregister_device(xpad->dev);
+	}
 }
 
 static int xpad_init_input(struct usb_xpad *xpad)
@@ -1313,6 +1342,7 @@ static int xpad_init_input(struct usb_xpad *xpad)
 	if (error)
 		goto err_disconnect_led;
 
+	xpad->input_created = true;
 	return 0;
 
 err_disconnect_led:
@@ -1366,6 +1396,7 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 	xpad->mapping = xpad_device[i].mapping;
 	xpad->xtype = xpad_device[i].xtype;
 	xpad->name = xpad_device[i].name;
+	INIT_WORK(&xpad->work, xpad_presence_work);
 
 	if (xpad->xtype == XTYPE_UNKNOWN) {
 		if (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {
@@ -1415,10 +1446,6 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 
 	usb_set_intfdata(intf, xpad);
 
-	error = xpad_init_input(xpad);
-	if (error)
-		goto err_deinit_output;
-
 	if (xpad->xtype == XTYPE_XBOX360W) {
 		/*
 		 * Submit the int URB immediately rather than waiting for open
@@ -1430,7 +1457,7 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 		xpad->irq_in->dev = xpad->udev;
 		error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
 		if (error)
-			goto err_deinit_input;
+			goto err_deinit_output;
 
 		/*
 		 * Send presence packet.
@@ -1442,13 +1469,15 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 		error = xpad_inquiry_pad_presence(xpad);
 		if (error)
 			goto err_kill_in_urb;
+	} else {
+		error = xpad_init_input(xpad);
+		if (error)
+			goto err_deinit_output;
 	}
 	return 0;
 
 err_kill_in_urb:
 	usb_kill_urb(xpad->irq_in);
-err_deinit_input:
-	xpad_deinit_input(xpad);
 err_deinit_output:
 	xpad_deinit_output(xpad);
 err_free_in_urb:
@@ -1465,17 +1494,19 @@ static void xpad_disconnect(struct usb_interface *intf)
 {
 	struct usb_xpad *xpad = usb_get_intfdata (intf);
 
-	xpad_deinit_input(xpad);
-	xpad_deinit_output(xpad);
-
-	if (xpad->xtype == XTYPE_XBOX360W) {
+	if (xpad->xtype == XTYPE_XBOX360W)
 		usb_kill_urb(xpad->irq_in);
-	}
+
+	cancel_work_sync(&xpad->work);
+
+	xpad_deinit_input(xpad);
 
 	usb_free_urb(xpad->irq_in);
 	usb_free_coherent(xpad->udev, XPAD_PKT_LEN,
 			xpad->idata, xpad->idata_dma);
 
+	xpad_deinit_output(xpad);
+
 	kfree(xpad);
 
 	usb_set_intfdata(intf, NULL);
-- 
2.17.1



