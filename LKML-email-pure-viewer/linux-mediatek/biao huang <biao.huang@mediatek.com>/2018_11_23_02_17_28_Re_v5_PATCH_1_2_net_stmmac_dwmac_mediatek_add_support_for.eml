Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 10:36:16 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga004.jf.intel.com (orsmga004.jf.intel.com [10.7.209.38])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id B63DF58037D;
	Thu, 22 Nov 2018 18:20:44 -0800 (PST)
Received: from fmsmga102.fm.intel.com ([10.1.193.69])
  by orsmga004-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 18:20:44 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Ax2FkBhxeqCoWYu7XCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0e8WKvad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWlPUNtRWSJfDI2z?=
 =?us-ascii?q?bYUPAPYGM+hXoIb9vEMOoBmlCAmwBu7i0CNEi2Xq0aA41ekqDAHI3BYnH9ILqH?=
 =?us-ascii?q?nbt9T1O70VUeuozKnI0C/Mb/VZ2Tzg74XHaREhruuLXb5qccrR1FMgFwXKjliL?=
 =?us-ascii?q?rIzqIS6a1uUXvGiH8eVgVvijhHIgqwF0uzWiwNonhIfOhoIQ0F/E9CN5zZ40Jd?=
 =?us-ascii?q?2+Rk57e8SrH4ZOuC6AKoR6WMQiQ3tnuCs817YIuoa7cTAUxJg7wxPTceGLfoaW?=
 =?us-ascii?q?7h75SeqcIit0iGhkdb+9nxq+7FKsxvPgWsS6ylpGsytIn9fWun0OyhDe7NWMRO?=
 =?us-ascii?q?Fn8Ue7wzmP0hje6uFaLkAwkqrWM4AhwrEumZoJq0jDHTH5mF/wjKCIckUo4O+o?=
 =?us-ascii?q?6/7oYrn+p5+cMZF7ih3mP6gwhsCyBf40PhUAUmSF4+iwyb7u8VHjTLhLjPA6iq?=
 =?us-ascii?q?zZv4rbJcQfqK65GQhV0oM75ha7Djem1skYnHYeIFJGZh2HlY7pNE/KIPzhCve+?=
 =?us-ascii?q?jVKsnylxx/3dIL3hDYvCLmLZnLfiY7l98UhcxxQ3zdxF4JJUEL4BLOrpWkDtrN?=
 =?us-ascii?q?zYEgM5MwuszubjCdV91Z0RVXiAA6+EK67StV6I5uQyI+iDfoMVuTD9K+Q76P7q?=
 =?us-ascii?q?l3M2hVgdfayx15sNdH+4BuhmI1meYXf0gtcOC2YKvhYkQ+ztklGCUSNTaGy0X6?=
 =?us-ascii?q?Iz/Tw7DIOmDYHeRoGimrCB3SG7HoFIaWBCEFyDDXDod4CcUfcWdC2SOtNhkiAD?=
 =?us-ascii?q?VbW5SY8h0g+huBX5y7pgKOrU/CoYuInn1Nh04e3TiB4z+SZ1D8Sbz2GCUWV0kn?=
 =?us-ascii?q?kUSD8x2aB1uVZ9xUub0ahkn/xYEsRe6OlSUgc6Mp7czPZ2C8roVQLDZdqJTFem?=
 =?us-ascii?q?QtO7ATA+VN4xwtkOY1pjFNWmlBzMwy2qA7oNnbyRGJM06r7c32T2J8tlyHbJzq?=
 =?us-ascii?q?8hg0MiQstOL2KmgKF/+hPXB47IlUWZiqmreb4d3C7L6GeM026OsFtEXw53VKXP?=
 =?us-ascii?q?RWofaVfOrdTl+kPCSKejBqk9PQtf18GOMKtKZcfvjVVdWvjjPtPSY2aym2e1AR?=
 =?us-ascii?q?aF3beMbIvse2UA0yTREkkEkwYP/XmYMQgyHDuuo2XbDDZ2D1Lgf1vs8fViqHO8?=
 =?us-ascii?q?VkI70huFb1N/2Lav+h4an/qcS+gN0bICoyohrzR0HFCg39PZEdaApgxhfLlCbt?=
 =?us-ascii?q?M5+ltIyWXZtwllNJy6M69inkIecxhwv072yxV3C4BAkc82rHMqzAt+M76Y3ElG?=
 =?us-ascii?q?dzOC2ZDwO7vXKmbp8RCraq7W3Eze0dmM9qcO7vQ4t0vsvAWzGkU+9HVn1sFf02?=
 =?us-ascii?q?GA6ZXSEAoSTZXxX14t+Bh+ub7bbTcy5oPO2XJ3LKm7ryXN29QqBOsi1BatZNNf?=
 =?us-ascii?q?MKKCFA/vHMwWHcmuKOo2m1e3ahIIJvxd9KkxP8m+bfuJxLarPPp8nDKhlWlG4J?=
 =?us-ascii?q?193liQ+CZmS+/I34wKw/eX3gacUzf8jVGhst34mIxeZDESGHa/xjbgBIJLeqJy?=
 =?us-ascii?q?eoMLA3+0I8Kr3tV+m4LtW3lA+V65BlMJxNWmeQCPYFz6xwFQ01oYoWammSeh0z?=
 =?us-ascii?q?N7iTUpobeB0yzUxOTicgEKOmpKRGlkkFftLpK4j9EcXEi0cQcpkAGp6lr9x6he?=
 =?us-ascii?q?vK5/NXXcQV9UfyjqKGFvSquxtruYb89P8p8oqjhXUOKnbFCeS779pQYa0iz5E2?=
 =?us-ascii?q?tfwjA7ay+lupHjkxNmj2KdKW55rGDFdsFo2Rff+NvcSOZT3jUcXil4ijrXBl+m?=
 =?us-ascii?q?M9my59qUlJTDsuG4V22/UJ1eai3rzYKGtCum6mxmGxy/n/avmtL5FQg2yzP019?=
 =?us-ascii?q?5vVS/QthbzfpHr17imMeJgZkRpBEXz681gFoF8k4swgood2XwbhpWT4HoGnn3/?=
 =?us-ascii?q?MdRd2aLicnUNQSQHzMLS4AjgwEdjNG6Gx5rlVnWBxctsf9q6bXkX2i4n78BKFb?=
 =?us-ascii?q?2b7LpLnSZuplq4rATRYeVynzsHyPsu7mIajP8NuAY30iqdBbUSF1FCPSPwjxSI?=
 =?us-ascii?q?88y+rKJPaWaqcLiw11BxkcqvDb6cuQFcRGj2eo05EiBu9MV/P0nB0Hny6oHiZd?=
 =?us-ascii?q?nRYsgfthySkxfckedVLIg9meYNhSpiIWj9p2Eqy/YnjRxy2pG3pJSHK2Jo/K6j?=
 =?us-ascii?q?Ax9XLDv1Z94I+jH2jKZThcKW34GpHpV8FTQHRproTfS0ED0MsfTrLRqBEDo5qn?=
 =?us-ascii?q?2DA7rQARef6Ft6r3LIC52kLGuYJH4dzdV/XhWdIFFfjRsQXDU7mJ45Cw+ryNbg?=
 =?us-ascii?q?cEd/+jAe+Fr4pgFQxeJvMhn1Sn3fqxuwajcoVJifKwJb7gNY6EfQL8Oe9fh/Hz?=
 =?us-ascii?q?1C8p2isQyNKXGbZwJSAmESQUGEA1HjPr+z5djP6eSYB+y+L+fQbrWKs+BRS/CI?=
 =?us-ascii?q?xZe32It84zmMLtmPPmVlD/Aj2ktDWm15G93EmzoVTSwbjTnNb8mdpBez4SB3qs?=
 =?us-ascii?q?G/8PL2WAPg/4ePCr1SMclx9BCym6uMK+mQhCNhIzZCypwM3WPIyKQY3FMKiyFh?=
 =?us-ascii?q?aTitEbcDtS7MVq7QmbVXDxkUayxtLstI8rk80xJJOc7ajNP1y7F5guQ0C1dDSV?=
 =?us-ascii?q?zuhMWpadYWLGG6MVPNHFyLO6ieJT3X38H3ZruxRqdNjOpPrR2/pzaaH1XnPjSC?=
 =?us-ascii?q?jDTpUxGvMedRjCCUJhBeuYe9cgpzBmjnVt7pdhq7MNpvhz0s3bI0nm/KNXIbMT?=
 =?us-ascii?q?Vkb0NNr7iQ4TlEjfllB2NB7mRqLe+fliad7unYLIsWsPRxDiR1keJa/Go1y79P?=
 =?us-ascii?q?4C5YQ/x1nTPYrsRyrFG+jumP1j1nXQJOqzlRgoKLuERiOaPB+ZhBWXbL5hQN7W?=
 =?us-ascii?q?qLBhQOpttlDMDvuq9KxtjOkqLzNClN89bO8cQAAMjULZHPDH10ChfgHnbrBQ0K?=
 =?us-ascii?q?BWqwOGjZwVNUlv669XCPqJU+7J/2l8xdZKVcUQk/F/odQkR4FdoNaMN9Xzoj17?=
 =?us-ascii?q?6GhcgHzX+zoBjYWMhZ+JvAU6TBUr3UND+FgOwcNFMzyrTiINFWb9Wj1g=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ANAAAGY/dbh0O0hNFiHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBgmmBAieDeYgYjgwUlycUgVsYGAsIAYhSIjQJDQEDAQEBAQEBAgE?=
 =?us-ascii?q?TAQEBCA0JCCkjDII2JAGCYQEBAQECAQEBASAERwsFAQkBAQoYAgImAgIDJAEvB?=
 =?us-ascii?q?g4FBYMcAYF5BwEFCqdCfDOKGYELin6BVz+BEYMSgxsBBIEjA4M8glcCiH8aBoF?=
 =?us-ascii?q?yhAhDM0+PJAcCgiCEXIYYhDMKAoIahzuHJ41Dhz6DL4FGgg1wUIJsCYIeF4heh?=
 =?us-ascii?q?UsyAQExgQUBAYxVAQE?=
X-IPAS-Result: =?us-ascii?q?A0ANAAAGY/dbh0O0hNFiHAEBAQQBAQcEAQGBUQcBAQsBgmm?=
 =?us-ascii?q?BAieDeYgYjgwUlycUgVsYGAsIAYhSIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjD?=
 =?us-ascii?q?II2JAGCYQEBAQECAQEBASAERwsFAQkBAQoYAgImAgIDJAEvBg4FBYMcAYF5BwE?=
 =?us-ascii?q?FCqdCfDOKGYELin6BVz+BEYMSgxsBBIEjA4M8glcCiH8aBoFyhAhDM0+PJAcCg?=
 =?us-ascii?q?iCEXIYYhDMKAoIahzuHJ41Dhz6DL4FGgg1wUIJsCYIeF4hehUsyAQExgQUBAYx?=
 =?us-ascii?q?VAQE?=
X-IronPort-AV: E=Sophos;i="5.56,268,1539673200"; 
   d="scan'208";a="54011233"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 18:20:42 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2392958AbeKWM7w (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 07:59:52 -0500
Received: from mailgw02.mediatek.com ([1.203.163.81]:37077 "EHLO
        mailgw02.mediatek.com" rhost-flags-OK-FAIL-OK-FAIL) by vger.kernel.org
        with ESMTP id S1727343AbeKWM7w (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 07:59:52 -0500
X-UUID: 75967576f72e4c3990d65c7339cca4bb-20181123
X-UUID: 75967576f72e4c3990d65c7339cca4bb-20181123
Received: from mtkcas34.mediatek.inc [(172.27.4.250)] by mailgw02.mediatek.com
        (envelope-from <biao.huang@mediatek.com>)
        (mailgw01.mediatek.com ESMTP with TLS)
        with ESMTP id 749348921; Fri, 23 Nov 2018 10:17:31 +0800
Received: from MTKCAS36.mediatek.inc (172.27.4.186) by MTKMBS31N1.mediatek.inc
 (172.27.4.69) with Microsoft SMTP Server (TLS) id 15.0.1395.4; Fri, 23 Nov
 2018 10:17:30 +0800
Received: from [10.17.3.153] (10.17.3.153) by MTKCAS36.mediatek.inc
 (172.27.4.170) with Microsoft SMTP Server id 15.0.1395.4 via Frontend
 Transport; Fri, 23 Nov 2018 10:17:29 +0800
Message-ID: <1542939448.24219.95.camel@mhfsdcap03>
Subject: Re: [v5, PATCH 1/2] net:stmmac: dwmac-mediatek: add support for
 mt2712
From: biao huang <biao.huang@mediatek.com>
To: Sean Wang <sean.wang@kernel.org>
CC: <davem@davemloft.net>, <robh+dt@kernel.org>,
        <mark.rutland@arm.com>, <devicetree@vger.kernel.org>,
        <nelson.chang@mediatek.com>, Andrew Lunn <andrew@lunn.ch>,
        <netdev@vger.kernel.org>, Liguo Zhang <liguo.zhang@mediatek.com>,
        <linux-kernel@vger.kernel.org>,
        Matthias Brugger <matthias.bgg@gmail.com>,
        <joabreu@synopsys.com>, <linux-mediatek@lists.infradead.org>,
        <honghui.zhang@mediatek.com>,
        <linux-arm-kernel@lists.infradead.org>
Date: Fri, 23 Nov 2018 10:17:28 +0800
In-Reply-To: <CAGp9LzoJTVm4OP+SRWCDk0TUmU5jNMFCsT_yyURXzXxjTF+-=g@mail.gmail.com>
References: <1542882521-18874-1-git-send-email-biao.huang@mediatek.com>
         <1542882521-18874-2-git-send-email-biao.huang@mediatek.com>
         <CAGp9LzoJTVm4OP+SRWCDk0TUmU5jNMFCsT_yyURXzXxjTF+-=g@mail.gmail.com>
Content-Type: text/plain; charset="UTF-8"
X-Mailer: Evolution 3.2.3-0ubuntu6 
Content-Transfer-Encoding: 7bit
MIME-Version: 1.0
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Dear Sean,
	Thanks for your comments.

On Thu, 2018-11-22 at 16:54 -0800, Sean Wang wrote:
> On Thu, Nov 22, 2018 at 2:29 AM Biao Huang <biao.huang@mediatek.com> wrote:
> >
> > Add Ethernet support for MediaTek SoCs from the mt2712 family
> >
> > Signed-off-by: Biao Huang <biao.huang@mediatek.com>
> > ---
> >  drivers/net/ethernet/stmicro/stmmac/Kconfig        |    8 +
> >  drivers/net/ethernet/stmicro/stmmac/Makefile       |    1 +
> >  .../net/ethernet/stmicro/stmmac/dwmac-mediatek.c   |  364 ++++++++++++++++++++
> >  3 files changed, 373 insertions(+)
> >  create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
> >
> > diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
> > index 324049e..6209cc1 100644
> > --- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
> > +++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
> > @@ -75,6 +75,14 @@ config DWMAC_LPC18XX
> >         ---help---
> >           Support for NXP LPC18xx/43xx DWMAC Ethernet.
> >
> > +config DWMAC_MEDIATEK
> > +       tristate "MediaTek MT27xx GMAC support"
> > +       depends on OF && (ARCH_MEDIATEK || COMPILE_TEST)
> > +       help
> > +         Support for MediaTek GMAC Ethernet controller.
> > +
> > +         This selects the MT2712 SoC support for the stmmac driver.
> > +
> >  config DWMAC_MESON
> >         tristate "Amlogic Meson dwmac support"
> >         default ARCH_MESON
> > diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
> > index 99967a8..bf09701 100644
> > --- a/drivers/net/ethernet/stmicro/stmmac/Makefile
> > +++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
> > @@ -13,6 +13,7 @@ obj-$(CONFIG_STMMAC_PLATFORM) += stmmac-platform.o
> >  obj-$(CONFIG_DWMAC_ANARION)    += dwmac-anarion.o
> >  obj-$(CONFIG_DWMAC_IPQ806X)    += dwmac-ipq806x.o
> >  obj-$(CONFIG_DWMAC_LPC18XX)    += dwmac-lpc18xx.o
> > +obj-$(CONFIG_DWMAC_MEDIATEK)   += dwmac-mediatek.o
> >  obj-$(CONFIG_DWMAC_MESON)      += dwmac-meson.o dwmac-meson8b.o
> >  obj-$(CONFIG_DWMAC_OXNAS)      += dwmac-oxnas.o
> >  obj-$(CONFIG_DWMAC_ROCKCHIP)   += dwmac-rk.o
> > diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
> > new file mode 100644
> > index 0000000..dd8d4cc
> > --- /dev/null
> > +++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
> > @@ -0,0 +1,364 @@
> > +// SPDX-License-Identifier: GPL-2.0
> > +/*
> > + * Copyright (c) 2018 MediaTek Inc.
> > + */
> > +#include <linux/io.h>
> > +#include <linux/mfd/syscon.h>
> > +#include <linux/of.h>
> > +#include <linux/of_device.h>
> > +#include <linux/of_net.h>
> > +#include <linux/regmap.h>
> > +#include <linux/stmmac.h>
> > +
> > +#include "stmmac.h"
> > +#include "stmmac_platform.h"
> > +
> > +/* Peri Configuration register for mt2712 */
> > +#define PERI_ETH_PHY_INTF_SEL  0x418
> > +#define PHY_INTF_MII_GMII      0
> > +#define PHY_INTF_RGMII         1
> > +#define PHY_INTF_RMII          4
> > +#define RMII_CLK_SRC_RXC       BIT(4)
> > +#define RMII_CLK_SRC_INTERNAL  BIT(5)
> > +
> > +#define PERI_ETH_PHY_DLY       0x428
> > +#define PHY_DLY_GTXC_INV       BIT(6)
> > +#define PHY_DLY_GTXC_ENABLE    BIT(5)
> > +#define PHY_DLY_GTXC_STAGES    GENMASK(4, 0)
> > +#define PHY_DLY_TXC_INV                BIT(20)
> > +#define PHY_DLY_TXC_ENABLE     BIT(19)
> > +#define PHY_DLY_TXC_STAGES     GENMASK(18, 14)
> > +#define PHY_DLY_TXC_SHIFT      14
> > +#define PHY_DLY_RXC_INV                BIT(13)
> > +#define PHY_DLY_RXC_ENABLE     BIT(12)
> > +#define PHY_DLY_RXC_STAGES     GENMASK(11, 7)
> > +#define PHY_DLY_RXC_SHIFT      7
> > +
> > +#define PERI_ETH_DLY_FINE      0x800
> > +#define ETH_RMII_DLY_TX_INV    BIT(2)
> > +#define ETH_FINE_DLY_GTXC      BIT(1)
> > +#define ETH_FINE_DLY_RXC       BIT(0)
> > +
> > +struct mac_delay_struct {
> > +       u32 tx_delay;
> > +       u32 rx_delay;
> > +       u32 tx_inv;
> bool should be enough
yes
> 
> > +       u32 rx_inv;
> bool should be enough
yes
> 
> > +};
> > +
> > +struct mediatek_dwmac_plat_data {
> > +       const struct mediatek_dwmac_variant *variant;
> > +       struct mac_delay_struct mac_delay;
> > +       struct clk_bulk_data *clks;
> > +       struct device_node *np;
> > +       struct regmap *peri_regmap;
> > +       struct device *dev;
> > +       int fine_tune;
> bool
> 
yes
> > +       int phy_mode;
> > +       int rmii_rxc;
> bool
yes
> 
> > +};
> > +
> > +struct mediatek_dwmac_variant {
> > +       int (*dwmac_set_phy_interface)(struct mediatek_dwmac_plat_data *plat);
> > +       int (*dwmac_set_delay)(struct mediatek_dwmac_plat_data *plat);
> > +
> > +       /* clock ids to be requested */
> > +       const char * const *clk_list;
> > +       int num_clks;
> > +
> > +       u32 dma_bit_mask;
> > +       u32 rx_delay_max;
> > +       u32 tx_delay_max;
> > +};
> > +
> > +/* list of clocks required for mac */
> > +static const char * const mt2712_dwmac_clk_l[] = {
> > +       "axi", "apb", "mac_main", "ptp_ref"
> > +};
> > +
> > +static int mt2712_set_interface(struct mediatek_dwmac_plat_data *plat)
> > +{
> > +       int rmii_rxc = plat->rmii_rxc ? RMII_CLK_SRC_RXC : 0;
> > +       u32 intf_val = 0;
> > +
> > +       /* select phy interface in top control domain */
> > +       switch (plat->phy_mode) {
> > +       case PHY_INTERFACE_MODE_MII:
> > +               intf_val |= PHY_INTF_MII_GMII;
> > +               break;
> > +       case PHY_INTERFACE_MODE_RMII:
> > +               intf_val |= PHY_INTF_RMII;
> > +               intf_val |= rmii_rxc;
> how about putting into one line such as intf_val |= (PHY_INTF_RMII | rmii_rxc) ?
> 
ok, will change in next version.
> > +               break;
> > +       case PHY_INTERFACE_MODE_RGMII:
> > +       case PHY_INTERFACE_MODE_RGMII_TXID:
> > +       case PHY_INTERFACE_MODE_RGMII_RXID:
> > +       case PHY_INTERFACE_MODE_RGMII_ID:
> > +               intf_val |= PHY_INTF_RGMII;
> > +               break;
> > +       default:
> > +               dev_err(plat->dev, "phy interface not supported\n");
> > +               return -EINVAL;
> > +       }
> > +
> > +       regmap_write(plat->peri_regmap, PERI_ETH_PHY_INTF_SEL, intf_val);
> > +
> > +       return 0;
> > +}
> > +
> > +static int mt2712_set_delay(struct mediatek_dwmac_plat_data *plat)
> > +{
> > +       struct mac_delay_struct *mac_delay = &plat->mac_delay;
> > +       u32 delay_val = 0;
> > +       u32 fine_val = 0;
> The same type declaration can be put into the one line
> 
Got it.
> > +
> > +       switch (plat->phy_mode) {
> 
> There exists some room for code optimization in the switch statement
> such as PHY_INTERFACE_MODE_MII and PHY_INTERFACE_MODE_RGMII both are
> almost the same and even the configuration for the other PHY modes can
> reuse their partial setup. It appears to be better using a common way
> to set up various PHY modes.
> 
I'll try define a function to handle it.
And how about like this:
	static u32 delay_setting(u32 delay, bool inv, u32 en_bit, u32
clk_shift, u32 clk_mask, u32 inv_bit) {
		u32 value = 0

		value |= delay ? en_bit : 0;
            	value |= (delay << clk_shift) & clk_mask;
              	value |= inv ? inv_bit : 0;
	}

	case PHY_INTERFACE_MODE_MII:
		delay_value |= delay_setting(mac_delay->tx_delay,
					     mac_delay->tx_inv,
					     PHY_DLY_TXC_ENABLE,
					     PHY_DLY_TXC_SHIFT,
					     PHY_DLY_TXC_STAGES,
					     PHY_DLY_TXC_INV);
		delay_value |= delay_setting(mac_delay->rx_delay,
					     mac_delay->rx_inv,
					     PHY_DLY_RXC_ENABLE,
					     PHY_DLY_RXC_SHIFT,
					     PHY_DLY_RXC_STAGES,
					     PHY_DLY_RXC_INV);

	case PHY_INTERFACE_MODE_RMII:
		if (plat->rmii_rxc) {
		     delay_value |= delay_setting(mac_delay->rx_delay,
					         mac_delay->rx_inv,
					         PHY_DLY_RXC_ENABLE,
					         PHY_DLY_RXC_SHIFT,
					         PHY_DLY_RXC_STAGES,
					         PHY_DLY_RXC_INV);
		    fine_val |= mac_delay->tx_inv ?
                                   ETH_RMII_DLY_TX_INV : 0;
		} else {
		     delay_value |= delay_setting(mac_delay->rx_delay,
					         mac_delay->rx_inv,
					         PHY_DLY_TXC_ENABLE,
					         PHY_DLY_TXC_SHIFT,
					         PHY_DLY_TXC_STAGES,
					         PHY_DLY_TXC_INV);
		    fine_val |= mac_delay->tx_inv ?
                                   ETH_RMII_DLY_TX_INV : 0;
		}
	case PHY_INTERFACE_MODE_RGMII:
              fine_val = plat->fine_tune ?
                          (ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC) : 0;
	      delay_value |= delay_setting(mac_delay->tx_delay,
					   mac_delay->tx_inv,
					   PHY_DLY_GTXC_ENABLE,
					   PHY_DLY_GTXC_SHIFT,
					   PHY_DLY_GTXC_STAGES,
					   PHY_DLY_GTXC_INV);
	     delay_value |= delay_setting(mac_delay->rx_delay,
					   mac_delay->rx_inv,
					   PHY_DLY_RXC_ENABLE,
					   PHY_DLY_RXC_SHIFT,
					   PHY_DLY_RXC_STAGES,
					   PHY_DLY_RXC_INV);
	case PHY_INTERFACE_MODE_RGMII_TXID:
              fine_val = plat->fine_tune ? ETH_FINE_DLY_RXC : 0;
	      delay_value |= delay_setting(mac_delay->rx_delay,
					   mac_delay->rx_inv,
					   PHY_DLY_RXC_ENABLE,
					   PHY_DLY_RXC_SHIFT,
					   PHY_DLY_RXC_STAGES,
					   PHY_DLY_RXC_INV);
	case PHY_INTERFACE_MODE_RGMII_RXID:
              fine_val = plat->fine_tune ? ETH_FINE_DLY_GTXC : 0;
	      delay_value |= delay_setting(mac_delay->tx_delay,
					   mac_delay->tx_inv,
					   PHY_DLY_GTXC_ENABLE,
					   PHY_DLY_GTXC_SHIFT,
					   PHY_DLY_GTXC_STAGES,
					   PHY_DLY_GTXC_INV);
	   
> > +       case PHY_INTERFACE_MODE_MII:
> > +               delay_val |= mac_delay->tx_delay ? PHY_DLY_TXC_ENABLE : 0;
> > +               delay_val |= (mac_delay->tx_delay << PHY_DLY_TXC_SHIFT) &
> > +                            PHY_DLY_TXC_STAGES;
> > +               delay_val |= mac_delay->tx_inv ? PHY_DLY_TXC_INV : 0;
> > +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> > +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> > +                            PHY_DLY_RXC_STAGES;
> > +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > +               break;
> > +       case PHY_INTERFACE_MODE_RMII:
> > +               if (plat->rmii_rxc) {
> > +                       delay_val |= mac_delay->rx_delay ?
> > +                                    PHY_DLY_RXC_ENABLE : 0;
> > +                       delay_val |= (mac_delay->rx_delay <<
> > +                                     PHY_DLY_RXC_SHIFT) & PHY_DLY_RXC_STAGES;
> > +                       delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > +                       fine_val |= mac_delay->tx_inv ?
> > +                                    ETH_RMII_DLY_TX_INV : 0;
> why is fine_val got from tx_inv?
> 
becase the tx inv will inverse the tx clock inside mac relative to
reference clock from external phy, and this bit is located in the same
register with fine-tune.
maybe I should rename fine_val to avoid misunderstanding.
> > +               } else {
> > +                       delay_val |= mac_delay->rx_delay ?
> > +                                    PHY_DLY_TXC_ENABLE : 0;
> > +                       delay_val |= (mac_delay->rx_delay <<
> > +                                    PHY_DLY_TXC_SHIFT) & PHY_DLY_TXC_STAGES;
> > +                       delay_val |= mac_delay->rx_inv ? PHY_DLY_TXC_INV : 0;
> > +                       fine_val |= mac_delay->tx_inv ?
> > +                                    ETH_RMII_DLY_TX_INV : 0;
> ditto, why is fine_val got from tx_inv?
> 
same as above. ETH_RMII_DLY_TX_INV is only for RMII, and located in the
same register with fine-tune.
> > +               }
> > +               break;
> > +       case PHY_INTERFACE_MODE_RGMII:
> > +               fine_val = plat->fine_tune ?
> > +                           (ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC) : 0;
> > +               delay_val |= mac_delay->tx_delay ? PHY_DLY_GTXC_ENABLE : 0;
> > +               delay_val |= mac_delay->tx_delay & PHY_DLY_GTXC_STAGES;
> > +               delay_val |= mac_delay->tx_inv ? PHY_DLY_GTXC_INV : 0;
> > +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> > +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> > +                            PHY_DLY_RXC_STAGES;
> > +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > +               break;
> > +       case PHY_INTERFACE_MODE_RGMII_TXID:
> > +               fine_val = plat->fine_tune ? ETH_FINE_DLY_RXC : 0;
> > +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> > +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> > +                            PHY_DLY_RXC_STAGES;
> > +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> why is PHY_INTERFACE_MODE_RGMII_TXID applied with *_RXC_* register
> bits, not with *_TXC_* bits? I'm a little confused about what path the
> register PHY_DLY_RXC_* cause the effects to? MAC to PHY or PHY to MAC?
> 
The PHY_INTERFACE_MODE_RGMII_TXID is defined in
Documentation/networking/phy.txt
means phy will handle delay in tx path, so mac need handle delay in rx
path here.
> > +               break;
> > +       case PHY_INTERFACE_MODE_RGMII_RXID:
> > +               fine_val = plat->fine_tune ? ETH_FINE_DLY_GTXC : 0;
> > +               delay_val |= mac_delay->tx_delay ? PHY_DLY_GTXC_ENABLE : 0;
> > +               delay_val |= mac_delay->tx_delay & PHY_DLY_GTXC_STAGES;
> > +               delay_val |= mac_delay->tx_inv ? PHY_DLY_GTXC_INV : 0;
> ditto, as the above quetion
> 
Similar answer as above.
> > +               break;
> > +       case PHY_INTERFACE_MODE_RGMII_ID:
> > +               break;
> > +       default:
> > +               dev_err(plat->dev, "phy interface not supported\n");
> > +               return -EINVAL;
> > +       }
> > +       regmap_write(plat->peri_regmap, PERI_ETH_PHY_DLY, delay_val);
> > +       regmap_write(plat->peri_regmap, PERI_ETH_DLY_FINE, fine_val);
> > +
> > +       return 0;
> > +}
> > +
> > +static const struct mediatek_dwmac_variant mt2712_gmac_variant = {
> > +               .dwmac_set_phy_interface = mt2712_set_interface,
> > +               .dwmac_set_delay = mt2712_set_delay,
> > +               .clk_list = mt2712_dwmac_clk_l,
> > +               .num_clks = ARRAY_SIZE(mt2712_dwmac_clk_l),
> > +               .dma_bit_mask = 33,
> > +               .rx_delay_max = 32,
> > +               .tx_delay_max = 32,
> > +};
> > +
> > +static int mediatek_dwmac_config_dt(struct mediatek_dwmac_plat_data *plat)
> > +{
> > +       u32 tx_delay, rx_delay;
> > +
> > +       plat->peri_regmap = syscon_regmap_lookup_by_phandle(plat->np, "mediatek,pericfg");
> > +       if (IS_ERR(plat->peri_regmap)) {
> > +               dev_err(plat->dev, "Failed to get pericfg syscon\n");
> > +               return PTR_ERR(plat->peri_regmap);
> > +       }
> > +
> > +       plat->phy_mode = of_get_phy_mode(plat->np);
> > +       if (plat->phy_mode < 0) {
> > +               dev_err(plat->dev, "not find phy-mode\n");
> > +               return -EINVAL;
> > +       }
> > +
> > +       if (!of_property_read_u32(plat->np, "mediatek,tx-delay", &tx_delay)) {
> > +               if (tx_delay < plat->variant->tx_delay_max) {
> > +                       plat->mac_delay.tx_delay = tx_delay;
> > +               } else {
> > +                       dev_err(plat->dev, "Invalid TX clock delay: %d\n", tx_delay);
> > +                       return -EINVAL;
> > +               }
> > +       }
> > +
> > +       if (!of_property_read_u32(plat->np, "mediatek,rx-delay", &rx_delay)) {
> > +               if (rx_delay < plat->variant->rx_delay_max) {
> > +                       plat->mac_delay.rx_delay = rx_delay;
> > +               } else {
> > +                       dev_err(plat->dev, "Invalid RX clock delay: %d\n", rx_delay);
> > +                       return -EINVAL;
> > +               }
> > +       }
> > +
> > +       plat->mac_delay.tx_inv = of_property_read_bool(plat->np, "mediatek,txc-inverse");
> > +       plat->mac_delay.rx_inv = of_property_read_bool(plat->np, "mediatek,rxc-inverse");
> > +       plat->fine_tune = of_property_read_bool(plat->np, "mediatek,fine-tune");
> > +       plat->rmii_rxc = of_property_read_bool(plat->np, "mediatek,rmii-rxc");
> > +
> > +       return 0;
> > +}
> > +
> > +static int mediatek_dwmac_clk_init(struct mediatek_dwmac_plat_data *plat)
> > +{
> > +       const struct mediatek_dwmac_variant *variant = plat->variant;
> > +       int num = variant->num_clks;
> > +       int i;
> put into the same line seems good
> 
ok
> > +
> > +       plat->clks = devm_kcalloc(plat->dev, num, sizeof(*plat->clks), GFP_KERNEL);
> > +       if (!plat->clks)
> > +               return -ENOMEM;
> > +
> > +       for (i = 0; i < num; i++)
> > +               plat->clks[i].id = variant->clk_list[i];
> > +
> > +       return devm_clk_bulk_get(plat->dev, num, plat->clks);
> > +}
> > +
> > +static int mediatek_dwmac_init(struct platform_device *pdev, void *priv)
> > +{
> > +       struct mediatek_dwmac_plat_data *plat = priv;
> > +       const struct mediatek_dwmac_variant *variant = plat->variant;
> > +       int ret = 0;
> zero initialized seems unnecessary
> 
ok, will not initialized here
> > +
> > +       ret = dma_set_mask_and_coherent(plat->dev, DMA_BIT_MASK(variant->dma_bit_mask));
> > +       if (ret) {
> > +               dev_err(plat->dev, "No suitable DMA available, err = %d\n", ret);
> > +               return ret;
> > +       }
> > +
> > +       ret = variant->dwmac_set_phy_interface(plat);
> > +       if (ret) {
> > +               dev_err(plat->dev, "failed to set phy interface, err = %d\n", ret);
> > +               return ret;
> > +       }
> > +
> > +       ret = variant->dwmac_set_delay(plat);
> > +       if (ret) {
> > +               dev_err(plat->dev, "failed to set delay value, err = %d\n", ret);
> > +               return ret;
> > +       }
> > +
> > +       ret = clk_bulk_prepare_enable(variant->num_clks, plat->clks);
> > +       if (ret) {
> > +               dev_err(plat->dev, "failed to enable clks, err = %d\n", ret);
> > +               return ret;
> > +       }
> > +
> > +       return 0;
> > +}
> > +
> > +static void mediatek_dwmac_exit(struct platform_device *pdev, void *priv)
> > +{
> > +       struct mediatek_dwmac_plat_data *plat = priv;
> > +       const struct mediatek_dwmac_variant *variant = plat->variant;
> > +
> > +       clk_bulk_disable_unprepare(variant->num_clks, plat->clks);
> > +}
> > +
> > +static int mediatek_dwmac_probe(struct platform_device *pdev)
> > +{
> > +       struct mediatek_dwmac_plat_data *priv_plat;
> > +       struct plat_stmmacenet_data *plat_dat;
> > +       struct stmmac_resources stmmac_res;
> > +       int ret = 0;
> zero initialized seems unnecessary
> 
ok, will not initialized here
> > +
> > +       priv_plat = devm_kzalloc(&pdev->dev, sizeof(*priv_plat), GFP_KERNEL);
> > +       if (!priv_plat)
> > +               return -ENOMEM;
> > +
> > +       priv_plat->variant = of_device_get_match_data(&pdev->dev);
> > +       if (!priv_plat->variant) {
> > +               dev_err(&pdev->dev, "Missing dwmac-mediatek variant\n");
> > +               return -EINVAL;
> > +       }
> > +
> > +       priv_plat->dev = &pdev->dev;
> > +       priv_plat->np = pdev->dev.of_node;
> > +
> > +       ret = mediatek_dwmac_config_dt(priv_plat);
> > +       if (ret)
> > +               return ret;
> > +
> > +       ret = mediatek_dwmac_clk_init(priv_plat);
> > +       if (ret)
> > +               return ret;
> > +
> > +       ret = stmmac_get_platform_resources(pdev, &stmmac_res);
> > +       if (ret)
> > +               return ret;
> > +
> > +       plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
> > +       if (IS_ERR(plat_dat))
> > +               return PTR_ERR(plat_dat);
> > +
> > +       plat_dat->interface = priv_plat->phy_mode;
> > +       /* clk_csr_i = 250-300MHz & MDC = clk_csr_i/124 */
> > +       plat_dat->clk_csr = 5;
> > +       plat_dat->has_gmac4 = 1;
> > +       plat_dat->has_gmac = 0;
> > +       plat_dat->pmt = 0;
> > +       plat_dat->maxmtu = ETH_DATA_LEN;
> > +       plat_dat->bsp_priv = priv_plat;
> > +       plat_dat->init = mediatek_dwmac_init;
> > +       plat_dat->exit = mediatek_dwmac_exit;
> > +       mediatek_dwmac_init(pdev, priv_plat);
> > +
> > +       ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
> > +       if (ret) {
> > +               stmmac_remove_config_dt(pdev, plat_dat);
> > +               return ret;
> > +       }
> > +
> > +       return 0;
> > +}
> > +
> > +static const struct of_device_id mediatek_dwmac_match[] = {
> > +       { .compatible = "mediatek,mt2712-gmac",
> > +         .data = &mt2712_gmac_variant },
> > +       { }
> > +};
> > +
> > +MODULE_DEVICE_TABLE(of, mediatek_dwmac_match);
> > +
> > +static struct platform_driver mediatek_dwmac_driver = {
> > +       .probe  = mediatek_dwmac_probe,
> > +       .remove = stmmac_pltfr_remove,
> > +       .driver = {
> > +               .name           = "dwmac-mediatek",
> > +               .pm             = &stmmac_pltfr_pm_ops,
> > +               .of_match_table = mediatek_dwmac_match,
> > +       },
> > +};
> > +module_platform_driver(mediatek_dwmac_driver);
> > --
> > 1.7.9.5
> >
> >
> > _______________________________________________
> > Linux-mediatek mailing list
> > Linux-mediatek@lists.infradead.org
> > http://lists.infradead.org/mailman/listinfo/linux-mediatek


