Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 10:36:09 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 5DF7B580460;
	Thu, 22 Nov 2018 16:54:47 -0800 (PST)
Received: from fmsmga102.fm.intel.com ([10.1.193.69])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 16:54:46 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AOLgK7R3suW/BnLAWsmDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?segSLfvxwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfFjfK3SYMkaSHJOUcZfVSNPAo2y?=
 =?us-ascii?q?YYgSAeQfIelYtJH9qlkVoBuiGQWhHv/jxiNUinL026AxzuQvERvB3AwlB98ArW?=
 =?us-ascii?q?rbo8/zNKwPUe+61q/IzTreZP5Rwjfy9pLHchY7rfCCR71wd8XRxFIsFwzblFWQ?=
 =?us-ascii?q?r5LqPzeP2uQKqWib4PNtWOSygGAprAFxpyKgxsYqioTRh4IVzF7E9T9jz4koO9?=
 =?us-ascii?q?K3UlN0bcSjEJtKuCGXMZZ9TMA6Q2xwpio21rkLtYSmcCUE1pgr3QPTZv+bf4SS?=
 =?us-ascii?q?4x/uVv6dLSlkiH9hYr6yhBa//VK+xuHiS8W4ylZHojZDn9LRrH4CzQbT5dKCSv?=
 =?us-ascii?q?Zl/keuxzKP1wfL5+FaLkA7i7DbJ4QiwrEujJoTt1rMHivslEXxlq+WeV0o+umu?=
 =?us-ascii?q?6+v5frXrvoGQO5Nwhw3kL6gjlNKzDf4lPgUNQ2SX4+Wx2b/78U38WrpKj/k2kq?=
 =?us-ascii?q?fDsJDdIMQWvqq5Aw5T0oY+5BezFjSm38oCnXkBMl1FfAuLj4/nOlHIPv/4F+yy?=
 =?us-ascii?q?g0qjkDh13fDKJL7hDYvXLnjFjrjheaxx60lGyAo81dxf/Y5bCqkdIPLvXU/8rN?=
 =?us-ascii?q?jYDh46MwOq2ermB8h925gaWWKOBK+ZLazTvUWJ5uIpP+mDeosVtCzhJPgi4v7k?=
 =?us-ascii?q?lWU5lkMFfam1wZsXb2i1HvR8LEWYfXrjmNABHX0KvgojVuPqjlKCXCVXZ3azWa?=
 =?us-ascii?q?I8+z46BJinDYfFWoCinriB0D2nEZ1RY2BMEkqMHmvwd4WYR/cMbzqfIs1mkjMa?=
 =?us-ascii?q?T7ShSIgh1ReotA/90LdnKuvU+isFtZPsztR15uvTlQ0s+jxwFciSz2aNT2RslG?=
 =?us-ascii?q?MSWzA2xLx/oVB6ylqby6d4mPxYFdtQ5/9TSAc1L5zcwvd+C9DzXALBY9iIREyn?=
 =?us-ascii?q?QtWgHTE+UNYxz8USbEZ6HtWolgrD0DayA78Ji7yLA4Q58qHG0Hj3Pcp9z3fG27?=
 =?us-ascii?q?Mnj1kpWcZPMWymhqhi9wncHYLJkkOZl7q0eqQYxiLC6GCDzW+WtkFCTAFwSbnF?=
 =?us-ascii?q?XWwYZkbOsNv2/F3CQKG0BbQnKARBz9WCJbVMatHuiVVGR/LjONDFbmK1mmewAw?=
 =?us-ascii?q?uIx7yWYIrrfWUdwDvSCEwenw8P+naGMBA0Bj29rGLGEDxuCVXvblvx/uZktnO0?=
 =?us-ascii?q?UFU4zwGQYE1nzLq65BgViOeYS/MS2LIEpSggpy91HFa7w9LZFd6AqxB9c6VbZN?=
 =?us-ascii?q?M3+E1H2n7BtwxhIpygKLhvhkIfcwRyuEPuyxV3C4Vancg2tn8qyxByKaaZ0FNH?=
 =?us-ascii?q?eDOVxpTwOrzRKmnv8xGjca/W2lfC0NmI/qcD8ug3q1LmvAuxDEot721n08VJ03?=
 =?us-ascii?q?ub/pjFFg4SXoz+U0kp9xl2varVYjQg6IzO031sMq60siHZ1tItBeslzAugfthF?=
 =?us-ascii?q?PKOFEg/yD9MVB8y0JOM2nFipawoOPPpO+64sI8Oma/yG1barPeZ9hj6pkX5L4Y?=
 =?us-ascii?q?F90k2W8Sp8RfXF35IEw/GewwuGWC3wjFanssDrh49EYSseEXa4ySjhHIRRfLF9?=
 =?us-ascii?q?fZ4XCWeyJM263s9+h5/xVHFC7l6sGlQG1NWveRWMdVz93BRc2lgNrnyjhCS30S?=
 =?us-ascii?q?Z0kzYvrqeE2CzOwuLidAcIO2JRRWlii0vsLpawj9wAQEeoaA0pngO/5Unm36hb?=
 =?us-ascii?q?uLh/L27LTEZIfij6NWFjXrGrtrqfZc5C85cosSRRUOShblGWUL/9ox0G0yz9G2?=
 =?us-ascii?q?tS3iw0dzavup/hhRx1lHqdLGpvrHreYcxwxw3Q5MbfRf5S2ToKXjJ4hiPUBli/?=
 =?us-ascii?q?Ptmp+8ubl5HYv+C6VmKhUIBTcCbxwYOBsiu7+XNlARmlk/+vnd3nFBAw0TXn2N?=
 =?us-ascii?q?lySSXIsBH8b5Hr1qugNuJrZEtoBF7668dhHoF+k40whIwf2HQAh5WV+2YHnnn3?=
 =?us-ascii?q?MdlBxa3+a38NTyYRw9HJ+AjlxFFjLnWRyoL6THqdw9FtZ9mnYmwM3CI94NtHCK?=
 =?us-ascii?q?OV7LxCgCt0rUC0rQPXYfhhgDgdzeEi52Idg+EMoAAt1DmSAqgOHUlEOizhjxGI?=
 =?us-ascii?q?79G9rKpNfmquf6a/1FFind+/FrGNuR9TWGz2epo5GS9w78N/ME/D0XHp64Hkfs?=
 =?us-ascii?q?XQYswXthGOjxjAiO1VIoorlvUWnSpnJX79vXo9xu4nihxu2Iu2vYmdJGVr4aK5?=
 =?us-ascii?q?GQVYNjzuasMX+zHti7ten8mM04CuGJVhBisEXJ/yQf20FzISsOztNxySHz0ktn?=
 =?us-ascii?q?ebBb3fEBeE50h8qHLPF42rO2uTJHkE1thiQBidJEpCgAEbRjk6n5g5Fhy0y8zl?=
 =?us-ascii?q?akt2+jcR5lvgoBtW1u1oLwX/UnvYpAqwaDc7Up2fIwRN7g1Y+0fZK8+e7v9wHy?=
 =?us-ascii?q?FF+J2utheNJ3efZwRJC2EJR0OFC0riPrmo+dnP7eyYCvCiIPvJZLWEsfZeWOuQ?=
 =?us-ascii?q?xZKzzotm+C6BN8WIPnl/Fv07x1BMXXZjF8TCnDUPTSMXmjnJb86aohe85yJ2ot?=
 =?us-ascii?q?q+8PTtRALg+4+PB6FOPtVo/hC8mb2DOPKIhCZlNTZY0YsBxX/Wx7ge314SiCBu?=
 =?us-ascii?q?eyOuEbQasi7NQ7zfmrVKDx4AcC5zMMpI76Qh3ghCI8Lbi9X11qJmgf4xEVtKSV?=
 =?us-ascii?q?vhmsSxb8wQP269LE/HBFqMNLmePzLL3tr4YbmiRrxQlulUsxywtC2fE0/iODSD?=
 =?us-ascii?q?ijboWwquMeFKkCGUIhhetJuhfRZqDGjpVMjmZQGjMN9rkT02xqU5hm/LNW4ZKz?=
 =?us-ascii?q?Rzb1lBoaGQ7SxGhPVyAGhB7ntjLemZlCeV9ejYKpAKsfR1BiR4jf5V4HM/y7FN?=
 =?us-ascii?q?9iFLWOR1mDfOrt5pu1ynkvOAyjxiUBpPrDZEnIOKvUV4NqXf+ZlNQnLE/BML7W?=
 =?us-ascii?q?WNBBUGvdplCtvzu69OztjDjr78KDBH84GcwcxJDcndL4SHLXMnPjLsFTLVBRcI?=
 =?us-ascii?q?TnigMmSMqVZalaSp+3ST5qczrJekzIEDQ7kdS1UzGdsZB15jEdhEJ414CGB32Y?=
 =?us-ascii?q?WHhdIFsCLt5CLaQ99X69WeDqqf?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AWAAD5Tvdbh0O0hNFiHgEGBwaBUQkLA?=
 =?us-ascii?q?YJpgQIng3mWJBSXJxSBWBsYCwgBiFIiNAkNAQMBAQEBAQECARMBAQEIDQkIKSM?=
 =?us-ascii?q?MgjYkAYJiAQIDAQEBIAQZAQEsCwEFCQEBCgsNAgImAgIDHwUBDAEFARwZBYMcA?=
 =?us-ascii?q?YIBBQqcITyKHXB8M4J2AQEFhxQIgQuJYoEcgVc/gRGDEoMbAQSBI4M/gleJG4Y?=
 =?us-ascii?q?Ad06PJAcCghwEhFyGGIQbGIImjmKNQ4c+gyAPIYElgg0zGjBDMQaCNQmCEgwXi?=
 =?us-ascii?q?F6FXx8ygQUBAYxVAQE?=
X-IPAS-Result: =?us-ascii?q?A0AWAAD5Tvdbh0O0hNFiHgEGBwaBUQkLAYJpgQIng3mWJBS?=
 =?us-ascii?q?XJxSBWBsYCwgBiFIiNAkNAQMBAQEBAQECARMBAQEIDQkIKSMMgjYkAYJiAQIDA?=
 =?us-ascii?q?QEBIAQZAQEsCwEFCQEBCgsNAgImAgIDHwUBDAEFARwZBYMcAYIBBQqcITyKHXB?=
 =?us-ascii?q?8M4J2AQEFhxQIgQuJYoEcgVc/gRGDEoMbAQSBI4M/gleJG4YAd06PJAcCghwEh?=
 =?us-ascii?q?FyGGIQbGIImjmKNQ4c+gyAPIYElgg0zGjBDMQaCNQmCEgwXiF6FXx8ygQUBAYx?=
 =?us-ascii?q?VAQE?=
X-IronPort-AV: E=Sophos;i="5.56,267,1539673200"; 
   d="scan'208";a="54006551"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 16:54:44 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2439226AbeKWLgk (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 06:36:40 -0500
Received: from mail.kernel.org ([198.145.29.99]:58020 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S2392434AbeKWLgj (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 06:36:39 -0500
Received: from mail-wr1-f50.google.com (mail-wr1-f50.google.com [209.85.221.50])
        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 4E4A520866;
        Fri, 23 Nov 2018 00:54:38 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1542934478;
        bh=YiLs5/aHB4nwvO/UFAiLeKz81hheFyQAMpufWFC371A=;
        h=References:In-Reply-To:From:Date:Subject:To:Cc:From;
        b=WgdVxMT3jPrwAL6tPYmhY0K27cfE5zoioya61vKyQcC4fzZ7iZRuwdwHEldY2xZhN
         Gi+Dvk9DL6KI4MxbAAsjCAH4F4VrKa5TR/MzLWJkW1zBlj8WY/zyPd0r5eL86yfbVc
         ldhy+fpdXHTVXjvaCLwp0JqA++2igLHWxVgo/rHE=
Received: by mail-wr1-f50.google.com with SMTP id t3so10779789wrr.3;
        Thu, 22 Nov 2018 16:54:38 -0800 (PST)
X-Gm-Message-State: AA+aEWZIFgoddegvWV2WM88PqiERqwt/grvakYIYC69t+wi2o4hdHGZj
        95SSt9v6zAtIuIbPO3CcuFcqqxpjLABPYfoIEl4=
X-Google-Smtp-Source: AFSGD/VwqS0ajwZmc7CAFn+NMborhUyDL/m8gXqZp2U2BScFSqyBdVKrzgMrNZTVSJZJMvpcMTobWsfdkBF2UdQd2QQ=
X-Received: by 2002:adf:b253:: with SMTP id y19mr10662034wra.184.1542934476701;
 Thu, 22 Nov 2018 16:54:36 -0800 (PST)
MIME-Version: 1.0
References: <1542882521-18874-1-git-send-email-biao.huang@mediatek.com> <1542882521-18874-2-git-send-email-biao.huang@mediatek.com>
In-Reply-To: <1542882521-18874-2-git-send-email-biao.huang@mediatek.com>
From: Sean Wang <sean.wang@kernel.org>
Date: Thu, 22 Nov 2018 16:54:25 -0800
X-Gmail-Original-Message-ID: <CAGp9LzoJTVm4OP+SRWCDk0TUmU5jNMFCsT_yyURXzXxjTF+-=g@mail.gmail.com>
Message-ID: <CAGp9LzoJTVm4OP+SRWCDk0TUmU5jNMFCsT_yyURXzXxjTF+-=g@mail.gmail.com>
Subject: Re: [v5, PATCH 1/2] net:stmmac: dwmac-mediatek: add support for mt2712
To: biao.huang@mediatek.com
Cc: davem@davemloft.net, robh+dt@kernel.org, mark.rutland@arm.com,
        devicetree@vger.kernel.org, nelson.chang@mediatek.com,
        Andrew Lunn <andrew@lunn.ch>, netdev@vger.kernel.org,
        Liguo Zhang <liguo.zhang@mediatek.com>,
        linux-kernel@vger.kernel.org,
        Matthias Brugger <matthias.bgg@gmail.com>,
        joabreu@synopsys.com, linux-mediatek@lists.infradead.org,
        honghui.zhang@mediatek.com, linux-arm-kernel@lists.infradead.org
Content-Type: text/plain; charset="UTF-8"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Thu, Nov 22, 2018 at 2:29 AM Biao Huang <biao.huang@mediatek.com> wrote:
>
> Add Ethernet support for MediaTek SoCs from the mt2712 family
>
> Signed-off-by: Biao Huang <biao.huang@mediatek.com>
> ---
>  drivers/net/ethernet/stmicro/stmmac/Kconfig        |    8 +
>  drivers/net/ethernet/stmicro/stmmac/Makefile       |    1 +
>  .../net/ethernet/stmicro/stmmac/dwmac-mediatek.c   |  364 ++++++++++++++++++++
>  3 files changed, 373 insertions(+)
>  create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
>
> diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
> index 324049e..6209cc1 100644
> --- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
> +++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
> @@ -75,6 +75,14 @@ config DWMAC_LPC18XX
>         ---help---
>           Support for NXP LPC18xx/43xx DWMAC Ethernet.
>
> +config DWMAC_MEDIATEK
> +       tristate "MediaTek MT27xx GMAC support"
> +       depends on OF && (ARCH_MEDIATEK || COMPILE_TEST)
> +       help
> +         Support for MediaTek GMAC Ethernet controller.
> +
> +         This selects the MT2712 SoC support for the stmmac driver.
> +
>  config DWMAC_MESON
>         tristate "Amlogic Meson dwmac support"
>         default ARCH_MESON
> diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
> index 99967a8..bf09701 100644
> --- a/drivers/net/ethernet/stmicro/stmmac/Makefile
> +++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
> @@ -13,6 +13,7 @@ obj-$(CONFIG_STMMAC_PLATFORM) += stmmac-platform.o
>  obj-$(CONFIG_DWMAC_ANARION)    += dwmac-anarion.o
>  obj-$(CONFIG_DWMAC_IPQ806X)    += dwmac-ipq806x.o
>  obj-$(CONFIG_DWMAC_LPC18XX)    += dwmac-lpc18xx.o
> +obj-$(CONFIG_DWMAC_MEDIATEK)   += dwmac-mediatek.o
>  obj-$(CONFIG_DWMAC_MESON)      += dwmac-meson.o dwmac-meson8b.o
>  obj-$(CONFIG_DWMAC_OXNAS)      += dwmac-oxnas.o
>  obj-$(CONFIG_DWMAC_ROCKCHIP)   += dwmac-rk.o
> diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
> new file mode 100644
> index 0000000..dd8d4cc
> --- /dev/null
> +++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-mediatek.c
> @@ -0,0 +1,364 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Copyright (c) 2018 MediaTek Inc.
> + */
> +#include <linux/io.h>
> +#include <linux/mfd/syscon.h>
> +#include <linux/of.h>
> +#include <linux/of_device.h>
> +#include <linux/of_net.h>
> +#include <linux/regmap.h>
> +#include <linux/stmmac.h>
> +
> +#include "stmmac.h"
> +#include "stmmac_platform.h"
> +
> +/* Peri Configuration register for mt2712 */
> +#define PERI_ETH_PHY_INTF_SEL  0x418
> +#define PHY_INTF_MII_GMII      0
> +#define PHY_INTF_RGMII         1
> +#define PHY_INTF_RMII          4
> +#define RMII_CLK_SRC_RXC       BIT(4)
> +#define RMII_CLK_SRC_INTERNAL  BIT(5)
> +
> +#define PERI_ETH_PHY_DLY       0x428
> +#define PHY_DLY_GTXC_INV       BIT(6)
> +#define PHY_DLY_GTXC_ENABLE    BIT(5)
> +#define PHY_DLY_GTXC_STAGES    GENMASK(4, 0)
> +#define PHY_DLY_TXC_INV                BIT(20)
> +#define PHY_DLY_TXC_ENABLE     BIT(19)
> +#define PHY_DLY_TXC_STAGES     GENMASK(18, 14)
> +#define PHY_DLY_TXC_SHIFT      14
> +#define PHY_DLY_RXC_INV                BIT(13)
> +#define PHY_DLY_RXC_ENABLE     BIT(12)
> +#define PHY_DLY_RXC_STAGES     GENMASK(11, 7)
> +#define PHY_DLY_RXC_SHIFT      7
> +
> +#define PERI_ETH_DLY_FINE      0x800
> +#define ETH_RMII_DLY_TX_INV    BIT(2)
> +#define ETH_FINE_DLY_GTXC      BIT(1)
> +#define ETH_FINE_DLY_RXC       BIT(0)
> +
> +struct mac_delay_struct {
> +       u32 tx_delay;
> +       u32 rx_delay;
> +       u32 tx_inv;
bool should be enough

> +       u32 rx_inv;
bool should be enough

> +};
> +
> +struct mediatek_dwmac_plat_data {
> +       const struct mediatek_dwmac_variant *variant;
> +       struct mac_delay_struct mac_delay;
> +       struct clk_bulk_data *clks;
> +       struct device_node *np;
> +       struct regmap *peri_regmap;
> +       struct device *dev;
> +       int fine_tune;
bool

> +       int phy_mode;
> +       int rmii_rxc;
bool

> +};
> +
> +struct mediatek_dwmac_variant {
> +       int (*dwmac_set_phy_interface)(struct mediatek_dwmac_plat_data *plat);
> +       int (*dwmac_set_delay)(struct mediatek_dwmac_plat_data *plat);
> +
> +       /* clock ids to be requested */
> +       const char * const *clk_list;
> +       int num_clks;
> +
> +       u32 dma_bit_mask;
> +       u32 rx_delay_max;
> +       u32 tx_delay_max;
> +};
> +
> +/* list of clocks required for mac */
> +static const char * const mt2712_dwmac_clk_l[] = {
> +       "axi", "apb", "mac_main", "ptp_ref"
> +};
> +
> +static int mt2712_set_interface(struct mediatek_dwmac_plat_data *plat)
> +{
> +       int rmii_rxc = plat->rmii_rxc ? RMII_CLK_SRC_RXC : 0;
> +       u32 intf_val = 0;
> +
> +       /* select phy interface in top control domain */
> +       switch (plat->phy_mode) {
> +       case PHY_INTERFACE_MODE_MII:
> +               intf_val |= PHY_INTF_MII_GMII;
> +               break;
> +       case PHY_INTERFACE_MODE_RMII:
> +               intf_val |= PHY_INTF_RMII;
> +               intf_val |= rmii_rxc;
how about putting into one line such as intf_val |= (PHY_INTF_RMII | rmii_rxc) ?

> +               break;
> +       case PHY_INTERFACE_MODE_RGMII:
> +       case PHY_INTERFACE_MODE_RGMII_TXID:
> +       case PHY_INTERFACE_MODE_RGMII_RXID:
> +       case PHY_INTERFACE_MODE_RGMII_ID:
> +               intf_val |= PHY_INTF_RGMII;
> +               break;
> +       default:
> +               dev_err(plat->dev, "phy interface not supported\n");
> +               return -EINVAL;
> +       }
> +
> +       regmap_write(plat->peri_regmap, PERI_ETH_PHY_INTF_SEL, intf_val);
> +
> +       return 0;
> +}
> +
> +static int mt2712_set_delay(struct mediatek_dwmac_plat_data *plat)
> +{
> +       struct mac_delay_struct *mac_delay = &plat->mac_delay;
> +       u32 delay_val = 0;
> +       u32 fine_val = 0;
The same type declaration can be put into the one line

> +
> +       switch (plat->phy_mode) {

There exists some room for code optimization in the switch statement
such as PHY_INTERFACE_MODE_MII and PHY_INTERFACE_MODE_RGMII both are
almost the same and even the configuration for the other PHY modes can
reuse their partial setup. It appears to be better using a common way
to set up various PHY modes.

> +       case PHY_INTERFACE_MODE_MII:
> +               delay_val |= mac_delay->tx_delay ? PHY_DLY_TXC_ENABLE : 0;
> +               delay_val |= (mac_delay->tx_delay << PHY_DLY_TXC_SHIFT) &
> +                            PHY_DLY_TXC_STAGES;
> +               delay_val |= mac_delay->tx_inv ? PHY_DLY_TXC_INV : 0;
> +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> +                            PHY_DLY_RXC_STAGES;
> +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> +               break;
> +       case PHY_INTERFACE_MODE_RMII:
> +               if (plat->rmii_rxc) {
> +                       delay_val |= mac_delay->rx_delay ?
> +                                    PHY_DLY_RXC_ENABLE : 0;
> +                       delay_val |= (mac_delay->rx_delay <<
> +                                     PHY_DLY_RXC_SHIFT) & PHY_DLY_RXC_STAGES;
> +                       delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> +                       fine_val |= mac_delay->tx_inv ?
> +                                    ETH_RMII_DLY_TX_INV : 0;
why is fine_val got from tx_inv?

> +               } else {
> +                       delay_val |= mac_delay->rx_delay ?
> +                                    PHY_DLY_TXC_ENABLE : 0;
> +                       delay_val |= (mac_delay->rx_delay <<
> +                                    PHY_DLY_TXC_SHIFT) & PHY_DLY_TXC_STAGES;
> +                       delay_val |= mac_delay->rx_inv ? PHY_DLY_TXC_INV : 0;
> +                       fine_val |= mac_delay->tx_inv ?
> +                                    ETH_RMII_DLY_TX_INV : 0;
ditto, why is fine_val got from tx_inv?

> +               }
> +               break;
> +       case PHY_INTERFACE_MODE_RGMII:
> +               fine_val = plat->fine_tune ?
> +                           (ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC) : 0;
> +               delay_val |= mac_delay->tx_delay ? PHY_DLY_GTXC_ENABLE : 0;
> +               delay_val |= mac_delay->tx_delay & PHY_DLY_GTXC_STAGES;
> +               delay_val |= mac_delay->tx_inv ? PHY_DLY_GTXC_INV : 0;
> +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> +                            PHY_DLY_RXC_STAGES;
> +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> +               break;
> +       case PHY_INTERFACE_MODE_RGMII_TXID:
> +               fine_val = plat->fine_tune ? ETH_FINE_DLY_RXC : 0;
> +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> +                            PHY_DLY_RXC_STAGES;
> +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
why is PHY_INTERFACE_MODE_RGMII_TXID applied with *_RXC_* register
bits, not with *_TXC_* bits? I'm a little confused about what path the
register PHY_DLY_RXC_* cause the effects to? MAC to PHY or PHY to MAC?

> +               break;
> +       case PHY_INTERFACE_MODE_RGMII_RXID:
> +               fine_val = plat->fine_tune ? ETH_FINE_DLY_GTXC : 0;
> +               delay_val |= mac_delay->tx_delay ? PHY_DLY_GTXC_ENABLE : 0;
> +               delay_val |= mac_delay->tx_delay & PHY_DLY_GTXC_STAGES;
> +               delay_val |= mac_delay->tx_inv ? PHY_DLY_GTXC_INV : 0;
ditto, as the above quetion

> +               break;
> +       case PHY_INTERFACE_MODE_RGMII_ID:
> +               break;
> +       default:
> +               dev_err(plat->dev, "phy interface not supported\n");
> +               return -EINVAL;
> +       }
> +       regmap_write(plat->peri_regmap, PERI_ETH_PHY_DLY, delay_val);
> +       regmap_write(plat->peri_regmap, PERI_ETH_DLY_FINE, fine_val);
> +
> +       return 0;
> +}
> +
> +static const struct mediatek_dwmac_variant mt2712_gmac_variant = {
> +               .dwmac_set_phy_interface = mt2712_set_interface,
> +               .dwmac_set_delay = mt2712_set_delay,
> +               .clk_list = mt2712_dwmac_clk_l,
> +               .num_clks = ARRAY_SIZE(mt2712_dwmac_clk_l),
> +               .dma_bit_mask = 33,
> +               .rx_delay_max = 32,
> +               .tx_delay_max = 32,
> +};
> +
> +static int mediatek_dwmac_config_dt(struct mediatek_dwmac_plat_data *plat)
> +{
> +       u32 tx_delay, rx_delay;
> +
> +       plat->peri_regmap = syscon_regmap_lookup_by_phandle(plat->np, "mediatek,pericfg");
> +       if (IS_ERR(plat->peri_regmap)) {
> +               dev_err(plat->dev, "Failed to get pericfg syscon\n");
> +               return PTR_ERR(plat->peri_regmap);
> +       }
> +
> +       plat->phy_mode = of_get_phy_mode(plat->np);
> +       if (plat->phy_mode < 0) {
> +               dev_err(plat->dev, "not find phy-mode\n");
> +               return -EINVAL;
> +       }
> +
> +       if (!of_property_read_u32(plat->np, "mediatek,tx-delay", &tx_delay)) {
> +               if (tx_delay < plat->variant->tx_delay_max) {
> +                       plat->mac_delay.tx_delay = tx_delay;
> +               } else {
> +                       dev_err(plat->dev, "Invalid TX clock delay: %d\n", tx_delay);
> +                       return -EINVAL;
> +               }
> +       }
> +
> +       if (!of_property_read_u32(plat->np, "mediatek,rx-delay", &rx_delay)) {
> +               if (rx_delay < plat->variant->rx_delay_max) {
> +                       plat->mac_delay.rx_delay = rx_delay;
> +               } else {
> +                       dev_err(plat->dev, "Invalid RX clock delay: %d\n", rx_delay);
> +                       return -EINVAL;
> +               }
> +       }
> +
> +       plat->mac_delay.tx_inv = of_property_read_bool(plat->np, "mediatek,txc-inverse");
> +       plat->mac_delay.rx_inv = of_property_read_bool(plat->np, "mediatek,rxc-inverse");
> +       plat->fine_tune = of_property_read_bool(plat->np, "mediatek,fine-tune");
> +       plat->rmii_rxc = of_property_read_bool(plat->np, "mediatek,rmii-rxc");
> +
> +       return 0;
> +}
> +
> +static int mediatek_dwmac_clk_init(struct mediatek_dwmac_plat_data *plat)
> +{
> +       const struct mediatek_dwmac_variant *variant = plat->variant;
> +       int num = variant->num_clks;
> +       int i;
put into the same line seems good

> +
> +       plat->clks = devm_kcalloc(plat->dev, num, sizeof(*plat->clks), GFP_KERNEL);
> +       if (!plat->clks)
> +               return -ENOMEM;
> +
> +       for (i = 0; i < num; i++)
> +               plat->clks[i].id = variant->clk_list[i];
> +
> +       return devm_clk_bulk_get(plat->dev, num, plat->clks);
> +}
> +
> +static int mediatek_dwmac_init(struct platform_device *pdev, void *priv)
> +{
> +       struct mediatek_dwmac_plat_data *plat = priv;
> +       const struct mediatek_dwmac_variant *variant = plat->variant;
> +       int ret = 0;
zero initialized seems unnecessary

> +
> +       ret = dma_set_mask_and_coherent(plat->dev, DMA_BIT_MASK(variant->dma_bit_mask));
> +       if (ret) {
> +               dev_err(plat->dev, "No suitable DMA available, err = %d\n", ret);
> +               return ret;
> +       }
> +
> +       ret = variant->dwmac_set_phy_interface(plat);
> +       if (ret) {
> +               dev_err(plat->dev, "failed to set phy interface, err = %d\n", ret);
> +               return ret;
> +       }
> +
> +       ret = variant->dwmac_set_delay(plat);
> +       if (ret) {
> +               dev_err(plat->dev, "failed to set delay value, err = %d\n", ret);
> +               return ret;
> +       }
> +
> +       ret = clk_bulk_prepare_enable(variant->num_clks, plat->clks);
> +       if (ret) {
> +               dev_err(plat->dev, "failed to enable clks, err = %d\n", ret);
> +               return ret;
> +       }
> +
> +       return 0;
> +}
> +
> +static void mediatek_dwmac_exit(struct platform_device *pdev, void *priv)
> +{
> +       struct mediatek_dwmac_plat_data *plat = priv;
> +       const struct mediatek_dwmac_variant *variant = plat->variant;
> +
> +       clk_bulk_disable_unprepare(variant->num_clks, plat->clks);
> +}
> +
> +static int mediatek_dwmac_probe(struct platform_device *pdev)
> +{
> +       struct mediatek_dwmac_plat_data *priv_plat;
> +       struct plat_stmmacenet_data *plat_dat;
> +       struct stmmac_resources stmmac_res;
> +       int ret = 0;
zero initialized seems unnecessary

> +
> +       priv_plat = devm_kzalloc(&pdev->dev, sizeof(*priv_plat), GFP_KERNEL);
> +       if (!priv_plat)
> +               return -ENOMEM;
> +
> +       priv_plat->variant = of_device_get_match_data(&pdev->dev);
> +       if (!priv_plat->variant) {
> +               dev_err(&pdev->dev, "Missing dwmac-mediatek variant\n");
> +               return -EINVAL;
> +       }
> +
> +       priv_plat->dev = &pdev->dev;
> +       priv_plat->np = pdev->dev.of_node;
> +
> +       ret = mediatek_dwmac_config_dt(priv_plat);
> +       if (ret)
> +               return ret;
> +
> +       ret = mediatek_dwmac_clk_init(priv_plat);
> +       if (ret)
> +               return ret;
> +
> +       ret = stmmac_get_platform_resources(pdev, &stmmac_res);
> +       if (ret)
> +               return ret;
> +
> +       plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
> +       if (IS_ERR(plat_dat))
> +               return PTR_ERR(plat_dat);
> +
> +       plat_dat->interface = priv_plat->phy_mode;
> +       /* clk_csr_i = 250-300MHz & MDC = clk_csr_i/124 */
> +       plat_dat->clk_csr = 5;
> +       plat_dat->has_gmac4 = 1;
> +       plat_dat->has_gmac = 0;
> +       plat_dat->pmt = 0;
> +       plat_dat->maxmtu = ETH_DATA_LEN;
> +       plat_dat->bsp_priv = priv_plat;
> +       plat_dat->init = mediatek_dwmac_init;
> +       plat_dat->exit = mediatek_dwmac_exit;
> +       mediatek_dwmac_init(pdev, priv_plat);
> +
> +       ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
> +       if (ret) {
> +               stmmac_remove_config_dt(pdev, plat_dat);
> +               return ret;
> +       }
> +
> +       return 0;
> +}
> +
> +static const struct of_device_id mediatek_dwmac_match[] = {
> +       { .compatible = "mediatek,mt2712-gmac",
> +         .data = &mt2712_gmac_variant },
> +       { }
> +};
> +
> +MODULE_DEVICE_TABLE(of, mediatek_dwmac_match);
> +
> +static struct platform_driver mediatek_dwmac_driver = {
> +       .probe  = mediatek_dwmac_probe,
> +       .remove = stmmac_pltfr_remove,
> +       .driver = {
> +               .name           = "dwmac-mediatek",
> +               .pm             = &stmmac_pltfr_pm_ops,
> +               .of_match_table = mediatek_dwmac_match,
> +       },
> +};
> +module_platform_driver(mediatek_dwmac_driver);
> --
> 1.7.9.5
>
>
> _______________________________________________
> Linux-mediatek mailing list
> Linux-mediatek@lists.infradead.org
> http://lists.infradead.org/mailman/listinfo/linux-mediatek
