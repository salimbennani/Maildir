Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 15:31:44 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 20A8E58037D;
	Thu, 22 Nov 2018 23:04:31 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 23:04:30 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Ayv8P0h+o0EUOVf9uRHKM819IXTAuvvDOBiVQ1KB9?=
 =?us-ascii?q?1+kVIJqq85mqBkHD//Il1AaPAd2Lraocw8Pt8InYEVQa5piAtH1QOLdtbDQizf?=
 =?us-ascii?q?ssogo7HcSeAlf6JvO5JwYzHcBFSUM3tyrjaRsdF8nxfUDdrWOv5jAOBBr/KRB1?=
 =?us-ascii?q?JuPoEYLOksi7ze+/94HQbglSmDaxfa55IQmrownWqsQYm5ZpJLwryhvOrHtIeu?=
 =?us-ascii?q?BWyn1tKFmOgRvy5dq+8YB6/ShItP0v68BPUaPhf6QlVrNYFygpM3o05MLwqxbO?=
 =?us-ascii?q?SxaE62YGXWUXlhpIBBXF7A3/U5zsvCb2qvZx1S+HNsDtU7s6RSqt4LtqSB/wiS?=
 =?us-ascii?q?cIKTg58H3MisdtiK5XuQ+tqwBjz4LRZoyeKfhwcb7Hfd4CSmVBUMReWSxPDI2/?=
 =?us-ascii?q?coUBEfYOPf1Ar4T/vFYOsQeyCBOwCO/z1jNFhHn71rA63eQ7FgHG2RQtEc8Qv3?=
 =?us-ascii?q?vOqtX+KacdXvqzzKnH0D7OaOhW1inn54jOaBwgr+uDXbR/ccfKykkgCRnFjlOO?=
 =?us-ascii?q?pozhJT+V0f4Ns2eC4udmSOmhiHYnphlvrjSzwsogkJTFi4wLxlze6Cl0w5o5Kc?=
 =?us-ascii?q?e5RUN5edKoDodcuiWAO4Z1Qs4uWXxktDg5x7EcuZO3YC4Hw4k9yRHFcfyIaY2I?=
 =?us-ascii?q?7wrjVOmPJTd4g2poeKywhxms60is0O78Wdeu0FZMsCVFlsPAtncX1xzc8sSHS/?=
 =?us-ascii?q?198Vm92TuXyQzf9uVJLVopmafVNZIt2KM8m5kPvUjZHyL7ml36jKqMeUUl/uio?=
 =?us-ascii?q?5f7nYrLjppKEM490iwf+Mrkhm8CmAuQ3LBIOX26F9uS4zbHj+kP4QLNUgf0sia?=
 =?us-ascii?q?TZrp/aKtoBpqKjAA9azJwj6xChADeiytgYmmMHLF1ddBKdk4fpI03OIOz/Dfqn?=
 =?us-ascii?q?h1SskTRryO7cMrzuH5XANXzDkLbnfbZg5E9Q0gszzdZD551KDrENOu78Wkj0tN?=
 =?us-ascii?q?bAFB82LxS0w/r7CNV6zo4eWXiAAq6FMKzItl+E/OIvI/SWa48TtzbwMPwl5//o?=
 =?us-ascii?q?jX8kll4RZ6ip3Z0LaH+mGvRqOVmWYX3pgt0ZC2cFohI+TPD2iF2FSTNTZXGyUL?=
 =?us-ascii?q?wm6jE4D4KmC4HDRoe2jbyF3Se7GIBWZ29cBlCNF3foa5uLW/MWZC2OJc9hlyQO?=
 =?us-ascii?q?VaK9RI85yRGuqAj6xqJ9IerP+i0YspHj2MJv5+LJlxE/7jh0D8Wb02GQQGB4hG?=
 =?us-ascii?q?IIRzkq3K9hpUxx0EuM0a99g/ZAD9xc++tJUhsmNZ7b1+F6CMr9WgTbcteNSVap?=
 =?us-ascii?q?WNOmAT4qQ9I1wt8OZVt9Gtq4ghDC2SqqH6Eal7iRCJMo9aLc2mD7J9xhxHbeyK?=
 =?us-ascii?q?khk14mT9NSOmK8mK5w6RLfB47TnEWfjKala6Ic0CnJ9GeAyGqOuFpVUApxUaXD?=
 =?us-ascii?q?QHAeaVHardX/5kPeUbCuDa4rPRdGyc6HMqFKcMHmjU1aRPf/P9TTe3++lH2uBR?=
 =?us-ascii?q?mW3L+MbJDle2MG3CrDDkgJiAQT/XeANQgjCSatuWPeDDpyFV3xZ0Pg6/VxqHS+?=
 =?us-ascii?q?TkUs1QGFc1Vh16ap+h4SnfGcV/IT3rcDuCc9qzV1HEyx387MB9qHvQpheKRcYd?=
 =?us-ascii?q?Uy4Fpc0WLZtgp9PoGvLqx4h14edRh3sF3q1xltFopAls0qpmswzAVuMaKYzE9B?=
 =?us-ascii?q?dzSA0J/qPr3YNGbz8w6vaqLMwV7ezcuZ9b0J6PQ7rFXjohqkFk4j83VhztlU3G?=
 =?us-ascii?q?GQ5pTMDAoOT53xVlw7+AR9p7HfeiM9/Z/b1WVwMamotT/Pw9IoBPY/xhm8Zdte?=
 =?us-ascii?q?MaOEGxX0E80VHMWuLO0qm160bhMLJuxS9ag0P9+4ePuCwqKkIOFgnDe+h2Rd/I?=
 =?us-ascii?q?99yl6M9zZ7SuPQxZYFwu2X0RGdVzjhi1etqMb3lp5eZTETB2aw1TLrBIpMaaJs?=
 =?us-ascii?q?Z4YLDmGuLtazxtV/gZ7tRnFZ+ESiB1MAxM+mZx6SY0bh0g1X0EQduWanljegzz?=
 =?us-ascii?q?xojzEpqbKS3SzPw+j4dBsLIHVLRHRkjVr3JYi0jtYaXFWnbgQzlRul41r6yLZf?=
 =?us-ascii?q?pKhlM2bTRkJIdTDsL25+SquwqqaCY8lX5ZMqqypXSue8YVOdSrLnuBsVySDjH2?=
 =?us-ascii?q?hfxDA9aT6qvI70nxh7iGKbMXZyo2DVecB2xRfD+tPcQeRd0SYBRCl9kTPXHESz?=
 =?us-ascii?q?P8G1/dWIkJfOquC/WHimVpFJcynrzIWAuTC/5W1rBx2/gv+ylsfmEQg8zS/0yd?=
 =?us-ascii?q?1qWT/Uoxb7Z4nhz766Pv5/fkl0GF/87NJ3GoJknYsxnp0Q2WUaiY+T/XoIimrz?=
 =?us-ascii?q?NdRb2aTjbHsCXzILwtjV4BT7101nNH6G24X5VnCFyMt7e9a6en8W2j46781SDa?=
 =?us-ascii?q?eU7b9EkjFvrlu2sw3ReuR9kSkHyfQ19nEame4JtREpziWcBLASAEZZMTbtlxSO?=
 =?us-ascii?q?89CxsqFXaHyzfri30Up0hcqhA62aogFARHb5fY8vHTN37sV6Kl7N0Wf86of5eN?=
 =?us-ascii?q?nLdtITtwaZkxPBj+hTNZIwmeAGhSthOWLho3Ilz/Q3ggBp3ZG/pIKHMXli/Lql?=
 =?us-ascii?q?Ah5EMT34f9gc9SvqjaZag8aaxYSvHoh6FzUPXZvoS++oET0IufTmMQaODCMzqn?=
 =?us-ascii?q?OBFbXDGg+f7V9sr2jTHJCzK3GXOH4ZwM1gRBaHIUxQnhsUUC8mnpIjFQCq2c/h?=
 =?us-ascii?q?cFp/5j8L/V71sR9MyuNuNxniXWbTvgaoajEoSJeBKBpa9B1N50DQMcaG9OJ8Az?=
 =?us-ascii?q?lY/oG9rAyKMmGaZwNIDXwQWkyZHV/jOKOi5cLH8+ieCeqzNP/OYbSIqexDWPaE?=
 =?us-ascii?q?35Ov0o16/zmSMsWDJGVtD/o+2kBbR3B2B9zZmykTSywQjy/Nb9CUpBa/+i10r8?=
 =?us-ascii?q?Cz6vfrWBjo5YuAFbRSK8hv+wutjKeHNu6Qgjt5KDlC2pMNw3/I1KYQ3FoIhy5y?=
 =?us-ascii?q?cDmtFKwKtTTRQ6LIhq9XExkbZjtpO8tV9K08xBdCOM7BhtPx1751lfo1C1ZDVV?=
 =?us-ascii?q?z8lcClf80KI2ehNFzZAEaHLqiJJTrOw8vve6OzVaVQjPlItx23oTubD07jPjGZ?=
 =?us-ascii?q?mzb1TRygLeFMgz+dPBFFvIG9cxBtCXXsTd78ax27NsN3giMywbEumnzKMmscOy?=
 =?us-ascii?q?Bmc0xRtr2Q8T9YgvJnFm1B9HVlK+yEmyef7+bAK5cWseFkAiJ7l+9B5HQ6yr1V?=
 =?us-ascii?q?7DxLRfBvmSvSqMJurE+ikuWV1jVnVx9O+X53g9eBvExlf6XE/59PcXPJ8BME8W?=
 =?us-ascii?q?iTTR8NoohLENrq7ptdw96Hq6v1J38W6N/d+40DDs7bAMGKKnwsNVzuAjGCX1hN?=
 =?us-ascii?q?diKiKWyK3x8Vq/qV7HDA68Fi8pU=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0DAAwC9pfdbh0O0hNFiHAECHwQBBgGBT?=
 =?us-ascii?q?QKBVIIWJ4N5lBaCDRSXJ4IHKwGIUiI2Bw0BAwEBAQEBAQIBEwEBAQgNCQgpIwy?=
 =?us-ascii?q?CNiQBgmIBAgIBAQIgBBkBATcBBAEJAQEKCw8CJgICAx8SAQUBHB6DHIF6CAWbY?=
 =?us-ascii?q?TyKHXB8M4J2AQEFhxMIgQuJYoEcgVc/gRGDEogCgleJARoGhnFOjyQHAoIcBI8?=
 =?us-ascii?q?PGJEImCEPIYEsAYIFMxowdAaCNYInF4hehV8fMoEFAQGMIgEB?=
X-IPAS-Result: =?us-ascii?q?A0DAAwC9pfdbh0O0hNFiHAECHwQBBgGBTQKBVIIWJ4N5lBa?=
 =?us-ascii?q?CDRSXJ4IHKwGIUiI2Bw0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmIBAgIBA?=
 =?us-ascii?q?QIgBBkBATcBBAEJAQEKCw8CJgICAx8SAQUBHB6DHIF6CAWbYTyKHXB8M4J2AQE?=
 =?us-ascii?q?FhxMIgQuJYoEcgVc/gRGDEogCgleJARoGhnFOjyQHAoIcBI8PGJEImCEPIYEsA?=
 =?us-ascii?q?YIFMxowdAaCNYInF4hehV8fMoEFAQGMIgEB?=
X-IronPort-AV: E=Sophos;i="5.56,268,1539673200"; 
   d="scan'208";a="41956408"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 23:04:28 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2408237AbeKWRrV (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 12:47:21 -0500
Received: from mail.kernel.org ([198.145.29.99]:41008 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S2389987AbeKWRrV (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 12:47:21 -0500
Received: from mail-wm1-f50.google.com (mail-wm1-f50.google.com [209.85.128.50])
        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 445F420874;
        Fri, 23 Nov 2018 07:04:23 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1542956663;
        bh=qBa5vrTxQm3PLD6hqDROz7PebumvAvHgRVL5lfDzj8M=;
        h=References:In-Reply-To:From:Date:Subject:To:Cc:From;
        b=ee0yQpbcMDvDi4GnZpw7O7FxMMOledv/eiiCDtzvcHIKN6HkVFEtsPBd5tvLa386R
         UBwuSUxyNkjPYFz5BBDF0OV9fHGIymTdMYnLnODV+IE6IV3oyPthVxo0U5ZZLF+Cxe
         pfJPsgahluQJERAeRRUsvyGOr/s5H0XrZcKdtdkM=
Received: by mail-wm1-f50.google.com with SMTP id y1so7633931wmi.3;
        Thu, 22 Nov 2018 23:04:23 -0800 (PST)
X-Gm-Message-State: AGRZ1gI98ytPW++MVjgn1ERxKPi2k/34BEb80XxGshHp4JgF+fZSOAcL
        bhqP+lpuXJ9/U+NZozspzsc6kj8hJN6BMXp9gNc=
X-Google-Smtp-Source: AFSGD/Ux+MOCCKren5OeDh7gJtT6ra2N2V6YT1MFSuHpbfjkQndo74Jmfb63XPIj4qKXvsuNcYq0GEZez/Tzn6tVsTw=
X-Received: by 2002:a1c:8d86:: with SMTP id p128-v6mr13334457wmd.48.1542956661620;
 Thu, 22 Nov 2018 23:04:21 -0800 (PST)
MIME-Version: 1.0
References: <1542882521-18874-1-git-send-email-biao.huang@mediatek.com>
 <1542882521-18874-2-git-send-email-biao.huang@mediatek.com>
 <CAGp9LzoJTVm4OP+SRWCDk0TUmU5jNMFCsT_yyURXzXxjTF+-=g@mail.gmail.com> <1542939448.24219.95.camel@mhfsdcap03>
In-Reply-To: <1542939448.24219.95.camel@mhfsdcap03>
From: Sean Wang <sean.wang@kernel.org>
Date: Thu, 22 Nov 2018 23:04:09 -0800
X-Gmail-Original-Message-ID: <CAGp9LzrdwXqQ+aHtCoKcxKx28xR21hKnpc+ruW4Gt7TyQLffsA@mail.gmail.com>
Message-ID: <CAGp9LzrdwXqQ+aHtCoKcxKx28xR21hKnpc+ruW4Gt7TyQLffsA@mail.gmail.com>
Subject: Re: [v5, PATCH 1/2] net:stmmac: dwmac-mediatek: add support for mt2712
To: biao.huang@mediatek.com
Cc: davem@davemloft.net, robh+dt@kernel.org, mark.rutland@arm.com,
        devicetree@vger.kernel.org, nelson.chang@mediatek.com,
        Andrew Lunn <andrew@lunn.ch>, netdev@vger.kernel.org,
        Liguo Zhang <liguo.zhang@mediatek.com>,
        linux-kernel@vger.kernel.org,
        Matthias Brugger <matthias.bgg@gmail.com>,
        joabreu@synopsys.com, linux-mediatek@lists.infradead.org,
        honghui.zhang@mediatek.com, linux-arm-kernel@lists.infradead.org
Content-Type: text/plain; charset="UTF-8"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

< ... >

> > > +       /* select phy interface in top control domain */
> > > +       switch (plat->phy_mode) {
> > > +       case PHY_INTERFACE_MODE_MII:
> > > +               intf_val |= PHY_INTF_MII_GMII;
> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RMII:
> > > +               intf_val |= PHY_INTF_RMII;
> > > +               intf_val |= rmii_rxc;
> > how about putting into one line such as intf_val |= (PHY_INTF_RMII | rmii_rxc) ?
> >
> ok, will change in next version.
> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RGMII:
> > > +       case PHY_INTERFACE_MODE_RGMII_TXID:
> > > +       case PHY_INTERFACE_MODE_RGMII_RXID:
> > > +       case PHY_INTERFACE_MODE_RGMII_ID:
> > > +               intf_val |= PHY_INTF_RGMII;
> > > +               break;
> > > +       default:
> > > +               dev_err(plat->dev, "phy interface not supported\n");
> > > +               return -EINVAL;
> > > +       }
> > > +
> > > +       regmap_write(plat->peri_regmap, PERI_ETH_PHY_INTF_SEL, intf_val);
> > > +
> > > +       return 0;
> > > +}
> > > +
> > > +static int mt2712_set_delay(struct mediatek_dwmac_plat_data *plat)
> > > +{
> > > +       struct mac_delay_struct *mac_delay = &plat->mac_delay;
> > > +       u32 delay_val = 0;
> > > +       u32 fine_val = 0;
> > The same type declaration can be put into the one line
> >
> Got it.
> > > +
> > > +       switch (plat->phy_mode) {
> >
> > There exists some room for code optimization in the switch statement
> > such as PHY_INTERFACE_MODE_MII and PHY_INTERFACE_MODE_RGMII both are
> > almost the same and even the configuration for the other PHY modes can
> > reuse their partial setup. It appears to be better using a common way
> > to set up various PHY modes.
> >
> I'll try define a function to handle it.
> And how about like this:
>         static u32 delay_setting(u32 delay, bool inv, u32 en_bit, u32
> clk_shift, u32 clk_mask, u32 inv_bit) {
>                 u32 value = 0
>
>                 value |= delay ? en_bit : 0;
>                 value |= (delay << clk_shift) & clk_mask;
>                 value |= inv ? inv_bit : 0;
>         }
>
>         case PHY_INTERFACE_MODE_MII:
>                 delay_value |= delay_setting(mac_delay->tx_delay,
>                                              mac_delay->tx_inv,
>                                              PHY_DLY_TXC_ENABLE,
>                                              PHY_DLY_TXC_SHIFT,
>                                              PHY_DLY_TXC_STAGES,
>                                              PHY_DLY_TXC_INV);

We can reuse FIELD_PREP defined in include/linux/bitfield.h to make up
of the value instead of creating your own function delay_setting here,
 and also PHY_DLY_TXC_SHIFT macro can be trimmed while you're using
FIED_PREP

>                 delay_value |= delay_setting(mac_delay->rx_delay,
>                                              mac_delay->rx_inv,
>                                              PHY_DLY_RXC_ENABLE,
>                                              PHY_DLY_RXC_SHIFT,
>                                              PHY_DLY_RXC_STAGES,
>                                              PHY_DLY_RXC_INV);
>
>         case PHY_INTERFACE_MODE_RMII:
>                 if (plat->rmii_rxc) {
>                      delay_value |= delay_setting(mac_delay->rx_delay,
>                                                  mac_delay->rx_inv,
>                                                  PHY_DLY_RXC_ENABLE,
>                                                  PHY_DLY_RXC_SHIFT,
>                                                  PHY_DLY_RXC_STAGES,
>                                                  PHY_DLY_RXC_INV);
>                     fine_val |= mac_delay->tx_inv ?
>                                    ETH_RMII_DLY_TX_INV : 0;
>                 } else {
>                      delay_value |= delay_setting(mac_delay->rx_delay,
>                                                  mac_delay->rx_inv,

shoudn't the parametors be mac_delay->tx_delay and mac_delay->tx_inv?

>                                                  PHY_DLY_TXC_ENABLE,
>                                                  PHY_DLY_TXC_SHIFT,
>                                                  PHY_DLY_TXC_STAGES,
>                                                  PHY_DLY_TXC_INV);
>                     fine_val |= mac_delay->tx_inv ?
>                                    ETH_RMII_DLY_TX_INV : 0;

if (plat->tx_inv)
      fine_val = ETH_RMII_DLY_TX_INV;
the default fine_val is zero so zero assignement can be trimmed when
!plat-> tx_inv

>                 }
>         case PHY_INTERFACE_MODE_RGMII:
>               fine_val = plat->fine_tune ?
>                           (ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC) : 0;

if (plat->fine_tune)
      fine_val = ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC;
the default fine_val is zero so zero assignement can be trimmed when
!plat->fine_tune

>               delay_value |= delay_setting(mac_delay->tx_delay,
>                                            mac_delay->tx_inv,
>                                            PHY_DLY_GTXC_ENABLE,
>                                            PHY_DLY_GTXC_SHIFT,
>                                            PHY_DLY_GTXC_STAGES,
>                                            PHY_DLY_GTXC_INV);
>              delay_value |= delay_setting(mac_delay->rx_delay,
>                                            mac_delay->rx_inv,
>                                            PHY_DLY_RXC_ENABLE,
>                                            PHY_DLY_RXC_SHIFT,
>                                            PHY_DLY_RXC_STAGES,
>                                            PHY_DLY_RXC_INV);
>         case PHY_INTERFACE_MODE_RGMII_TXID:
>               fine_val = plat->fine_tune ? ETH_FINE_DLY_RXC : 0;
>               delay_value |= delay_setting(mac_delay->rx_delay,
>                                            mac_delay->rx_inv,
>                                            PHY_DLY_RXC_ENABLE,
>                                            PHY_DLY_RXC_SHIFT,
>                                            PHY_DLY_RXC_STAGES,
>                                            PHY_DLY_RXC_INV);
>         case PHY_INTERFACE_MODE_RGMII_RXID:
>               fine_val = plat->fine_tune ? ETH_FINE_DLY_GTXC : 0;
>               delay_value |= delay_setting(mac_delay->tx_delay,
>                                            mac_delay->tx_inv,
>                                            PHY_DLY_GTXC_ENABLE,
>                                            PHY_DLY_GTXC_SHIFT,
>                                            PHY_DLY_GTXC_STAGES,
>                                            PHY_DLY_GTXC_INV);
>

phy_mode is used to indicate what phy mode would be tweaked when mac
is connected to the phy so I thought mac delay can be independent from
phy internal delay  that means PHY_INTERFACE_MODE_RGMII_RXID and
PHY_INTERFACE_MODE_RGMII_TXID can apply the same setting as
PHY_INTERFACE_MODE_RGMII does.

> > > +       case PHY_INTERFACE_MODE_MII:
> > > +               delay_val |= mac_delay->tx_delay ? PHY_DLY_TXC_ENABLE : 0;
> > > +               delay_val |= (mac_delay->tx_delay << PHY_DLY_TXC_SHIFT) &
> > > +                            PHY_DLY_TXC_STAGES;
> > > +               delay_val |= mac_delay->tx_inv ? PHY_DLY_TXC_INV : 0;
> > > +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> > > +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> > > +                            PHY_DLY_RXC_STAGES;
> > > +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RMII:
> > > +               if (plat->rmii_rxc) {
> > > +                       delay_val |= mac_delay->rx_delay ?
> > > +                                    PHY_DLY_RXC_ENABLE : 0;
> > > +                       delay_val |= (mac_delay->rx_delay <<
> > > +                                     PHY_DLY_RXC_SHIFT) & PHY_DLY_RXC_STAGES;
> > > +                       delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > > +                       fine_val |= mac_delay->tx_inv ?
> > > +                                    ETH_RMII_DLY_TX_INV : 0;
> > why is fine_val got from tx_inv?
> >
> becase the tx inv will inverse the tx clock inside mac relative to
> reference clock from external phy, and this bit is located in the same
> register with fine-tune.
> maybe I should rename fine_val to avoid misunderstanding.

If you add more comments to say that, fine_val remains would be okay

> > > +               } else {
> > > +                       delay_val |= mac_delay->rx_delay ?
> > > +                                    PHY_DLY_TXC_ENABLE : 0;
> > > +                       delay_val |= (mac_delay->rx_delay <<
> > > +                                    PHY_DLY_TXC_SHIFT) & PHY_DLY_TXC_STAGES;
> > > +                       delay_val |= mac_delay->rx_inv ? PHY_DLY_TXC_INV : 0;
> > > +                       fine_val |= mac_delay->tx_inv ?
> > > +                                    ETH_RMII_DLY_TX_INV : 0;
> > ditto, why is fine_val got from tx_inv?
> >
> same as above. ETH_RMII_DLY_TX_INV is only for RMII, and located in the
> same register with fine-tune.

adding a fewer comments helps to avoid some confusion

> > > +               }
> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RGMII:
> > > +               fine_val = plat->fine_tune ?
> > > +                           (ETH_FINE_DLY_GTXC | ETH_FINE_DLY_RXC) : 0;
> > > +               delay_val |= mac_delay->tx_delay ? PHY_DLY_GTXC_ENABLE : 0;
> > > +               delay_val |= mac_delay->tx_delay & PHY_DLY_GTXC_STAGES;
> > > +               delay_val |= mac_delay->tx_inv ? PHY_DLY_GTXC_INV : 0;
> > > +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> > > +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> > > +                            PHY_DLY_RXC_STAGES;
> > > +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RGMII_TXID:
> > > +               fine_val = plat->fine_tune ? ETH_FINE_DLY_RXC : 0;
> > > +               delay_val |= mac_delay->rx_delay ? PHY_DLY_RXC_ENABLE : 0;
> > > +               delay_val |= (mac_delay->rx_delay << PHY_DLY_RXC_SHIFT) &
> > > +                            PHY_DLY_RXC_STAGES;
> > > +               delay_val |= mac_delay->rx_inv ? PHY_DLY_RXC_INV : 0;
> > why is PHY_INTERFACE_MODE_RGMII_TXID applied with *_RXC_* register
> > bits, not with *_TXC_* bits? I'm a little confused about what path the
> > register PHY_DLY_RXC_* cause the effects to? MAC to PHY or PHY to MAC?
> >
> The PHY_INTERFACE_MODE_RGMII_TXID is defined in
> Documentation/networking/phy.txt
> means phy will handle delay in tx path, so mac need handle delay in rx
> path here.

See the above explains: phy_mode is used to indicate what phy mode
would be tweaked when mac is connected to the phy so I thought mac
delay can be independent of phy internal delay that means
PHY_INTERFACE_MODE_RGMII_RXID and PHY_INTERFACE_MODE_RGMII_TXID can
apply the same setting as PHY_INTERFACE_MODE_RGMII does.

> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RGMII_RXID:
> > > +               fine_val = plat->fine_tune ? ETH_FINE_DLY_GTXC : 0;
> > > +               delay_val |= mac_delay->tx_delay ? PHY_DLY_GTXC_ENABLE : 0;
> > > +               delay_val |= mac_delay->tx_delay & PHY_DLY_GTXC_STAGES;
> > > +               delay_val |= mac_delay->tx_inv ? PHY_DLY_GTXC_INV : 0;
> > ditto, as the above quetion
> >
> Similar answer as above.
> > > +               break;
> > > +       case PHY_INTERFACE_MODE_RGMII_ID:
> > > +               break;
> > > +       default:
> > > +               dev_err(plat->dev, "phy interface not supported\n");
> > > +               return -EINVAL;
> > > +       }
> > > +       regmap_write(plat->peri_regmap, PERI_ETH_PHY_DLY, delay_val);
> > > +       regmap_write(plat->peri_regmap, PERI_ETH_DLY_FINE, fine_val);
> > > +
> > > +       return 0;
> > > +}
> > > +
> > > +static const struct mediatek_dwmac_variant mt2712_gmac_variant = {
> > > +               .dwmac_set_phy_interface = mt2712_set_interface,
> > > +               .dwmac_set_delay = mt2712_set_delay,
> > > +               .clk_list = mt2712_dwmac_clk_l,
> > > +               .num_clks = ARRAY_SIZE(mt2712_dwmac_clk_l),
> > > +               .dma_bit_mask = 33,
> > > +               .rx_delay_max = 32,
> > > +               .tx_delay_max = 32,
> > > +};
> > > +
> > > +static int mediatek_dwmac_config_dt(struct mediatek_dwmac_plat_data *plat)
> > > +{
> > > +       u32 tx_delay, rx_delay;
> > > +
> > > +       plat->peri_regmap = syscon_regmap_lookup_by_phandle(plat->np, "mediatek,pericfg");

you're also missing the property definition in dt-binding.

> > > +       if (IS_ERR(plat->peri_regmap)) {
> > > +               dev_err(plat->dev, "Failed to get pericfg syscon\n");
> > > +               return PTR_ERR(plat->peri_regmap);
> > > +       }
> > > +
> > > +       plat->phy_mode = of_get_phy_mode(plat->np);
> > > +       if (plat->phy_mode < 0) {
> > > +               dev_err(plat->dev, "not find phy-mode\n");
> > > +               return -EINVAL;
> > > +       }
> > > +
> > > +       if (!of_property_read_u32(plat->np, "mediatek,tx-delay", &tx_delay)) {
> > > +               if (tx_delay < plat->variant->tx_delay_max) {
> > > +                       plat->mac_delay.tx_delay = tx_delay;
> > > +               } else {
> > > +                       dev_err(plat->dev, "Invalid TX clock delay: %d\n", tx_delay);
> > > +                       return -EINVAL;
> > > +               }
> > > +       }
> > > +
> > > +       if (!of_property_read_u32(plat->np, "mediatek,rx-delay", &rx_delay)) {
> > > +               if (rx_delay < plat->variant->rx_delay_max) {
> > > +                       plat->mac_delay.rx_delay = rx_delay;
> > > +               } else {
> > > +                       dev_err(plat->dev, "Invalid RX clock delay: %d\n", rx_delay);
> > > +                       return -EINVAL;
> > > +               }
> > > +       }
> > > +
> > > +       plat->mac_delay.tx_inv = of_property_read_bool(plat->np, "mediatek,txc-inverse");
> > > +       plat->mac_delay.rx_inv = of_property_read_bool(plat->np, "mediatek,rxc-inverse");
> > > +       plat->fine_tune = of_property_read_bool(plat->np, "mediatek,fine-tune");
> > > +       plat->rmii_rxc = of_property_read_bool(plat->np, "mediatek,rmii-rxc");
> > > +
> > > +       return 0;
> > > +}
> > > +
> > > +static int mediatek_dwmac_clk_init(struct mediatek_dwmac_plat_data *plat)
> > > +{
> > > +       const struct mediatek_dwmac_variant *variant = plat->variant;
> > > +       int num = variant->num_clks;
> > > +       int i;
> > put into the same line seems good
> >
> ok
> > > +
> > > +       plat->clks = devm_kcalloc(plat->dev, num, sizeof(*plat->clks), GFP_KERNEL);
> > > +       if (!plat->clks)
> > > +               return -ENOMEM;
> > > +
> > > +       for (i = 0; i < num; i++)
> > > +               plat->clks[i].id = variant->clk_list[i];
> > > +
> > > +       return devm_clk_bulk_get(plat->dev, num, plat->clks);
> > > +}
> > > +
> > > +static int mediatek_dwmac_init(struct platform_device *pdev, void *priv)
> > > +{
> > > +       struct mediatek_dwmac_plat_data *plat = priv;
> > > +       const struct mediatek_dwmac_variant *variant = plat->variant;
> > > +       int ret = 0;
> > zero initialized seems unnecessary
> >
> ok, will not initialized here
> > > +
> > > +       ret = dma_set_mask_and_coherent(plat->dev, DMA_BIT_MASK(variant->dma_bit_mask));
> > > +       if (ret) {
> > > +               dev_err(plat->dev, "No suitable DMA available, err = %d\n", ret);
> > > +               return ret;
> > > +       }
> > > +
> > > +       ret = variant->dwmac_set_phy_interface(plat);
> > > +       if (ret) {
> > > +               dev_err(plat->dev, "failed to set phy interface, err = %d\n", ret);
> > > +               return ret;
> > > +       }
> > > +
> > > +       ret = variant->dwmac_set_delay(plat);
> > > +       if (ret) {
> > > +               dev_err(plat->dev, "failed to set delay value, err = %d\n", ret);
> > > +               return ret;
> > > +       }
> > > +
> > > +       ret = clk_bulk_prepare_enable(variant->num_clks, plat->clks);
> > > +       if (ret) {
> > > +               dev_err(plat->dev, "failed to enable clks, err = %d\n", ret);
> > > +               return ret;
> > > +       }
> > > +
> > > +       return 0;
> > > +}
> > > +
> > > +static void mediatek_dwmac_exit(struct platform_device *pdev, void *priv)
> > > +{
> > > +       struct mediatek_dwmac_plat_data *plat = priv;
> > > +       const struct mediatek_dwmac_variant *variant = plat->variant;
> > > +
> > > +       clk_bulk_disable_unprepare(variant->num_clks, plat->clks);
> > > +}
> > > +
> > > +static int mediatek_dwmac_probe(struct platform_device *pdev)
> > > +{
> > > +       struct mediatek_dwmac_plat_data *priv_plat;
> > > +       struct plat_stmmacenet_data *plat_dat;
> > > +       struct stmmac_resources stmmac_res;
> > > +       int ret = 0;
> > zero initialized seems unnecessary
> >
> ok, will not initialized here
> > > +
> > > +       priv_plat = devm_kzalloc(&pdev->dev, sizeof(*priv_plat), GFP_KERNEL);
> > > +       if (!priv_plat)
> > > +               return -ENOMEM;
> > > +
> > > +       priv_plat->variant = of_device_get_match_data(&pdev->dev);
> > > +       if (!priv_plat->variant) {
> > > +               dev_err(&pdev->dev, "Missing dwmac-mediatek variant\n");
> > > +               return -EINVAL;
> > > +       }
> > > +
> > > +       priv_plat->dev = &pdev->dev;
> > > +       priv_plat->np = pdev->dev.of_node;
> > > +
> > > +       ret = mediatek_dwmac_config_dt(priv_plat);
> > > +       if (ret)
> > > +               return ret;
> > > +
> > > +       ret = mediatek_dwmac_clk_init(priv_plat);
> > > +       if (ret)
> > > +               return ret;
> > > +
> > > +       ret = stmmac_get_platform_resources(pdev, &stmmac_res);
> > > +       if (ret)
> > > +               return ret;
> > > +

< ... >
