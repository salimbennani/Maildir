Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:36:03 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 7995F58037D;
	Fri, 23 Nov 2018 08:42:09 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by fmsmga001-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 08:42:08 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AG78fIhVwLzw8EZ+qzojyaHGJNCTV8LGtZVwlr6E/?=
 =?us-ascii?q?grcLSJyIuqrYZhCFvadThVPEFb/W9+hDw7KP9fy4CSpYud6oizMrSNR0TRgLiM?=
 =?us-ascii?q?EbzUQLIfWuLgnFFsPsdDEwB89YVVVorDmROElRH9viNRWJ+iXhpTEdFQ/iOgVr?=
 =?us-ascii?q?O+/7BpDdj9it1+C15pbffxhEiCCybL9uLxi6txndutULioZ+N6g9zQfErGFVcO?=
 =?us-ascii?q?pM32NoIlyTnxf45siu+ZNo7jpdtfE8+cNeSKv2Z6s3Q6BWAzQgKGA1+dbktQLf?=
 =?us-ascii?q?QguV53sTSXsZnxxVCAXY9h76X5Pxsizntuph3SSRIMP7QawoVTmk8qxmUwHjhj?=
 =?us-ascii?q?sZODEl8WHXks1wg7xdoBK9vBx03orYbJiIOPZiYq/ReNUXTndDUMlMTSxMGoOy?=
 =?us-ascii?q?YZUSAeQPPuhWqJL9p0MMoBalGQWgGPnixiNSi3PqwaE31fkqHwHc3AwnGtIDqH?=
 =?us-ascii?q?Dao8vuNKcJUOC60LPHxijBYPNLxDzw74rIfQ4hoPGRRr9wctTeyVMpFwzbilWc?=
 =?us-ascii?q?s4vlPyma1ukUtWWQ8uluVfq3hmI5tw18piKjytoih4XXnI4Z11PJ+TljzIs0J9?=
 =?us-ascii?q?C0UFN3bNqkHZdKqi2XOYt7Ttk8T212pSo20KMKtJimdyYQ0psn3QTQa/mffoiI?=
 =?us-ascii?q?/B3jUOGRLC9mhHJqZr2/nQy+8Uu+xe3mUMm7zlJKojBCktnWuXABzx3T6s6ZRf?=
 =?us-ascii?q?th5kqtxyqD2gTJ5u1ZL004i7DXJ4Miz7IsjJYesEbOEjfzmErsja+Wcksk+vKv?=
 =?us-ascii?q?6+Tierjmop6cN4lpigDxK6gumdKwAf4+MgcQW2iX4OO81bPl/ULnWrVHleM2kq?=
 =?us-ascii?q?bHv5DAP8gbpbC2AxVT0ok97xazFTCm0M4XnXUfNlJKZAqHj5T1O1HJOP34Cfa/?=
 =?us-ascii?q?g1eynztxyPHGI6bsApHMLnjFjbfgcqxx609ayAov099f44hYBa0GIPL2QkXxrs?=
 =?us-ascii?q?DXDgclMwyoxObqENV92ZkfWWKTGKCZN7nesV+V5u01JemMa5QYuDL8K/gj+v7v?=
 =?us-ascii?q?gmU1mV4bfam1w5QXbGq0EehhI0WceXDsmMsOEX8WvgoiS+znkF+CUTlNaHqoXK?=
 =?us-ascii?q?I84Tc7CIShDYrYQoCtgbqB3Dq0H5FMZ2BGDEyMHmnsd4meR/gMbyeSKNd7kjMY?=
 =?us-ascii?q?TbihV5Mh1Ra2uQDg0LpnLu3U+i4CuZL5ztd15fbelRUz9TxyEsSc3HuBT2Bynm?=
 =?us-ascii?q?MUWTA22LpzrlB6yleGyaJ4meBXFcRP5/NVVQc3LZ3cwPZ8C9zoXgLBf82GSFCp?=
 =?us-ascii?q?Qti9BTExT9Qxw8IBYkpnGtWiiAzD0DSuA7MPi7OLA5k0+LrG33ftP8Z912rG1K?=
 =?us-ascii?q?45glY7WMRPK3OpirR/9wfJAY7JiFuWl6CteaQY3y7N8WODwHGKvEFZVg5wTKrE?=
 =?us-ascii?q?UWoeZkvQsdT2+EfCQ6WyBrQgNwtL0dSCJbdSat31kVVGQ+/uN8nEbGKvhWi8Hx?=
 =?us-ascii?q?aIyamKbIrxZWod2j7QCEwFkwAV4HaHOhIyBiano2LCEjNuEUjjbF/r8el7sHm7?=
 =?us-ascii?q?VFM7zxmWb0190Lq44gIVhf2ZS/MUwrIEuCcgpy9oHFqn2NLWEd6ApwtnfKVTet?=
 =?us-ascii?q?495FZH1WTEtw1yJJCgLqZihkIAfARzpU/hyxJ3CoBYm8gwsHwq1BZyKb6f0F5Z?=
 =?us-ascii?q?bTyY2Y7/O7LJJWjy5hygcLPW1UzE39aQ+acP7+o4pk7nvAGoEEoi7npm38NU03?=
 =?us-ascii?q?ua+pXFEg4SXYjtXUYw8hhwv6vabTUl54PIyX1sNrG5sz/f294zGOQp0Behf9dF?=
 =?us-ascii?q?P6OCGw//CMkaB8moKOw3lFmldBMEPOZO9KEqO8OqbeeJ2KmuPOx4hjKpkXxH4J?=
 =?us-ascii?q?xh0kKL7yd8UO/I0IofzPGCwwSHUC3wjFG/vcDtmIBIfC0dEXC7ySf5GoFRfKpy?=
 =?us-ascii?q?fYAQBGeqIs23wMh+hpH3V35Z8l6jG00J2MuzdRWOaFz92BVa1V4Lrny/hSu40z?=
 =?us-ascii?q?t0nikpr6qexiDPw/7udAEaOm5NX2RiiVbsIY6pj9EVRkSobg4plAe76kb+3aRU?=
 =?us-ascii?q?uKN/L2zLS0dSYyf2N31iUre3treaYc5A8okosSZUUOS7e1yaUaTyoxgZ0yPiGW?=
 =?us-ascii?q?tR2jY7eiquupX4mRx6lW2cIGxyrHrfZcF/2xPf6MbASv5W2zoMXDN4hiXPBlig?=
 =?us-ascii?q?I9mp+s2ZlpfZveC5TW6hVJxTcS/wwIOEtSu743BqABKlk/CynN3nDRY10Svh29?=
 =?us-ascii?q?Z2UiXIqQ72YpP32KSiLeJnYk5oCUf/68VgG4FyiIswhIwK1ngciZWY5n4HkWb1?=
 =?us-ascii?q?MdVG1qPydnsNRTgXw9HL5AjpwlFsLnWMx4jhTHWS3tNhZ8WmYmMRwi896sFKCK?=
 =?us-ascii?q?SO47Bekyp6vEG4rR7PbvhnhTgS1+Eu6HEBjuENuQotyDidA78IEUlZOyzsiwqH?=
 =?us-ascii?q?79SkoKpLY2avdKC61FBiktC5ELGCvgZcVW7lepclGC989MR+P0jK0H3u8YHkY9?=
 =?us-ascii?q?jQYMkXth2VlRfAkudUJIgwlvoMmSpoJ2b9sWc5xO48iBxkxYu6s5SfK2Vx4KK5?=
 =?us-ascii?q?BQZVOSbvaMMU/jHtkLxSnsKL3420GpVhGzMLXIbnTP6yETISs+jnOBiKEDEmtn?=
 =?us-ascii?q?ibHr/fFxeF6Eh6t3LPD4yrN3aPKXkb19piQQeSJFdFjAAIRjk6nYM5FgO3xMzn?=
 =?us-ascii?q?akh5/Ssc5lr5qhtK1+JpOAPzUmbZpAe0dDg0TIKTIwZR7gFH/03VK9CR7vpvHy?=
 =?us-ascii?q?FE+Z2stAyMKmuGZwRREGEGQEqEC0r4Prmp49nA/POVBu6/L/vIfLWPpvZSV/aO?=
 =?us-ascii?q?xZKzzIRm+yyAOdmIPnlnF/c7wFZMXWhlG8TFnDUCUywXmDzMb86Ypxe8+zd7rs?=
 =?us-ascii?q?Ol8PTsVwLg+5GPC6ZJMdh0/xC2gKGDN/OfhSpjKDZY0I8MymHMyLQFwFESjCRu?=
 =?us-ascii?q?fSG3EbscrS7NUL7QmqhPAhEBdiN8L9FI4Lw83wVXPc7bi8j41rp5jv4zFldEWk?=
 =?us-ascii?q?btmsCvZcwWPW69MEnLC1qMNLSDPTfL2d34YbugSb1Mi+VZrwGwuTeeE0P5IjuP?=
 =?us-ascii?q?jSXmVxCxPuFKlyybOB1euIegchdiE2TjTdTmagGlP99zlzE53bo0hnbSP24GLT?=
 =?us-ascii?q?d8a19NrqGX7S5AgvRwAWpB7n9kLemCgymY7unYJYwQsftkGSl0k+Na4HIny7pa?=
 =?us-ascii?q?9i1ERfp1mDfMod5quV2pju6Pyj80GCZJ/zJKgp+b+EZvI6PU8rFeVnveuhEA92?=
 =?us-ascii?q?OdD1INvdQ2JMfovvVyx8PUlan6YAZfu4bW8NoBL8vZMsSKNDwmKxW/S22cNxcM?=
 =?us-ascii?q?UTP+bTKXvEdaivzHsyTN9pU=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AkAQBtLfhbh0O0hNFjgheDbCeEW4gVi?=
 =?us-ascii?q?yGCIWaWQYF2ERgTAYhaIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjDII2JAGCaQI?=
 =?us-ascii?q?kGQEBNwEFCQJQA20FgxyCAgQBph6BbDOCdgEBBYJDhFIIh16DD4EcF4FAP4ERg?=
 =?us-ascii?q?hRJiw6JJYV2kGkJDZEXCxiJXIcsmDCBRoINfQg7gmyCJxcSiEyFPz8ygQUBAYw?=
 =?us-ascii?q?hAQE?=
X-IPAS-Result: =?us-ascii?q?A0AkAQBtLfhbh0O0hNFjgheDbCeEW4gViyGCIWaWQYF2ERg?=
 =?us-ascii?q?TAYhaIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjDII2JAGCaQIkGQEBNwEFCQJQA?=
 =?us-ascii?q?20FgxyCAgQBph6BbDOCdgEBBYJDhFIIh16DD4EcF4FAP4ERghRJiw6JJYV2kGk?=
 =?us-ascii?q?JDZEXCxiJXIcsmDCBRoINfQg7gmyCJxcSiEyFPz8ygQUBAYwhAQE?=
X-IronPort-AV: E=Sophos;i="5.56,270,1539673200"; 
   d="scan'208";a="53475987"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 08:41:27 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2440663AbeKXD0T (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 22:26:19 -0500
Received: from mail.kernel.org ([198.145.29.99]:51316 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1730360AbeKXD0T (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 22:26:19 -0500
Received: from linux-8ccs.suse.de (nat.nue.novell.com [195.135.221.2])
        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 6470C20659;
        Fri, 23 Nov 2018 16:41:20 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1542991281;
        bh=J3vO6H0YiiJdMxR+5Qw1fEniZkiFowp6lz9dyjQTKwc=;
        h=From:To:Cc:Subject:Date:From;
        b=QNrEYwmmMo79v9e3heQKRpCPH+z+dxWSxKwKgx0TZEZU6Fg1d9rzXf+x2sruNWT4f
         YX7UmJ3kYVDeZoXZSXeH9pqRojBg23uP0zVIeco9eOgovimjRpVw1VhVGPRtfJ6FME
         SRmecwLf0Hvf95SI63UfjeU+J9Ecxur/Z2cJhfuI=
From: Jessica Yu <jeyu@kernel.org>
To: linux-kernel@vger.kernel.org
Cc: Miroslav Benes <mbenes@suse.cz>, Jessica Yu <jeyu@kernel.org>
Subject: [PATCH v2] module: make it clearer when we're handling kallsyms symbols vs exported symbols
Date: Fri, 23 Nov 2018 17:41:04 +0100
Message-Id: <20181123164104.6054-1-jeyu@kernel.org>
X-Mailer: git-send-email 2.16.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

The module loader internally works with both exported symbols
represented as struct kernel_symbol, as well as Elf symbols from a
module's symbol table. It's hard to distinguish sometimes which type of
symbol we're handling given that some helper function names are not
consistent or helpful. Take get_ksymbol() for instance - are we
looking for an exported symbol or a kallsyms symbol here? Or symname()
and kernel_symbol_name() - which function handles an exported symbol and
which one an Elf symbol?

Clean up and unify the function naming scheme a bit to make it clear
which kind of symbol we're handling. This change only affects static
functions internal to the module loader.

Signed-off-by: Jessica Yu <jeyu@kernel.org>
---

v2: renamed kallsyms_find_* funcs to find_kallsyms_* to follow the
    already existing <verb>_<noun> naming convention in module.c

 kernel/module.c | 78 ++++++++++++++++++++++++++++++++-------------------------
 1 file changed, 44 insertions(+), 34 deletions(-)

diff --git a/kernel/module.c b/kernel/module.c
index 49a405891587..1b5edf78694c 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -495,9 +495,9 @@ struct find_symbol_arg {
 	const struct kernel_symbol *sym;
 };
 
-static bool check_symbol(const struct symsearch *syms,
-				 struct module *owner,
-				 unsigned int symnum, void *data)
+static bool check_exported_symbol(const struct symsearch *syms,
+				  struct module *owner,
+				  unsigned int symnum, void *data)
 {
 	struct find_symbol_arg *fsa = data;
 
@@ -555,9 +555,9 @@ static int cmp_name(const void *va, const void *vb)
 	return strcmp(a, kernel_symbol_name(b));
 }
 
-static bool find_symbol_in_section(const struct symsearch *syms,
-				   struct module *owner,
-				   void *data)
+static bool find_exported_symbol_in_section(const struct symsearch *syms,
+					    struct module *owner,
+					    void *data)
 {
 	struct find_symbol_arg *fsa = data;
 	struct kernel_symbol *sym;
@@ -565,13 +565,14 @@ static bool find_symbol_in_section(const struct symsearch *syms,
 	sym = bsearch(fsa->name, syms->start, syms->stop - syms->start,
 			sizeof(struct kernel_symbol), cmp_name);
 
-	if (sym != NULL && check_symbol(syms, owner, sym - syms->start, data))
+	if (sym != NULL && check_exported_symbol(syms, owner,
+						 sym - syms->start, data))
 		return true;
 
 	return false;
 }
 
-/* Find a symbol and return it, along with, (optional) crc and
+/* Find an exported symbol and return it, along with, (optional) crc and
  * (optional) module which owns it.  Needs preempt disabled or module_mutex. */
 const struct kernel_symbol *find_symbol(const char *name,
 					struct module **owner,
@@ -585,7 +586,7 @@ const struct kernel_symbol *find_symbol(const char *name,
 	fsa.gplok = gplok;
 	fsa.warn = warn;
 
-	if (each_symbol_section(find_symbol_in_section, &fsa)) {
+	if (each_symbol_section(find_exported_symbol_in_section, &fsa)) {
 		if (owner)
 			*owner = fsa.owner;
 		if (crc)
@@ -2198,7 +2199,7 @@ EXPORT_SYMBOL_GPL(__symbol_get);
  *
  * You must hold the module_mutex.
  */
-static int verify_export_symbols(struct module *mod)
+static int verify_exported_symbols(struct module *mod)
 {
 	unsigned int i;
 	struct module *owner;
@@ -2519,10 +2520,10 @@ static void free_modinfo(struct module *mod)
 
 #ifdef CONFIG_KALLSYMS
 
-/* lookup symbol in given range of kernel_symbols */
-static const struct kernel_symbol *lookup_symbol(const char *name,
-	const struct kernel_symbol *start,
-	const struct kernel_symbol *stop)
+/* Lookup exported symbol in given range of kernel_symbols */
+static const struct kernel_symbol *lookup_exported_symbol(const char *name,
+							  const struct kernel_symbol *start,
+							  const struct kernel_symbol *stop)
 {
 	return bsearch(name, start, stop - start,
 			sizeof(struct kernel_symbol), cmp_name);
@@ -2533,9 +2534,10 @@ static int is_exported(const char *name, unsigned long value,
 {
 	const struct kernel_symbol *ks;
 	if (!mod)
-		ks = lookup_symbol(name, __start___ksymtab, __stop___ksymtab);
+		ks = lookup_exported_symbol(name, __start___ksymtab, __stop___ksymtab);
 	else
-		ks = lookup_symbol(name, mod->syms, mod->syms + mod->num_syms);
+		ks = lookup_exported_symbol(name, mod->syms, mod->syms + mod->num_syms);
+
 	return ks != NULL && kernel_symbol_value(ks) == value;
 }
 
@@ -3592,7 +3594,7 @@ static int complete_formation(struct module *mod, struct load_info *info)
 	mutex_lock(&module_mutex);
 
 	/* Find duplicate symbols (must be called under lock). */
-	err = verify_export_symbols(mod);
+	err = verify_exported_symbols(mod);
 	if (err < 0)
 		goto out;
 
@@ -3911,15 +3913,19 @@ static inline int is_arm_mapping_symbol(const char *str)
 	       && (str[2] == '\0' || str[2] == '.');
 }
 
-static const char *symname(struct mod_kallsyms *kallsyms, unsigned int symnum)
+static const char *kallsyms_symbol_name(struct mod_kallsyms *kallsyms, unsigned int symnum)
 {
 	return kallsyms->strtab + kallsyms->symtab[symnum].st_name;
 }
 
-static const char *get_ksymbol(struct module *mod,
-			       unsigned long addr,
-			       unsigned long *size,
-			       unsigned long *offset)
+/*
+ * Given a module and address, find the corresponding symbol and return its name
+ * while providing its size and offset if needed.
+ */
+static const char *find_kallsyms_symbol(struct module *mod,
+					unsigned long addr,
+					unsigned long *size,
+					unsigned long *offset)
 {
 	unsigned int i, best = 0;
 	unsigned long nextval;
@@ -3939,8 +3945,8 @@ static const char *get_ksymbol(struct module *mod,
 
 		/* We ignore unnamed symbols: they're uninformative
 		 * and inserted at a whim. */
-		if (*symname(kallsyms, i) == '\0'
-		    || is_arm_mapping_symbol(symname(kallsyms, i)))
+		if (*kallsyms_symbol_name(kallsyms, i) == '\0'
+		    || is_arm_mapping_symbol(kallsyms_symbol_name(kallsyms, i)))
 			continue;
 
 		if (kallsyms->symtab[i].st_value <= addr
@@ -3958,7 +3964,8 @@ static const char *get_ksymbol(struct module *mod,
 		*size = nextval - kallsyms->symtab[best].st_value;
 	if (offset)
 		*offset = addr - kallsyms->symtab[best].st_value;
-	return symname(kallsyms, best);
+
+	return kallsyms_symbol_name(kallsyms, best);
 }
 
 void * __weak dereference_module_function_descriptor(struct module *mod,
@@ -3983,7 +3990,8 @@ const char *module_address_lookup(unsigned long addr,
 	if (mod) {
 		if (modname)
 			*modname = mod->name;
-		ret = get_ksymbol(mod, addr, size, offset);
+
+		ret = find_kallsyms_symbol(mod, addr, size, offset);
 	}
 	/* Make a copy in here where it's safe */
 	if (ret) {
@@ -4006,9 +4014,10 @@ int lookup_module_symbol_name(unsigned long addr, char *symname)
 		if (within_module(addr, mod)) {
 			const char *sym;
 
-			sym = get_ksymbol(mod, addr, NULL, NULL);
+			sym = find_kallsyms_symbol(mod, addr, NULL, NULL);
 			if (!sym)
 				goto out;
+
 			strlcpy(symname, sym, KSYM_NAME_LEN);
 			preempt_enable();
 			return 0;
@@ -4031,7 +4040,7 @@ int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,
 		if (within_module(addr, mod)) {
 			const char *sym;
 
-			sym = get_ksymbol(mod, addr, size, offset);
+			sym = find_kallsyms_symbol(mod, addr, size, offset);
 			if (!sym)
 				goto out;
 			if (modname)
@@ -4062,7 +4071,7 @@ int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
 		if (symnum < kallsyms->num_symtab) {
 			*value = kallsyms->symtab[symnum].st_value;
 			*type = kallsyms->symtab[symnum].st_info;
-			strlcpy(name, symname(kallsyms, symnum), KSYM_NAME_LEN);
+			strlcpy(name, kallsyms_symbol_name(kallsyms, symnum), KSYM_NAME_LEN);
 			strlcpy(module_name, mod->name, MODULE_NAME_LEN);
 			*exported = is_exported(name, *value, mod);
 			preempt_enable();
@@ -4074,13 +4083,14 @@ int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
 	return -ERANGE;
 }
 
-static unsigned long mod_find_symname(struct module *mod, const char *name)
+/* Given a module and name of symbol, find and return the symbol's value */
+static unsigned long find_kallsyms_symbol_value(struct module *mod, const char *name)
 {
 	unsigned int i;
 	struct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);
 
 	for (i = 0; i < kallsyms->num_symtab; i++)
-		if (strcmp(name, symname(kallsyms, i)) == 0 &&
+		if (strcmp(name, kallsyms_symbol_name(kallsyms, i)) == 0 &&
 		    kallsyms->symtab[i].st_shndx != SHN_UNDEF)
 			return kallsyms->symtab[i].st_value;
 	return 0;
@@ -4097,12 +4107,12 @@ unsigned long module_kallsyms_lookup_name(const char *name)
 	preempt_disable();
 	if ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {
 		if ((mod = find_module_all(name, colon - name, false)) != NULL)
-			ret = mod_find_symname(mod, colon+1);
+			ret = find_kallsyms_symbol_value(mod, colon+1);
 	} else {
 		list_for_each_entry_rcu(mod, &modules, list) {
 			if (mod->state == MODULE_STATE_UNFORMED)
 				continue;
-			if ((ret = mod_find_symname(mod, name)) != 0)
+			if ((ret = find_kallsyms_symbol_value(mod, name)) != 0)
 				break;
 		}
 	}
@@ -4131,7 +4141,7 @@ int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,
 			if (kallsyms->symtab[i].st_shndx == SHN_UNDEF)
 				continue;
 
-			ret = fn(data, symname(kallsyms, i),
+			ret = fn(data, kallsyms_symbol_name(kallsyms, i),
 				 mod, kallsyms->symtab[i].st_value);
 			if (ret != 0)
 				return ret;
-- 
2.16.4

