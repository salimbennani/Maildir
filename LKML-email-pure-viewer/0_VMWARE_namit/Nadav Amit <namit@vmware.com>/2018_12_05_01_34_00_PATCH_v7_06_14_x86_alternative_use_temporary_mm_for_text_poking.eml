Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 06 Dec 2018 08:47:30 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga003.jf.intel.com (orsmga003.jf.intel.com [10.7.209.27])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 0470358014B;
	Wed,  5 Dec 2018 00:56:00 -0800 (PST)
Received: from fmsmga101.fm.intel.com ([10.1.193.65])
  by orsmga003-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 05 Dec 2018 00:55:59 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AMhSFBh39Bsg5RRD6smDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?segSKf3xwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfFjfK3SYMkaSHJBUMhPSiJPDICy?=
 =?us-ascii?q?YYwNAOoPMulXs5L9p0MMoBalGQmgGPnixiNSi3PqwaE31fkqHwHc3AwnGtIDqG?=
 =?us-ascii?q?zao8/oO6gIT+C+0bXFzTDCb/NKxDzw747IfQokofGNQbJ9atTRyUwhFgzflFWf?=
 =?us-ascii?q?t5bpMC+S1uQIqmWW6fdrW+G3i2M/tQ19vjyiyt0xhoTHmI4Z0E3I+CZlzIovJN?=
 =?us-ascii?q?C1SlZ3bcC4HJZTrS2XM5Z6Ttk+T21ypSo3ybkLtJimdyYQ0psn3QTQa/mffoiI?=
 =?us-ascii?q?/B3jUOGRLC9mhHJqZr2/nQy+8Uu+xe3mUMm7zlJKojBCktnWuXABzx3T6s6ZRf?=
 =?us-ascii?q?th5kqtxyqD2gTJ5u1ZL004i7DXJ4Miz7IsjJYesEbOEjfzmErsja+Wcksk+vKv?=
 =?us-ascii?q?6+Tierjmop6cN4lpigDxK6gumdKwAf4+MgcQW2iX4OO81bPl/ULnWrVHleM2kq?=
 =?us-ascii?q?bHv5DAP8gbpbC2AxVT0ok97xazFTCm0M4XnXUfNlJKZAqHj5T1O1HJOP34Cfa/?=
 =?us-ascii?q?g1eynztxyPHGI6bsApHMLnjFjbfgcqxx609ayAov099f44hYBa0GIPL2QkXxrs?=
 =?us-ascii?q?DXDgclMwyoxObqENV92ZkfWWKTGKCZN7nesV+V5u01JemMa5QYuDL8K/gj+v7v?=
 =?us-ascii?q?gmU1mV4bfam1w5QXbGq0EehhI0WceXDsmMsOEX8WvgoiS+znkF+CUTlNaHqoXK?=
 =?us-ascii?q?I84Tc7CIShDYrYQoCtgbqB3Dq0H5FMZ2BGDEyMHmnsd4meR/gMbyeSKNd7kjMY?=
 =?us-ascii?q?TbihV5Mh1Ra2uQDg0LpnLu3U+i4CuZL5ztd15fbelRUz9TxyEsSc3HuBT2Bynm?=
 =?us-ascii?q?MUWTA22LpzrlB6yleGyaJ4meBXFcRP5/NVVQc3LZ3cwPZ8C9zoXgLBf82GSFCp?=
 =?us-ascii?q?Qti9BTExT9Qxw8IBYkpnGtWiiAzD0DSuA7MPi7OLA5k0+LrG33ftP8Z912rG1K?=
 =?us-ascii?q?45glY7WMRPK3OpirR/9wfJAY7JiFuWl6CteaQY3y7N8WODwHGKvEFZVg5wTKrE?=
 =?us-ascii?q?UWoeZkvQsdT2+EfCQ6WyBrQgNwtL0dSCJbdSat31kVVGQ+/uN8nEbGKvhWi8Hx?=
 =?us-ascii?q?aIyamKbIrxZWod2j7QCEwFkwAV4HaHOhIyBiano2LCEjNuEUjjbF/r8el7sHm7?=
 =?us-ascii?q?VFM7zxmWb0190Lq44gIVhf2ZS/MUwrIEuCcgpy9oHFqn2NLWEd6ApwtnfKVTet?=
 =?us-ascii?q?495FZH1WTEtw1yJJCgLqZihkIAfARzpU/hyxJ3CoBYm8gwsHwq1BZyKb6f0F5Z?=
 =?us-ascii?q?bTyY2Y7/O7LJJWjy5hygcLPW1UzE39aQ+acP7+o4pk7nvAGoEEoi7npm38NU03?=
 =?us-ascii?q?ua+pXFEg4SXYjtXUYw8hhwv6vabTUl54PIyX1sNrG5sz/f294zGOQp0Behf9dF?=
 =?us-ascii?q?P6OCGw//CMkaB8moKOw3lFmldBMEPOZO9KEqO8OqbeeJ2KmuPOx4hjKpkXxH4J?=
 =?us-ascii?q?xh0kKL7yd8UO/I0IofzPGCwwSHUC3wjFG/vcDtmIBIfC0dEXC7ySf5GoFRfKpy?=
 =?us-ascii?q?fYAQBGeqIs23wMh+hpH3V35Z8l6jG00J2MuzdRWOaFz92BVa1V4Lrny/hSu40z?=
 =?us-ascii?q?t0nikpr6qexiDPw/7udAEaOm5NX2RiiVbsIY6pj9EVRkSobg4plAe76kb+3aRU?=
 =?us-ascii?q?uKN/L2zLS0dSYyf2N31iUre3treaYc5A8okosSZUUOS7e1yaUaTyoxgZ0yPiGW?=
 =?us-ascii?q?tR2jY7eiquupX4mRx6lW2cIGxyrHrfZcF/2xPf6MbASv5W2zoMXDN4hiXPBlig?=
 =?us-ascii?q?I9mp+s2ZlpfZveC5TW6hVJxTcS/wwIOEtSu743BqABKlk/CynN3nDRY10Svh29?=
 =?us-ascii?q?Z2UiXIqQ72YpP32KSiLeJnYk5oCUf/68VgG4FyiIswhIwK1ngciZWY5n4HkWb1?=
 =?us-ascii?q?MdVG1qPydnsNRTgXw9HL5AjpwlFsLnWMx4jhTHWS3tNhZ8WmYmMRwi896sFKCK?=
 =?us-ascii?q?SO47Bekyp6vEG4rR7PbvhnhTgS1+Eu6HEBjuENuQotyDidA78IEUlZOyzsiwqH?=
 =?us-ascii?q?79SkoKpLY2avdKC61FBiktC5ELGCvgZcVW7lepclGC989MR+P0jK0H3u8YHkY9?=
 =?us-ascii?q?jQYMkXth2VlRfAkudUJIgwlvoMmSpoJ2b9sWc5xO48iBxkxYu6s5SfK2Vx4KK5?=
 =?us-ascii?q?BQZVOSbvaMMU/jHtkLxSnsKL3420GpVhGzMLXIbnTP6yETISs+jnOBiKEDEmtn?=
 =?us-ascii?q?ibHr/fFxeF6Eh6t3LPD4yrN3aPKXkb19piQQeSJFdFjAAIRjk6nYM5FgO3xMzn?=
 =?us-ascii?q?akh5/Ssc5lr5qhtK1+JpOAPzUmbZpAe0dDg0TIKTIwZR7gFH/03VK9CR7vpvHy?=
 =?us-ascii?q?FE+Z2stAyMKmuGZwRREGEGQEqEC0r4Prmp49nA/POVBu6/L/vIfLWPpvZSV/aO?=
 =?us-ascii?q?xZKzzIRm+yyAOdmIPnlnF/c7wFZMXWhlG8TFnDUCUywXmDzMb86Ypxe8+zd7rs?=
 =?us-ascii?q?Ol8PTsVwLg+5GPC6ZJMdh0/xC2gKGDN/OfhSpjKDZY0I8MymHMyLQFwFESjCRu?=
 =?us-ascii?q?fSG3EbscrS7NUL7QmqhPAhEBdiN8L9FI4Lw83wVXPc7bi8j41rp5jv4zFldEWk?=
 =?us-ascii?q?btmsCvZcwWPW69MEnLC1qMNLSDPTfL2d34YbugSb1Mi+VZrwGwuTeeE0P5IjuP?=
 =?us-ascii?q?jSXmVxCxPuFKlyybOB1euIegchdiE2TjTdTmagGlP99zlzE53bo0hnbSP24GLT?=
 =?us-ascii?q?d8a19NrqGX7S5AgvRwAWpB7n9kLemCgymY7unYJYwQsftkGSl0k+Na4HIny7pa?=
 =?us-ascii?q?9i1ERfp1mDfMod5quV2pju6Pyj80GCZJ/xdNi4XDmEJmP6zDvs1FWHDL+zoX4G?=
 =?us-ascii?q?mQAghMrNxgXI7BoadVn/7GmKvtYB5H8s6cqc0VAsnIANyCL3M7PFziHzuCX1hN?=
 =?us-ascii?q?diKiKWyK3x8Vq/qV7HDA68Fi8pU=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AcAAAakgdch0O0hNFkHQEBBQEHBQEvg?=
 =?us-ascii?q?SIIAQsBg1wECyeMEo4vaJZQFIFfLBMBh04iNAkNAQMBAQEBAQECARMBAQEIDQk?=
 =?us-ascii?q?IKS+CNiQBgmIDAwECaQ0GCQEBGDgDVAYOBQWDHIICBaYviiyHb4QvF4FAP4ERg?=
 =?us-ascii?q?l2FDw+FcwKJDoIThQ+QHwmRNgsYkSyGL5QQgg0zGggbFYMngicXjj4eAQExgQU?=
 =?us-ascii?q?BAYhaKoIjAQE?=
X-IPAS-Result: =?us-ascii?q?A0AcAAAakgdch0O0hNFkHQEBBQEHBQEvgSIIAQsBg1wECye?=
 =?us-ascii?q?MEo4vaJZQFIFfLBMBh04iNAkNAQMBAQEBAQECARMBAQEIDQkIKS+CNiQBgmIDA?=
 =?us-ascii?q?wECaQ0GCQEBGDgDVAYOBQWDHIICBaYviiyHb4QvF4FAP4ERgl2FDw+FcwKJDoI?=
 =?us-ascii?q?ThQ+QHwmRNgsYkSyGL5QQgg0zGggbFYMngicXjj4eAQExgQUBAYhaKoIjAQE?=
X-IronPort-AV: E=Sophos;i="5.56,317,1539673200"; 
   d="scan'208";a="65387791"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mga01b.intel.com with ESMTP; 05 Dec 2018 00:55:58 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727585AbeLEIwx (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Wed, 5 Dec 2018 03:52:53 -0500
Received: from ex13-edg-ou-001.vmware.com ([208.91.0.189]:33316 "EHLO
        EX13-EDG-OU-001.vmware.com" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S1727403AbeLEIwL (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Wed, 5 Dec 2018 03:52:11 -0500
Received: from sc9-mailhost3.vmware.com (10.113.161.73) by
 EX13-EDG-OU-001.vmware.com (10.113.208.155) with Microsoft SMTP Server id
 15.0.1156.6; Wed, 5 Dec 2018 00:52:02 -0800
Received: from sc2-haas01-esx0118.eng.vmware.com (sc2-haas01-esx0118.eng.vmware.com [10.172.44.118])
        by sc9-mailhost3.vmware.com (Postfix) with ESMTP id 0CBC941391;
        Wed,  5 Dec 2018 00:52:05 -0800 (PST)
From: Nadav Amit <namit@vmware.com>
To: Ingo Molnar <mingo@redhat.com>
CC: <linux-kernel@vger.kernel.org>, <x86@kernel.org>,
        "H. Peter Anvin" <hpa@zytor.com>,
        Thomas Gleixner <tglx@linutronix.de>,
        Borislav Petkov <bp@alien8.de>,
        Andy Lutomirski <luto@kernel.org>,
        Nadav Amit <nadav.amit@gmail.com>,
        Dave Hansen <dave.hansen@linux.intel.com>,
        Peter Zijlstra <peterz@infradead.org>, <linux_dti@icloud.com>,
        <linux-integrity@vger.kernel.org>,
        <linux-security-module@vger.kernel.org>,
        Nadav Amit <namit@vmware.com>,
        Kees Cook <keescook@chromium.org>,
        Dave Hansen <dave.hansen@intel.com>,
        Masami Hiramatsu <mhiramat@kernel.org>
Subject: [PATCH v7 06/14] x86/alternative: use temporary mm for text poking
Date: Tue, 4 Dec 2018 17:34:00 -0800
Message-ID: <20181205013408.47725-7-namit@vmware.com>
X-Mailer: git-send-email 2.17.1
In-Reply-To: <20181205013408.47725-1-namit@vmware.com>
References: <20181205013408.47725-1-namit@vmware.com>
MIME-Version: 1.0
Content-Type: text/plain
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

text_poke() can potentially compromise the security as it sets temporary
PTEs in the fixmap. These PTEs might be used to rewrite the kernel code
from other cores accidentally or maliciously, if an attacker gains the
ability to write onto kernel memory.

Moreover, since remote TLBs are not flushed after the temporary PTEs are
removed, the time-window in which the code is writable is not limited if
the fixmap PTEs - maliciously or accidentally - are cached in the TLB.
To address these potential security hazards, we use a temporary mm for
patching the code.

Finally, text_poke() is also not conservative enough when mapping pages,
as it always tries to map 2 pages, even when a single one is sufficient.
So try to be more conservative, and do not map more than needed.

Cc: Andy Lutomirski <luto@kernel.org>
Cc: Kees Cook <keescook@chromium.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Dave Hansen <dave.hansen@intel.com>
Cc: Masami Hiramatsu <mhiramat@kernel.org>
Signed-off-by: Nadav Amit <namit@vmware.com>
---
 arch/x86/include/asm/fixmap.h |   2 -
 arch/x86/kernel/alternative.c | 109 +++++++++++++++++++++++++++-------
 arch/x86/xen/mmu_pv.c         |   2 -
 3 files changed, 87 insertions(+), 26 deletions(-)

diff --git a/arch/x86/include/asm/fixmap.h b/arch/x86/include/asm/fixmap.h
index 50ba74a34a37..9da8cccdf3fb 100644
--- a/arch/x86/include/asm/fixmap.h
+++ b/arch/x86/include/asm/fixmap.h
@@ -103,8 +103,6 @@ enum fixed_addresses {
 #ifdef CONFIG_PARAVIRT
 	FIX_PARAVIRT_BOOTMAP,
 #endif
-	FIX_TEXT_POKE1,	/* reserve 2 pages for text_poke() */
-	FIX_TEXT_POKE0, /* first page is last, because allocation is backward */
 #ifdef	CONFIG_X86_INTEL_MID
 	FIX_LNW_VRTC,
 #endif
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index 57fdde308bb6..8fc4685f3117 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -11,6 +11,7 @@
 #include <linux/stop_machine.h>
 #include <linux/slab.h>
 #include <linux/kdebug.h>
+#include <linux/mmu_context.h>
 #include <asm/text-patching.h>
 #include <asm/alternative.h>
 #include <asm/sections.h>
@@ -683,41 +684,105 @@ __ro_after_init unsigned long poking_addr;
 
 static void *__text_poke(void *addr, const void *opcode, size_t len)
 {
+	bool cross_page_boundary = offset_in_page(addr) + len > PAGE_SIZE;
+	temporary_mm_state_t prev;
+	struct page *pages[2] = {NULL};
 	unsigned long flags;
-	char *vaddr;
-	struct page *pages[2];
-	int i;
+	pte_t pte, *ptep;
+	spinlock_t *ptl;
 
 	/*
-	 * While boot memory allocator is runnig we cannot use struct
-	 * pages as they are not yet initialized.
+	 * While boot memory allocator is running we cannot use struct pages as
+	 * they are not yet initialized.
 	 */
 	BUG_ON(!after_bootmem);
 
 	if (!core_kernel_text((unsigned long)addr)) {
 		pages[0] = vmalloc_to_page(addr);
-		pages[1] = vmalloc_to_page(addr + PAGE_SIZE);
+		if (cross_page_boundary)
+			pages[1] = vmalloc_to_page(addr + PAGE_SIZE);
 	} else {
 		pages[0] = virt_to_page(addr);
 		WARN_ON(!PageReserved(pages[0]));
-		pages[1] = virt_to_page(addr + PAGE_SIZE);
+		if (cross_page_boundary)
+			pages[1] = virt_to_page(addr + PAGE_SIZE);
 	}
-	BUG_ON(!pages[0]);
+	BUG_ON(!pages[0] || (cross_page_boundary && !pages[1]));
+
 	local_irq_save(flags);
-	set_fixmap(FIX_TEXT_POKE0, page_to_phys(pages[0]));
-	if (pages[1])
-		set_fixmap(FIX_TEXT_POKE1, page_to_phys(pages[1]));
-	vaddr = (char *)fix_to_virt(FIX_TEXT_POKE0);
-	memcpy(&vaddr[(unsigned long)addr & ~PAGE_MASK], opcode, len);
-	clear_fixmap(FIX_TEXT_POKE0);
-	if (pages[1])
-		clear_fixmap(FIX_TEXT_POKE1);
-	local_flush_tlb();
-	sync_core();
-	/* Could also do a CLFLUSH here to speed up CPU recovery; but
-	   that causes hangs on some VIA CPUs. */
-	for (i = 0; i < len; i++)
-		BUG_ON(((char *)addr)[i] != ((char *)opcode)[i]);
+
+	/*
+	 * The lock is not really needed, but this allows to avoid open-coding.
+	 */
+	ptep = get_locked_pte(poking_mm, poking_addr, &ptl);
+
+	/*
+	 * This must not fail; preallocated in poking_init().
+	 */
+	VM_BUG_ON(!ptep);
+
+	pte = mk_pte(pages[0], PAGE_KERNEL);
+	set_pte_at(poking_mm, poking_addr, ptep, pte);
+
+	if (cross_page_boundary) {
+		pte = mk_pte(pages[1], PAGE_KERNEL);
+		set_pte_at(poking_mm, poking_addr + PAGE_SIZE, ptep + 1, pte);
+	}
+
+	/*
+	 * Loading the temporary mm behaves as a compiler barrier, which
+	 * guarantees that the PTE will be set at the time memcpy() is done.
+	 */
+	prev = use_temporary_mm(poking_mm);
+
+	kasan_disable_current();
+	memcpy((u8 *)poking_addr + offset_in_page(addr), opcode, len);
+	kasan_enable_current();
+
+	/*
+	 * Ensure that the PTE is only cleared after the instructions of memcpy
+	 * were issued by using a compiler barrier.
+	 */
+	barrier();
+
+	pte_clear(poking_mm, poking_addr, ptep);
+
+	/*
+	 * __flush_tlb_one_user() performs a redundant TLB flush when PTI is on,
+	 * as it also flushes the corresponding "user" address spaces, which
+	 * does not exist.
+	 *
+	 * Poking, however, is already very inefficient since it does not try to
+	 * batch updates, so we ignore this problem for the time being.
+	 *
+	 * Since the PTEs do not exist in other kernel address-spaces, we do
+	 * not use __flush_tlb_one_kernel(), which when PTI is on would cause
+	 * more unwarranted TLB flushes.
+	 *
+	 * There is a slight anomaly here: the PTE is a supervisor-only and
+	 * (potentially) global and we use __flush_tlb_one_user() but this
+	 * should be fine.
+	 */
+	__flush_tlb_one_user(poking_addr);
+	if (cross_page_boundary) {
+		pte_clear(poking_mm, poking_addr + PAGE_SIZE, ptep + 1);
+		__flush_tlb_one_user(poking_addr + PAGE_SIZE);
+	}
+
+	/*
+	 * Loading the previous page-table hierarchy requires a serializing
+	 * instruction that already allows the core to see the updated version.
+	 * Xen-PV is assumed to serialize execution in a similar manner.
+	 */
+	unuse_temporary_mm(prev);
+
+	pte_unmap_unlock(ptep, ptl);
+	/*
+	 * If the text doesn't match what we just wrote; something is
+	 * fundamentally screwy, there's nothing we can really do about that.
+	 */
+	BUG_ON(memcmp(addr, opcode, len));
+
 	local_irq_restore(flags);
 	return addr;
 }
diff --git a/arch/x86/xen/mmu_pv.c b/arch/x86/xen/mmu_pv.c
index a5d7ed125337..e9b474c396d2 100644
--- a/arch/x86/xen/mmu_pv.c
+++ b/arch/x86/xen/mmu_pv.c
@@ -2318,8 +2318,6 @@ static void xen_set_fixmap(unsigned idx, phys_addr_t phys, pgprot_t prot)
 #elif defined(CONFIG_X86_VSYSCALL_EMULATION)
 	case VSYSCALL_PAGE:
 #endif
-	case FIX_TEXT_POKE0:
-	case FIX_TEXT_POKE1:
 		/* All local page mappings */
 		pte = pfn_pte(phys, prot);
 		break;
-- 
2.17.1

