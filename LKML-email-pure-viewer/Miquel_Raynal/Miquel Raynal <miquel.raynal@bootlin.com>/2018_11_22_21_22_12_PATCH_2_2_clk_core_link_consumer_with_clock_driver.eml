Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 08:32:17 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 20F8058037D;
	Thu, 22 Nov 2018 13:22:49 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by fmsmga001-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 13:22:48 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AepwP5hSJWNxdcKlJC8fEsBo4A9psv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YRGCt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZAo2y?=
 =?us-ascii?q?cZYBAeQCM+hfrYb9qVQBoxSlBQm0Bu7i0SNEi3zs0KEmyektDR3K0Qo9FNwOqn?=
 =?us-ascii?q?TUq9D1Ob8VX+C01anI0CvMb/dL0jnh8ofJchYhruuIXbltdsfRzEgvFxrYjlqO?=
 =?us-ascii?q?rYzpJSmV2f4Nsmid9eVgUfmihHUgqwF2vjivwsYsio/Tio0JzVDE8Dx0zYAoLt?=
 =?us-ascii?q?O7UE52ecCoHIdUui2AKod7TN0uT3t1tCs51rEKo5+2cSoSxJkj2hLTceKLf5aH?=
 =?us-ascii?q?7x75SeqcLjR1iGh4dL6jiRu/91WrxPfmWcmuyllKqzJIktnSuXAJ0Bze8taHSv?=
 =?us-ascii?q?Rj8Ue7wzqP1B7c6vtCIU8qkarXMZkhwqQ/lpYLsETDGDH5mFnugaOIakkp/vKk?=
 =?us-ascii?q?5/npb7n4vJOQKox5hh3kPqkvmMGzGeE4PRIPX2if9+S8zrrj/UjhTbVOj/02lL?=
 =?us-ascii?q?TZsZ/DKcQYuKG5GQlV3Zgn6xqmCDen3tIYkmcdLF9eZhKHgJbmO0vULPD7E/i/?=
 =?us-ascii?q?mVKsnylvx/zcOb3hGJrNImDZkLj9ZbZ991JcyA0rwNBb5pJUCa8OLOj8W0/sr9?=
 =?us-ascii?q?HYCh45Mwqpw+foEtl914UeWX6RDa+dKq/drViI5uc3KemWeIAVoCr9K+Qi5/P2?=
 =?us-ascii?q?jX82g14dfbWz0psQcny4HulmLF+fYXrjmdoBFWYKvgwjTO3lklGCUDhTZ2qsUK?=
 =?us-ascii?q?I4/D00FIWmDYLbTIC3nLOBxDu7HoFRZm1eCFCMFmnne5+HW/cLbiKSJMhhnycA?=
 =?us-ascii?q?VbigTY8hyB6vuBX7y7phMurb5CkYuYj/29hy4u3ZjQsy+iBsD8SBz2GNSHl5kX?=
 =?us-ascii?q?kTRz8226B/olZxyk2Z3qh6mPFYEd1T5/VUUgY1L5Lczup6C8zsVQLFZNuGVFGm?=
 =?us-ascii?q?QtC+CzErUt0x28MOY1p6G9i6jRDMxSyqD6URl7yKHpM09K3c0mP1J8Z8zXbGya?=
 =?us-ascii?q?Ygg0MnQstJKW2pmKp/+xLPCI7OlkWTj7yqergE3C7R6GeDynKDs1xCXw5uT6rJ?=
 =?us-ascii?q?R3AfaVHQrdTi+EzCSbiiCbAkMgtEzc6PMa9KatzvjVVbS/bvItXeY2Stm2iuAR?=
 =?us-ascii?q?aE3K+DbI3ve28FxiXSFFAEkxwP/XaBLQUxGz2uo3zAAzB0FVLgeUXs8fJgp3O9?=
 =?us-ascii?q?VUI0ywCKb0t817u64BIVhPqcS+8N0bIAoisutzJ0HFOl1dLMF9WAvxZhfLlbYd?=
 =?us-ascii?q?4l/FdH1GfZtwthPpygL6FunEIefx5wv0P00xV3C4NAkccxoXMuzQpyL7+Y0Vxb?=
 =?us-ascii?q?ezOZ25DwJqPYKm3o8B+zbK7W30nU0MyK9acX9PQ4t1LjsRmzGUom7Xpm3Mda0n?=
 =?us-ascii?q?uG6prREQodTIj+UkA09xh9ubHXeS0954LS1X1xPqi4qD7C29Q1BOQ7zhasZctQ?=
 =?us-ascii?q?MKSBFAXqCc0VG9CuKPA2m1iudh8FPP1S+LQoMM+8dvqG2LSkPOBvnD+9iWRH4Y?=
 =?us-ascii?q?Z90l+D9iZmS+7I2YoFzO+c3gedSzj8i1KhuNjtmY9YfTESAna/yS/8CY5LZ619?=
 =?us-ascii?q?YZwECX2zLM2w3Nl+gYDiW2RZ9FK6G1wJwsupdgeMYFzn2g1Q018aoXimmSu+0j?=
 =?us-ascii?q?x1nCslrquZ3CzS3evicAALNXJMRGlnlV3sO5S7j8gGXEi0aAgkjBuk5Ufgy6lb?=
 =?us-ascii?q?vqh/NHTTQUFTcijyLmFiVLawt7WYb85O7pMorTtYUOCmbV+GTb79pgMQ0zn/EG?=
 =?us-ascii?q?tG2DA7azaqt437nxNgkmKdL3VzrH3DdcFr3xjf59/cRf9X3jUYQil1kj3XBlm6?=
 =?us-ascii?q?P9m08tSYjZbDsuaiV22/Up1fazXkzYSFtCGj/21lHQW/n+yvmt3gCQU70TX019?=
 =?us-ascii?q?5wWSXKrRb8ZJLm16C7MeJhY0lpC0Xw68t8GoFijIQwgIsc1mQdhpWQ5XAHi3v8?=
 =?us-ascii?q?Mc1H2aLia3oAXT0LzMTU4AT/2E1jM2iGx4T2VniGxsthZt+6Yn4Z2y4n7sBKDr?=
 =?us-ascii?q?uU46JAnSdvvlW4qgfRa+BnnjgB0fsu9GIag+YRtQoozyWdAaodEVNWPCPyjBSI?=
 =?us-ascii?q?886xrL9Ma2mxa7iw21FzndSgDLGEvwFdV2z1epYkHS9s8Mp/NEjA32H06oHhYN?=
 =?us-ascii?q?PQd84ctgWIkxfciOhYMI4xlv0PhSZ9OGPyp3sly/MgjRx13JG3p4yHK2Rr/KKk?=
 =?us-ascii?q?DR9ULDz1Z8UP+j7ziaZShNqZ34eqHp95ADUEQIPoTe60EDIVrfnoLByBEDo4qn?=
 =?us-ascii?q?eGA7bfGRKf5Vxir3LOFZCrKn6WKGMYzdVkWBmSOkhfjBoIUzU9m54zDhqqy9D5?=
 =?us-ascii?q?cEdl+jAR4Ub1qhlWxeJtKRb/SX3TpBuyZjc3VZifLwdW7gdY6EfOKsGe6uNzHy?=
 =?us-ascii?q?dF/pyutgCNK2qbZxhWAmENQECLG1fjPry279na7+eYHva+L+fJYbiWqe1eUOqI?=
 =?us-ascii?q?xYuy0oR8+TaALN6PPn5kD/00wUdDWXF5G8LEmzQAUSAXliTNb9KFqxe44CF4ss?=
 =?us-ascii?q?e/8PHzUgL1+YSPE6dSMclo+x2ugaeMKe+QhCV6KTZZzJ8MxmXIyL8Q3FEMkSFu?=
 =?us-ascii?q?aiKtHK8EtS7MSqLQh6BWAwQaayN1KMtH8aY80hNRNs7cj9P/zqR4geItC1dZSV?=
 =?us-ascii?q?zhndmkatYXI26mLlPIGkaKOK6CJT3K2Mz3ZaK8SbtNjORbrRGwuDCbE1P9MTSH?=
 =?us-ascii?q?jTXmSxevMeRUhiGBIBNeoJ29cgpqCWX7UNLmaxi7PMVrgjEs3bI0hm3FNWgHPD?=
 =?us-ascii?q?h4ckNNqKCQ7CxCjvV+HWxB8mRqLe2elymF6OnYL44cseF3DSRsi+Ja/HM6xqNV?=
 =?us-ascii?q?7S5eQvx1nSrSrth2rFCnkumA0DxnUBVVpzZPhYKLu1hiOKrD+plBX3bE4AwC7W?=
 =?us-ascii?q?GKBxsWoNtlD46nh6cF79nElKv+LH9+7sjN4MYAG8WcfMebLWA4LBf1BDP8BgIU?=
 =?us-ascii?q?ST+hL2yZjEtYxrXazWGYtpg3rNDGn4sCAutAXlskGtsZB15jEdhEJ414CHdsq6?=
 =?us-ascii?q?OAl8MM4TKdrR/eDJFev5baRtqbG/DrKTCEnf9DfRRO3LCufqoJMYiu/k17d1R+?=
 =?us-ascii?q?1L7DCkzZWZgZpyx4cwIw5l9E4X53SkU53EX5bgKrpnQUEKjnzVYNlgJibLF1p3?=
 =?us-ascii?q?/X6FAtKw+P/XNonQ=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ANAAAoHfdbh0O0hNFiHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBg2snjBGMAIIhlyaBcywTAYhSIjQJDQEDAQEBAQEBAgETAQEBCA0?=
 =?us-ascii?q?JCCkvgjYkAYJiAwMBAiQLAUYGCQEBGDgDKSsGARIFFoMGggIEAak6M4N9hh+HX?=
 =?us-ascii?q?oQrgVc/gRGNawKJH4FylHEHAoIcBIQdg2yGeyORCJl2gg0zGiODPIInF44dPzK?=
 =?us-ascii?q?BBAEBATuJTSmCJAEB?=
X-IPAS-Result: =?us-ascii?q?A0ANAAAoHfdbh0O0hNFiHAEBAQQBAQcEAQGBUQcBAQsBg2s?=
 =?us-ascii?q?njBGMAIIhlyaBcywTAYhSIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkvgjYkAYJiA?=
 =?us-ascii?q?wMBAiQLAUYGCQEBGDgDKSsGARIFFoMGggIEAak6M4N9hh+HXoQrgVc/gRGNawK?=
 =?us-ascii?q?JH4FylHEHAoIcBIQdg2yGeyORCJl2gg0zGiODPIInF44dPzKBBAEBATuJTSmCJ?=
 =?us-ascii?q?AEB?=
X-IronPort-AV: E=Sophos;i="5.56,267,1539673200"; 
   d="scan'208";a="53394240"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 13:22:29 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2438966AbeKWIDh (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 03:03:37 -0500
Received: from mail.bootlin.com ([62.4.15.54]:40155 "EHLO mail.bootlin.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1732941AbeKWIDf (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 03:03:35 -0500
Received: by mail.bootlin.com (Postfix, from userid 110)
        id 3AD9C20DBE; Thu, 22 Nov 2018 22:22:23 +0100 (CET)
X-Spam-Checker-Version: SpamAssassin 3.4.2 (2018-09-13) on mail.bootlin.com
X-Spam-Level: 
X-Spam-Status: No, score=-1.0 required=5.0 tests=ALL_TRUSTED,SHORTCIRCUIT,
        URIBL_BLOCKED shortcircuit=ham autolearn=disabled version=3.4.2
Received: from localhost.localdomain (unknown [91.224.148.103])
        by mail.bootlin.com (Postfix) with ESMTPSA id 7D87C2072F;
        Thu, 22 Nov 2018 22:22:22 +0100 (CET)
From: Miquel Raynal <miquel.raynal@bootlin.com>
To: Michael Turquette <mturquette@baylibre.com>,
        Stephen Boyd <sboyd@kernel.org>,
        Russell King <linux@armlinux.org.uk>
Cc: linux-clk@vger.kernel.org, linux-kernel@vger.kernel.org,
        linux-arm-kernel@lists.infradead.org,
        Thomas Petazzoni <thomas.petazzoni@bootlin.com>,
        Antoine Tenart <antoine.tenart@bootlin.com>,
        Maxime Chevallier <maxime.chevallier@bootlin.com>,
        Gregory Clement <gregory.clement@bootlin.com>,
        Nadav Haklai <nadavh@marvell.com>,
        Miquel Raynal <miquel.raynal@bootlin.com>
Subject: [PATCH 2/2] clk: core: link consumer with clock driver
Date: Thu, 22 Nov 2018 22:22:12 +0100
Message-Id: <20181122212212.16039-3-miquel.raynal@bootlin.com>
X-Mailer: git-send-email 2.19.1
In-Reply-To: <20181122212212.16039-1-miquel.raynal@bootlin.com>
References: <20181122212212.16039-1-miquel.raynal@bootlin.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

One major concern when, for instance, suspending/resuming a platform
is to never access registers before the underlying clock has been
resumed, otherwise most of the time the kernel will just crash. One
solution is to use syscore operations when registering clock drivers
suspend/resume callbacks. One problem of using syscore_ops is that the
suspend/resume scheduling will depend on the order of the
registrations, which brings (unacceptable) randomness in the process.

A feature called device links has been introduced to handle such
situation. It creates dependencies between consumers and providers,
enforcing e.g. the suspend/resume order when needed. Such feature is
already in use for regulators.

Add device links support in the clock subsystem by creating/deleting
the links at get/put time.

Example of a boot (ESPRESSObin, A3700 SoC) with devices linked to clocks:
ahci-mvebu d00e0000.sata: Linked as a consumer to d0013000.nb-periph-clk
mvneta d0030000.ethernet: Linked as a consumer to d0018000.sb-periph-clk
xhci-hcd d0058000.usb: Linked as a consumer to d0018000.sb-periph-clk
xenon-sdhci d00d0000.sdhci: Linked as a consumer to d0013000.nb-periph-clk
xenon-sdhci d00d0000.sdhci: Dropping the link to d0013000.nb-periph-clk
advk-pcie d0070000.pcie: Linked as a consumer to d0018000.sb-periph-clk
xenon-sdhci d00d0000.sdhci: Linked as a consumer to d0013000.nb-periph-clk
xenon-sdhci d00d0000.sdhci: Linked as a consumer to regulator.1
cpu cpu0: Linked as a consumer to d0013000.nb-periph-clk
cpu cpu0: Dropping the link to d0013000.nb-periph-clk
cpu cpu0: Linked as a consumer to d0013000.nb-periph-clk

Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
---
 drivers/clk/clk.c            | 20 ++++++++++++++++++++
 drivers/clk/clkdev.c         | 13 ++++++++++---
 include/linux/clk-provider.h |  2 ++
 3 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index b799347c5fd6..33a0f2b0533a 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -90,6 +90,7 @@ struct clk {
 	unsigned long max_rate;
 	unsigned int exclusive_count;
 	struct hlist_node clks_node;
+	struct device_link *link;
 };
 
 /***           runtime pm          ***/
@@ -262,6 +263,25 @@ struct clk_hw *__clk_get_hw(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(__clk_get_hw);
 
+void __clk_device_link(struct device *consumer, struct clk *clk)
+{
+	if (!consumer || !clk || !clk->core)
+		return;
+
+	clk->link = device_link_add(consumer, clk->core->dev,
+				    DL_FLAG_STATELESS);
+}
+EXPORT_SYMBOL_GPL(__clk_device_link);
+
+void __clk_device_unlink(struct clk *clk)
+{
+	if (!clk || !clk->link)
+		return;
+
+	device_link_del(clk->link);
+}
+EXPORT_SYMBOL_GPL(__clk_device_unlink);
+
 unsigned int clk_hw_get_num_parents(const struct clk_hw *hw)
 {
 	return hw->core->num_parents;
diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c
index 9ab3db8b3988..fccfd4c01457 100644
--- a/drivers/clk/clkdev.c
+++ b/drivers/clk/clkdev.c
@@ -194,20 +194,27 @@ EXPORT_SYMBOL(clk_get_sys);
 struct clk *clk_get(struct device *dev, const char *con_id)
 {
 	const char *dev_id = dev ? dev_name(dev) : NULL;
-	struct clk *clk;
+	struct clk *clk = NULL;
 
 	if (dev && dev->of_node) {
 		clk = __of_clk_get_by_name(dev->of_node, dev_id, con_id);
-		if (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)
+		if (PTR_ERR(clk) == -EPROBE_DEFER)
 			return clk;
 	}
 
-	return clk_get_sys(dev_id, con_id);
+	if (IS_ERR_OR_NULL(clk))
+		clk = clk_get_sys(dev_id, con_id);
+
+	if (!IS_ERR(clk))
+		__clk_device_link(dev, clk);
+
+	return clk;
 }
 EXPORT_SYMBOL(clk_get);
 
 void clk_put(struct clk *clk)
 {
+	__clk_device_unlink(clk);
 	__clk_put(clk);
 }
 EXPORT_SYMBOL(clk_put);
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 60c51871b04b..c7ba8098f854 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -781,6 +781,8 @@ void devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw);
 const char *__clk_get_name(const struct clk *clk);
 const char *clk_hw_get_name(const struct clk_hw *hw);
 struct clk_hw *__clk_get_hw(struct clk *clk);
+void __clk_device_link(struct device *consumer, struct clk *clk);
+void __clk_device_unlink(struct clk *clk);
 unsigned int clk_hw_get_num_parents(const struct clk_hw *hw);
 struct clk_hw *clk_hw_get_parent(const struct clk_hw *hw);
 struct clk_hw *clk_hw_get_parent_by_index(const struct clk_hw *hw,
-- 
2.19.1

