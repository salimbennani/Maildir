Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 02 Dec 2018 19:25:17 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from mta-temp.ostc.intel.com (mta-temp.ostc.intel.com [10.54.63.100])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id E0ADE580BB4;
	Sat,  1 Dec 2018 18:20:37 -0800 (PST)
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by mta-temp.ostc.intel.com (Postfix) with ESMTPS id A9EBE627B4;
	Sat,  1 Dec 2018 10:01:49 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by fmsmga006-1.fm.intel.com with ESMTP; 01 Dec 2018 10:01:24 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Am5cnahZSxq7OG0B1PEK2p9D/LSx+4OfEezUN459i?=
 =?us-ascii?q?sYplN5qZpcizYx7h7PlgxGXEQZ/co6odzbaO4+a4ASQp2tWoiDg6aptCVhsI24?=
 =?us-ascii?q?09vjcLJ4q7M3D9N+PgdCcgHc5PBxdP9nC/NlVJSo6lPwWB6nK94iQPFRrhKAF7?=
 =?us-ascii?q?Ovr6GpLIj8Swyuu+54Dfbx9HiTahYr5+Ngm6oRnMvcQKnIVuLbo8xAHUqXVSYe?=
 =?us-ascii?q?RWwm1oJVOXnxni48q74YBu/SdNtf8/7sBMSar1cbg2QrxeFzQmLns65Nb3uhnZ?=
 =?us-ascii?q?TAuA/WUTX2MLmRdVGQfF7RX6XpDssivms+d2xSeXMdHqQb0yRD+v9LlgRgP2hy?=
 =?us-ascii?q?gbNj456GDXhdJ2jKJHuxKquhhzz5fJbI2JKPZye6XQds4YS2VcRMZcTyJPDIOi?=
 =?us-ascii?q?YYUSDOQOP+hYoY7yqFQSohW+HhGsCeH0xz9UhHL7x7E23v49HQ3Y2gErAtIAsG?=
 =?us-ascii?q?7TrNXwLKocVee1zK/SwjXfb/NZwzH945XWfx87pPGDQ6hwcc3XyUIyEA7FjFSQ?=
 =?us-ascii?q?ppD7Mz6bzekNsHaU7/BmVe2xj24rsQZxoiKgxso1jITCm4wbylfB9SpjwYY1I8?=
 =?us-ascii?q?W1R1R9YdG+FJtQsC6aO5FqTcMlRmFlvjsxxL4euZOjYiQG1JAqywTCZ/GJbYSE?=
 =?us-ascii?q?+A/vWeWNLTtihX9oeqqzihWv/US6zuDxV9O43EhEoydKiNXAq38A2h/V58OaUP?=
 =?us-ascii?q?Vy5F2h1iyK1w3L6uFLP0Q0la3DJp4/zb4/iIATvV7AHiDogkX2irGZdkE+9uiv?=
 =?us-ascii?q?8eTnba3qpp6aN4BqlgHzKroiltC7DOgiLwQDUXaX9f6h2LDg4UH1WrRHg/8unq?=
 =?us-ascii?q?ncqp/aJMAbpqCjAw9S14Yu8xK/Dzag0NQFkngLNVFFdwydj4jvJV7OJOn0DfCx?=
 =?us-ascii?q?glSqjjhr3evLPqPuAprTNHjPirThcqhn605a1gUzycpT55VOCrEOOP7zQFP+tM?=
 =?us-ascii?q?TEDh8lNAy52+LnCNR+1owAQ26ODbKZPbjWsV+J4OIvPuaNaJUUuDb7N/gq+fru?=
 =?us-ascii?q?gWUlll8aeKmjxYEXZ2ygHvR6P0WZZmLhgtcbHmcLogoxVuvqhEeCUT5OfXmyWa?=
 =?us-ascii?q?086yo/CIKnC4fDW4+sjKaA3Ce9Ap1ZeGRGBkqQHnfvcoWOQ+0MZz6KIs99jjwE?=
 =?us-ascii?q?UqCsS40m1R6wrgP6yL1nLuzS+i0frp/j0Nl15+vOlRA97zB0DsKd032TQGFwhG?=
 =?us-ascii?q?8HWzg23KVnq0xn1liDybR4g+BfFdFL/fxJSQc6NZnfz+BgEdD9QADBc8yNSFan?=
 =?us-ascii?q?RNWmHD4wQsgww98If0ZyBdGiggrf0CqtBr8fj6aLC4As8qLAw3jxIN5wy3Xc26?=
 =?us-ascii?q?knlVUmRspPOneghq5w7AXTA4/Jk0OEl6elb6gc3SjN9HudwmqKpk1XTAlwUaDd?=
 =?us-ascii?q?V3AFekTWtcj55l/FT7K2FLsoKBVBxtCYJqtKcNLpi05GS+nlONjZZ2KxmGKwBR?=
 =?us-ascii?q?KTy7OIbYrqfXgd3SrHBEgFlQAT4WiJNQwkCii9pGLeCSRkFUjzbEP07el+tHS7?=
 =?us-ascii?q?Q1cpwA6QcU1uyaC5+h4PivyaUPMcwLQEtTwlqzV1Gla9wt3XB8CBpwpnYKVTf9?=
 =?us-ascii?q?c97E1b2mLesgx3JoagILx6hl4CbwR3uFvj1wl2CoVFlsgqsHMqzQpoJaKEyl9B?=
 =?us-ascii?q?cCmY3ZTxOr3RJWn/5xSva6/Q2lHD39ea4KYP6PIkq1r9uAGlDFYt83Ji09NNyX?=
 =?us-ascii?q?uT+o3KDBYOUZL2Sks47Rx6qK/VYyYj54LYz2ZjMbSpvTDY3dIpB+wlygi7ctdb?=
 =?us-ascii?q?MaOEEhLyEsIAC8ivLuwqh0ambhYeMO9O8640Otusd+Ga166zIOZggDWmgHxH4Y?=
 =?us-ascii?q?BgyE6D6zBwS+/I35kfxfGY0RCKVzP9jFenr8D2lppIZTAUHmqj1yfkAJRdabF1?=
 =?us-ascii?q?fYYOEW2uOdG4xs1ih57xXH5V7ESjB1Ia18CzYxqdclv90RdW1UsJu3ynmDK0wC?=
 =?us-ascii?q?BunDEts6WQwjbOw+PkdBccPm5LRW9ijUrjIISujtAaWlSoYBYtlBe/+Un6wK1b?=
 =?us-ascii?q?rrxlL2bPWUdIYzT2L2Z6X6qwt7qOec5O5IkzsSVKVuSxelSaSr/7oxsH3CLvBW?=
 =?us-ascii?q?pexDYndz60vpX1hQB1iGWYLHxrtnrWZdlwxQvD5NzbXfNR3CAJRDN7iTnUAViw?=
 =?us-ascii?q?JcKp8s+Xl5fAs+C+UXyuVptIfCnvzIOAsja75GJwDR2+mfCzhsPoEQwg3SDn0N?=
 =?us-ascii?q?lqUD3CrAzgbYnzy6S6LeVnc1FoBVDm7Mp2AIN+koo2hJwL3Xgah5OV/WcIkGvp?=
 =?us-ascii?q?MNVb377+Y2QJRTIR39HV5w3l0lV5Ln2V34L5Smmdwsx5atm5eGwW2zgx78BXCK?=
 =?us-ascii?q?iO6rxEkjB4ol65rQLXfPh8kS0Ryfoo6H4Gne4JvBAhwTmaArAXBUNYJzDjlwyU?=
 =?us-ascii?q?79Ciq6VafGOvcbmz1EVkh9ygAq+NohpAWHnnYJctBjF/7t9wMF/X1H3z64fkeM?=
 =?us-ascii?q?TfbN4Jtx2UlQvAgPZRKJ4rivUKgi9nM3rnvXI50+47kQBu3ZaisYibLGVt+bi1?=
 =?us-ascii?q?Ax9COT3zesMT4SrtjadFk8aS3oCvGIhhGzoRUJvpS/KoDCwdtfD9OwmSFz08r2?=
 =?us-ascii?q?+RGaDDEg+H9Edms3XPHoiwOH6NI3kZychiSAOZJExCmw0UWDQ6npgkFgGl3sDh?=
 =?us-ascii?q?cUF55iwP6V78sBdD1uVoNxznWGfFuAiocis0SISYLBdO7AFN/ULVPtKF7u5pAy?=
 =?us-ascii?q?FU5J6hrBGOKmyGYQRHF3oJV1eAB1DiOLmu+NbB//KZBuq4M/vBf7GOpfZCWPeP?=
 =?us-ascii?q?wJKlypFm8CqUNsWTInliCOU220pEXXBkAsTZhi8ASyoNmyLWaM6bohi89zZzrs?=
 =?us-ascii?q?C+9vTrRQ3u6ZGOC7tULdVg5RS2jb2fOO6XgSZzMSxY2Y8UxX/U1Lgf20YfiyFw?=
 =?us-ascii?q?eDmsErQAti/NQLjTmq9NCB4bZD18NNFV76InxQRNPc/bitXo1r93lPI1ClFFVU?=
 =?us-ascii?q?D/lcGtf8AFP2a9NFbfDkaRKLuGPSHLw93wYa6kU7JQkf5btweutjebCUPjOjWD?=
 =?us-ascii?q?miLtVxCuN+FMkS6aMAZfuIG7bhZiF2zjQMj6ZR28Nd99lSc2zqEshnPWKW4cNi?=
 =?us-ascii?q?Bxc19Mrr2V9y9Xnu9zFHBB7nV7K+mJgCKZ7+jeKpYLvvpnGCV0l+RG4Hskz7tZ?=
 =?us-ascii?q?9j1LRPtwmCHKtN5hv0mmkvWTyjpgSBdPqixEhISOvUVjP6XW7phBWXbe8xIL4m?=
 =?us-ascii?q?WdEBAKp9pjCt3ytKFc0NnPlKTvKDhc99LY59cTB8/RKJHPDH10CgbkFjfSRDMC?=
 =?us-ascii?q?VTfjYXrDikJUlreK8WWchpE8o5zrl9wFTboNB3IvEfZPKENjFcACKZE/dTohnK?=
 =?us-ascii?q?ScioZc53u19kL5R8hAuJ3DEPWIDqO8e36ikbBYak5QkvvDJoMJO9i+ghQ6Zw?=
 =?us-ascii?q?=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAAAaywJch0O0hNFjGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYFVgRSBAieMEV+LewEBBoE1FIkLhGuJPhSBYxAYCwgBh3Y?=
 =?us-ascii?q?iNAkNAQMBAQEBAQECARMBAQEKCwkIKSMMgjYkAYJiAQICAQECFwEMEwYBATcBB?=
 =?us-ascii?q?AEJAQEKISUDDEgGCgkFD4MNAYF0BQgEAQqkSoFsM4J2AQEFhx4IiDKCToEcgQ+?=
 =?us-ascii?q?BBxJ/gxKERh8EAQyFZoEsAQGHegoogUeED0aBBoRkimEBBgIBhwCKMSMKgVGFE?=
 =?us-ascii?q?YMlhxWHaoV/iwSBRoINMxowgWGBTgmCEgwXg0qFFIU/QDKBAgMBASETij8rgiA?=
 =?us-ascii?q?BAQ?=
X-IPAS-Result: =?us-ascii?q?A0AEAAAaywJch0O0hNFjGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYFVgRSBAieMEV+LewEBBoE1FIkLhGuJPhSBYxAYCwgBh3YiNAkNAQMBAQEBA?=
 =?us-ascii?q?QECARMBAQEKCwkIKSMMgjYkAYJiAQICAQECFwEMEwYBATcBBAEJAQEKISUDDEg?=
 =?us-ascii?q?GCgkFD4MNAYF0BQgEAQqkSoFsM4J2AQEFhx4IiDKCToEcgQ+BBxJ/gxKERh8EA?=
 =?us-ascii?q?QyFZoEsAQGHegoogUeED0aBBoRkimEBBgIBhwCKMSMKgVGFEYMlhxWHaoV/iwS?=
 =?us-ascii?q?BRoINMxowgWGBTgmCEgwXg0qFFIU/QDKBAgMBASETij8rgiABAQ?=
X-IronPort-AV: E=Sophos;i="5.56,303,1539673200"; 
   d="scan'208";a="42371111"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 01 Dec 2018 10:01:22 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1725754AbeLBFLV (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sun, 2 Dec 2018 00:11:21 -0500
Received: from mail.kernel.org ([198.145.29.99]:52690 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1725726AbeLBFLV (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 2 Dec 2018 00:11:21 -0500
Received: from archlinux (cpc91196-cmbg18-2-0-cust659.5-4.cable.virginm.net [81.96.234.148])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id D07EA2082F;
        Sat,  1 Dec 2018 17:39:02 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1543685944;
        bh=ZqCusjVdr3VZMfDrlR0k0UJQy1nHpKvA0qb85X9o25M=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=0aSnagSnVPdKwkeKUpxcCxiBaFu4ZU+nIlYRUlIlsfbYNCNEdrFmZLLeEXwQRnM0u
         gdamiDaGzCFxRQquVLTJ9cRdJyOuevCEn1of9MR3VbWxkrL+Xwi2hzn2OEWt2c/ZOn
         00ocUItk8Zy6vVa8zCkmzoVuz8tUUwWN2HeoGqEY=
Date: Sat, 1 Dec 2018 17:39:00 +0000
From: Jonathan Cameron <jic23@kernel.org>
To: Stefan Popa <stefan.popa@analog.com>
Cc: <Michael.Hennerich@analog.com>, <knaack.h@gmx.de>,
        <lars@metafoo.de>, <pmeerw@pmeerw.net>,
        <gregkh@linuxfoundation.org>, <linux-kernel@vger.kernel.org>,
        <linux-iio@vger.kernel.org>, <devel@driverdev.osuosl.org>
Subject: Re: [PATCH v3 1/2] staging: iio: ad7606: Move out of staging
Message-ID: <20181201173900.26549f11@archlinux>
In-Reply-To: <1543510599-14744-1-git-send-email-stefan.popa@analog.com>
References: <1543510599-14744-1-git-send-email-stefan.popa@analog.com>
X-Mailer: Claws Mail 3.17.1 (GTK+ 2.24.32; x86_64-pc-linux-gnu)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Thu, 29 Nov 2018 18:56:39 +0200
Stefan Popa <stefan.popa@analog.com> wrote:

> Move ad7606 ADC driver out of staging and into the mainline.
> 
> Signed-off-by: Stefan Popa <stefan.popa@analog.com>

Hi Stefan,

This has fallen into the usual trap that if I take 'just one last look'
at something I always find just one more thing (well 2 here) to comment
on...

However, they are both very minor but nice to fix things that can be
done after moving out of staging as I don't want to delay that by
going to a v4.  Of course, if there are other review comments that
need fixing then please do tidy these up as well.

Thanks.  Good progress on moving stuff out of staging this cycle
so I'm very happy ;)

Jonathan

> ---
> Changes in v2:
> 	- Simplified the Kconfig menu.
> 	- Added SPDX-License-Identifier.
> 	- Ordered the includes alphabetically.
> 	- Used a threaded interrupt.
> 	- Replaced ad7606_poll_bh_to_ring() with ad7606_trigger_handler().
> 	- Used a trigger. 
> 	- Replaced wait_event_interruptible() with wait_for_completion_timeout().
> 	- Replaced wake_up_interruptible() with complete().
> 	- Used devm_iio_triggered_buffer_setup().
> 	- Added buffer_ops.
> 	- Used single line comments where needed.
> 	- Removed the gap between docs and struct.
> 	- Added ad7606_of_match[].
> Changes in v3:
> 	- Added a comment which offers more information of the way the interrupt
> 	  is triggered.
> 	- Fixed the way a new conversion is triggered.
> 	- endianness = IIO_CPU
> 	- Removed unnecessary mutex locks.
> 	- Removed the buffer_postdisable ops and replaced it with buffer_predisable.
> 	- Added a devm_add_action_or_reset() which deals with regulator_disable().
> 	- Misc style fixes.
> 	
>  MAINTAINERS                          |   7 +
>  drivers/iio/adc/Kconfig              |  28 ++
>  drivers/iio/adc/Makefile             |   3 +
>  drivers/iio/adc/ad7606.c             | 605 +++++++++++++++++++++++++++++++++++
>  drivers/iio/adc/ad7606.h             | 106 ++++++
>  drivers/iio/adc/ad7606_par.c         | 105 ++++++
>  drivers/iio/adc/ad7606_spi.c         |  82 +++++
>  drivers/staging/iio/adc/Kconfig      |  34 --
>  drivers/staging/iio/adc/Makefile     |   3 -
>  drivers/staging/iio/adc/ad7606.c     | 565 --------------------------------
>  drivers/staging/iio/adc/ad7606.h     | 106 ------
>  drivers/staging/iio/adc/ad7606_par.c | 113 -------
>  drivers/staging/iio/adc/ad7606_spi.c |  79 -----
>  13 files changed, 936 insertions(+), 900 deletions(-)
>  create mode 100644 drivers/iio/adc/ad7606.c
>  create mode 100644 drivers/iio/adc/ad7606.h
>  create mode 100644 drivers/iio/adc/ad7606_par.c
>  create mode 100644 drivers/iio/adc/ad7606_spi.c
>  delete mode 100644 drivers/staging/iio/adc/ad7606.c
>  delete mode 100644 drivers/staging/iio/adc/ad7606.h
>  delete mode 100644 drivers/staging/iio/adc/ad7606_par.c
>  delete mode 100644 drivers/staging/iio/adc/ad7606_spi.c
> 
> diff --git a/MAINTAINERS b/MAINTAINERS
> index f642044..843545d 100644
> --- a/MAINTAINERS
> +++ b/MAINTAINERS
> @@ -839,6 +839,13 @@ S:	Supported
>  F:	drivers/iio/dac/ad5758.c
>  F:	Documentation/devicetree/bindings/iio/dac/ad5758.txt
>  
> +ANALOG DEVICES INC AD7606 DRIVER
> +M:	Stefan Popa <stefan.popa@analog.com>
> +L:	linux-iio@vger.kernel.org
> +W:	http://ez.analog.com/community/linux-device-drivers
> +S:	Supported
> +F:	drivers/iio/adc/ad7606.c
> +
>  ANALOG DEVICES INC AD9389B DRIVER
>  M:	Hans Verkuil <hans.verkuil@cisco.com>
>  L:	linux-media@vger.kernel.org
> diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
> index a52fea8..c3f61c9 100644
> --- a/drivers/iio/adc/Kconfig
> +++ b/drivers/iio/adc/Kconfig
> @@ -58,6 +58,34 @@ config AD7476
>  	  To compile this driver as a module, choose M here: the
>  	  module will be called ad7476.
>  
> +config AD7606
> +	tristate
> +	depends on GPIOLIB || COMPILE_TEST
> +	depends on HAS_IOMEM
> +	select IIO_BUFFER
> +	select IIO_TRIGGERED_BUFFER
> +
> +config AD7606_IFACE_PARALLEL
> +	tristate "Analog Devices AD7606 ADC driver with parallel interface support"
> +	select AD7606
> +	help
> +	  Say yes here to build parallel interface support for Analog Devices:
> +	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
> +
> +	  To compile this driver as a module, choose M here: the
> +	  module will be called ad7606_parallel.
> +
> +config AD7606_IFACE_SPI
> +	tristate "Analog Devices AD7606 ADC driver with spi interface support"
> +	depends on SPI
> +	select AD7606
> +	help
> +	  Say yes here to build spi interface support for Analog Devices:
> +	  ad7605-4, ad7606, ad7606-6, ad7606-4 analog to digital converters (ADC).
> +
> +	  To compile this driver as a module, choose M here: the
> +	  module will be called ad7606_spi.
> +
>  config AD7766
>  	tristate "Analog Devices AD7766/AD7767 ADC driver"
>  	depends on SPI_MASTER
> diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
> index a6e6a0b..b734f4f 100644
> --- a/drivers/iio/adc/Makefile
> +++ b/drivers/iio/adc/Makefile
> @@ -8,6 +8,9 @@ obj-$(CONFIG_AD_SIGMA_DELTA) += ad_sigma_delta.o
>  obj-$(CONFIG_AD7266) += ad7266.o
>  obj-$(CONFIG_AD7291) += ad7291.o
>  obj-$(CONFIG_AD7298) += ad7298.o
> +obj-$(CONFIG_AD7606_IFACE_PARALLEL) += ad7606_par.o
> +obj-$(CONFIG_AD7606_IFACE_SPI) += ad7606_spi.o
> +obj-$(CONFIG_AD7606) += ad7606.o
>  obj-$(CONFIG_AD7923) += ad7923.o
>  obj-$(CONFIG_AD7476) += ad7476.o
>  obj-$(CONFIG_AD7766) += ad7766.o
> diff --git a/drivers/iio/adc/ad7606.c b/drivers/iio/adc/ad7606.c
> new file mode 100644
> index 0000000..7eb06b3
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606.c
> @@ -0,0 +1,605 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +/*
> + * AD7606 SPI ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#include <linux/delay.h>
> +#include <linux/device.h>
> +#include <linux/err.h>
> +#include <linux/gpio/consumer.h>
> +#include <linux/interrupt.h>
> +#include <linux/kernel.h>
> +#include <linux/module.h>
> +#include <linux/regulator/consumer.h>
> +#include <linux/sched.h>
> +#include <linux/slab.h>
> +#include <linux/sysfs.h>
> +
> +#include <linux/iio/iio.h>
> +#include <linux/iio/buffer.h>
> +#include <linux/iio/sysfs.h>
> +#include <linux/iio/trigger.h>
> +#include <linux/iio/triggered_buffer.h>
> +#include <linux/iio/trigger_consumer.h>
> +
> +#include "ad7606.h"
> +
> +/*
> + * Scales are computed as 5000/32768 and 10000/32768 respectively,
> + * so that when applied to the raw values they provide mV values
> + */
> +static const unsigned int scale_avail[2][2] = {
> +	{0, 152588}, {0, 305176}
> +};
> +
> +static int ad7606_reset(struct ad7606_state *st)
> +{
> +	if (st->gpio_reset) {
> +		gpiod_set_value(st->gpio_reset, 1);
> +		ndelay(100); /* t_reset >= 100ns */
> +		gpiod_set_value(st->gpio_reset, 0);
> +		return 0;
> +	}
> +
> +	return -ENODEV;
> +}
> +
> +static int ad7606_read_samples(struct ad7606_state *st)
> +{
> +	unsigned int num = st->chip_info->num_channels;
> +	u16 *data = st->data;
> +	int ret;
> +
> +	/*
> +	 * The frstdata signal is set to high while and after reading the sample
> +	 * of the first channel and low for all other channels. This can be used
> +	 * to check that the incoming data is correctly aligned. During normal
> +	 * operation the data should never become unaligned, but some glitch or
> +	 * electrostatic discharge might cause an extra read or clock cycle.
> +	 * Monitoring the frstdata signal allows to recover from such failure
> +	 * situations.
> +	 */
> +
> +	if (st->gpio_frstdata) {
> +		ret = st->bops->read_block(st->dev, 1, data);
> +		if (ret)
> +			return ret;
> +
> +		if (!gpiod_get_value(st->gpio_frstdata)) {
> +			ad7606_reset(st);
> +			return -EIO;
> +		}
> +
> +		data++;
> +		num--;
> +	}
> +
> +	return st->bops->read_block(st->dev, num, data);
> +}
> +
> +static irqreturn_t ad7606_trigger_handler(int irq, void *p)
> +{
> +	struct iio_poll_func *pf = p;
> +	struct iio_dev *indio_dev = pf->indio_dev;
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int ret;
> +
> +	mutex_lock(&st->lock);
> +
> +	ret = ad7606_read_samples(st);
> +	if (ret == 0)
> +		iio_push_to_buffers_with_timestamp(indio_dev, st->data,
> +						   iio_get_time_ns(indio_dev));
> +
> +	iio_trigger_notify_done(indio_dev->trig);
> +	/* The rising edge of the CONVST signal starts a new conversion. */
> +	gpiod_set_value(st->gpio_convst, 1);
> +
> +	mutex_unlock(&st->lock);
> +
> +	return IRQ_HANDLED;
> +}
> +
> +static int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned int ch)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int ret;
> +
> +	gpiod_set_value(st->gpio_convst, 1);
> +	ret = wait_for_completion_timeout(&st->completion,
> +					  msecs_to_jiffies(1000));
> +	if (!ret) {
> +		ret = -ETIMEDOUT;
> +		goto error_ret;
> +	}
> +
> +	ret = ad7606_read_samples(st);
> +	if (ret == 0)
> +		ret = st->data[ch];
> +
> +error_ret:
> +	gpiod_set_value(st->gpio_convst, 0);
> +
> +	return ret;
> +}
> +
> +static int ad7606_read_raw(struct iio_dev *indio_dev,
> +			   struct iio_chan_spec const *chan,
> +			   int *val,
> +			   int *val2,
> +			   long m)
> +{
> +	int ret;
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	switch (m) {
> +	case IIO_CHAN_INFO_RAW:
> +		ret = iio_device_claim_direct_mode(indio_dev);
> +		if (ret)
> +			return ret;
> +
> +		ret = ad7606_scan_direct(indio_dev, chan->address);
> +		iio_device_release_direct_mode(indio_dev);
> +
> +		if (ret < 0)
> +			return ret;
> +		*val = (short)ret;
> +		return IIO_VAL_INT;
> +	case IIO_CHAN_INFO_SCALE:
> +		*val = scale_avail[st->range][0];
> +		*val2 = scale_avail[st->range][1];
> +		return IIO_VAL_INT_PLUS_MICRO;
> +	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
> +		*val = st->oversampling;
> +		return IIO_VAL_INT;
> +	}
> +	return -EINVAL;
> +}
> +
> +static ssize_t in_voltage_scale_available_show(struct device *dev,
> +					       struct device_attribute *attr,
> +					       char *buf)
> +{
> +	int i, len = 0;
> +
> +	for (i = 0; i < ARRAY_SIZE(scale_avail); i++)
> +		len += scnprintf(buf + len, PAGE_SIZE - len, "%d.%06u ",
> +				 scale_avail[i][0], scale_avail[i][1]);
> +
> +	buf[len - 1] = '\n';
> +
> +	return len;
> +}
> +
> +static IIO_DEVICE_ATTR_RO(in_voltage_scale_available, 0);
> +
> +static int ad7606_oversampling_get_index(unsigned int val)
> +{
> +	unsigned char supported[] = {1, 2, 4, 8, 16, 32, 64};
> +	int i;
> +
> +	for (i = 0; i < ARRAY_SIZE(supported); i++)
> +		if (val == supported[i])
> +			return i;
> +
> +	return -EINVAL;
> +}
> +
> +static int ad7606_write_raw(struct iio_dev *indio_dev,
> +			    struct iio_chan_spec const *chan,
> +			    int val,
> +			    int val2,
> +			    long mask)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int values[3];
> +	int ret, i;
> +
> +	switch (mask) {
> +	case IIO_CHAN_INFO_SCALE:
> +		ret = -EINVAL;
> +		mutex_lock(&st->lock);
> +		for (i = 0; i < ARRAY_SIZE(scale_avail); i++)
> +			if (val2 == scale_avail[i][1]) {
> +				gpiod_set_value(st->gpio_range, i);
> +				st->range = i;
> +
> +				ret = 0;
> +				break;
> +			}
> +		mutex_unlock(&st->lock);
> +
> +		return ret;
> +	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
> +		if (val2)
> +			return -EINVAL;
> +		ret = ad7606_oversampling_get_index(val);
> +		if (ret < 0)
> +			return ret;
> +
> +		values[0] = (ret >> 0) & 1;
> +		values[1] = (ret >> 1) & 1;
> +		values[2] = (ret >> 2) & 1;
> +
> +		mutex_lock(&st->lock);
> +		gpiod_set_array_value(ARRAY_SIZE(values), st->gpio_os->desc,
> +				      values);
> +		st->oversampling = val;
> +		mutex_unlock(&st->lock);
> +
> +		return 0;
> +	default:
> +		return -EINVAL;
> +	}
> +}
> +
> +static IIO_CONST_ATTR(oversampling_ratio_available, "1 2 4 8 16 32 64");
> +
> +static struct attribute *ad7606_attributes_os_and_range[] = {
> +	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
> +	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group ad7606_attribute_group_os_and_range = {
> +	.attrs = ad7606_attributes_os_and_range,
> +};
> +
> +static struct attribute *ad7606_attributes_os[] = {
> +	&iio_const_attr_oversampling_ratio_available.dev_attr.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group ad7606_attribute_group_os = {
> +	.attrs = ad7606_attributes_os,
> +};
> +
> +static struct attribute *ad7606_attributes_range[] = {
> +	&iio_dev_attr_in_voltage_scale_available.dev_attr.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group ad7606_attribute_group_range = {
> +	.attrs = ad7606_attributes_range,
> +};
> +
> +#define AD760X_CHANNEL(num, mask) {				\
> +		.type = IIO_VOLTAGE,				\
> +		.indexed = 1,					\
> +		.channel = num,					\
> +		.address = num,					\
> +		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
> +		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\
> +		.info_mask_shared_by_all = mask,		\
> +		.scan_index = num,				\
> +		.scan_type = {					\
> +			.sign = 's',				\
> +			.realbits = 16,				\
> +			.storagebits = 16,			\
> +			.endianness = IIO_CPU,			\
> +		},						\
> +}
> +
> +#define AD7605_CHANNEL(num)	\
> +	AD760X_CHANNEL(num, 0)
> +
> +#define AD7606_CHANNEL(num)	\
> +	AD760X_CHANNEL(num, BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO))
> +
> +static const struct iio_chan_spec ad7605_channels[] = {
> +	IIO_CHAN_SOFT_TIMESTAMP(4),
> +	AD7605_CHANNEL(0),
> +	AD7605_CHANNEL(1),
> +	AD7605_CHANNEL(2),
> +	AD7605_CHANNEL(3),
> +};
> +
> +static const struct iio_chan_spec ad7606_channels[] = {
> +	IIO_CHAN_SOFT_TIMESTAMP(8),
> +	AD7606_CHANNEL(0),
> +	AD7606_CHANNEL(1),
> +	AD7606_CHANNEL(2),
> +	AD7606_CHANNEL(3),
> +	AD7606_CHANNEL(4),
> +	AD7606_CHANNEL(5),
> +	AD7606_CHANNEL(6),
> +	AD7606_CHANNEL(7),
> +};
> +
> +static const struct ad7606_chip_info ad7606_chip_info_tbl[] = {
> +	/* More devices added in future */
> +	[ID_AD7605_4] = {
> +		.channels = ad7605_channels,
> +		.num_channels = 5,
> +	},
> +	[ID_AD7606_8] = {
> +		.channels = ad7606_channels,
> +		.num_channels = 9,
> +		.has_oversampling = true,
> +	},
> +	[ID_AD7606_6] = {
> +		.channels = ad7606_channels,
> +		.num_channels = 7,
> +		.has_oversampling = true,
> +	},
> +	[ID_AD7606_4] = {
> +		.channels = ad7606_channels,
> +		.num_channels = 5,
> +		.has_oversampling = true,
> +	},
> +};
> +
> +static int ad7606_request_gpios(struct ad7606_state *st)
> +{
> +	struct device *dev = st->dev;
> +
> +	st->gpio_convst = devm_gpiod_get(dev, "adi,conversion-start",
> +					 GPIOD_OUT_LOW);
> +	if (IS_ERR(st->gpio_convst))
> +		return PTR_ERR(st->gpio_convst);
> +
> +	st->gpio_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
> +	if (IS_ERR(st->gpio_reset))
> +		return PTR_ERR(st->gpio_reset);
> +
> +	st->gpio_range = devm_gpiod_get_optional(dev, "adi,range",
> +						 GPIOD_OUT_LOW);
> +	if (IS_ERR(st->gpio_range))
> +		return PTR_ERR(st->gpio_range);
> +
> +	st->gpio_standby = devm_gpiod_get_optional(dev, "standby",
> +						   GPIOD_OUT_HIGH);
> +	if (IS_ERR(st->gpio_standby))
> +		return PTR_ERR(st->gpio_standby);
> +
> +	st->gpio_frstdata = devm_gpiod_get_optional(dev, "adi,first-data",
> +						    GPIOD_IN);
> +	if (IS_ERR(st->gpio_frstdata))
> +		return PTR_ERR(st->gpio_frstdata);
> +
> +	if (!st->chip_info->has_oversampling)
> +		return 0;
> +
> +	st->gpio_os = devm_gpiod_get_array_optional(dev,
> +						    "adi,oversampling-ratio",
> +						    GPIOD_OUT_LOW);
> +	return PTR_ERR_OR_ZERO(st->gpio_os);
> +}
> +
> +/*
> + * The BUSY signal indicates when conversions are in progress, so when a rising
> + * edge of CONVST is applied, BUSY goes logic high and transitions low at the
> + * end of the entire conversion process. The falling edge of the BUSY signal
> + * triggers this interrupt.
> + */
> +static irqreturn_t ad7606_interrupt(int irq, void *dev_id)
> +{
> +	struct iio_dev *indio_dev = dev_id;
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (iio_buffer_enabled(indio_dev)) {
> +		gpiod_set_value(st->gpio_convst, 0);
> +		iio_trigger_poll_chained(st->trig);
> +	} else {
> +		complete(&st->completion);
> +	}
> +
> +	return IRQ_HANDLED;
> +};
> +
> +static int ad7606_validate_trigger(struct iio_dev *indio_dev,
> +				   struct iio_trigger *trig)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (st->trig != trig)
> +		return -EINVAL;
> +
> +	return 0;
> +}
> +
> +static int ad7606_buffer_postenable(struct iio_dev *indio_dev)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	iio_triggered_buffer_postenable(indio_dev);
> +	gpiod_set_value(st->gpio_convst, 1);
> +
> +	return 0;
> +}
> +
> +static int ad7606_buffer_predisable(struct iio_dev *indio_dev)
> +{
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +	int ret;
> +
> +	reinit_completion(&st->completion);
> +	gpiod_set_value(st->gpio_convst, 1);
> +	ret = wait_for_completion_timeout(&st->completion,
> +					  msecs_to_jiffies(1000));
> +	gpiod_set_value(st->gpio_convst, 0);
> +
> +	return iio_triggered_buffer_predisable(indio_dev);
> +}
> +
> +static const struct iio_buffer_setup_ops ad7606_buffer_ops = {
> +	.postenable = &ad7606_buffer_postenable,
> +	.predisable = &ad7606_buffer_predisable,
> +};
> +
> +static const struct iio_info ad7606_info_no_os_or_range = {
> +	.read_raw = &ad7606_read_raw,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_info ad7606_info_os_and_range = {
> +	.read_raw = &ad7606_read_raw,
> +	.write_raw = &ad7606_write_raw,
> +	.attrs = &ad7606_attribute_group_os_and_range,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_info ad7606_info_os = {
> +	.read_raw = &ad7606_read_raw,
> +	.write_raw = &ad7606_write_raw,
> +	.attrs = &ad7606_attribute_group_os,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_info ad7606_info_range = {
> +	.read_raw = &ad7606_read_raw,
> +	.write_raw = &ad7606_write_raw,
> +	.attrs = &ad7606_attribute_group_range,
> +	.validate_trigger = &ad7606_validate_trigger,
> +};
> +
> +static const struct iio_trigger_ops ad7606_trigger_ops = {
> +	.validate_device = iio_trigger_validate_own_device,
> +};
> +
> +static void ad7606_regulator_disable(void *data)
> +{
> +	struct ad7606_state *st = data;
> +
> +	regulator_disable(st->reg);
> +}
> +
> +int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
> +		 const char *name, unsigned int id,
> +		 const struct ad7606_bus_ops *bops)
> +{
> +	struct ad7606_state *st;
> +	int ret;
> +	struct iio_dev *indio_dev;
> +
> +	indio_dev = devm_iio_device_alloc(dev, sizeof(*st));
> +	if (!indio_dev)
> +		return -ENOMEM;
> +
> +	st = iio_priv(indio_dev);
> +	dev_set_drvdata(dev, indio_dev);
> +
> +	st->dev = dev;
> +	mutex_init(&st->lock);
> +	st->bops = bops;
> +	st->base_address = base_address;
> +	/* tied to logic low, analog input range is +/- 5V */
> +	st->range = 0;
> +	st->oversampling = 1;
> +
> +	st->reg = devm_regulator_get(dev, "avcc");
> +	if (IS_ERR(st->reg))
> +		return PTR_ERR(st->reg);
> +
> +	ret = regulator_enable(st->reg);
> +	if (ret) {
> +		dev_err(dev, "Failed to enable specified AVcc supply\n");
> +		return ret;
> +	}
> +
> +	ret = devm_add_action_or_reset(dev, ad7606_regulator_disable, st);
> +	if (ret)
> +		return ret;
> +
> +	st->chip_info = &ad7606_chip_info_tbl[id];
> +
> +	ret = ad7606_request_gpios(st);
> +	if (ret)
> +		return ret;
> +
> +	indio_dev->dev.parent = dev;
> +	if (st->gpio_os) {
> +		if (st->gpio_range)
> +			indio_dev->info = &ad7606_info_os_and_range;
> +		else
> +			indio_dev->info = &ad7606_info_os;
> +	} else {
> +		if (st->gpio_range)
> +			indio_dev->info = &ad7606_info_range;
> +		else
> +			indio_dev->info = &ad7606_info_no_os_or_range;
> +	}
> +	indio_dev->modes = INDIO_DIRECT_MODE;
> +	indio_dev->name = name;
> +	indio_dev->channels = st->chip_info->channels;
> +	indio_dev->num_channels = st->chip_info->num_channels;
> +
> +	ret = ad7606_reset(st);
> +	if (ret)
> +		dev_warn(st->dev, "failed to RESET: no RESET GPIO specified\n");
> +
> +	st->trig = devm_iio_trigger_alloc(dev, "%s-dev%d",
> +					  indio_dev->name, indio_dev->id);
> +	if (st->trig == NULL)
> +		return -ENOMEM;
> +
> +	st->trig->ops = &ad7606_trigger_ops;
> +	st->trig->dev.parent = dev;
> +	iio_trigger_set_drvdata(st->trig, indio_dev);
> +	ret = devm_iio_trigger_register(dev, st->trig);
> +	if (ret)
> +		return ret;
> +
> +	indio_dev->trig = iio_trigger_get(st->trig);
> +
> +	init_completion(&st->completion);
> +
> +	ret = devm_request_threaded_irq(dev, irq,
> +					NULL,
> +					&ad7606_interrupt,
> +					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
> +					name, indio_dev);
> +	if (ret)
> +		return ret;
> +
> +	ret = devm_iio_triggered_buffer_setup(dev, indio_dev,
> +					      &iio_pollfunc_store_time,
> +					      &ad7606_trigger_handler,
> +					      &ad7606_buffer_ops);
> +	if (ret)
> +		return ret;
> +
> +	return devm_iio_device_register(dev, indio_dev);
> +

Odd place for a blank line.

> +}
> +EXPORT_SYMBOL_GPL(ad7606_probe);
> +
> +#ifdef CONFIG_PM_SLEEP

There has been a fairly strong move towards avoiding this protection
in favour of __maybe_unused.  It's far to easy to get the mess
of PM options wrong so this is much safer rather than protections
in every driver.

> +
> +static int ad7606_suspend(struct device *dev)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (st->gpio_standby) {
> +		gpiod_set_value(st->gpio_range, 1);
> +		gpiod_set_value(st->gpio_standby, 0);
> +	}
> +
> +	return 0;
> +}
> +
> +static int ad7606_resume(struct device *dev)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	if (st->gpio_standby) {
> +		gpiod_set_value(st->gpio_range, st->range);
> +		gpiod_set_value(st->gpio_standby, 1);
> +		ad7606_reset(st);
> +	}
> +
> +	return 0;
> +}
> +
> +SIMPLE_DEV_PM_OPS(ad7606_pm_ops, ad7606_suspend, ad7606_resume);
> +EXPORT_SYMBOL_GPL(ad7606_pm_ops);
> +
> +#endif
> +
> +MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
> +MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
> +MODULE_LICENSE("GPL");
> diff --git a/drivers/iio/adc/ad7606.h b/drivers/iio/adc/ad7606.h
> new file mode 100644
> index 0000000..d70659e
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606.h
> @@ -0,0 +1,106 @@
> +/* SPDX-License-Identifier: GPL-2.0+ */
> +/*
> + * AD7606 ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#ifndef IIO_ADC_AD7606_H_
> +#define IIO_ADC_AD7606_H_
> +
> +/**
> + * struct ad7606_chip_info - chip specific information
> + * @channels:		channel specification
> + * @num_channels:	number of channels
> + * @has_oversampling:   whether the device has oversampling support
> + */
> +struct ad7606_chip_info {
> +	const struct iio_chan_spec	*channels;
> +	unsigned int			num_channels;
> +	bool				has_oversampling;
> +};
> +
> +/**
> + * struct ad7606_state - driver instance specific data
> + * @dev		pointer to kernel device
> + * @chip_info		entry in the table of chips that describes this device
> + * @reg		regulator info for the the power supply of the device
> + * @poll_work		work struct for continuously reading data from the device
> + *			into an IIO triggered buffer
> + * @wq_data_avail	wait queue struct for buffer mode
> + * @bops		bus operations (SPI or parallel)
> + * @range		voltage range selection, selects which scale to apply
> + * @oversampling	oversampling selection
> + * @done		marks whether reading data is done
> + * @base_address	address from where to read data in parallel operation
> + * @lock		protect sensor state from concurrent accesses to GPIOs
> + * @gpio_convst	GPIO descriptor for conversion start signal (CONVST)
> + * @gpio_reset		GPIO descriptor for device hard-reset
> + * @gpio_range		GPIO descriptor for range selection
> + * @gpio_standby	GPIO descriptor for stand-by signal (STBY),
> + *			controls power-down mode of device
> + * @gpio_frstdata	GPIO descriptor for reading from device when data
> + *			is being read on the first channel
> + * @gpio_os		GPIO descriptors to control oversampling on the device
> + * @complete		completion to indicate end of conversion

It is neither called complete nor in this location in the structure..

> + * @trig		The IIO trigger associated with the device.
> + * @data		buffer for reading data from the device
> + */
> +struct ad7606_state {
> +	struct device			*dev;
> +	const struct ad7606_chip_info	*chip_info;
> +	struct regulator		*reg;
> +	struct work_struct		poll_work;
> +	wait_queue_head_t		wq_data_avail;
> +	const struct ad7606_bus_ops	*bops;
> +	unsigned int			range;
> +	unsigned int			oversampling;
> +	bool				done;
> +	void __iomem			*base_address;
> +
> +	struct mutex			lock; /* protect sensor state */
> +	struct gpio_desc		*gpio_convst;
> +	struct gpio_desc		*gpio_reset;
> +	struct gpio_desc		*gpio_range;
> +	struct gpio_desc		*gpio_standby;
> +	struct gpio_desc		*gpio_frstdata;
> +	struct gpio_descs		*gpio_os;
> +	struct iio_trigger		*trig;
> +	struct completion		completion;
> +
> +	/*
> +	 * DMA (thus cache coherency maintenance) requires the
> +	 * transfer buffers to live in their own cache lines.
> +	 * 8 * 16-bit samples + 64-bit timestamp
> +	 */
> +	unsigned short			data[12] ____cacheline_aligned;
> +};
> +
> +/**
> + * struct ad7606_bus_ops - driver bus operations
> + * @read_block		function pointer for reading blocks of data
> + */
> +struct ad7606_bus_ops {
> +	/* more methods added in future? */
> +	int (*read_block)(struct device *dev, int num, void *data);
> +};
> +
> +int ad7606_probe(struct device *dev, int irq, void __iomem *base_address,
> +		 const char *name, unsigned int id,
> +		 const struct ad7606_bus_ops *bops);
> +
> +enum ad7606_supported_device_ids {
> +	ID_AD7605_4,
> +	ID_AD7606_8,
> +	ID_AD7606_6,
> +	ID_AD7606_4
> +};
> +
> +#ifdef CONFIG_PM_SLEEP
> +extern const struct dev_pm_ops ad7606_pm_ops;
> +#define AD7606_PM_OPS (&ad7606_pm_ops)
> +#else
> +#define AD7606_PM_OPS NULL
> +#endif
> +
> +#endif /* IIO_ADC_AD7606_H_ */
> diff --git a/drivers/iio/adc/ad7606_par.c b/drivers/iio/adc/ad7606_par.c
> new file mode 100644
> index 0000000..32c7069
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606_par.c
> @@ -0,0 +1,105 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +/*
> + * AD7606 Parallel Interface ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#include <linux/module.h>
> +#include <linux/platform_device.h>
> +#include <linux/types.h>
> +#include <linux/err.h>
> +#include <linux/io.h>
> +
> +#include <linux/iio/iio.h>
> +#include "ad7606.h"
> +
> +static int ad7606_par16_read_block(struct device *dev,
> +				   int count, void *buf)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	insw((unsigned long)st->base_address, buf, count);
> +
> +	return 0;
> +}
> +
> +static const struct ad7606_bus_ops ad7606_par16_bops = {
> +	.read_block = ad7606_par16_read_block,
> +};
> +
> +static int ad7606_par8_read_block(struct device *dev,
> +				  int count, void *buf)
> +{
> +	struct iio_dev *indio_dev = dev_get_drvdata(dev);
> +	struct ad7606_state *st = iio_priv(indio_dev);
> +
> +	insb((unsigned long)st->base_address, buf, count * 2);
> +
> +	return 0;
> +}
> +
> +static const struct ad7606_bus_ops ad7606_par8_bops = {
> +	.read_block = ad7606_par8_read_block,
> +};
> +
> +static int ad7606_par_probe(struct platform_device *pdev)
> +{
> +	const struct platform_device_id *id = platform_get_device_id(pdev);
> +	struct resource *res;
> +	void __iomem *addr;
> +	resource_size_t remap_size;
> +	int irq;
> +
> +	irq = platform_get_irq(pdev, 0);
> +	if (irq < 0) {
> +		dev_err(&pdev->dev, "no irq: %d\n", irq);
> +		return irq;
> +	}
> +
> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
> +	addr = devm_ioremap_resource(&pdev->dev, res);
> +	if (IS_ERR(addr))
> +		return PTR_ERR(addr);
> +
> +	remap_size = resource_size(res);
> +
> +	return ad7606_probe(&pdev->dev, irq, addr,
> +			    id->name, id->driver_data,
> +			    remap_size > 1 ? &ad7606_par16_bops :
> +			    &ad7606_par8_bops);
> +}
> +
> +static const struct platform_device_id ad7606_driver_ids[] = {
> +	{ .name	= "ad7605-4", .driver_data = ID_AD7605_4, },
> +	{ .name	= "ad7606-4", .driver_data = ID_AD7606_4, },
> +	{ .name	= "ad7606-6", .driver_data = ID_AD7606_6, },
> +	{ .name	= "ad7606-8", .driver_data = ID_AD7606_8, },
> +	{ }
> +};
> +MODULE_DEVICE_TABLE(platform, ad7606_driver_ids);
> +
> +static const struct of_device_id ad7606_of_match[] = {
> +	{ .compatible = "adi,ad7605-4" },
> +	{ .compatible = "adi,ad7606-4" },
> +	{ .compatible = "adi,ad7606-6" },
> +	{ .compatible = "adi,ad7606-8" },
> +	{ },
> +};
> +MODULE_DEVICE_TABLE(of, ad7606_of_match);
> +
> +static struct platform_driver ad7606_driver = {
> +	.probe = ad7606_par_probe,
> +	.id_table = ad7606_driver_ids,
> +	.driver = {
> +		.name = "ad7606",
> +		.pm = AD7606_PM_OPS,
> +		.of_match_table = ad7606_of_match,
> +	},
> +};
> +module_platform_driver(ad7606_driver);
> +
> +MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
> +MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
> +MODULE_LICENSE("GPL");
> diff --git a/drivers/iio/adc/ad7606_spi.c b/drivers/iio/adc/ad7606_spi.c
> new file mode 100644
> index 0000000..6bb1867
> --- /dev/null
> +++ b/drivers/iio/adc/ad7606_spi.c
> @@ -0,0 +1,82 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +/*
> + * AD7606 SPI ADC driver
> + *
> + * Copyright 2011 Analog Devices Inc.
> + */
> +
> +#include <linux/module.h>
> +#include <linux/spi/spi.h>
> +#include <linux/types.h>
> +#include <linux/err.h>
> +
> +#include <linux/iio/iio.h>
> +#include "ad7606.h"
> +
> +#define MAX_SPI_FREQ_HZ		23500000	/* VDRIVE above 4.75 V */
> +
> +static int ad7606_spi_read_block(struct device *dev,
> +				 int count, void *buf)
> +{
> +	struct spi_device *spi = to_spi_device(dev);
> +	int i, ret;
> +	unsigned short *data = buf;
> +	__be16 *bdata = buf;
> +
> +	ret = spi_read(spi, buf, count * 2);
> +	if (ret < 0) {
> +		dev_err(&spi->dev, "SPI read error\n");
> +		return ret;
> +	}
> +
> +	for (i = 0; i < count; i++)
> +		data[i] = be16_to_cpu(bdata[i]);
> +
> +	return 0;
> +}
> +
> +static const struct ad7606_bus_ops ad7606_spi_bops = {
> +	.read_block = ad7606_spi_read_block,
> +};
> +
> +static int ad7606_spi_probe(struct spi_device *spi)
> +{
> +	const struct spi_device_id *id = spi_get_device_id(spi);
> +
> +	return ad7606_probe(&spi->dev, spi->irq, NULL,
> +			    id->name, id->driver_data,
> +			    &ad7606_spi_bops);
> +}
> +
> +static const struct spi_device_id ad7606_id_table[] = {
> +	{ "ad7605-4", ID_AD7605_4 },
> +	{ "ad7606-4", ID_AD7606_4 },
> +	{ "ad7606-6", ID_AD7606_6 },
> +	{ "ad7606-8", ID_AD7606_8 },
> +	{}
> +};
> +MODULE_DEVICE_TABLE(spi, ad7606_id_table);
> +
> +static const struct of_device_id ad7606_of_match[] = {
> +	{ .compatible = "adi,ad7605-4" },
> +	{ .compatible = "adi,ad7606-4" },
> +	{ .compatible = "adi,ad7606-6" },
> +	{ .compatible = "adi,ad7606-8" },
> +	{ },
> +};
> +MODULE_DEVICE_TABLE(of, ad7606_of_match);
> +
> +static struct spi_driver ad7606_driver = {
> +	.driver = {
> +		.name = "ad7606",
> +		.of_match_table = ad7606_of_match,
> +		.pm = AD7606_PM_OPS,
> +	},
> +	.probe = ad7606_spi_probe,
> +	.id_table = ad7606_id_table,
> +};
> +module_spi_driver(ad7606_driver);
> +
> +MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
> +MODULE_DESCRIPTION("Analog Devices AD7606 ADC");
> +MODULE_LICENSE("GPL v2");

...

