Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:35:51 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga003.jf.intel.com (orsmga003.jf.intel.com [10.7.209.27])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 401A75803EB;
	Fri, 23 Nov 2018 08:19:22 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by orsmga003-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 08:19:22 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Aj0EEmBRTyGh+zbX1FonKE+O0h9psv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64Yh2Et8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZAY2y?=
 =?us-ascii?q?cosBAfQPM+laoYnyu1UBohSxCwm3HOPiyCRFhmP00KAgz+gtDRvL0Q4mEtkTsH?=
 =?us-ascii?q?rUttL1NKIKXO6p1qbH0CjDZO5O1zf89IfIdRQhruuSUrlta8TRyFMvGB3fgV6N?=
 =?us-ascii?q?roHlJSma2fkQs2eD6epgVP6gi2kjqw5rvDej3N8siojTho0L0F/J7jh5wJ4uKt?=
 =?us-ascii?q?GiUk57ZsepHZ1NvC+ZL4t7Wt0uT31stSog17ELt4C3cDIXxJkk2xLTcf2KfoqQ?=
 =?us-ascii?q?7h7+W+udPC10iXFldb6lmhq/8FSsxvfhWsS21ltBszBLncPWtn8X0hze8siHRe?=
 =?us-ascii?q?V5/kemwTuPyQ/T5f9eIUwulqrUNYQhwrgumZoXq0jDGTX2mErugK+XcEUr5PSo?=
 =?us-ascii?q?5vz5brn6opKQLZJ4hw/gPqg0h8CyAvg0PhIPUmWZ4ei80afs/Uz9QLVElP02la?=
 =?us-ascii?q?zZvYjeJcQaoK65HgBU3p8g6xmhFTem1soXnX0eIFJCdhOHiZbmO0vVLfDmAvew?=
 =?us-ascii?q?nU6snC1ox//YJL3hBIvCLnzZnLfmZ7Z95FZQyBAvwtBH+5JUFrYBLer3Wk/wt9?=
 =?us-ascii?q?zXEAU1MgOpw+v8DNV914UeWX+AA6ODMaPSt0OI6fwrI+WWeIAVvzP9IeA/5/Hy?=
 =?us-ascii?q?lX85hUMdfa6x0JsXcn+4H+hmLF+eYXb2gtcBDH0FvgwxTOHxjF2CUDhTZ2u9Xq?=
 =?us-ascii?q?4m5zE7Dp6mApnHRoy3nLOB2yK7FIVMZm9aElCMDWvod4KcVvcObyKdPNVtkj8D?=
 =?us-ascii?q?VbinTY8h0gqjtAv7y7phM+rV9TcUtZPl1Nhp+eLTkQs++iBzD8SYy2uNVX17nn?=
 =?us-ascii?q?sURz8q26ByuVZyykyD0ah/gPxUD8ZT6OlLUgohMZ7czup6C839Ww7bf9eJTkqm?=
 =?us-ascii?q?TcuiAT0rUt0xxNoOaV5nG9q+lhDDwzaqA7gNmryIHpM09LjQ33zwJ8lnzXbG27?=
 =?us-ascii?q?Isj10nQstJKG2nibRz9wnVB47VjUqZk7ymergb3C7I7G2D13aBvFlEUA5sVqXI?=
 =?us-ascii?q?RW0QaVHIrdvn/E/CT6WhCbI8MgRfz86OLa9Kat7sjVVCX/rjPNXeY2Ssm2a/Hx?=
 =?us-ascii?q?qIx7WMbJb0dGUZxinSFE8EkwUL93acKQc+Hjuho37ZDDF2CF3geV3s/vdkpHO7?=
 =?us-ascii?q?VEA0yRqKYFNn17eu/h4VhPqcS+4c374euSchrSl0E0i5397MF9WAoA9hdr1GYd?=
 =?us-ascii?q?wh+FdHyX7ZtwtlM5y8LqBig1kecxh3v0LuzRl3Fp9Mkc8wrHMuzQpyL62Y3UhF?=
 =?us-ascii?q?dzOZ25DwJ7LWJnPz/BCpd67ZxFXe3MyK9acI7fQys0/jsx2xFko+73Vn1MFY3G?=
 =?us-ascii?q?GY5prUAwsdT5LwXlws+Bhnur7VeC8954DT1X1yKqS0tj7C29Q0BOoq0BqgftFf?=
 =?us-ascii?q?ML+aGw/2CcEVG8+uKOkykVizch0EJPxS9LIzP86+d/qGxbSnM/p6kDOnjWRI+o?=
 =?us-ascii?q?Z90k2X+ip4S+7I2YsFwv6C0guGUTf8kEmussTtlY9YYjESG3K1yTL4C45Jeq1y?=
 =?us-ascii?q?YYELBH+0I8222tpxnYTtVGNf9FK5AVMJxtWpeRuLY1PhxwJQ0VkYrmK9mSu/yT?=
 =?us-ascii?q?x5iDUprquZ3CzTzOXubhsHOmhXRGZ8iVfgO5S7j9cfXEKwdQgmiAOl5Vrmx6hc?=
 =?us-ascii?q?vKl+L2jTTV1IfiTsNGFiT62wu6GGY85O7pMorCpWXP69YVCcVr7yvR8a3zn/EG?=
 =?us-ascii?q?tZwTAxbyuqtYnhnxxmlGKdK25+rHjDdsFqxhff59vcSeRK3jUcRyl4ijjXBl6i?=
 =?us-ascii?q?MNmv5tiUk5bDsuajV2OuTJFTcC/rzZ+euyu//2FlHRq/n/WrkN39DQc6yTP718?=
 =?us-ascii?q?VtVSjQrBfzeI7r2764MeJmeEllH1v868t8GoFjnYo8npAQ2X4GhpqL+XoLi3v8?=
 =?us-ascii?q?MdJe2ajmdnoCWSYLw8LJ4AjiwEBjLWiGx4PjWnWd38tufd+6YmwN1yI57sBKDr?=
 =?us-ascii?q?qU7bNekSt0pFq4sRzeYfxnkjgBzvsu7WYQg/sVtwo10iWdHrcSEFFdPSztlBSH?=
 =?us-ascii?q?9cqyratJa2a0bbi/ylB+ksu/A7GYrQFRQ3L5epYkHS9t4cRzKlPM0Hvv6o76fN?=
 =?us-ascii?q?ncd84cthqRkx3YlehaNIoxluYWhSpgIW/9oXoly+shgR1vx566upWHK352/KK4?=
 =?us-ascii?q?GRNYMjz1Z8UO+jDil6pen8CW35yxEZVlADkEQJzoTfewGjIIqfvnLxqOECE7qn?=
 =?us-ascii?q?qDArXQBwif6EN7r37VF5CrKmqaJH0YzdVkWRmcK1ZTgAESXDUmgJE5Ehqmy9Dm?=
 =?us-ascii?q?cEd8/joR/EL3qgNQyuJ0MBnySmXfqx2tajgqU5iTNgZW4htB50fIMsye8+RzED?=
 =?us-ascii?q?tD/pC6qAyNK2qbZxlHDG0TW0yEAUzjMaeq5dXa7+eYAe++JePUYbqSsexeS+uI?=
 =?us-ascii?q?xZW334pm+DaMK9yPPmR4AP09wEZDRnd5G8LWmzgUTywXliTNb9OUpRum+y13qN?=
 =?us-ascii?q?y//+rvWA71+YSPDL5SO811+x+qmaeDK/KQhCFhJDZYyJwMxHzIyLse3FIIiCFu?=
 =?us-ascii?q?bT6tEbseui7XUaLQgbRaDxoaayN1KctJ4Lgw3ghLOc7HlNz10qR0geIyC1dATV?=
 =?us-ascii?q?bhgN2mZdQWI2GhM1PKHFyENKmdKj3R3c72YbmwSblRjOhPsx2wuDCbE1LsPziZ?=
 =?us-ascii?q?ljnpUQyvPv9IjC2BIBNev4S9eA53CWf/VNLmdgG7MNhvgD0qwL00g2nGOnIGPT?=
 =?us-ascii?q?dgc0NCsLuQ4DhcgvV+HWxB83VkIfOFmyaf8+nXNJIWveF3DSRzkuJQ+G46xKdN?=
 =?us-ascii?q?7CFYWPx1nzPfr950rFGgl+mPyzxnXwJPqzZLno2Lu0piNL7d9plBX3bE4R0M4X?=
 =?us-ascii?q?+RCxQMu9tqFNnvt7pMxdjIkaKgYAtFpujT98oaT+3JMtqHITJ1Kx3jGTiSCRYf?=
 =?us-ascii?q?VT66HWjFggpWl/TEsjWPr5M6o4Lg3pUDTLhGWHQ6E/obDgJuG9lGaJN6U3Umlr?=
 =?us-ascii?q?iWl+YM5Hy3th6XQ99V+tjdUfiSQvnzADWUl79JY10P27y8ZYEaLI69wVF+blB8?=
 =?us-ascii?q?kKzDAU+WVtdI5mVnbwQzpExWtnZzVHc+80fkYRmq638SDbi/mRtywgJ6bPQk8j?=
 =?us-ascii?q?v27hE9K17Ooy0xuEM2nsnhgDbXezn0aO+0QI1RFSv/8UQ8KYn8SAZ4diW3nEd+?=
 =?us-ascii?q?MzzERqoXhLwkPWpxjwjauJZnGvNGS6BAJhgKyqK5ffIthG5Vpjjv405M4u/MBN?=
 =?us-ascii?q?NalREneNb4tXtMxjVlbdUyIaXdYrJI1FVZrr+WtGmy0bZik0clO08R/TbKK2Yz?=
 =?us-ascii?q?s0sSO+xjfnLw8w=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ASAAC8J/hbh0O0hNFjHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBAYNqJ4N5iBhfiyGCDRSXJ4F2KRMBhECEGiI0CQ0BAwEBAQEBAQI?=
 =?us-ascii?q?BEwEBAQgNCQgpIwxCARABgWIkAYJiAQIDAQIgBBkBATcBBQkBAQoYAgImAgIDV?=
 =?us-ascii?q?AYBCQkFgxyCAgQBphdwfDOCdgEBBYJEhFEIgQuKfoIWgRGDEoR+gwSCV4kbhkO?=
 =?us-ascii?q?BAo8kBwKKKYcekQiZViCCDTMag1+CGwkDF4lZhEU+ATGBBQEBIYFMijQBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ASAAC8J/hbh0O0hNFjHAEBAQQBAQcEAQGBUQcBAQsBAYN?=
 =?us-ascii?q?qJ4N5iBhfiyGCDRSXJ4F2KRMBhECEGiI0CQ0BAwEBAQEBAQIBEwEBAQgNCQgpI?=
 =?us-ascii?q?wxCARABgWIkAYJiAQIDAQIgBBkBATcBBQkBAQoYAgImAgIDVAYBCQkFgxyCAgQ?=
 =?us-ascii?q?BphdwfDOCdgEBBYJEhFEIgQuKfoIWgRGDEoR+gwSCV4kbhkOBAo8kBwKKKYcek?=
 =?us-ascii?q?QiZViCCDTMag1+CGwkDF4lZhEU+ATGBBQEBIYFMijQBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,270,1539673200"; 
   d="scan'208";a="42005122"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 08:19:20 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2410167AbeKXDEI (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 22:04:08 -0500
Received: from mail-sender220.upb.ro ([141.85.13.220]:32976 "EHLO mx.upb.ro"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S2391108AbeKXDEI (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 22:04:08 -0500
Received: from mx.upb.ro (localhost [127.0.0.1])
        by mx.upb.ro (Postfix) with ESMTPS id 050D8B560087;
        Fri, 23 Nov 2018 18:19:13 +0200 (EET)
Received: from localhost (localhost [127.0.0.1])
        by mx.upb.ro (Postfix) with ESMTP id DE17FB560084;
        Fri, 23 Nov 2018 18:19:12 +0200 (EET)
DKIM-Filter: OpenDKIM Filter v2.10.3 mx.upb.ro DE17FB560084
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=upb.ro;
        s=96342B8A-77E4-11E5-BA93-D93D0963A2DF; t=1542989952;
        bh=ScBOo8yrdfmrXzp2z+nbIXolqSVz4o9uW6/StjHyT/M=;
        h=Message-ID:From:To:Date:Mime-Version;
        b=KfZxZgpusPCRtjAC0yH4KVWDhmPadAWXPyBdWlPGXWp1LpiNGNZjD25mXVePYuQe1
         IYc8dY5PfsnxHVAzq3JAWaox1A/p9jZp/bSqFPuuOgx/CKQqhGiDn8EKCI0vshMW4I
         15kdyBYsiTFzI8yvqdNn63GmG5VcP7nThkNaDs6k=
Received: from mx.upb.ro ([127.0.0.1])
        by localhost (mx.upb.ro [127.0.0.1]) (amavisd-new, port 10026)
        with ESMTP id E9fRIwjnNamd; Fri, 23 Nov 2018 18:19:12 +0200 (EET)
Received: from asus-rog (arh.pub.ro [141.85.160.17])
        by mx.upb.ro (Postfix) with ESMTPSA id B5129B560060;
        Fri, 23 Nov 2018 18:19:12 +0200 (EET)
Message-ID: <0ae5847b34b070ed51eca2b55c4b473b4e47da73.camel@upb.ro>
Subject: Re: [PATCH 3/3] spi: at91-usart: add DMA support
From: Radu Nicolae Pirea <radu_nicolae.pirea@upb.ro>
To: Robin Murphy <robin.murphy@arm.com>, richard.genoud@gmail.com,
        lee.jones@linaro.org, robh+dt@kernel.org, mark.rutland@arm.com,
        nicolas.ferre@microchip.com, alexandre.belloni@bootlin.com,
        ludovic.desroches@microchip.co, broonie@kernel.org
Cc: devicetree@vger.kernel.org, linux-kernel@vger.kernel.org,
        linux-arm-kernel@lists.infradead.org, linux-spi@vger.kernel.org
Date: Fri, 23 Nov 2018 18:19:05 +0200
In-Reply-To: <fe367c1a-700d-c6e3-6b09-ded1a47f2475@arm.com>
References: <20181121112732.15690-1-radu_nicolae.pirea@upb.ro>
         <20181121112732.15690-4-radu_nicolae.pirea@upb.ro>
         <fe367c1a-700d-c6e3-6b09-ded1a47f2475@arm.com>
Content-Type: text/plain; charset="UTF-8"
User-Agent: Evolution 3.30.2 
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Wed, 2018-11-21 at 17:38 +0000, Robin Murphy wrote:
> On 21/11/2018 11:27, Radu Pirea wrote:
> > This patch adds support for DMA. Transfers are done with dma only
> > if
> > they are longer than 16 bytes in order to achieve a better
> > performance.
> > DMA setup introduces a little overhead and for transfers shorter
> > than 16
> > bytes there is no performance improvement.
> > 
> > Signed-off-by: Radu Pirea <radu_nicolae.pirea@upb.ro>
> > ---
> >   drivers/spi/spi-at91-usart.c | 223
> > ++++++++++++++++++++++++++++++++++-
> >   1 file changed, 221 insertions(+), 2 deletions(-)
> > 
> > diff --git a/drivers/spi/spi-at91-usart.c b/drivers/spi/spi-at91-
> > usart.c
> > index 0b07c746453d..4d908afeaec9 100644
> > --- a/drivers/spi/spi-at91-usart.c
> > +++ b/drivers/spi/spi-at91-usart.c
> > @@ -8,9 +8,12 @@
> >   
> >   #include <linux/clk.h>
> >   #include <linux/delay.h>
> > +#include <linux/dmaengine.h>
> > +#include <linux/dma-direction.h>
> 
> It looks rather odd to include this from a driver that isn't
> otherwise 
> touching anything from linux/dma-mapping.h.
> 
> >   #include <linux/interrupt.h>
> >   #include <linux/kernel.h>
> >   #include <linux/module.h>
> > +#include <linux/of_platform.h>
> >   #include <linux/of_gpio.h>
> >   #include <linux/platform_device.h>
> >   #include <linux/pm_runtime.h>
> > @@ -58,6 +61,8 @@
> >   
> >   #define US_INIT \
> >   	(US_MR_SPI_MASTER | US_MR_CHRL | US_MR_CLKO | US_MR_WRDBT)
> > +#define US_DMA_MIN_BYTES       16
> > +#define US_DMA_TIMEOUT         (msecs_to_jiffies(1000))
> >   
> >   /* Register access macros */
> >   #define at91_usart_spi_readl(port, reg) \
> > @@ -71,14 +76,19 @@
> >   	writeb_relaxed((value), (port)->regs + US_##reg)
> >   
> >   struct at91_usart_spi {
> > +	struct platform_device  *mpdev;
> >   	struct spi_transfer	*current_transfer;
> >   	void __iomem		*regs;
> >   	struct device		*dev;
> >   	struct clk		*clk;
> >   
> > +	struct completion	xfer_completion;
> > +
> >   	/*used in interrupt to protect data reading*/
> >   	spinlock_t		lock;
> >   
> > +	phys_addr_t		phybase;
> > +
> >   	int			irq;
> >   	unsigned int		current_tx_remaining_bytes;
> >   	unsigned int		current_rx_remaining_bytes;
> > @@ -87,8 +97,184 @@ struct at91_usart_spi {
> >   	u32			status;
> >   
> >   	bool			xfer_failed;
> > +	bool			use_dma;
> >   };
> >   
> > +static void dma_callback(void *data)
> > +{
> > +	struct spi_controller   *ctlr = data;
> > +	struct at91_usart_spi   *aus = spi_master_get_devdata(ctlr);
> > +
> > +	at91_usart_spi_writel(aus, IER, US_IR_RXRDY);
> > +	aus->current_rx_remaining_bytes = 0;
> > +	complete(&aus->xfer_completion);
> > +}
> > +
> > +static bool at91_usart_spi_can_dma(struct spi_controller *ctrl,
> > +				   struct spi_device *spi,
> > +				   struct spi_transfer *xfer)
> > +{
> > +	struct at91_usart_spi *aus = spi_master_get_devdata(ctrl);
> > +
> > +	return aus->use_dma && xfer->len >= US_DMA_MIN_BYTES;
> > +}
> > +
> > +static int at91_usart_spi_configure_dma(struct spi_controller
> > *ctlr,
> > +					struct at91_usart_spi *aus)
> > +{
> > +	struct dma_slave_config slave_config;
> > +	struct device *dev = &aus->mpdev->dev;
> > +	phys_addr_t phybase = aus->phybase;
> > +	dma_cap_mask_t mask;
> > +	int err = 0;
> > +
> > +	dma_cap_zero(mask);
> > +	dma_cap_set(DMA_SLAVE, mask);
> > +
> > +	ctlr->dma_tx = dma_request_slave_channel_reason(dev, "tx");
> > +	if (IS_ERR_OR_NULL(ctlr->dma_tx)) {
> > +		if (IS_ERR(ctlr->dma_tx)) {
> > +			err = PTR_ERR(ctlr->dma_tx);
> > +			goto at91_usart_spi_error_clear;
> > +		}
> > +
> > +		dev_dbg(dev,
> > +			"DMA TX channel not available, SPI unable to
> > use DMA\n");
> > +		err = -EBUSY;
> > +		goto at91_usart_spi_error_clear;
> > +	}
> > +
> > +	ctlr->dma_rx = dma_request_slave_channel_reason(dev, "rx");
> > +	if (IS_ERR_OR_NULL(ctlr->dma_rx)) {
> > +		if (IS_ERR(ctlr->dma_rx)) {
> > +			err = PTR_ERR(ctlr->dma_rx);
> > +			goto at91_usart_spi_error;
> > +		}
> > +
> > +		dev_dbg(dev,
> > +			"DMA RX channel not available, SPI unable to
> > use DMA\n");
> > +		err = -EBUSY;
> > +		goto at91_usart_spi_error;
> > +	}
> > +
> > +	slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
> > +	slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
> > +	slave_config.dst_addr = (dma_addr_t)phybase + US_THR;
> > +	slave_config.src_addr = (dma_addr_t)phybase + US_RHR;
> > +	slave_config.src_maxburst = 1;
> > +	slave_config.dst_maxburst = 1;
> > +	slave_config.device_fc = false;
> > +
> > +	slave_config.direction = DMA_DEV_TO_MEM;
> > +	if (dmaengine_slave_config(ctlr->dma_rx, &slave_config)) {
> > +		dev_err(&ctlr->dev,
> > +			"failed to configure rx dma channel\n");
> > +		err = -EINVAL;
> > +		goto at91_usart_spi_error;
> > +	}
> > +
> > +	slave_config.direction = DMA_MEM_TO_DEV;
> > +	if (dmaengine_slave_config(ctlr->dma_tx, &slave_config)) {
> > +		dev_err(&ctlr->dev,
> > +			"failed to configure tx dma channel\n");
> > +		err = -EINVAL;
> > +		goto at91_usart_spi_error;
> > +	}
> > +
> > +	aus->use_dma = true;
> > +	return 0;
> > +
> > +at91_usart_spi_error:
> > +	if (!IS_ERR_OR_NULL(ctlr->dma_tx))
> > +		dma_release_channel(ctlr->dma_tx);
> > +	if (!IS_ERR_OR_NULL(ctlr->dma_rx))
> > +		dma_release_channel(ctlr->dma_rx);
> > +	ctlr->dma_tx = NULL;
> > +	ctlr->dma_rx = NULL;
> > +
> > +at91_usart_spi_error_clear:
> > +	return err;
> > +}
> > +
> > +static void at91_usart_spi_release_dma(struct spi_controller
> > *ctlr)
> > +{
> > +	if (ctlr->dma_rx)
> > +		dma_release_channel(ctlr->dma_rx);
> > +	if (ctlr->dma_tx)
> > +		dma_release_channel(ctlr->dma_tx);
> > +}
> > +
> > +static void at91_usart_spi_stop_dma(struct spi_controller *ctlr)
> > +{
> > +	if (ctlr->dma_rx)
> > +		dmaengine_terminate_all(ctlr->dma_rx);
> > +	if (ctlr->dma_tx)
> > +		dmaengine_terminate_all(ctlr->dma_tx);
> > +}
> > +
> > +static int at91_usart_spi_dma_transfer(struct spi_controller
> > *ctlr,
> > +				       struct spi_transfer *xfer)
> > +{
> > +	struct at91_usart_spi *aus = spi_master_get_devdata(ctlr);
> > +	struct dma_chan	 *rxchan = ctlr->dma_rx;
> > +	struct dma_chan *txchan = ctlr->dma_tx;
> > +	struct dma_async_tx_descriptor *rxdesc;
> > +	struct dma_async_tx_descriptor *txdesc;
> > +	dma_cookie_t cookie;
> > +
> > +	rxdesc = dmaengine_prep_slave_sg(rxchan,
> > +					 xfer->rx_sg.sgl,
> > +					 xfer->rx_sg.nents,
> > +					 DMA_FROM_DEVICE,
> 
> Ah, this argument should be a dma_transfer_direction, not a 
> dma_data_direction (confusing I know, but they belong to different 
> APIs). I assume you mean DMA_DEV_TO_MEM here...

Hi Robin,

I hoped I used the correct values here, but it seems not.

Thanks. I will fix.

> 
> > +					 DMA_PREP_INTERRUPT |
> > +					 DMA_CTRL_ACK);
> > +	if (!rxdesc)
> > +		goto at91_usart_spi_err_dma;
> > +
> > +	txdesc = dmaengine_prep_slave_sg(txchan,
> > +					 xfer->tx_sg.sgl,
> > +					 xfer->tx_sg.nents,
> > +					 DMA_TO_DEVICE,
> 
> ...and DMA_MEM_TO_DEV here.
> 
> Robin.
> 
> > +					 DMA_PREP_INTERRUPT |
> > +					 DMA_CTRL_ACK);
> > +	if (!txdesc)
> > +		goto at91_usart_spi_err_dma;
> > +
> > +	/* Disable RX interrupt */
> > +	at91_usart_spi_writel(aus, IDR, US_IR_RXRDY);
> > +
> > +	rxdesc->callback = dma_callback;
> > +	rxdesc->callback_param = ctlr;
> > +
> > +	cookie = rxdesc->tx_submit(rxdesc);
> > +	if (dma_submit_error(cookie))
> > +		goto at91_usart_spi_err_dma;
> > +
> > +	cookie = txdesc->tx_submit(txdesc);
> > +	if (dma_submit_error(cookie))
> > +		goto at91_usart_spi_err_dma;
> > +
> > +	rxchan->device->device_issue_pending(rxchan);
> > +	txchan->device->device_issue_pending(txchan);
> > +
> > +	return 0;
> > +
> > +at91_usart_spi_err_dma:
> > +	/* Enable RX interrupt if submission of any of descriptors
> > fails
> > +	 * and fallback to PIO
> > +	 */
> > +	at91_usart_spi_writel(aus, IER, US_IR_RXRDY);
> > +	at91_usart_spi_stop_dma(ctlr);
> > +
> > +	return -ENOMEM;
> > +}
> > +
> > +static unsigned long at91_usart_spi_dma_timeout(struct
> > at91_usart_spi *aus)
> > +{
> > +	return wait_for_completion_timeout(&aus->xfer_completion,
> > +					   US_DMA_TIMEOUT);
> > +}
> > +
> >   static inline u32 at91_usart_spi_tx_ready(struct at91_usart_spi
> > *aus)
> >   {
> >   	return aus->status & US_IR_TXRDY;
> > @@ -221,6 +407,8 @@ static int at91_usart_spi_transfer_one(struct
> > spi_controller *ctlr,
> >   				       struct spi_transfer *xfer)
> >   {
> >   	struct at91_usart_spi *aus = spi_master_get_devdata(ctlr);
> > +	unsigned long dma_timeout = 0;
> > +	int ret = 0;
> >   
> >   	at91_usart_spi_set_xfer_speed(aus, xfer);
> >   	aus->xfer_failed = false;
> > @@ -230,8 +418,25 @@ static int at91_usart_spi_transfer_one(struct
> > spi_controller *ctlr,
> >   
> >   	while ((aus->current_tx_remaining_bytes ||
> >   		aus->current_rx_remaining_bytes) && !aus->xfer_failed)
> > {
> > -		at91_usart_spi_read_status(aus);
> > -		at91_usart_spi_tx(aus);
> > +		reinit_completion(&aus->xfer_completion);
> > +		if (at91_usart_spi_can_dma(ctlr, spi, xfer) &&
> > +		    !ret) {
> > +			ret = at91_usart_spi_dma_transfer(ctlr, xfer);
> > +			if (ret)
> > +				continue;
> > +
> > +			dma_timeout = at91_usart_spi_dma_timeout(aus);
> > +
> > +			if (WARN_ON(dma_timeout == 0)) {
> > +				dev_err(&spi->dev, "DMA transfer
> > timeout\n");
> > +				return -EIO;
> > +			}
> > +			aus->current_tx_remaining_bytes = 0;
> > +		} else {
> > +			at91_usart_spi_read_status(aus);
> > +			at91_usart_spi_tx(aus);
> > +		}
> > +
> >   		cpu_relax();
> >   	}
> >   
> > @@ -350,6 +555,7 @@ static int at91_usart_spi_probe(struct
> > platform_device *pdev)
> >   	controller->transfer_one = at91_usart_spi_transfer_one;
> >   	controller->prepare_message = at91_usart_spi_prepare_message;
> >   	controller->unprepare_message =
> > at91_usart_spi_unprepare_message;
> > +	controller->can_dma = at91_usart_spi_can_dma;
> >   	controller->cleanup = at91_usart_spi_cleanup;
> >   	controller->max_speed_hz = DIV_ROUND_UP(clk_get_rate(clk),
> >   						US_MIN_CLK_DIV);
> > @@ -381,7 +587,17 @@ static int at91_usart_spi_probe(struct
> > platform_device *pdev)
> >   	aus->spi_clk = clk_get_rate(clk);
> >   	at91_usart_spi_init(aus);
> >   
> > +	aus->phybase = regs->start;
> > +
> > +	aus->mpdev = to_platform_device(pdev->dev.parent);
> > +
> > +	ret = at91_usart_spi_configure_dma(controller, aus);
> > +	if (ret)
> > +		goto at91_usart_fail_dma;
> > +
> >   	spin_lock_init(&aus->lock);
> > +	init_completion(&aus->xfer_completion);
> > +
> >   	ret = devm_spi_register_master(&pdev->dev, controller);
> >   	if (ret)
> >   		goto at91_usart_fail_register_master;
> > @@ -394,6 +610,8 @@ static int at91_usart_spi_probe(struct
> > platform_device *pdev)
> >   	return 0;
> >   
> >   at91_usart_fail_register_master:
> > +	at91_usart_spi_release_dma(controller);
> > +at91_usart_fail_dma:
> >   	clk_disable_unprepare(clk);
> >   at91_usart_spi_probe_fail:
> >   	spi_master_put(controller);
> > @@ -458,6 +676,7 @@ static int at91_usart_spi_remove(struct
> > platform_device *pdev)
> >   	struct spi_controller *ctlr = platform_get_drvdata(pdev);
> >   	struct at91_usart_spi *aus = spi_master_get_devdata(ctlr);
> >   
> > +	at91_usart_spi_release_dma(ctlr);
> >   	clk_disable_unprepare(aus->clk);
> >   
> >   	return 0;
> > 

