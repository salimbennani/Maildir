Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:34:35 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga007.fm.intel.com (fmsmga007.fm.intel.com [10.253.24.52])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 923EC58037D;
	Fri, 23 Nov 2018 03:35:22 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by fmsmga007-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 03:35:22 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AsZHbiRdzDmQvBk43aQYZ1F+MlGMj4u6mDksu8pMi?=
 =?us-ascii?q?zoh2WeGdxc6+YxaN2/xhgRfzUJnB7Loc0qyK6/CmATRIyK3CmUhKSIZLWR4BhJ?=
 =?us-ascii?q?detC0bK+nBN3fGKuX3ZTcxBsVIWQwt1Xi6NU9IBJS2PAWK8TW94jEIBxrwKxd+?=
 =?us-ascii?q?KPjrFY7OlcS30P2594HObwlSizexfbB/IA+qoQnNq8IbnZZsJqEtxxXTv3BGYf?=
 =?us-ascii?q?5WxWRmJVKSmxbz+MK994N9/ipTpvws6ddOXb31cKokQ7NYCi8mM30u683wqRbD?=
 =?us-ascii?q?VwqP6WACXWgQjxFFHhLK7BD+Xpf2ryv6qu9w0zSUMMHqUbw5Xymp4rx1QxH0li?=
 =?us-ascii?q?gIKz858HnWisNuiqJbvAmhrAF7z4LNfY2ZKOZycqbbcNgHR2ROQ9xRWjRcDI2i?=
 =?us-ascii?q?YYsBD+kPM+hWoIbypVQBsRSwBRK0BO7t0TJImn370rcm3+g9HwzL3AotFM8Ovn?=
 =?us-ascii?q?TOq9X1Mb8fX/yyzKnH0zrDde5d1yzg6IfSbx8hu/aMXaltesfW00kvEAzFgUuK?=
 =?us-ascii?q?qYz8JD6VyuUNv3KH4OpnUOKikmgqoBxyrDi33soglJXFi4YPxlzZ+yh13pw5Kc?=
 =?us-ascii?q?C7RUJne9KpEZlduzmHO4Z2QM4uWXxktSQmxrEcpJK2fjQGxI4pyhPebfGMbpKG?=
 =?us-ascii?q?7Qj5VOmLJDd1nHJld6y7hxa16UWg1OL8Wdeu0FpQrSpKjMPMtnYT2BzX8MSHTe?=
 =?us-ascii?q?F9/ki51TaO0QDc9P1ELFgqmabHL5Mt2KM8m5QNvUjZAyP7m1n6gLWXe0gm4uSo?=
 =?us-ascii?q?7v7oYrTipp+SLY90jQT+P7wqmsy+B+Q4LwcPU3GY+euizr3j+1P2QLFTgv0xnK?=
 =?us-ascii?q?jZto7VJd4Aq66nDA9azJwj5wy8Dzi4ytQYm2cILFZfdBKAlYjpNEnCIOrkAven?=
 =?us-ascii?q?n1SsjDBryujCPr3gAZXCMGLPkbj8fbtm705cyQwzzc1Q5p5OC7EBJu7zVVH1tN?=
 =?us-ascii?q?DCEhA5NAm0yf79CNphzoMeRX6PAqiBPaPSq1CI5/4vLPOLZIMPuDb9NuIq5/jh?=
 =?us-ascii?q?jXIinV8dfK+p3YYYaXyiH/RmJVmZbmTogtsbDWgKuQ8+RvTwiFKeST5Te2qyX6?=
 =?us-ascii?q?Uk6zE5D4KpE53PRoOqgLyH2ie7GYZbZmRHClCKDHfpeJ+IW/YKaCKOPMBhliYI?=
 =?us-ascii?q?WqSmS48kzRuurhP1y6J7LurI/S0VrYjs1MN15+3UlhE+7yZ0AN6f02yWS2F0n2?=
 =?us-ascii?q?UIRyI53axloEx9zEuD3rZ8g/BCCdNT4PZJWB8gNZHA1+x6F8zyWgXZc9eKUlmm?=
 =?us-ascii?q?RM+qATUwTt0rxd8ObF1wG9GjjhDFwiqrDKUZl72NBJwo7K3c22L9KNp6y3bDzK?=
 =?us-ascii?q?MhlUUpQtNTNW26ga5y7xXcCJTXk0qHjaqqdb4T3CjW9Gidy2qCu0VYUA11UaXB?=
 =?us-ascii?q?Rn0fYkrWrdLk5kLNVbOuCLInMhdfxs6GMKdFdtrpjVBeTvf5JNvee36xm3u3BR?=
 =?us-ascii?q?uQ27yDdpTqdHsH0CXdEkcElRsT8miANQUlAiehomTeDCFhFF71YkPs9/V+p22/?=
 =?us-ascii?q?TkMu0w6KaEhh3aKv+hEJnfycV+8T3rUctSc9qjV0GVG9387WC9uAvQZhYL9QYd?=
 =?us-ascii?q?Qn4FdD1GLZsQN9M4ekL6BjgF4ebgt2s1nv1xVxFoVPj8wqoGk2wwp1LKKSyElB?=
 =?us-ascii?q?eC+A3ZDsJr3XLXH/8wqra6HI1VDRztaX9r0U5/QltlrspgepFkkl83V5yNRV13?=
 =?us-ascii?q?qc5pPXDAsdS57xU0A39wRkqLHeeCUy+4TU1Xh0O6murjDCw84pBPciyhu4f9Zf?=
 =?us-ascii?q?LbmIGxPoH8wbB8ihMuoqm1eyYxIAPeBS8rM0Psy8e/uH3q6rIPhvnDa8gWtb54?=
 =?us-ascii?q?B911qG9zBgRe7Qw5YF3/aY0xOdVzf9kFiuqNr3lp1DZT0IGGqw1zLkBI9IaqJu?=
 =?us-ascii?q?Z4kLDXqhLNOtxtV5gZ7gQHpY9F+lB1Mb186lYxuSb1rh3QJO0UQbu2ComSy9zz?=
 =?us-ascii?q?ZsiTEmsrKf3DDSw+TlbBcGOm9LSHNijFv2Ooi0ktYaUVOsbwgokhul+En7y7Ja?=
 =?us-ascii?q?pKR5M2ncX0NIczLqIGFlV6u6rqCCbNJX6JM0rSVXV/yxYVKARb7noBsa0CTjE3?=
 =?us-ascii?q?FFxD8hdDGquZT5nxpkh2KbN3tzqHvZecdtxRbQ/tDcRPhR3iYYSyl8kzXYGl+8?=
 =?us-ascii?q?P9yx99WOi5jDqvy+V36mVpBLcSjk14SAuDG55W1rBx2yhPSzmtzhEQgn3i73zd?=
 =?us-ascii?q?hqVSPUrBniZonnzbi1MeVifkNwHl/z99J6Gp1ikos3nJwQ2mIVhpSP8XoHjGf8?=
 =?us-ascii?q?K9Nb2a3lYXoJRD4LxcPV4Qf/1E1iKHKJ25z2VnGHzsR9YNm6Z3sc2jgh4MBSFK?=
 =?us-ascii?q?eU8LtEkDNwolq5rgLee+JxnzkDxvs19H4VnfsJtxEzwSWHDbAfBk1YPS3qlxSV?=
 =?us-ascii?q?4NGytqRXZGCzcbeu0Epyh8yuDLaHogtEQnb2Zo8iHTNs7sV4KF/MzHrz6oT+dN?=
 =?us-ascii?q?jRd90TsACUkwzbj+hUM58xkvsKhSx6OWPyp3Elyug7jQBw0pG+poSIN2Jt/Keh?=
 =?us-ascii?q?CB5CKjL1f98T+i3qjatGhcmZxYevHpF8GjkRWJvoUOmlEDYTtfThKgaPHycwqn?=
 =?us-ascii?q?adGbrDAwCf7F1qoG7IE5CuL3uXPmUWzc1+RBmBI0xSmAIUUy8/npEnDQCm3tDh?=
 =?us-ascii?q?fF165jAM5V74tx1MxfhzNxTkVmffpQGoaio7SZSFLRpW6B1C6FnRMcCE8u1zGC?=
 =?us-ascii?q?RY9IW7rAORMmybexhIDWYRV02EAFDjI6Cu5cTa/OieHOa+NPzOYbOBqeFFU/eI?=
 =?us-ascii?q?xJSv0pZp/jqWN8WPOGViAOM/2kZZQX95HMHZkS0VSyMLjyLNc9KbpBCk9y13sM?=
 =?us-ascii?q?+/8ffrWAHu5YeVCLtSK9Jv+x+ojqeZKu6Qnz10KTJZ1pMK2H/Jx6IT3F8UiyFy?=
 =?us-ascii?q?aTatFa4MujLKTKLVgqVXFQIUaztvNMtU6KIxxhNCOdPAhdPvyLF5juQ5C1NEVV?=
 =?us-ascii?q?H6nsGpZMoKI3yyNV/dBUaLMqiGKiPPw83tfay8TrhQhv1OtxKsoTabD1PjPjOb?=
 =?us-ascii?q?mjn1VhCvNPtAgz2BMBNCuIGybBBtBHPnTNLnbB27LdB2gSc3wb0ymnPFK2ocPS?=
 =?us-ascii?q?JgfENKq72a9TlYjelnG2xd8nplKvGJmiaD4OneL5YWsP1rDTx1luJa+ns6zbRV?=
 =?us-ascii?q?4TpARPx0nivSs9Fvr0unkumJ1jpoTh5OpixXi4KMuEUxcZneo6FJRnvAtDYE9n?=
 =?us-ascii?q?ebGR0J7499A8Liv6R4wdHDmaT4JXFJ9NeCuYNIC8XKKcmKLGAsPDL3FzPOSggI?=
 =?us-ascii?q?VzimMSfYnUMLw9+I8XjAlJ81p4KkoYcHRqVcTxRhDPQVB158NMADZpxwW2V3wv?=
 =?us-ascii?q?agkMcU6C/m/1HqT8JAs8WCD6rKDA=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AYAAB/5fdbh0O0hNFjHAEBAQQBAQcEA?=
 =?us-ascii?q?QGBUQcBAQsBgmx/J4wRi32CDRRmlkEUgVsWAQEYEwGIVyI0CQ0BAwEBAQEBAQI?=
 =?us-ascii?q?BEwEBAQgNCQgpIwyCNiQBgmIBAgMBAiQZAQE2AQEFCQEBChgJFg8DBgMCAQIBR?=
 =?us-ascii?q?QYBDAEFAgEBAYMcggIFpiGBbDOCdgEBBYJDhE8IjAkXgUA/gRGCFEk1hEMfhXe?=
 =?us-ascii?q?JARoGBIFuhAhDgQKPJAmCIIgJhx6BWYgIJocBiW2OHAICAgIEBQIUgUaCDTMaC?=
 =?us-ascii?q?BsVgyeCGwwXg0qKVD8xgQUBAYlUKYIkAQE?=
X-IPAS-Result: =?us-ascii?q?A0AYAAB/5fdbh0O0hNFjHAEBAQQBAQcEAQGBUQcBAQsBgmx?=
 =?us-ascii?q?/J4wRi32CDRRmlkEUgVsWAQEYEwGIVyI0CQ0BAwEBAQEBAQIBEwEBAQgNCQgpI?=
 =?us-ascii?q?wyCNiQBgmIBAgMBAiQZAQE2AQEFCQEBChgJFg8DBgMCAQIBRQYBDAEFAgEBAYM?=
 =?us-ascii?q?cggIFpiGBbDOCdgEBBYJDhE8IjAkXgUA/gRGCFEk1hEMfhXeJARoGBIFuhAhDg?=
 =?us-ascii?q?QKPJAmCIIgJhx6BWYgIJocBiW2OHAICAgIEBQIUgUaCDTMaCBsVgyeCGwwXg0q?=
 =?us-ascii?q?KVD8xgQUBAYlUKYIkAQE?=
X-IronPort-AV: E=Sophos;i="5.56,269,1539673200"; 
   d="scan'208";a="53069188"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 03:35:20 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2503826AbeKWWTK (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 17:19:10 -0500
Received: from fllv0015.ext.ti.com ([198.47.19.141]:45794 "EHLO
        fllv0015.ext.ti.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1729929AbeKWWTK (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 17:19:10 -0500
Received: from lelv0266.itg.ti.com ([10.180.67.225])
        by fllv0015.ext.ti.com (8.15.2/8.15.2) with ESMTP id wANBZ97L005046;
        Fri, 23 Nov 2018 05:35:09 -0600
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=ti.com;
        s=ti-com-17Q1; t=1542972909;
        bh=Mxfgl5vFtDetWATJkozv6ygXJFBzsLX6OpXiKiIXRqo=;
        h=Subject:To:References:CC:From:Date:In-Reply-To;
        b=SeMvF44Uha//JzG5uR42RlvQQw+YG7ct+l+7XCt1l7pyvzVHuO8fuOFO1cKJKixLM
         3SI6G4GJwEHyBFHfxYAbzzDNoXNWMrTwfRtKaeJaQQPpuoFeJj9UtGxR7cXvG3RU8Y
         zAVTEFTDmc8Hrk40qgB+iudySa0MlaX4CMLZX9uM=
Received: from DLEE100.ent.ti.com (dlee100.ent.ti.com [157.170.170.30])
        by lelv0266.itg.ti.com (8.15.2/8.15.2) with ESMTPS id wANBZ9NT118504
        (version=TLSv1.2 cipher=AES256-GCM-SHA384 bits=256 verify=FAIL);
        Fri, 23 Nov 2018 05:35:09 -0600
Received: from DLEE106.ent.ti.com (157.170.170.36) by DLEE100.ent.ti.com
 (157.170.170.30) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id 15.1.1591.10; Fri, 23
 Nov 2018 05:35:07 -0600
Received: from dflp32.itg.ti.com (10.64.6.15) by DLEE106.ent.ti.com
 (157.170.170.36) with Microsoft SMTP Server (version=TLS1_0,
 cipher=TLS_RSA_WITH_AES_256_CBC_SHA) id 15.1.1591.10 via Frontend Transport;
 Fri, 23 Nov 2018 05:35:07 -0600
Received: from [192.168.2.6] (ileax41-snat.itg.ti.com [10.172.224.153])
        by dflp32.itg.ti.com (8.14.3/8.13.8) with ESMTP id wANBZ4TR019775;
        Fri, 23 Nov 2018 05:35:05 -0600
Subject: Re: [RFC PATCH v2 04/15] usb:cdns3: Driver initialization code.
To: Pawel Laszczak <pawell@cadence.com>, <devicetree@vger.kernel.org>
References: <1542535751-16079-1-git-send-email-pawell@cadence.com>
 <1542535751-16079-5-git-send-email-pawell@cadence.com>
CC: <gregkh@linuxfoundation.org>, <linux-usb@vger.kernel.org>,
        <linux-kernel@vger.kernel.org>, <adouglas@cadence.com>,
        <jbergsagel@ti.com>, <nsekhar@ti.com>, <nm@ti.com>,
        <sureshp@cadence.com>, <peter.chen@nxp.com>, <pjez@cadence.com>,
        <kurahul@cadence.com>
From: Roger Quadros <rogerq@ti.com>
Message-ID: <5BF7E5E8.3090406@ti.com>
Date: Fri, 23 Nov 2018 13:35:04 +0200
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:38.0) Gecko/20100101
 Thunderbird/38.6.0
MIME-Version: 1.0
In-Reply-To: <1542535751-16079-5-git-send-email-pawell@cadence.com>
Content-Type: text/plain; charset="windows-1252"
Content-Transfer-Encoding: 7bit
X-EXCLAIMER-MD-CONFIG: e1e8a2fd-e40a-4ac6-ac9b-f7e9cc9ee180
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On 18/11/18 12:09, Pawel Laszczak wrote:
> Patch adds core.c and core.h file that implements initialization
> of platform driver and adds function responsible for selecting,
> switching and running appropriate Device/Host mode.
> 
> Signed-off-by: Pawel Laszczak <pawell@cadence.com>
> ---
>  drivers/usb/cdns3/Makefile |   2 +
>  drivers/usb/cdns3/core.c   | 413 +++++++++++++++++++++++++++++++++++++
>  drivers/usb/cdns3/core.h   | 100 +++++++++
>  3 files changed, 515 insertions(+)
>  create mode 100644 drivers/usb/cdns3/core.c
>  create mode 100644 drivers/usb/cdns3/core.h
> 
> diff --git a/drivers/usb/cdns3/Makefile b/drivers/usb/cdns3/Makefile
> index dcdd62003c6a..02d25b23c5d3 100644
> --- a/drivers/usb/cdns3/Makefile
> +++ b/drivers/usb/cdns3/Makefile
> @@ -1,3 +1,5 @@
> +obj-$(CONFIG_USB_CDNS3)			+= cdns3.o
>  obj-$(CONFIG_USB_CDNS3_PCI_WRAP)	+= cdns3-pci.o
>  
> +cdns3-y					:= core.o
>  cdns3-pci-y		 		:= cdns3-pci-wrap.o
> diff --git a/drivers/usb/cdns3/core.c b/drivers/usb/cdns3/core.c
> new file mode 100644
> index 000000000000..f9055d4da67f
> --- /dev/null
> +++ b/drivers/usb/cdns3/core.c
> @@ -0,0 +1,413 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Driver.
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Peter Chen <peter.chen@nxp.com>
> + *         Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#include <linux/module.h>
> +#include <linux/kernel.h>
> +#include <linux/platform_device.h>
> +#include <linux/interrupt.h>
> +#include <linux/io.h>
> +#include <linux/pm_runtime.h>
> +
> +#include "gadget.h"
> +#include "core.h"
> +
> +static inline struct cdns3_role_driver *cdns3_get_current_role_driver(struct cdns3 *cdns)
> +{
> +	WARN_ON(cdns->role >= CDNS3_ROLE_END || !cdns->roles[cdns->role]);
> +	return cdns->roles[cdns->role];
> +}
> +
> +static inline int cdns3_role_start(struct cdns3 *cdns, enum cdns3_roles role)
> +{
> +	int ret;
> +
> +	if (role >= CDNS3_ROLE_END)

WARN_ON()?

> +		return 0;
> +
> +	if (!cdns->roles[role])
> +		return -ENXIO;
> +
> +	mutex_lock(&cdns->mutex);
> +	cdns->role = role;
> +	ret = cdns->roles[role]->start(cdns);
> +	mutex_unlock(&cdns->mutex);
> +	return ret;
> +}
> +
> +static inline void cdns3_role_stop(struct cdns3 *cdns)
> +{
> +	enum cdns3_roles role = cdns->role;
> +
> +	if (role == CDNS3_ROLE_END)

WARN_ON(role >= CNDS3_ROLE_END) ?

> +		return;
> +
> +	mutex_lock(&cdns->mutex);
> +	cdns->roles[role]->stop(cdns);
> +	cdns->role = CDNS3_ROLE_END;

Why change the role here? You are just stopping the role not changing it.
I think cdns->role should remain unchanged, so we can call cdns3_role_start()
if required without error.

> +	mutex_unlock(&cdns->mutex);
> +}
> +
> +static enum cdns3_roles cdns3_get_role(struct cdns3 *cdns)
> +{
> +	if (cdns->roles[CDNS3_ROLE_HOST] && cdns->roles[CDNS3_ROLE_GADGET]) {
> +		//TODO: implements selecting device/host mode
> +		return CDNS3_ROLE_HOST;
> +	}
> +	return cdns->roles[CDNS3_ROLE_HOST]
> +		? CDNS3_ROLE_HOST
> +		: CDNS3_ROLE_GADGET;

Why not just
	return cdns->role;

I'm wondering if we really need this function.
> +}

> +
> +/**
> + * cdns3_core_init_role - initialize role of operation
> + * @cdns: Pointer to cdns3 structure
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_core_init_role(struct cdns3 *cdns)
> +{
> +	struct device *dev = cdns->dev;
> +	enum usb_dr_mode dr_mode;
> +
> +	dr_mode = usb_get_dr_mode(dev);
> +	cdns->role = CDNS3_ROLE_END;
> +
> +	/*
> +	 * If driver can't read mode by means of usb_get_dr_mdoe function then
> +	 * chooses mode according with Kernel configuration. This setting
> +	 * can be restricted later depending on strap pin configuration.
> +	 */
> +	if (dr_mode == USB_DR_MODE_UNKNOWN) {
> +		if (IS_ENABLED(CONFIG_USB_CDNS3_HOST) &&
> +		    IS_ENABLED(CONFIG_USB_CDNS3_GADGET))
> +			dr_mode = USB_DR_MODE_OTG;
> +		else if (IS_ENABLED(CONFIG_USB_CDNS3_HOST))
> +			dr_mode = USB_DR_MODE_HOST;
> +		else if (IS_ENABLED(CONFIG_USB_CDNS3_GADGET))
> +			dr_mode = USB_DR_MODE_PERIPHERAL;
> +	}
> +
> +	if (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_HOST) {
> +		//TODO: implements host initialization

		/* TODO: Add host role */ ?

> +	}
> +
> +	if (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_PERIPHERAL) {
> +		//TODO: implements device initialization

		/* TODO: Add device role */ ?

> +	}
> +
> +	if (!cdns->roles[CDNS3_ROLE_HOST] && !cdns->roles[CDNS3_ROLE_GADGET]) {
> +		dev_err(dev, "no supported roles\n");
> +		return -ENODEV;
> +	}
> +
> +	cdns->dr_mode = dr_mode;
> +	return 0;
> +}
> +
> +/**
> + * cdns3_irq - interrupt handler for cdns3 core device
> + *
> + * @irq: irq number for cdns3 core device
> + * @data: structure of cdns3
> + *
> + * Returns IRQ_HANDLED or IRQ_NONE
> + */
> +static irqreturn_t cdns3_irq(int irq, void *data)
> +{
> +	struct cdns3 *cdns = data;
> +	irqreturn_t ret = IRQ_NONE;
> +
> +	/* Handle device/host interrupt */
> +	if (cdns->role != CDNS3_ROLE_END)

Is it because of this that you need to set role to END at role_stop?
I think it is better to add a state variable to struct cdns3_role_driver, so we can
check if it is active or stopped.

e.g.
	if (cdns3_get_current_role_driver(cdns)->state == CDNS3_ROLE_STATE_ACTIVE)

> +		ret = cdns3_get_current_role_driver(cdns)->irq(cdns);
> +
> +	return ret;
> +}
> +
> +static void cdns3_remove_roles(struct cdns3 *cdns)

Should this be called cdns3_exit_roles() to be opposite of cdns3_init_roles()?

> +{
> +	//TODO: implements this function
> +}

> +
> +static int cdns3_do_role_switch(struct cdns3 *cdns, enum cdns3_roles role)
> +{
> +	enum cdns3_roles current_role;
> +	int ret = 0;
> +
> +	current_role = cdns->role;
> +
> +	if (role == CDNS3_ROLE_END)
> +		return 0;

role == END looks like error state. and it should never happen.
WARN here?

> +
> +	dev_dbg(cdns->dev, "Switching role");
> +

Don't you have to stop the previous role before starting the new role?

> +	ret = cdns3_role_start(cdns, role);
> +	if (ret) {
> +		/* Back to current role */
> +		dev_err(cdns->dev, "set %d has failed, back to %d\n",
> +			role, current_role);
> +		ret = cdns3_role_start(cdns, current_role);
> +	}
> +
> +	return ret;
> +}
> +
> +/**
> + * cdns3_role_switch - work queue handler for role switch
> + *
> + * @work: work queue item structure
> + *
> + * Handles below events:
> + * - Role switch for dual-role devices
> + * - CDNS3_ROLE_GADGET <--> CDNS3_ROLE_END for peripheral-only devices
> + */
> +static void cdns3_role_switch(struct work_struct *work)
> +{
> +	enum cdns3_roles role = CDNS3_ROLE_END;
> +	struct cdns3 *cdns;
> +	bool device, host;
> +
> +	cdns = container_of(work, struct cdns3, role_switch_wq);
> +
> +	//TODO: implements this functions.
> +	//host = cdns3_is_host(cdns);
> +	//device = cdns3_is_device(cdns);
> +	host = 1;
> +	device = 0;
> +
> +	if (host)
> +		role = CDNS3_ROLE_HOST;
> +	else if (device)
> +		role = CDNS3_ROLE_GADGET;
> +
> +	if (cdns->desired_dr_mode == cdns->current_dr_mode &&
> +	    cdns->role == role)
> +		return;
> +

I think all the below code can be moved to cdns3_do_role_switch().

> +	pm_runtime_get_sync(cdns->dev);
> +	cdns3_role_stop(cdns);
> +
> +	if (host) {
> +		if (cdns->roles[CDNS3_ROLE_HOST])
> +			cdns3_do_role_switch(cdns, CDNS3_ROLE_HOST);
> +		pm_runtime_put_sync(cdns->dev);
> +		return;
> +	}
> +
> +	if (device)
> +		cdns3_do_role_switch(cdns, CDNS3_ROLE_GADGET);
> +	else
> +		cdns3_do_role_switch(cdns, CDNS3_ROLE_END);
> +
> +	pm_runtime_put_sync(cdns->dev);
> +}
> +
> +/**
> + * cdns3_probe - probe for cdns3 core device
> + * @pdev: Pointer to cdns3 core platform device
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_probe(struct platform_device *pdev)
> +{
> +	struct device *dev = &pdev->dev;
> +	struct resource	*res;
> +	struct cdns3 *cdns;
> +	void __iomem *regs;
> +	int ret;
> +
> +	cdns = devm_kzalloc(dev, sizeof(*cdns), GFP_KERNEL);
> +	if (!cdns)
> +		return -ENOMEM;
> +
> +	cdns->dev = dev;
> +
> +	platform_set_drvdata(pdev, cdns);
> +
> +	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
> +	if (!res) {
> +		dev_err(dev, "missing IRQ\n");
> +		return -ENODEV;
> +	}
> +	cdns->irq = res->start;
> +
> +	/*
> +	 * Request memory region
> +	 * region-0: xHCI
> +	 * region-1: Peripheral
> +	 * region-2: OTG registers
> +	 */

The memory region order is different from the dt-binding.
There it is OTG, host(xhci), device (peripheral).

> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
> +	regs = devm_ioremap_resource(dev, res);
> +
> +	if (IS_ERR(regs))
> +		return PTR_ERR(regs);
> +	cdns->xhci_regs = regs;
> +	cdns->xhci_res = res;
> +
> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
> +	regs = devm_ioremap_resource(dev, res);
> +	if (IS_ERR(regs))
> +		return PTR_ERR(regs);
> +	cdns->dev_regs	= regs;
> +
> +	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
> +	regs = devm_ioremap_resource(dev, res);
> +	if (IS_ERR(regs))
> +		return PTR_ERR(regs);
> +	cdns->otg_regs = regs;
> +
> +	mutex_init(&cdns->mutex);
> +
> +	cdns->phy = devm_phy_get(dev, "cdns3,usbphy");

"cdns3,usbphy" is not documented in dt-binding.

> +	if (IS_ERR(cdns->phy)) {
> +		dev_info(dev, "no generic phy found\n");
> +		cdns->phy = NULL;
> +		/*
> +		 * fall through here!
> +		 * if no generic phy found, phy init
> +		 * should be done under boot!
> +		 */

No you shouldn't fall through always if it is an error condition.
Something like this should work better.

        if (IS_ERR(cnds->phy)) {
                ret = PTR_ERR(cdns->phy);
                if (ret == -ENOSYS || ret == -ENODEV) {
                        cdns->phy = NULL;
                } else if (ret == -EPROBE_DEFER) {
                        return ret;
                } else {
                        dev_err(dev, "no phy found\n");
                        goto err0;
                }
        }

So if PHY was provided in DT, and PHY support/drivers is present
and error condition means something is wrong and we have to error out.

> +	} else {
> +		phy_init(cdns->phy);
> +	}

You can do phy_init() outside the else.

> +
> +	ret = cdns3_core_init_role(cdns);
> +	if (ret)
> +		goto err1;
> +
> +	INIT_WORK(&cdns->role_switch_wq, cdns3_role_switch);
> +	if (ret)
> +		goto err2;
> +
> +	if (ret)
> +		goto err2;
> +
> +	cdns->role = cdns3_get_role(cdns);

I think this should move to cdns3_core_init_role().

> +
> +	ret = devm_request_irq(dev, cdns->irq, cdns3_irq, IRQF_SHARED,
> +			       dev_name(dev), cdns);
> +
> +	if (ret)
> +		goto err2;

How about moving request_irq to before cdsn3_core_init_role()?

Then you can move cdns3_role_start() as well to core_init_role().

> +
> +	ret = cdns3_role_start(cdns, cdns->role);
> +	if (ret) {
> +		dev_err(dev, "can't start %s role\n",
> +			cdns3_get_current_role_driver(cdns)->name);
> +		goto err2;
> +	}
> +
> +	device_set_wakeup_capable(dev, true);
> +	pm_runtime_set_active(dev);
> +	pm_runtime_enable(dev);
> +
> +	/*
> +	 * The controller needs less time between bus and controller suspend,
> +	 * and we also needs a small delay to avoid frequently entering low
> +	 * power mode.
> +	 */
> +	pm_runtime_set_autosuspend_delay(dev, 20);
> +	pm_runtime_mark_last_busy(dev);
> +	pm_runtime_use_autosuspend(dev);
> +	dev_dbg(dev, "Cadence USB3 core: probe succeed\n");
> +
> +	return 0;
> +
> +err2:
> +	cdns3_remove_roles(cdns);
> +err1:

phy_exit() ?

> +	return ret;
> +}
> +
> +/**
> + * cdns3_remove - unbind drd driver and clean up
> + * @pdev: Pointer to Linux platform device
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_remove(struct platform_device *pdev)
> +{
> +	struct cdns3 *cdns = platform_get_drvdata(pdev);
> +
> +	pm_runtime_get_sync(&pdev->dev);
> +	pm_runtime_disable(&pdev->dev);
> +	pm_runtime_put_noidle(&pdev->dev);
> +	cdns3_remove_roles(cdns);

phy_exit() ?

> +
> +	return 0;
> +}
> +
> +#ifdef CONFIG_OF
> +static const struct of_device_id of_cdns3_match[] = {
> +	{ .compatible = "cdns,usb3" },
> +	{ },
> +};
> +MODULE_DEVICE_TABLE(of, of_cdns3_match);
> +#endif
> +
> +#ifdef CONFIG_PM
> +
> +#ifdef CONFIG_PM_SLEEP
> +static int cdns3_suspend(struct device *dev)
> +{
> +	//TODO: implements this function
> +	return 0;
> +}
> +
> +static int cdns3_resume(struct device *dev)
> +{
> +	//TODO: implements this function
> +	return 0;
> +}
> +#endif /* CONFIG_PM_SLEEP */
> +static int cdns3_runtime_suspend(struct device *dev)
> +{	//TODO: implements this function
> +	return 0;
> +}
> +
> +static int cdns3_runtime_resume(struct device *dev)
> +{
> +	//TODO: implements this function
> +	return 0;
> +}
> +#endif /* CONFIG_PM */
> +
> +static const struct dev_pm_ops cdns3_pm_ops = {
> +	SET_SYSTEM_SLEEP_PM_OPS(cdns3_suspend, cdns3_resume)
> +	SET_RUNTIME_PM_OPS(cdns3_runtime_suspend, cdns3_runtime_resume, NULL)
> +};
> +
> +static struct platform_driver cdns3_driver = {
> +	.probe		= cdns3_probe,
> +	.remove		= cdns3_remove,
> +	.driver		= {
> +		.name	= "cdns-usb3",
> +		.of_match_table	= of_match_ptr(of_cdns3_match),
> +		.pm	= &cdns3_pm_ops,
> +	},
> +};
> +
> +static int __init cdns3_driver_platform_register(void)
> +{
> +	return platform_driver_register(&cdns3_driver);
> +}
> +module_init(cdns3_driver_platform_register);
> +
> +static void __exit cdns3_driver_platform_unregister(void)
> +{
> +	platform_driver_unregister(&cdns3_driver);
> +}
> +module_exit(cdns3_driver_platform_unregister);
> +
> +MODULE_ALIAS("platform:cdns3");
> +MODULE_AUTHOR("Pawel Laszczak <pawell@cadence.com>");
> +MODULE_LICENSE("GPL v2");
> +MODULE_DESCRIPTION("Cadence USB3 DRD Controller Driver");
> diff --git a/drivers/usb/cdns3/core.h b/drivers/usb/cdns3/core.h
> new file mode 100644
> index 000000000000..7c8204fe4d3d
> --- /dev/null
> +++ b/drivers/usb/cdns3/core.h
> @@ -0,0 +1,100 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * Cadence USBSS DRD Driver.
> + *
> + * Copyright (C) 2017 NXP
> + * Copyright (C) 2018 Cadence.
> + *
> + * Authors: Peter Chen <peter.chen@nxp.com>
> + *          Pawel Laszczak <pawell@cadence.com>
> + */
> +#include <linux/usb/otg.h>
> +
> +#ifndef __LINUX_CDNS3_CORE_H
> +#define __LINUX_CDNS3_CORE_H
> +
> +struct cdns3;
> +enum cdns3_roles {
> +	CDNS3_ROLE_HOST = 0,
> +	CDNS3_ROLE_GADGET,
> +	CDNS3_ROLE_END,
> +};
> +
> +/**
> + * struct cdns3_role_driver - host/gadget role driver
> + * @start: start this role
> + * @stop: stop this role
> + * @suspend: suspend callback for this role
> + * @resume: resume callback for this role
> + * @irq: irq handler for this role
> + * @name: role name string (host/gadget)
> + */
> +struct cdns3_role_driver {
> +	int (*start)(struct cdns3 *cdns);
> +	void (*stop)(struct cdns3 *cdns);
> +	int (*suspend)(struct cdns3 *cdns, bool do_wakeup);
> +	int (*resume)(struct cdns3 *cdns, bool hibernated);
> +	irqreturn_t (*irq)(struct cdns3 *cdns);
> +	const char *name;
> +};
> +
> +#define CDNS3_NUM_OF_CLKS	5
> +/**
> + * struct cdns3 - Representation of Cadence USB3 DRD controller.
> + * @dev: pointer to Cadence device struct
> + * @xhci_regs: pointer to base of xhci registers
> + * @xhci_res: the resource for xhci
> + * @dev_regs: pointer to base of dev registers
> + * @otg_regs: pointer to base of otg registers
> + * @irq: irq number for controller
> + * @roles: array of supported roles for this controller
> + * @role: current role
> + * @host_dev: the child host device pointer for cdns3 core
> + * @gadget_dev: the child gadget device pointer for cdns3 core
> + * @usb: phy for this controller
> + * @role_switch_wq: work queue item for role switch
> + * @in_lpm: the controller in low power mode
> + * @wakeup_int: the wakeup interrupt
> + * @mutex: the mutex for concurrent code at driver
> + * @dr_mode: supported mode of operation it can be only Host, only Device
> + *           or OTG mode that allow to switch between Device and Host mode.
> + *           This field based on hardware configuration and cant't be changed.

But dr_mode can be forced in device-tree. So it isn't really only hardware configuration.

> + * @current_dr_role: current mode of operation when in dual-role mode
> + * @desired_dr_role: desired mode of operation when in dual-role mode.
> + *           This value can be changed during runtime.
> + *           Available options depends on  dr_mode:
> + *           dr_mode                 |  desired_dr_role and current_dr_role
> + *           ----------------------------------------------------------------
> + *           USB_DR_MODE_HOST        | only USB_DR_MODE_HOST
> + *           USB_DR_MODE_PERIPHERAL  | only USB_DR_MODE_PERIPHERAL
> + *           USB_DR_MODE_OTG         | only USB_DR_MODE_HOST
> + *           USB_DR_MODE_OTG         | only USB_DR_MODE_PERIPHERAL
> + *           USB_DR_MODE_OTG         | USB_DR_MODE_OTG

Do you need to update the right hand side to reflect ROLEs instead of MODE?

> + *
> + *           Desired_dr_role can be changed by means of debugfs.
> + * @root: debugfs root folder pointer
> + */
> +struct cdns3 {
> +	struct device			*dev;
> +	void __iomem			*xhci_regs;
> +	struct resource			*xhci_res;
> +	struct cdns3_usb_regs __iomem	*dev_regs;
> +	struct cdns3_otg_regs		*otg_regs;
> +	int irq;
> +	struct cdns3_role_driver	*roles[CDNS3_ROLE_END];
> +	enum cdns3_roles		role;
> +	struct device			*host_dev;
> +	struct device			*gadget_dev;
> +	struct phy			*phy;
> +	struct work_struct		role_switch_wq;
> +	int				in_lpm:1;
> +	int				wakeup_int:1;
> +	/* mutext used in workqueue*/
> +	struct mutex			mutex;
> +	enum usb_dr_mode		dr_mode;
> +	enum usb_dr_mode		current_dr_mode;
> +	enum usb_dr_mode		desired_dr_mode;
> +	struct dentry			*root;
> +};
> +
> +#endif /* __LINUX_CDNS3_CORE_H */
> 

cheers,
-roger
-- 
Texas Instruments Finland Oy, Porkkalankatu 22, 00180 Helsinki.
Y-tunnus/Business ID: 0615521-4. Kotipaikka/Domicile: Helsinki
