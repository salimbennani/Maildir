Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 22 Nov 2018 22:45:33 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 5DF1958037D;
	Thu, 22 Nov 2018 06:34:06 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by orsmga007-1.jf.intel.com with ESMTP; 22 Nov 2018 06:34:06 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Axvz2gBRIKpFQPow3rqVmSzcpSNpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa64YRKCt8tkgFKBZ4jH8fUM07OQ7/iwHzRYqb+681k6OKRWUBEEjc?=
 =?us-ascii?q?hE1ycBO+WiTXPBEfjxciYhF95DXlI2t1uyMExSBdqsLwaK+i764jEdAAjwOhRo?=
 =?us-ascii?q?LerpBIHSk9631+ev8JHPfglEnjWwba9xIRmssQndqtQdjJd/JKo21hbHuGZDdf?=
 =?us-ascii?q?5MxWNvK1KTnhL86dm18ZV+7SleuO8v+tBZX6nicKs2UbJXDDI9M2Ao/8LrrgXM?=
 =?us-ascii?q?TRGO5nQHTGoblAdDDhXf4xH7WpfxtTb6tvZ41SKHM8D6Uaw4VDK/5KpwVhTmlD?=
 =?us-ascii?q?kIOCI48GHPi8x/kqRboA66pxdix4LYeZyZOOZicq/Ye94RWGhPUdtLVyFZDI2y?=
 =?us-ascii?q?b5UBAfcCM+ZWoIbyu0YBohmwCgm3HOPiyCRFhmPq0aAgz+gtDRvL0BImEtkTsH?=
 =?us-ascii?q?rUttL1NKIKXO671qbIyzTDYO1S2Tzg54fHbAwhoe2SUrJqbMHczlQgGBnDjlWR?=
 =?us-ascii?q?t4PlOyiY1uoDs2mV6+pgUfijhHInqwxopDWk28kiio7Mho0Py1DE8z10wIgvJd?=
 =?us-ascii?q?KmVkF0fMCrEIBTtyGGMIt2WtkuQ2ZyuCY10rEGt5C7fSYOyJQj3RLQd/yHfo6V?=
 =?us-ascii?q?6RzgTOacOSl0iG5hdb6lmhq//1asxvfhWsS3zFpGtCtIn9vUunwTzRPf9taLR/?=
 =?us-ascii?q?5g8kqg2juC0gDe5+BALE8qkKfXN5ssz7AtmpYPsEnOGzL5lUT4gaKUc0gr5+ql?=
 =?us-ascii?q?5/rpb7jjuJCRNI95hwH4P68zgMKwG/44PRILX2WD+eSzyrnj/UrhTbVUgf05jL?=
 =?us-ascii?q?PZvIrZJcsFvK65BRFa0oI55xa4FTem38wUnXgBLF1bZBKKl5blN03KLfziEPuy?=
 =?us-ascii?q?jUqgnC12y/3FIrHtGJTAI3rbnLfkZ7l96kpcyAQpzdBY4pJZErUBIPP1Wk/su9?=
 =?us-ascii?q?3UFxw5PBKuw+bhFtp90poSWWWBA6+fLqzSq0SF5vwgI+aSfo8ZojX9JOY/5/7o?=
 =?us-ascii?q?k3A5nUURfa6z3ZsYcHy4BOhpI12FYXrwhdcMCWMKvgs9TOP0klGDXiNTam22X6?=
 =?us-ascii?q?I94DE7FY2nAZ3CRoCrnLyOwiO7EodKaWBBD1CGCW3oeJmcW/cQdCKSJddskjwe?=
 =?us-ascii?q?WrigV48uzxauuBX6y7p6NOXU/CIYuInn1Nh04e3TiB4z+SZ1D8Sbz2GCUWV0kn?=
 =?us-ascii?q?kUSD8x2aB1uVZ9xUub0ahkn/xYEsRe5/FOUggkL5LczOt6C9b0WgLGZdqJTFem?=
 =?us-ascii?q?QtO7ATA+VN4xwtkOY1pjFNWmlBzMwy2qA7oNnbyRGJM06r7c32T2J8tl0XnGz6?=
 =?us-ascii?q?khj14lQsdVL22pnKx/+hPXB47IlUWZiqmreb4d3C7L6GeM026OsFtEXw53VKXP?=
 =?us-ascii?q?RWofaVfOrdTl+kPCSKejCbc9PQtH08KCLqpKZcfvjVVJX/rjPNXeY2Ssm2a/Hx?=
 =?us-ascii?q?qIx7WMbJb0dGUZxinSFE8EkwUL93acKQc+Hjuho37ZDDF2CF3geV3s/vdkpHO7?=
 =?us-ascii?q?VEA0yRqKYFNn17ay/h4VhvmcS/cI07IAuSchrSh0HVmn09LXDdqAuxRufKFGbd?=
 =?us-ascii?q?wh51dH0HrTtxZhMZy4M6BimlkefhxqsEz0yRV4FJ9Mkcgwo3Ms1wp9N6SY3UhF?=
 =?us-ascii?q?dzOZ25DwJ7LWJnPz/BCpd67ZxFXe3MyK9acI7fQys0/jsx2xFko+73Vn1MFY02?=
 =?us-ascii?q?ed5pXPCwoSTZLxU0Yt+xhmvb3aZTM954fV1X1qPqm5qTvC29MvBOs4xResZdZf?=
 =?us-ascii?q?MKWYFADsF80WHdShKOsvm1KxdBILIPhS9LIoP8Ohb/aJwqqrM/hvnT24jWVL+p?=
 =?us-ascii?q?ty0l+R+CVmTO7I3JEFw++D0wuDVjf8ikqhs8/tlYBFYzESAnSwySz+CIFNYa1y?=
 =?us-ascii?q?eJ4BCX2yLM2v2tV+m5ntVmZY9V6+HV8JxNWleBuSb1Pn2w1Q2l8aoXimmSu+0j?=
 =?us-ascii?q?x1nCslrquZ3CzS3evicAALNXJMRGlnlV3sO5S7j8gGXEi0aAgkjAGl5UfmyKdB?=
 =?us-ascii?q?vqRwMm7TTV1OfyfoNWFiU7K8uaaYbM5L9Zwnrz9XUOO6YV2BTr79oh0a0z7sHm?=
 =?us-ascii?q?dExTA7cS2qtYv9nxBglG2dK3NzpmLDec5s3Rff+MDcRflJ0zsGRSl0kznWCkKn?=
 =?us-ascii?q?P9m0+9WZjJPDsuG4V2K8WZxfayjrzYWctCSl4W1mGwGwn/e2mtf/Cwg1zTf718?=
 =?us-ascii?q?V2VSXPtBv8YJPk1765MeJkeUlkHkT85NB5GoF9k4swgo8f2X4Bi5WR/HoHl3rz?=
 =?us-ascii?q?MNpB1aL/anoNWSAEw9rP7Af5301jK2qDx5jlWXWF3sthe966b3sW2y0n6MBGEq?=
 =?us-ascii?q?WU7L1CnSZuplq4rATRYeVynzsHyPsu7mIajP8NuAY30iqdBbUSF1FCPSPwjxSI?=
 =?us-ascii?q?88y+rKJPaWasa7ew1VByndC8DL6YpAFcV230epMjHS9288V+P0jA0Hz16oH4Zt?=
 =?us-ascii?q?bQacgfuQGTkxfFl+JVMo4+luIWhSp7PmLwpXgly+84jRN0x527spaIK35x/K2n?=
 =?us-ascii?q?GB5XLSP6Z9kc+jz2iaZen8CW352gH5l7GzULWofoQuysED4IqfvnMAOOGiUmqn?=
 =?us-ascii?q?iHAbrfAROf6EB+onLTFJCrMmubJXgDwtVkWRmdP1dfgAEPUTU+n545EB2qxcP7?=
 =?us-ascii?q?fEd44DAR+kD3qh9Wxu10MBn/V3/VpB20ZTcsVJifMB1W4xlZ6EjPNsye6v9zEz?=
 =?us-ascii?q?tc/p28twGNLm2bZwJVDWAGQECEBlbjPqWw6tnE6eSXGu2+L/7Wa7WUteNeT+uI?=
 =?us-ascii?q?xY6o0oZ+/TaDLMCPMWd5D/EhxkpPR3N5G9namzUSTSwYjTnNYtWfpBe9/C13s8?=
 =?us-ascii?q?++/O7qWALp+YuAFb9SPc9z9BCxhKeJL/SQizphKTZEypMMwmfFybgY3F4PkiFu?=
 =?us-ascii?q?aiOiEbIauS7WS6LQnKBXAgUfayNyMstI8q090hNMOc7dltP6yLp4guQpBFdCUF?=
 =?us-ascii?q?zrgtupatASI2GhKFPHA16GNLSYKj3KwMH3YqK8RadTjOVOsB2wtiiUE1X+PjSY?=
 =?us-ascii?q?jDTpUxGvMedRjCCUJhBeuYe9cgpzBmjnVt7pdhq7MNpvhz0s3bI0nm/KNXIbMT?=
 =?us-ascii?q?VkaUxNs6af7TlGjfR/AWBB6ntlIPKAmyaY6enYN5kXveFqAiRyi+JV/nA6x6FJ?=
 =?us-ascii?q?4yFDQfx/gDHSocJ2o1G6jumPzSJqUAZPqjZOno6EoV9uNrnZ9pZeX3bJ5xYN7W?=
 =?us-ascii?q?SWCxQXqNppENzvu6ZMytfRkKL/MitN89XR/cEEHcjbNNqHMGY9MRruADPVDBEK?=
 =?us-ascii?q?TTiuNWHegUxSiPCT9n2PoZg8pZjhg54OSr5dVFwoGfIWEEVlHNoeIJhpWjMoi6?=
 =?us-ascii?q?KUjMkN5Sn2kB6EY8FXvYvOUP6ISdzpJCyElrlPZxYOwrSweY0VOpehgxQ6QlZ/?=
 =?us-ascii?q?lYXOXUHXWIYejDdma1oYqUNM/Xw2cGAvx0//Ileh6XkSGPqckBApjg84auR7p2?=
 =?us-ascii?q?Sk2Es+Olef/Hh4q0I2g9iwxGnJKDM=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAAAmvvZbh0O0hNFiGQEBAQEBAQEBA?=
 =?us-ascii?q?QEBAQcBAQEBAQGBUQQBAQEBAQsBgTCBOYECJ4wQjAGCDRSOIokEFIFjDgEBGAs?=
 =?us-ascii?q?IAYFLhwciNAkNAQMBAQEBAQECARMBAQEIDQkIKSMMgjYkAYJhAQEBAQMBAQEXD?=
 =?us-ascii?q?RMGAQEsCwEFCQEBCg4HAwklAwwFEwEMAQUBIhMFgxwBggEBBAqeDDyKHYFsM4J?=
 =?us-ascii?q?2AQEFhjlnCBKKW4EcF4F/gRGBcIEigxsBBIEjhhaJGwYEhgaBNY8aCgmBEYEPh?=
 =?us-ascii?q?FyGGIQQCxhfek2HKzaHAY1Dh32CSQYCCQcPIYElgg0zGggwO4JsCYISDBcSgxC?=
 =?us-ascii?q?FPIU/PzKBBQEBjFQBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ABAAAmvvZbh0O0hNFiGQEBAQEBAQEBAQEBAQcBAQEBAQG?=
 =?us-ascii?q?BUQQBAQEBAQsBgTCBOYECJ4wQjAGCDRSOIokEFIFjDgEBGAsIAYFLhwciNAkNA?=
 =?us-ascii?q?QMBAQEBAQECARMBAQEIDQkIKSMMgjYkAYJhAQEBAQMBAQEXDRMGAQEsCwEFCQE?=
 =?us-ascii?q?BCg4HAwklAwwFEwEMAQUBIhMFgxwBggEBBAqeDDyKHYFsM4J2AQEFhjlnCBKKW?=
 =?us-ascii?q?4EcF4F/gRGBcIEigxsBBIEjhhaJGwYEhgaBNY8aCgmBEYEPhFyGGIQQCxhfek2?=
 =?us-ascii?q?HKzaHAY1Dh32CSQYCCQcPIYElgg0zGggwO4JsCYISDBcSgxCFPIU/PzKBBQEBj?=
 =?us-ascii?q?FQBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="41197839"
X-Amp-Result: UNSCANNABLE
X-Amp-File-Uploaded: False
Unscannable: 2
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 06:34:04 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2437461AbeKWBNi (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 20:13:38 -0500
Received: from mail-ed1-f68.google.com ([209.85.208.68]:40701 "EHLO
        mail-ed1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2395565AbeKWBNi (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 20:13:38 -0500
Received: by mail-ed1-f68.google.com with SMTP id d3so7877393edx.7
        for <linux-kernel@vger.kernel.org>; Thu, 22 Nov 2018 06:33:58 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=ffwll.ch; s=google;
        h=sender:date:from:to:cc:subject:message-id:mail-followup-to
         :references:mime-version:content-disposition:in-reply-to:user-agent;
        bh=yiEbzgDRxpBEAX9OL6wY3WuLde78C5jWTnqCZUMsGpg=;
        b=LnM24r/Umw2Wq2PoHAG5iE71CnNJ5OkaFDYz0z2EINmnez2+S8REZLHcXlt84IHws2
         g4fX4KrNj0o7M+V8Eobi7JgBKMJY/btTVldYDWaSV61OdIjWnCFGwn55XSg1ZbiJLBQc
         PQKVDEaddFTmUiw1UaYh7Fk/sqlcBq40JXWko=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
         :mail-followup-to:references:mime-version:content-disposition
         :in-reply-to:user-agent;
        bh=yiEbzgDRxpBEAX9OL6wY3WuLde78C5jWTnqCZUMsGpg=;
        b=aWg2LtyevpGLwu5kLVxvpbMoAxNhhQH0iRRoklCtmgEEAJ6V+tRIQbGNYx+Zyjxjdu
         IczIrgEiJlrUPiRF8aGoipMD5fldtCRE/879C87GdhGGsyw/98LD62Z5b28KsBlnlHk/
         7A0w9MwFuOjIaXWB6nOWzPbL41QuBQ3nS1mZPcPXbIob5sykhmiJpHIaxFXdkE7uz8jY
         WoBPE54wDJ0OSitZxZXchISUt+KEkdLZu79rDyxtETf+PoZ0bx9fLtmx+fIMqDNsy3Nr
         DVb39LkHyBOrTH61orfNhsrCDZC7qnu/Ka9E7k6CettfM7wLUIGR9jGzT7gf/idX5TXM
         lgng==
X-Gm-Message-State: AA+aEWZQvhLnN3UaOivaXSp8NEml+Uj86d1TIBohXbNi/6ixCTvPU00M
        CNkVcFbeahaWHiPe20CwSHhiBA==
X-Google-Smtp-Source: AFSGD/W5IBu+z8dgv7Ax4pOoBiPeJVRFbr0OMFCgENHEDOZflnMwnHN4IIQ5hUVjtc7s50ShIEKo6Q==
X-Received: by 2002:a50:9996:: with SMTP id m22mr9799646edb.7.1542897237749;
        Thu, 22 Nov 2018 06:33:57 -0800 (PST)
Received: from phenom.ffwll.local ([2a02:168:569e:0:3106:d637:d723:e855])
        by smtp.gmail.com with ESMTPSA id z50sm10146419edz.1.2018.11.22.06.33.56
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Thu, 22 Nov 2018 06:33:56 -0800 (PST)
Date: Thu, 22 Nov 2018 15:33:54 +0100
From: Daniel Vetter <daniel@ffwll.ch>
To: Oleksandr Andrushchenko <andr2000@gmail.com>
Cc: xen-devel@lists.xenproject.org, linux-kernel@vger.kernel.org,
        dri-devel@lists.freedesktop.org, alsa-devel@alsa-project.org,
        jgross@suse.com, boris.ostrovsky@oracle.com,
        Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Subject: Re: [Xen-devel][PATCH 2/3] drm/xen-front: Use Xen common shared
 buffer implementation
Message-ID: <20181122143354.GG4266@phenom.ffwll.local>
Mail-Followup-To: Oleksandr Andrushchenko <andr2000@gmail.com>,
        xen-devel@lists.xenproject.org, linux-kernel@vger.kernel.org,
        dri-devel@lists.freedesktop.org, alsa-devel@alsa-project.org,
        jgross@suse.com, boris.ostrovsky@oracle.com,
        Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
References: <20181122100230.14976-1-andr2000@gmail.com>
 <20181122100230.14976-2-andr2000@gmail.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20181122100230.14976-2-andr2000@gmail.com>
X-Operating-System: Linux phenom 4.18.0-2-amd64 
User-Agent: Mutt/1.10.1 (2018-07-13)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Thu, Nov 22, 2018 at 12:02:29PM +0200, Oleksandr Andrushchenko wrote:
> From: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
> 
> Use page directory based shared buffer implementation
> now available as common code for Xen frontend drivers.
> 
> Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
> ---
>  drivers/gpu/drm/xen/Kconfig               |   1 +
>  drivers/gpu/drm/xen/Makefile              |   1 -
>  drivers/gpu/drm/xen/xen_drm_front.c       |  60 ++--
>  drivers/gpu/drm/xen/xen_drm_front_gem.c   |   1 -
>  drivers/gpu/drm/xen/xen_drm_front_shbuf.c | 414 ----------------------
>  drivers/gpu/drm/xen/xen_drm_front_shbuf.h |  64 ----
>  6 files changed, 30 insertions(+), 511 deletions(-)
>  delete mode 100644 drivers/gpu/drm/xen/xen_drm_front_shbuf.c
>  delete mode 100644 drivers/gpu/drm/xen/xen_drm_front_shbuf.h
> 
> diff --git a/drivers/gpu/drm/xen/Kconfig b/drivers/gpu/drm/xen/Kconfig
> index 4cca160782ab..f969d486855d 100644
> --- a/drivers/gpu/drm/xen/Kconfig
> +++ b/drivers/gpu/drm/xen/Kconfig
> @@ -12,6 +12,7 @@ config DRM_XEN_FRONTEND
>  	select DRM_KMS_HELPER
>  	select VIDEOMODE_HELPERS
>  	select XEN_XENBUS_FRONTEND
> +	select XEN_FRONT_PGDIR_SHBUF
>  	help
>  	  Choose this option if you want to enable a para-virtualized
>  	  frontend DRM/KMS driver for Xen guest OSes.
> diff --git a/drivers/gpu/drm/xen/Makefile b/drivers/gpu/drm/xen/Makefile
> index 712afff5ffc3..825905f67faa 100644
> --- a/drivers/gpu/drm/xen/Makefile
> +++ b/drivers/gpu/drm/xen/Makefile
> @@ -4,7 +4,6 @@ drm_xen_front-objs := xen_drm_front.o \
>  		      xen_drm_front_kms.o \
>  		      xen_drm_front_conn.o \
>  		      xen_drm_front_evtchnl.o \
> -		      xen_drm_front_shbuf.o \
>  		      xen_drm_front_cfg.o \
>  		      xen_drm_front_gem.o
>  
> diff --git a/drivers/gpu/drm/xen/xen_drm_front.c b/drivers/gpu/drm/xen/xen_drm_front.c
> index 6b6d5ab82ec3..9597544fecc1 100644
> --- a/drivers/gpu/drm/xen/xen_drm_front.c
> +++ b/drivers/gpu/drm/xen/xen_drm_front.c
> @@ -19,6 +19,7 @@
>  #include <xen/xen.h>
>  #include <xen/xenbus.h>
>  
> +#include <xen/xen-front-pgdir-shbuf.h>
>  #include <xen/interface/io/displif.h>
>  
>  #include "xen_drm_front.h"
> @@ -26,28 +27,20 @@
>  #include "xen_drm_front_evtchnl.h"
>  #include "xen_drm_front_gem.h"
>  #include "xen_drm_front_kms.h"
> -#include "xen_drm_front_shbuf.h"
>  
>  struct xen_drm_front_dbuf {
>  	struct list_head list;
>  	u64 dbuf_cookie;
>  	u64 fb_cookie;
> -	struct xen_drm_front_shbuf *shbuf;
> +
> +	struct xen_front_pgdir_shbuf shbuf;
>  };
>  
> -static int dbuf_add_to_list(struct xen_drm_front_info *front_info,
> -			    struct xen_drm_front_shbuf *shbuf, u64 dbuf_cookie)
> +static void dbuf_add_to_list(struct xen_drm_front_info *front_info,
> +			     struct xen_drm_front_dbuf *dbuf, u64 dbuf_cookie)
>  {
> -	struct xen_drm_front_dbuf *dbuf;
> -
> -	dbuf = kzalloc(sizeof(*dbuf), GFP_KERNEL);
> -	if (!dbuf)
> -		return -ENOMEM;
> -
>  	dbuf->dbuf_cookie = dbuf_cookie;
> -	dbuf->shbuf = shbuf;
>  	list_add(&dbuf->list, &front_info->dbuf_list);
> -	return 0;
>  }
>  
>  static struct xen_drm_front_dbuf *dbuf_get(struct list_head *dbuf_list,
> @@ -64,11 +57,14 @@ static struct xen_drm_front_dbuf *dbuf_get(struct list_head *dbuf_list,
>  
>  static void dbuf_flush_fb(struct list_head *dbuf_list, u64 fb_cookie)
>  {
> +#if IS_ENABLED(CONFIG_X86)
>  	struct xen_drm_front_dbuf *buf, *q;
>  
>  	list_for_each_entry_safe(buf, q, dbuf_list, list)
>  		if (buf->fb_cookie == fb_cookie)
> -			xen_drm_front_shbuf_flush(buf->shbuf);
> +			drm_clflush_pages(buf->shbuf.pages,
> +					  buf->shbuf.num_pages);
> +#endif

Why do we need to clflush here only on x86? Feels fairly fishy, but I
think we've discussed this problem for long time with the original
submission already.

Anyway, I'm all for code duplication removal, so if the Xen folks are
happy with patch 1, this one here has my ack. Might also be best to merge
all three through the Xen tree. Fallback would be xen folks sending a
topic pull request with these 3 patches to drm-misc and takashi's sound
tree.
-Daniel

>  }
>  
>  static void dbuf_free(struct list_head *dbuf_list, u64 dbuf_cookie)
> @@ -78,8 +74,8 @@ static void dbuf_free(struct list_head *dbuf_list, u64 dbuf_cookie)
>  	list_for_each_entry_safe(buf, q, dbuf_list, list)
>  		if (buf->dbuf_cookie == dbuf_cookie) {
>  			list_del(&buf->list);
> -			xen_drm_front_shbuf_unmap(buf->shbuf);
> -			xen_drm_front_shbuf_free(buf->shbuf);
> +			xen_front_pgdir_shbuf_unmap(&buf->shbuf);
> +			xen_front_pgdir_shbuf_free(&buf->shbuf);
>  			kfree(buf);
>  			break;
>  		}
> @@ -91,8 +87,8 @@ static void dbuf_free_all(struct list_head *dbuf_list)
>  
>  	list_for_each_entry_safe(buf, q, dbuf_list, list) {
>  		list_del(&buf->list);
> -		xen_drm_front_shbuf_unmap(buf->shbuf);
> -		xen_drm_front_shbuf_free(buf->shbuf);
> +		xen_front_pgdir_shbuf_unmap(&buf->shbuf);
> +		xen_front_pgdir_shbuf_free(&buf->shbuf);
>  		kfree(buf);
>  	}
>  }
> @@ -171,9 +167,9 @@ int xen_drm_front_dbuf_create(struct xen_drm_front_info *front_info,
>  			      u32 bpp, u64 size, struct page **pages)
>  {
>  	struct xen_drm_front_evtchnl *evtchnl;
> -	struct xen_drm_front_shbuf *shbuf;
> +	struct xen_drm_front_dbuf *dbuf;
>  	struct xendispl_req *req;
> -	struct xen_drm_front_shbuf_cfg buf_cfg;
> +	struct xen_front_pgdir_shbuf_cfg buf_cfg;
>  	unsigned long flags;
>  	int ret;
>  
> @@ -181,28 +177,29 @@ int xen_drm_front_dbuf_create(struct xen_drm_front_info *front_info,
>  	if (unlikely(!evtchnl))
>  		return -EIO;
>  
> +	dbuf = kzalloc(sizeof(*dbuf), GFP_KERNEL);
> +	if (!dbuf)
> +		return -ENOMEM;
> +
> +	dbuf_add_to_list(front_info, dbuf, dbuf_cookie);
> +
>  	memset(&buf_cfg, 0, sizeof(buf_cfg));
>  	buf_cfg.xb_dev = front_info->xb_dev;
> +	buf_cfg.num_pages = DIV_ROUND_UP(size, PAGE_SIZE);
>  	buf_cfg.pages = pages;
> -	buf_cfg.size = size;
> +	buf_cfg.pgdir = &dbuf->shbuf;
>  	buf_cfg.be_alloc = front_info->cfg.be_alloc;
>  
> -	shbuf = xen_drm_front_shbuf_alloc(&buf_cfg);
> -	if (IS_ERR(shbuf))
> -		return PTR_ERR(shbuf);
> -
> -	ret = dbuf_add_to_list(front_info, shbuf, dbuf_cookie);
> -	if (ret < 0) {
> -		xen_drm_front_shbuf_free(shbuf);
> -		return ret;
> -	}
> +	ret = xen_front_pgdir_shbuf_alloc(&buf_cfg);
> +	if (ret < 0)
> +		goto fail_shbuf_alloc;
>  
>  	mutex_lock(&evtchnl->u.req.req_io_lock);
>  
>  	spin_lock_irqsave(&front_info->io_lock, flags);
>  	req = be_prepare_req(evtchnl, XENDISPL_OP_DBUF_CREATE);
>  	req->op.dbuf_create.gref_directory =
> -			xen_drm_front_shbuf_get_dir_start(shbuf);
> +			xen_front_pgdir_shbuf_get_dir_start(&dbuf->shbuf);
>  	req->op.dbuf_create.buffer_sz = size;
>  	req->op.dbuf_create.dbuf_cookie = dbuf_cookie;
>  	req->op.dbuf_create.width = width;
> @@ -221,7 +218,7 @@ int xen_drm_front_dbuf_create(struct xen_drm_front_info *front_info,
>  	if (ret < 0)
>  		goto fail;
>  
> -	ret = xen_drm_front_shbuf_map(shbuf);
> +	ret = xen_front_pgdir_shbuf_map(&dbuf->shbuf);
>  	if (ret < 0)
>  		goto fail;
>  
> @@ -230,6 +227,7 @@ int xen_drm_front_dbuf_create(struct xen_drm_front_info *front_info,
>  
>  fail:
>  	mutex_unlock(&evtchnl->u.req.req_io_lock);
> +fail_shbuf_alloc:
>  	dbuf_free(&front_info->dbuf_list, dbuf_cookie);
>  	return ret;
>  }
> diff --git a/drivers/gpu/drm/xen/xen_drm_front_gem.c b/drivers/gpu/drm/xen/xen_drm_front_gem.c
> index c85bfe7571cb..53be4c7dc0a4 100644
> --- a/drivers/gpu/drm/xen/xen_drm_front_gem.c
> +++ b/drivers/gpu/drm/xen/xen_drm_front_gem.c
> @@ -22,7 +22,6 @@
>  #include <xen/balloon.h>
>  
>  #include "xen_drm_front.h"
> -#include "xen_drm_front_shbuf.h"
>  
>  struct xen_gem_object {
>  	struct drm_gem_object base;
> diff --git a/drivers/gpu/drm/xen/xen_drm_front_shbuf.c b/drivers/gpu/drm/xen/xen_drm_front_shbuf.c
> deleted file mode 100644
> index d333b67cc1a0..000000000000
> --- a/drivers/gpu/drm/xen/xen_drm_front_shbuf.c
> +++ /dev/null
> @@ -1,414 +0,0 @@
> -// SPDX-License-Identifier: GPL-2.0 OR MIT
> -
> -/*
> - *  Xen para-virtual DRM device
> - *
> - * Copyright (C) 2016-2018 EPAM Systems Inc.
> - *
> - * Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
> - */
> -
> -#include <drm/drmP.h>
> -
> -#if defined(CONFIG_X86)
> -#include <drm/drm_cache.h>
> -#endif
> -#include <linux/errno.h>
> -#include <linux/mm.h>
> -
> -#include <asm/xen/hypervisor.h>
> -#include <xen/balloon.h>
> -#include <xen/xen.h>
> -#include <xen/xenbus.h>
> -#include <xen/interface/io/ring.h>
> -#include <xen/interface/io/displif.h>
> -
> -#include "xen_drm_front.h"
> -#include "xen_drm_front_shbuf.h"
> -
> -struct xen_drm_front_shbuf_ops {
> -	/*
> -	 * Calculate number of grefs required to handle this buffer,
> -	 * e.g. if grefs are required for page directory only or the buffer
> -	 * pages as well.
> -	 */
> -	void (*calc_num_grefs)(struct xen_drm_front_shbuf *buf);
> -	/* Fill page directory according to para-virtual display protocol. */
> -	void (*fill_page_dir)(struct xen_drm_front_shbuf *buf);
> -	/* Claim grant references for the pages of the buffer. */
> -	int (*grant_refs_for_buffer)(struct xen_drm_front_shbuf *buf,
> -				     grant_ref_t *priv_gref_head, int gref_idx);
> -	/* Map grant references of the buffer. */
> -	int (*map)(struct xen_drm_front_shbuf *buf);
> -	/* Unmap grant references of the buffer. */
> -	int (*unmap)(struct xen_drm_front_shbuf *buf);
> -};
> -
> -grant_ref_t xen_drm_front_shbuf_get_dir_start(struct xen_drm_front_shbuf *buf)
> -{
> -	if (!buf->grefs)
> -		return GRANT_INVALID_REF;
> -
> -	return buf->grefs[0];
> -}
> -
> -int xen_drm_front_shbuf_map(struct xen_drm_front_shbuf *buf)
> -{
> -	if (buf->ops->map)
> -		return buf->ops->map(buf);
> -
> -	/* no need to map own grant references */
> -	return 0;
> -}
> -
> -int xen_drm_front_shbuf_unmap(struct xen_drm_front_shbuf *buf)
> -{
> -	if (buf->ops->unmap)
> -		return buf->ops->unmap(buf);
> -
> -	/* no need to unmap own grant references */
> -	return 0;
> -}
> -
> -void xen_drm_front_shbuf_flush(struct xen_drm_front_shbuf *buf)
> -{
> -#if defined(CONFIG_X86)
> -	drm_clflush_pages(buf->pages, buf->num_pages);
> -#endif
> -}
> -
> -void xen_drm_front_shbuf_free(struct xen_drm_front_shbuf *buf)
> -{
> -	if (buf->grefs) {
> -		int i;
> -
> -		for (i = 0; i < buf->num_grefs; i++)
> -			if (buf->grefs[i] != GRANT_INVALID_REF)
> -				gnttab_end_foreign_access(buf->grefs[i],
> -							  0, 0UL);
> -	}
> -	kfree(buf->grefs);
> -	kfree(buf->directory);
> -	kfree(buf);
> -}
> -
> -/*
> - * number of grefs a page can hold with respect to the
> - * struct xendispl_page_directory header
> - */
> -#define XEN_DRM_NUM_GREFS_PER_PAGE ((PAGE_SIZE - \
> -		offsetof(struct xendispl_page_directory, gref)) / \
> -		sizeof(grant_ref_t))
> -
> -static int get_num_pages_dir(struct xen_drm_front_shbuf *buf)
> -{
> -	/* number of pages the page directory consumes itself */
> -	return DIV_ROUND_UP(buf->num_pages, XEN_DRM_NUM_GREFS_PER_PAGE);
> -}
> -
> -static void backend_calc_num_grefs(struct xen_drm_front_shbuf *buf)
> -{
> -	/* only for pages the page directory consumes itself */
> -	buf->num_grefs = get_num_pages_dir(buf);
> -}
> -
> -static void guest_calc_num_grefs(struct xen_drm_front_shbuf *buf)
> -{
> -	/*
> -	 * number of pages the page directory consumes itself
> -	 * plus grefs for the buffer pages
> -	 */
> -	buf->num_grefs = get_num_pages_dir(buf) + buf->num_pages;
> -}
> -
> -#define xen_page_to_vaddr(page) \
> -		((uintptr_t)pfn_to_kaddr(page_to_xen_pfn(page)))
> -
> -static int backend_unmap(struct xen_drm_front_shbuf *buf)
> -{
> -	struct gnttab_unmap_grant_ref *unmap_ops;
> -	int i, ret;
> -
> -	if (!buf->pages || !buf->backend_map_handles || !buf->grefs)
> -		return 0;
> -
> -	unmap_ops = kcalloc(buf->num_pages, sizeof(*unmap_ops),
> -			    GFP_KERNEL);
> -	if (!unmap_ops) {
> -		DRM_ERROR("Failed to get memory while unmapping\n");
> -		return -ENOMEM;
> -	}
> -
> -	for (i = 0; i < buf->num_pages; i++) {
> -		phys_addr_t addr;
> -
> -		addr = xen_page_to_vaddr(buf->pages[i]);
> -		gnttab_set_unmap_op(&unmap_ops[i], addr, GNTMAP_host_map,
> -				    buf->backend_map_handles[i]);
> -	}
> -
> -	ret = gnttab_unmap_refs(unmap_ops, NULL, buf->pages,
> -				buf->num_pages);
> -
> -	for (i = 0; i < buf->num_pages; i++) {
> -		if (unlikely(unmap_ops[i].status != GNTST_okay))
> -			DRM_ERROR("Failed to unmap page %d: %d\n",
> -				  i, unmap_ops[i].status);
> -	}
> -
> -	if (ret)
> -		DRM_ERROR("Failed to unmap grant references, ret %d", ret);
> -
> -	kfree(unmap_ops);
> -	kfree(buf->backend_map_handles);
> -	buf->backend_map_handles = NULL;
> -	return ret;
> -}
> -
> -static int backend_map(struct xen_drm_front_shbuf *buf)
> -{
> -	struct gnttab_map_grant_ref *map_ops = NULL;
> -	unsigned char *ptr;
> -	int ret, cur_gref, cur_dir_page, cur_page, grefs_left;
> -
> -	map_ops = kcalloc(buf->num_pages, sizeof(*map_ops), GFP_KERNEL);
> -	if (!map_ops)
> -		return -ENOMEM;
> -
> -	buf->backend_map_handles = kcalloc(buf->num_pages,
> -					   sizeof(*buf->backend_map_handles),
> -					   GFP_KERNEL);
> -	if (!buf->backend_map_handles) {
> -		kfree(map_ops);
> -		return -ENOMEM;
> -	}
> -
> -	/*
> -	 * read page directory to get grefs from the backend: for external
> -	 * buffer we only allocate buf->grefs for the page directory,
> -	 * so buf->num_grefs has number of pages in the page directory itself
> -	 */
> -	ptr = buf->directory;
> -	grefs_left = buf->num_pages;
> -	cur_page = 0;
> -	for (cur_dir_page = 0; cur_dir_page < buf->num_grefs; cur_dir_page++) {
> -		struct xendispl_page_directory *page_dir =
> -				(struct xendispl_page_directory *)ptr;
> -		int to_copy = XEN_DRM_NUM_GREFS_PER_PAGE;
> -
> -		if (to_copy > grefs_left)
> -			to_copy = grefs_left;
> -
> -		for (cur_gref = 0; cur_gref < to_copy; cur_gref++) {
> -			phys_addr_t addr;
> -
> -			addr = xen_page_to_vaddr(buf->pages[cur_page]);
> -			gnttab_set_map_op(&map_ops[cur_page], addr,
> -					  GNTMAP_host_map,
> -					  page_dir->gref[cur_gref],
> -					  buf->xb_dev->otherend_id);
> -			cur_page++;
> -		}
> -
> -		grefs_left -= to_copy;
> -		ptr += PAGE_SIZE;
> -	}
> -	ret = gnttab_map_refs(map_ops, NULL, buf->pages, buf->num_pages);
> -
> -	/* save handles even if error, so we can unmap */
> -	for (cur_page = 0; cur_page < buf->num_pages; cur_page++) {
> -		buf->backend_map_handles[cur_page] = map_ops[cur_page].handle;
> -		if (unlikely(map_ops[cur_page].status != GNTST_okay))
> -			DRM_ERROR("Failed to map page %d: %d\n",
> -				  cur_page, map_ops[cur_page].status);
> -	}
> -
> -	if (ret) {
> -		DRM_ERROR("Failed to map grant references, ret %d", ret);
> -		backend_unmap(buf);
> -	}
> -
> -	kfree(map_ops);
> -	return ret;
> -}
> -
> -static void backend_fill_page_dir(struct xen_drm_front_shbuf *buf)
> -{
> -	struct xendispl_page_directory *page_dir;
> -	unsigned char *ptr;
> -	int i, num_pages_dir;
> -
> -	ptr = buf->directory;
> -	num_pages_dir = get_num_pages_dir(buf);
> -
> -	/* fill only grefs for the page directory itself */
> -	for (i = 0; i < num_pages_dir - 1; i++) {
> -		page_dir = (struct xendispl_page_directory *)ptr;
> -
> -		page_dir->gref_dir_next_page = buf->grefs[i + 1];
> -		ptr += PAGE_SIZE;
> -	}
> -	/* last page must say there is no more pages */
> -	page_dir = (struct xendispl_page_directory *)ptr;
> -	page_dir->gref_dir_next_page = GRANT_INVALID_REF;
> -}
> -
> -static void guest_fill_page_dir(struct xen_drm_front_shbuf *buf)
> -{
> -	unsigned char *ptr;
> -	int cur_gref, grefs_left, to_copy, i, num_pages_dir;
> -
> -	ptr = buf->directory;
> -	num_pages_dir = get_num_pages_dir(buf);
> -
> -	/*
> -	 * while copying, skip grefs at start, they are for pages
> -	 * granted for the page directory itself
> -	 */
> -	cur_gref = num_pages_dir;
> -	grefs_left = buf->num_pages;
> -	for (i = 0; i < num_pages_dir; i++) {
> -		struct xendispl_page_directory *page_dir =
> -				(struct xendispl_page_directory *)ptr;
> -
> -		if (grefs_left <= XEN_DRM_NUM_GREFS_PER_PAGE) {
> -			to_copy = grefs_left;
> -			page_dir->gref_dir_next_page = GRANT_INVALID_REF;
> -		} else {
> -			to_copy = XEN_DRM_NUM_GREFS_PER_PAGE;
> -			page_dir->gref_dir_next_page = buf->grefs[i + 1];
> -		}
> -		memcpy(&page_dir->gref, &buf->grefs[cur_gref],
> -		       to_copy * sizeof(grant_ref_t));
> -		ptr += PAGE_SIZE;
> -		grefs_left -= to_copy;
> -		cur_gref += to_copy;
> -	}
> -}
> -
> -static int guest_grant_refs_for_buffer(struct xen_drm_front_shbuf *buf,
> -				       grant_ref_t *priv_gref_head,
> -				       int gref_idx)
> -{
> -	int i, cur_ref, otherend_id;
> -
> -	otherend_id = buf->xb_dev->otherend_id;
> -	for (i = 0; i < buf->num_pages; i++) {
> -		cur_ref = gnttab_claim_grant_reference(priv_gref_head);
> -		if (cur_ref < 0)
> -			return cur_ref;
> -
> -		gnttab_grant_foreign_access_ref(cur_ref, otherend_id,
> -						xen_page_to_gfn(buf->pages[i]),
> -						0);
> -		buf->grefs[gref_idx++] = cur_ref;
> -	}
> -	return 0;
> -}
> -
> -static int grant_references(struct xen_drm_front_shbuf *buf)
> -{
> -	grant_ref_t priv_gref_head;
> -	int ret, i, j, cur_ref;
> -	int otherend_id, num_pages_dir;
> -
> -	ret = gnttab_alloc_grant_references(buf->num_grefs, &priv_gref_head);
> -	if (ret < 0) {
> -		DRM_ERROR("Cannot allocate grant references\n");
> -		return ret;
> -	}
> -
> -	otherend_id = buf->xb_dev->otherend_id;
> -	j = 0;
> -	num_pages_dir = get_num_pages_dir(buf);
> -	for (i = 0; i < num_pages_dir; i++) {
> -		unsigned long frame;
> -
> -		cur_ref = gnttab_claim_grant_reference(&priv_gref_head);
> -		if (cur_ref < 0)
> -			return cur_ref;
> -
> -		frame = xen_page_to_gfn(virt_to_page(buf->directory +
> -					PAGE_SIZE * i));
> -		gnttab_grant_foreign_access_ref(cur_ref, otherend_id, frame, 0);
> -		buf->grefs[j++] = cur_ref;
> -	}
> -
> -	if (buf->ops->grant_refs_for_buffer) {
> -		ret = buf->ops->grant_refs_for_buffer(buf, &priv_gref_head, j);
> -		if (ret)
> -			return ret;
> -	}
> -
> -	gnttab_free_grant_references(priv_gref_head);
> -	return 0;
> -}
> -
> -static int alloc_storage(struct xen_drm_front_shbuf *buf)
> -{
> -	buf->grefs = kcalloc(buf->num_grefs, sizeof(*buf->grefs), GFP_KERNEL);
> -	if (!buf->grefs)
> -		return -ENOMEM;
> -
> -	buf->directory = kcalloc(get_num_pages_dir(buf), PAGE_SIZE, GFP_KERNEL);
> -	if (!buf->directory)
> -		return -ENOMEM;
> -
> -	return 0;
> -}
> -
> -/*
> - * For be allocated buffers we don't need grant_refs_for_buffer as those
> - * grant references are allocated at backend side
> - */
> -static const struct xen_drm_front_shbuf_ops backend_ops = {
> -	.calc_num_grefs = backend_calc_num_grefs,
> -	.fill_page_dir = backend_fill_page_dir,
> -	.map = backend_map,
> -	.unmap = backend_unmap
> -};
> -
> -/* For locally granted references we do not need to map/unmap the references */
> -static const struct xen_drm_front_shbuf_ops local_ops = {
> -	.calc_num_grefs = guest_calc_num_grefs,
> -	.fill_page_dir = guest_fill_page_dir,
> -	.grant_refs_for_buffer = guest_grant_refs_for_buffer,
> -};
> -
> -struct xen_drm_front_shbuf *
> -xen_drm_front_shbuf_alloc(struct xen_drm_front_shbuf_cfg *cfg)
> -{
> -	struct xen_drm_front_shbuf *buf;
> -	int ret;
> -
> -	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
> -	if (!buf)
> -		return ERR_PTR(-ENOMEM);
> -
> -	if (cfg->be_alloc)
> -		buf->ops = &backend_ops;
> -	else
> -		buf->ops = &local_ops;
> -
> -	buf->xb_dev = cfg->xb_dev;
> -	buf->num_pages = DIV_ROUND_UP(cfg->size, PAGE_SIZE);
> -	buf->pages = cfg->pages;
> -
> -	buf->ops->calc_num_grefs(buf);
> -
> -	ret = alloc_storage(buf);
> -	if (ret)
> -		goto fail;
> -
> -	ret = grant_references(buf);
> -	if (ret)
> -		goto fail;
> -
> -	buf->ops->fill_page_dir(buf);
> -
> -	return buf;
> -
> -fail:
> -	xen_drm_front_shbuf_free(buf);
> -	return ERR_PTR(ret);
> -}
> diff --git a/drivers/gpu/drm/xen/xen_drm_front_shbuf.h b/drivers/gpu/drm/xen/xen_drm_front_shbuf.h
> deleted file mode 100644
> index 7545c692539e..000000000000
> --- a/drivers/gpu/drm/xen/xen_drm_front_shbuf.h
> +++ /dev/null
> @@ -1,64 +0,0 @@
> -/* SPDX-License-Identifier: GPL-2.0 OR MIT */
> -
> -/*
> - *  Xen para-virtual DRM device
> - *
> - * Copyright (C) 2016-2018 EPAM Systems Inc.
> - *
> - * Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
> - */
> -
> -#ifndef __XEN_DRM_FRONT_SHBUF_H_
> -#define __XEN_DRM_FRONT_SHBUF_H_
> -
> -#include <linux/kernel.h>
> -#include <linux/scatterlist.h>
> -
> -#include <xen/grant_table.h>
> -
> -struct xen_drm_front_shbuf {
> -	/*
> -	 * number of references granted for the backend use:
> -	 *  - for allocated/imported dma-buf's this holds number of grant
> -	 *    references for the page directory and pages of the buffer
> -	 *  - for the buffer provided by the backend this holds number of
> -	 *    grant references for the page directory as grant references for
> -	 *    the buffer will be provided by the backend
> -	 */
> -	int num_grefs;
> -	grant_ref_t *grefs;
> -	unsigned char *directory;
> -
> -	int num_pages;
> -	struct page **pages;
> -
> -	struct xenbus_device *xb_dev;
> -
> -	/* these are the ops used internally depending on be_alloc mode */
> -	const struct xen_drm_front_shbuf_ops *ops;
> -
> -	/* Xen map handles for the buffer allocated by the backend */
> -	grant_handle_t *backend_map_handles;
> -};
> -
> -struct xen_drm_front_shbuf_cfg {
> -	struct xenbus_device *xb_dev;
> -	size_t size;
> -	struct page **pages;
> -	bool be_alloc;
> -};
> -
> -struct xen_drm_front_shbuf *
> -xen_drm_front_shbuf_alloc(struct xen_drm_front_shbuf_cfg *cfg);
> -
> -grant_ref_t xen_drm_front_shbuf_get_dir_start(struct xen_drm_front_shbuf *buf);
> -
> -int xen_drm_front_shbuf_map(struct xen_drm_front_shbuf *buf);
> -
> -int xen_drm_front_shbuf_unmap(struct xen_drm_front_shbuf *buf);
> -
> -void xen_drm_front_shbuf_flush(struct xen_drm_front_shbuf *buf);
> -
> -void xen_drm_front_shbuf_free(struct xen_drm_front_shbuf *buf);
> -
> -#endif /* __XEN_DRM_FRONT_SHBUF_H_ */
> -- 
> 2.19.1
> 
> _______________________________________________
> dri-devel mailing list
> dri-devel@lists.freedesktop.org
> https://lists.freedesktop.org/mailman/listinfo/dri-devel

-- 
Daniel Vetter
Software Engineer, Intel Corporation
http://blog.ffwll.ch
