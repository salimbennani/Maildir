Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:34:00 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga001.jf.intel.com (orsmga001.jf.intel.com [10.7.209.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id B4C1258037D;
	Fri, 23 Nov 2018 02:35:47 -0800 (PST)
Received: from fmsmga102.fm.intel.com ([10.1.193.69])
  by orsmga001-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 02:35:46 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ABvdEHxHyWKX7hGSAKPMqip1GYnF86YWxBRYc798d?=
 =?us-ascii?q?s5kLTJ75o8q8bnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjm58axlVAHnhz?=
 =?us-ascii?q?sGNz4h8WHYlMpwjL5AoBm8oxBz2pPYbJ2JOPZ7eK7WYNEUSndbXstJVyJPHJ6y?=
 =?us-ascii?q?YYUMAeUOMuhXs5L9p0MMoBalGQmiGfnixiNUinPqw6E31fkqHwHc3AwnGtIDqH?=
 =?us-ascii?q?rYosnvO6ccS++60q3IxijHYf9MxDzy6IjJcgsmof6QXrJwcMTdwlQoGgPfjFWR?=
 =?us-ascii?q?p5foPymX1uUDs2mb9O1gWv6si24msQ1xpCagxts1h4TPm4kbyUjE+D1nzIopId?=
 =?us-ascii?q?C0UlN3bNC6HJdKqi2XNJd6TtkjTmxqoCo3yLkLtYSmcCUJx5kr3QDTZvyIfoSS?=
 =?us-ascii?q?/x7vSfqdLDFlj3x/Yr2/nQy98U24x+38SMa01FFKozJbktnDqH8NzQbf6suZRf?=
 =?us-ascii?q?tn+EeuxzKP2xrU6uFeLkA4javbK5g/zb4sjpcfr1jPEyvslEnrgqKaaF8o9vWr?=
 =?us-ascii?q?5uj7eLnrp52RO5dxig7kM6QunsK/Af4/MggLR2Wb/eW81Lv+/Uz2WblKjeM5kr?=
 =?us-ascii?q?PfsJ/EIcQXv6m5AgFT0ok98RayFCmm0NsGknkdNl5FewyIj5LvO17QJPD0F/C/?=
 =?us-ascii?q?g06jkDtz3fDJIqXhAonRLnjEiLrhebd9601CxwYpwtFf+olZCrUAIPL1R0/wu8?=
 =?us-ascii?q?bUDh4/Mwyo3ennDM9x2Z8ZWWKKGqWZKr/dsUeU5uIzJOmBfI8Vtyz8K/g5/fHu?=
 =?us-ascii?q?imU1mV8Afaaz25sXZ2u1HvBnI0WffHrtjc0NEWYMvgoiUuPqjEeOXiJUZ3a3R6?=
 =?us-ascii?q?g8/C00CJq6DYffQYCgmL6B3CClEZFMZWBGDVaMEXHvd4ifX/cMaSSSItJukzAe?=
 =?us-ascii?q?VLihTZMh2g+qtAPg17VnKe/U8DUCtZ3/zNh1+/HTlRYq+DNuFMSd02aNT2Jukm?=
 =?us-ascii?q?MSXTA23rtyoUh8yleFzKh5jOZUFd1V5/NVTAg6MYTQwPB9C9D3QgjBZMuGSE66?=
 =?us-ascii?q?QtW6BjE8VtExzMUIY0pnH9WijwrM3yylA7IOk7yLBZo08r/T3nTrJsZ9zWrG27?=
 =?us-ascii?q?clj1U8XsRPMmimjLZl9wfPH47Jj1mZl6GyeKsBxiHN6nmMwXCOvE5CVg5wSrvK?=
 =?us-ascii?q?XXYYakvSrtT540fCQqSqCbQmNAtB1MGDJrFLat3vkVVJWvPjNM7CbGK2nme6HQ?=
 =?us-ascii?q?yIya+UbIr2Z2Ud2z3QB1UenAAN43mKLwg+CT2no2LFEjNuE0niY0ft8el4tXO6?=
 =?us-ascii?q?QVU4zwCMb019ybW1/gQZiuCbS/MWxrgEojsuqy1oHFah2NLbE8aApwtkfKVbfd?=
 =?us-ascii?q?M94FdG2XjFtwBnOZygNaRihl8YcwR4pE7u0xR3CoNdkckltn8qzQxyKb6G31NF?=
 =?us-ascii?q?bT+XwZfwOrjPIGno4B+vc7LW2k3Z0NuO4KgP7Oo3qlr9swCpDEYt6Ghn3MRP3H?=
 =?us-ascii?q?ua5ZXKCxQSXIn1UkY28Rh6ur7bbjM854PSyX1jL620viXe1NIuAesv0gygcMtH?=
 =?us-ascii?q?MKOYCA/yFNUXBsizKOAwh1eldBMFPOBI+64yMMOrbP+G2K+tPOZ9kzOql2VH4I?=
 =?us-ascii?q?Zh0k2S8ypwUPLH35EAw/uAxAuISy/8jEu9ssDwgY1EfzASEXalxij+GYFRYbd+?=
 =?us-ascii?q?fYAVBme0Is2738lxiITpW3FF6lGjHVQG2MmydBqWblz92xBQ1EsNrXymnyu40y?=
 =?us-ascii?q?J7kzUzoqWD2yzOxvzodAAbNW5TWGlikVDsLJC0jtAbRkSpbxIllAC45Ub83KVb?=
 =?us-ascii?q?oKV/L2/OQUZHZST2LmdiUreuubqGecJA9JQosSBPWuSmfV+aUqL9owcd0y77HW?=
 =?us-ascii?q?tR3io7dzKpupX+hRB6k3iSLHVwrHrYf8F/2xHf6cfYRf5Q2DoGWSZ5hSPWBli6?=
 =?us-ascii?q?I9mm49GUm43fveC5UmKrTodTfjXzzYOcqCu74nVnAB2lkPC0gNHnEwk60Sng2t?=
 =?us-ascii?q?luVCXIqgv8Y4bx26S7N+JnYldnBFvm58VmHYF+l5M6hIsM1ngCmpWV4X0HnH/w?=
 =?us-ascii?q?MdpB2KLydnoNRSMRzN7T7wjow0ljLnOPx4LkWXSR2MphZ9+mYmwI3iIx9dxFCK?=
 =?us-ascii?q?CR7LZchyt6vkK4rR7NYfh6hjodzPou6H0AjO0Ttgsi0D6dAqwMEklCJiPjiQ6I?=
 =?us-ascii?q?79+loaVTZWavd6Ww1UVkkdCgCrGCvh9TWHLjdpg+Gi9w6911MEjQ333r9oHkZN?=
 =?us-ascii?q?7QYMoPth2TlhfMlelUJ4g3lvoXnipnImP9sGYhy+46ixxuwJ67sJKGK2Vr4KK2?=
 =?us-ascii?q?HBpYOifpaMMU/zHnlbxekdqO34CzApVhHS0GU4DyQvKvFDISqO7rNwKTEDAnrn?=
 =?us-ascii?q?ebGLzfHRKQ6Ut8rnLPFYyrOG+TJHUD0dpiQxydLlRFgA8IRDU6goI5Fgeyyczj?=
 =?us-ascii?q?akh54y4e5kXiphtQ0O5oNAT/UmTCpAeucDg0U4OSLB5X7gFE+kfUPtaS7uN1Hy?=
 =?us-ascii?q?FE4JKhqBaBJXCcZwRNFWsJQFCLB0j/Prmy4tnN6+iZBu2jL/vXfLWBs+peW+2T?=
 =?us-ascii?q?xZKo1Itm8C2BNsGOPnlkEv061VBPXXF/G8TFhToPTzYbmD7Kb86evB284DF4rt?=
 =?us-ascii?q?ij8PT3XwLi/YuPBKVTMdVs+BC2gL2PN+2KhCZ+JjZXyIkMxWLTyLUE2F4Siidu?=
 =?us-ascii?q?dySiELgatC7NSr7QlbFTDxIBdyxzM85I5bom3gZRIc7bls/11rlgg/EvFldKTk?=
 =?us-ascii?q?bhld+pZMAQJ2G9NUjKBEKKNLSAOD3KzNv7YaK6Sb1MkupUswe8tiqcE0/mJj6D?=
 =?us-ascii?q?jSXmVwizMeFQiyGWJABeuIC4chp3FWfvVs7pah2lP99xljA2xbw0hnXXNW8TKz?=
 =?us-ascii?q?R8ckVNrqGO4iNcmPlwB2tB7n99J+mehymZ9/XYKooRsfZzAiV7jeRa4HE7y7tT?=
 =?us-ascii?q?9C5FRfx1lzHUrt5huFymluiPyjx6UBtBsDpLhYSLvVl8NqXd7JVPRXHE/BdepV?=
 =?us-ascii?q?mXXjALocZ1QuXK8/RUy97ShOfrLR9c/N/Ou8gRHc7ZLISAKnV3YjTzHzuBRjEM?=
 =?us-ascii?q?QzemMSn9wQRigeqV/X6U5NBusJrzsIAMVa5AU1c2F7UcB1gzT49KG4t+Qj5xye?=
 =?us-ascii?q?3Tt8UP/3fr6UCJHMg=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AvAAAa1/dbh0O0hNFiHQEBBQEHBQGBU?=
 =?us-ascii?q?QgBCwGBVQWBC4EGJ4wRi32CIWaWQRSBWzATAYhVIjQJDQEDAQEBAQEBAgETAQE?=
 =?us-ascii?q?BCA0JCCkvgjYkAYJpAiQTPwYJAh8MDAkQAwwBTRMFglFLggIEAagTM4lZPowJE?=
 =?us-ascii?q?QY+gUGBEYJdB4RnChVlhRwCiH+CEoQIEJBZBwICkS0YgVmPL4ltkAmCDXsKO4J?=
 =?us-ascii?q?sgicXEo4LPzIBYiIBAYlVgkwBAQ?=
X-IPAS-Result: =?us-ascii?q?A0AvAAAa1/dbh0O0hNFiHQEBBQEHBQGBUQgBCwGBVQWBC4E?=
 =?us-ascii?q?GJ4wRi32CIWaWQRSBWzATAYhVIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkvgjYkA?=
 =?us-ascii?q?YJpAiQTPwYJAh8MDAkQAwwBTRMFglFLggIEAagTM4lZPowJEQY+gUGBEYJdB4R?=
 =?us-ascii?q?nChVlhRwCiH+CEoQIEJBZBwICkS0YgVmPL4ltkAmCDXsKO4JsgicXEo4LPzIBY?=
 =?us-ascii?q?iIBAYlVgkwBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,269,1539673200"; 
   d="scan'208";a="54044337"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 02:35:45 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2503294AbeKWVTX (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 16:19:23 -0500
Received: from cloudserver094114.home.pl ([79.96.170.134]:56845 "EHLO
        cloudserver094114.home.pl" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S2409362AbeKWVTX (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 16:19:23 -0500
Received: from 79.184.254.110.ipv4.supernova.orange.pl (79.184.254.110) (HELO aspire.rjw.lan)
 by serwer1319399.home.pl (79.96.170.134) with SMTP (IdeaSmtpServer 0.83.157)
 id 9d9d4d00e5e1312e; Fri, 23 Nov 2018 11:35:37 +0100
From: "Rafael J. Wysocki" <rjw@rjwysocki.net>
To: Linux PM <linux-pm@vger.kernel.org>
Cc: Giovanni Gherdovich <ggherdovich@suse.cz>,
        Doug Smythies <dsmythies@telus.net>,
        Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>,
        Peter Zijlstra <peterz@infradead.org>,
        LKML <linux-kernel@vger.kernel.org>,
        Frederic Weisbecker <frederic@kernel.org>,
        Mel Gorman <mgorman@suse.de>,
        Daniel Lezcano <daniel.lezcano@linaro.org>
Subject: [RFC/RFT][PATCH v6] cpuidle: New timer events oriented governor for tickless systems
Date: Fri, 23 Nov 2018 11:35:38 +0100
Message-ID: <42865872.dmYH3PmblP@aspire.rjw.lan>
MIME-Version: 1.0
Content-Transfer-Encoding: 7Bit
Content-Type: text/plain; charset="us-ascii"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

The venerable menu governor does some thigns that are quite
questionable in my view.

First, it includes timer wakeups in the pattern detection data and
mixes them up with wakeups from other sources which in some cases
causes it to expect what essentially would be a timer wakeup in a
time frame in which no timer wakeups are possible (becuase it knows
the time until the next timer event and that is later than the
expected wakeup time).

Second, it uses the extra exit latency limit based on the predicted
idle duration and depending on the number of tasks waiting on I/O,
even though those tasks may run on a different CPU when they are
woken up.  Moreover, the time ranges used by it for the sleep length
correction factors depend on whether or not there are tasks waiting
on I/O, which again doesn't imply anything in particular, and they
are not correlated to the list of available idle states in any way
whatever.

Also, the pattern detection code in menu may end up considering
values that are too large to matter at all, in which cases running
it is a waste of time.

A major rework of the menu governor would be required to address
these issues and the performance of at least some workloads (tuned
specifically to the current behavior of the menu governor) is likely
to suffer from that.  It is thus better to introduce an entirely new
governor without them and let everybody use the governor that works
better with their actual workloads.

The new governor introduced here, the timer events oriented (TEO)
governor, uses the same basic strategy as menu: it always tries to
find the deepest idle state that can be used in the given conditions.
However, it applies a different approach to that problem.

First, it doesn't use "correction factors" for the time till the
closest timer, but instead it tries to correlate the measured idle
duration values with the available idle states and use that
information to pick up the idle state that is most likely to "match"
the upcoming CPU idle interval.

Second, it doesn't take the number of "I/O waiters" into account at
all and the pattern detection code in it avoids taking timer wakeups
into account.  It also only uses idle duration values less than the
current time till the closest timer (with the tick excluded) for that
purpose.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
---

v5 -> v6:
 * Avoid applying poll_time_limit to non-polling idle states by mistake.
 * Use idle duration measured by the governor for everything (as it likely is
   more accurate than the one measured by the core).
 * Rename SPIKE to PULSE.
 * Do not run pattern detection upfront.  Instead, use recent idle duration
   values to refine the state selection after finding a candidate idle state.
 * Do not use the expected idle duration as an extra latency constraint
   (exit latency is less than the target residency for all of the idle states
   known to me anyway, so this doesn't change anything in practice).

v4 -> v5:
 * Avoid using shallow idle states when the tick has been stopped already.

v3 -> v4:
 * Make the pattern detection avoid returning too early if the minimum
   sample is too far from the average.
 * Reformat the changelog (as requested by Peter).

v2 -> v3:
 * Simplify the pattern detection code and make it return a value
	lower than the time to the closest timer if the majority of recent
	idle intervals are below it regardless of their variance (that should
	cause it to be slightly more aggressive).
 * Do not count wakeups from state 0 due to the time limit in poll_idle()
   as non-timer.

---
 drivers/cpuidle/Kconfig            |   11 
 drivers/cpuidle/governors/Makefile |    1 
 drivers/cpuidle/governors/teo.c    |  450 +++++++++++++++++++++++++++++++++++++
 3 files changed, 462 insertions(+)

Index: linux-pm/drivers/cpuidle/governors/teo.c
===================================================================
--- /dev/null
+++ linux-pm/drivers/cpuidle/governors/teo.c
@@ -0,0 +1,450 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Timer events oriented CPU idle governor
+ *
+ * Copyright (C) 2018 Intel Corporation
+ * Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
+ *
+ * The idea of this governor is based on the observation that on many systems
+ * timer events are two or more orders of magnitude more frequent than any
+ * other interrupts, so they are likely to be the most significant source of CPU
+ * wakeups from idle states.  Moreover, information about what happened in the
+ * (relatively recent) past can be used to estimate whether or not the deepest
+ * idle state with target residency within the time to the closest timer is
+ * likely to be suitable for the upcoming idle time of the CPU and, if not, then
+ * which of the shallower idle states to choose.
+ *
+ * Of course, non-timer wakeup sources are more important in some use cases and
+ * they can be covered by taking a few most recent idle time intervals of the
+ * CPU into account.  However, even in that case it is not necessary to consider
+ * idle duration values greater than the time till the closest timer, as the
+ * patterns that they may belong to produce average values close enough to
+ * the time till the closest timer (sleep length) anyway.
+ *
+ * Thus this governor estimates whether or not the upcoming idle time of the CPU
+ * is likely to be significantly shorter than the sleep length and selects an
+ * idle state for it in accordance with that, as follows:
+ *
+ * - Find an idle state on the basis of the sleep length and state statistics
+ *   collected over time:
+ *
+ *   o Find the deepest idle state whose target residency is less than or euqal
+ *     to the sleep length.
+ *
+ *   o Select it if it matched both the sleep length and the observed idle
+ *     duration in the past more often than it matched the sleep length alone
+ *     (i.e. the observed idle duration was significantly shorter than the sleep
+ *     length matched by it).
+ *
+ *   o Otherwise, select the shallower state with the greatest matched "early"
+ *     wakeups metric.
+ *
+ * - If at least half of the most recent idle duration values is below the
+ *   target residency of the idle state selected so far, use those values to
+ *   compute the new expected idle duration and find an idle state matching it
+ *   (which has to be shallower than the one selected so far).
+ */
+
+#include <linux/cpuidle.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/sched/clock.h>
+#include <linux/tick.h>
+
+/*
+ * The PULSE value is added to metrics when they grow and the DECAY_SHIFT value
+ * is used for decreasing metrics on a regular basis.
+ */
+#define PULSE		1024
+#define DECAY_SHIFT	3
+
+/*
+ * Number of the most recent idle duration values to take into consideration for
+ * the detection of wakeup patterns.
+ */
+#define INTERVALS	8
+
+/**
+ * struct teo_idle_state - Idle state data used by the TEO cpuidle governor.
+ * @early_hits: "Early" CPU wakeups matched by this state.
+ * @hits: "On time" CPU wakeups matched by this state.
+ * @misses: CPU wakeups "missed" by this state.
+ *
+ * A CPU wakeup is "matched" by a given idle state if the idle duration measured
+ * after the wakeup is between the target residency of that state and the target
+ * residnecy of the next one (or if this is the deepest available idle state, it
+ * "matches" a CPU wakeup when the measured idle duration is at least equal to
+ * its target residency).
+ *
+ * Also, from the TEO governor prespective, a CPU wakeup from idle is "early" if
+ * it occurs significantly earlier than the closest expected timer event (that
+ * is, early enough to match an idle state shallower than the one matching the
+ * time till the closest timer event).  Otherwise, the wakeup is "on time", or
+ * it is a "hit".
+ *
+ * A "miss" occurs when the given state doesn't match the wakeup, but it matches
+ * the time till the closest timer event used for idle state selection.
+ */
+struct teo_idle_state {
+	unsigned int early_hits;
+	unsigned int hits;
+	unsigned int misses;
+};
+
+/**
+ * struct teo_cpu - CPU data used by the TEO cpuidle governor.
+ * @time_span_ns: Time between idle state selection and post-wakeup update.
+ * @sleep_length_ns: Time till the closest timer event (at the selection time).
+ * @states: Idle states data corresponding to this CPU.
+ * @last_state: Idle state entered by the CPU last time.
+ * @interval_idx: Index of the most recent saved idle interval.
+ * @intervals: Saved idle duration values.
+ */
+struct teo_cpu {
+	u64 time_span_ns;
+	u64 sleep_length_ns;
+	struct teo_idle_state states[CPUIDLE_STATE_MAX];
+	int last_state;
+	int interval_idx;
+	unsigned int intervals[INTERVALS];
+};
+
+static DEFINE_PER_CPU(struct teo_cpu, teo_cpus);
+
+/**
+ * teo_update - Update CPU data after wakeup.
+ * @drv: cpuidle driver containing state data.
+ * @dev: Target CPU.
+ */
+static void teo_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)
+{
+	struct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);
+	unsigned int sleep_length_us = ktime_to_us(cpu_data->sleep_length_ns);
+	int i, idx_hit = -1, idx_timer = -1;
+	unsigned int measured_us;
+
+	if (cpu_data->time_span_ns == cpu_data->sleep_length_ns) {
+		/* One of the safety nets has triggered (most likely). */
+		measured_us = sleep_length_us;
+	} else {
+		measured_us = dev->last_residency;
+		i = cpu_data->last_state;
+		if (measured_us >= 2 * drv->states[i].exit_latency)
+			measured_us -= drv->states[i].exit_latency;
+		else
+			measured_us /= 2;
+	}
+
+	/*
+	 * Decay the "early hits" metric for all of the states and find the
+	 * states matching the sleep length and the measured idle duration.
+	 */
+	for (i = 0; i < drv->state_count; i++) {
+		unsigned int early_hits = cpu_data->states[i].early_hits;
+
+		cpu_data->states[i].early_hits -= early_hits >> DECAY_SHIFT;
+
+		if (drv->states[i].target_residency <= measured_us)
+			idx_hit = i;
+
+		if (drv->states[i].target_residency <= sleep_length_us)
+			idx_timer = i;
+	}
+
+	/*
+	 * Update the "hits" and "misses" data for the state matching the sleep
+	 * length.  If it matches the measured idle duration too, this is a hit,
+	 * so increase the "hits" metric for it then.  Otherwise, this is a
+	 * miss, so increase the "misses" metric for it.  In the latter case
+	 * also increase the "early hits" metric for the state that actually
+	 * matches the measured idle duration.
+	 */
+	if (idx_timer >= 0) {
+		unsigned int hits = cpu_data->states[idx_timer].hits;
+		unsigned int misses = cpu_data->states[idx_timer].misses;
+
+		hits -= hits >> DECAY_SHIFT;
+		misses -= misses >> DECAY_SHIFT;
+
+		if (idx_timer > idx_hit) {
+			misses += PULSE;
+			if (idx_hit >= 0)
+				cpu_data->states[idx_hit].early_hits += PULSE;
+		} else {
+			hits += PULSE;
+		}
+
+		cpu_data->states[idx_timer].misses = misses;
+		cpu_data->states[idx_timer].hits = hits;
+	}
+
+	/*
+	 * Save idle duration values corresponding to non-timer wakeups for
+	 * pattern detection.
+	 *
+	 * If the total time span between idle state selection and the "reflect"
+	 * callback is greater than or equal to the sleep length determined at
+	 * the idle state selection time, the wakeup is likely to be due to a
+	 * timer event.
+	 */
+	if (cpu_data->time_span_ns >= cpu_data->sleep_length_ns)
+		measured_us = UINT_MAX;
+
+	cpu_data->intervals[cpu_data->interval_idx++] = measured_us;
+	if (cpu_data->interval_idx > INTERVALS)
+		cpu_data->interval_idx = 0;
+}
+
+/**
+ * teo_find_shallower_state - Find shallower idle state matching given duration.
+ * @drv: cpuidle driver containing state data.
+ * @dev: Target CPU.
+ * @state_idx: Index of the capping idle state.
+ * @duration_us: Idle duration value to match.
+ */
+static int teo_find_shallower_state(struct cpuidle_driver *drv,
+				    struct cpuidle_device *dev, int state_idx,
+				    unsigned int duration_us)
+{
+	int i;
+
+	for (i = state_idx - 1; i > 0; i--) {
+		if (drv->states[i].disabled || dev->states_usage[i].disable)
+			continue;
+
+		if (drv->states[i].target_residency <= duration_us)
+			break;
+	}
+	return i;
+}
+
+/**
+ * teo_select - Selects the next idle state to enter.
+ * @drv: cpuidle driver containing state data.
+ * @dev: Target CPU.
+ * @stop_tick: Indication on whether or not to stop the scheduler tick.
+ */
+static int teo_select(struct cpuidle_driver *drv, struct cpuidle_device *dev,
+		      bool *stop_tick)
+{
+	struct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);
+	int latency_req = cpuidle_governor_latency_req(dev->cpu);
+	unsigned int duration_us, count;
+	int max_early_idx, idx, i;
+	ktime_t delta_tick;
+
+	if (cpu_data->last_state >= 0) {
+		teo_update(drv, dev);
+		cpu_data->last_state = -1;
+	}
+
+	cpu_data->time_span_ns = local_clock();
+
+	cpu_data->sleep_length_ns = tick_nohz_get_sleep_length(&delta_tick);
+	duration_us = ktime_to_us(cpu_data->sleep_length_ns);
+
+	count = 0;
+	max_early_idx = -1;
+	idx = -1;
+
+	for (i = 0; i < drv->state_count; i++) {
+		struct cpuidle_state *s = &drv->states[i];
+		struct cpuidle_state_usage *su = &dev->states_usage[i];
+
+		if (s->disabled || su->disable) {
+			/*
+			 * If the "early hits" metric of a disabled state is
+			 * greater than the current maximum, it should be taken
+			 * into account, because it would be a mistake to select
+			 * a deeper state with lower "early hits" metric.  The
+			 * index cannot be changed to point to it, however, so
+			 * just increase the max count alone and let the index
+			 * still point to a shallower idle state.
+			 */
+			if (max_early_idx >= 0 &&
+			    count < cpu_data->states[i].early_hits)
+				count = cpu_data->states[i].early_hits;
+
+			continue;
+		}
+
+		if (idx < 0)
+			idx = i; /* first enabled state */
+
+		if (s->target_residency > duration_us) {
+			/*
+			 * If the "hits" metric of the state matching the sleep
+			 * length is greater than its "misses" metric, that is
+			 * the one to use.
+			 */
+			if (cpu_data->states[idx].hits > cpu_data->states[idx].misses)
+				break;
+
+			/*
+			 * It is more likely that one of the shallower states
+			 * will match the idle duration measured after wakeup,
+			 * so take the one with the maximum "early hits" metric,
+			 * but if that cannot be determined, just use the state
+			 * selected so far.
+			 */
+			if (max_early_idx >= 0) {
+				idx = max_early_idx;
+				duration_us = drv->states[idx].target_residency;
+			}
+			break;
+		}
+		if (s->exit_latency > latency_req) {
+			/*
+			 * If we break out of the loop for latency reasons, use
+			 * the target residency of the selected state as the
+			 * expected idle duration to avoid stopping the tick
+			 * as long as that target residency is low enough.
+			 */
+			duration_us = drv->states[idx].target_residency;
+			break;
+		}
+
+		idx = i;
+
+		if (count < cpu_data->states[i].early_hits &&
+		    !(tick_nohz_tick_stopped() &&
+		      drv->states[i].target_residency < TICK_USEC)) {
+			count = cpu_data->states[i].early_hits;
+			max_early_idx = i;
+		}
+	}
+
+	if (idx < 0) {
+		idx = 0; /* No states enabled. Must use 0. */
+	} else if (idx > 0) {
+		unsigned int max = 0;
+		u64 sum = 0;
+
+		count = 0;
+
+		/*
+		 * Count and sum the most recent idle duration values less than
+		 * the target residency of the state selected so far, find the
+		 * max.
+		 */
+		for (i = 0; i < INTERVALS; i++) {
+			unsigned int val = cpu_data->intervals[i];
+
+			if (val >= drv->states[idx].target_residency)
+				continue;
+
+			count++;
+			sum += val;
+
+			if (val > max)
+				max = val;
+		}
+
+		/*
+		 * Give up if the majority of the most recent idle duration
+		 * values are not in the interesting range.
+		 */
+		if (count >= INTERVALS / 2) {
+			unsigned int avg_us;
+
+			/*
+			 * Discard the max to push the average towards shallower
+			 * idle state somewhat (it is better to underestimate
+			 * the idle duration than to overestimate it).
+			 */
+			count--;
+			sum -= max;
+
+			avg_us = div64_u64(sum, count);
+
+			/*
+			 * Avoid spending too much time in an idle state that
+			 * would be too shallow.
+			 */
+			if (!(tick_nohz_tick_stopped() && avg_us < TICK_USEC)) {
+				idx = teo_find_shallower_state(drv, dev, idx, avg_us);
+				duration_us = avg_us;
+			}
+		}
+	}
+
+	/*
+	 * Don't stop the tick if the selected state is a polling one or if the
+	 * expected idle duration is shorter than the tick period length.
+	 */
+	if (((drv->states[idx].flags & CPUIDLE_FLAG_POLLING) ||
+	    duration_us < TICK_USEC) && !tick_nohz_tick_stopped()) {
+		unsigned int delta_tick_us = ktime_to_us(delta_tick);
+
+		*stop_tick = false;
+
+		/*
+		 * The tick is not going to be stopped, so if the target
+		 * residency of the state to be returned is not within the time
+		 * till the closest timer including the tick, try to correct
+		 * that.
+		 */
+		if (idx > 0 && drv->states[idx].target_residency > delta_tick_us)
+			idx = teo_find_shallower_state(drv, dev, idx, delta_tick_us);
+	}
+
+	return idx;
+}
+
+/**
+ * teo_reflect - Note that governor data for the CPU need to be updated.
+ * @dev: Target CPU.
+ * @state: Entered state.
+ */
+static void teo_reflect(struct cpuidle_device *dev, int state)
+{
+	struct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);
+
+	cpu_data->last_state = state;
+	/*
+	 * If the wakeup was not "natural", but triggered by one of the safety
+	 * nets, assume that the CPU might have been idle for the entire sleep
+	 * length time.
+	 */
+	if (dev->poll_time_limit ||
+	    (tick_nohz_idle_got_tick() && cpu_data->sleep_length_ns > TICK_NSEC)) {
+		dev->poll_time_limit = false;
+		cpu_data->time_span_ns = cpu_data->sleep_length_ns;
+	} else {
+		cpu_data->time_span_ns = local_clock() - cpu_data->time_span_ns;
+	}
+}
+
+/**
+ * teo_enable_device - Initialize the governor's data for the target CPU.
+ * @drv: cpuidle driver (not used).
+ * @dev: Target CPU.
+ */
+static int teo_enable_device(struct cpuidle_driver *drv,
+			     struct cpuidle_device *dev)
+{
+	struct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);
+	int i;
+
+	memset(cpu_data, 0, sizeof(*cpu_data));
+
+	for (i = 0; i < INTERVALS; i++)
+		cpu_data->intervals[i] = UINT_MAX;
+
+	return 0;
+}
+
+static struct cpuidle_governor teo_governor = {
+	.name =		"teo",
+	.rating =	22,
+	.enable =	teo_enable_device,
+	.select =	teo_select,
+	.reflect =	teo_reflect,
+};
+
+static int __init teo_governor_init(void)
+{
+	return cpuidle_register_governor(&teo_governor);
+}
+
+postcore_initcall(teo_governor_init);
Index: linux-pm/drivers/cpuidle/Kconfig
===================================================================
--- linux-pm.orig/drivers/cpuidle/Kconfig
+++ linux-pm/drivers/cpuidle/Kconfig
@@ -23,6 +23,17 @@ config CPU_IDLE_GOV_LADDER
 config CPU_IDLE_GOV_MENU
 	bool "Menu governor (for tickless system)"
 
+config CPU_IDLE_GOV_TEO
+	bool "Timer events oriented governor (for tickless systems)"
+	help
+	  Menu governor derivative that uses a simplified idle state
+	  selection method focused on timer events and does not do any
+	  interactivity boosting.
+
+	  Some workloads benefit from using this governor and it generally
+	  should be safe to use.  Say Y here if you are not happy with the
+	  alternatives.
+
 config DT_IDLE_STATES
 	bool
 
Index: linux-pm/drivers/cpuidle/governors/Makefile
===================================================================
--- linux-pm.orig/drivers/cpuidle/governors/Makefile
+++ linux-pm/drivers/cpuidle/governors/Makefile
@@ -4,3 +4,4 @@
 
 obj-$(CONFIG_CPU_IDLE_GOV_LADDER) += ladder.o
 obj-$(CONFIG_CPU_IDLE_GOV_MENU) += menu.o
+obj-$(CONFIG_CPU_IDLE_GOV_TEO) += teo.o

