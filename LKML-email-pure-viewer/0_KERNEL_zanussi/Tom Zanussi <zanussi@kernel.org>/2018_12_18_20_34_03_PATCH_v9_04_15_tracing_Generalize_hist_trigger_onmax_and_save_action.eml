Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  19 Dec 2018 08:43:06 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga005.jf.intel.com (orsmga005.jf.intel.com [10.7.209.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 7688658055F;
	Tue, 18 Dec 2018 12:35:00 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga005-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 18 Dec 2018 12:35:00 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3Ay80xixIKQJ8D8MEGtdmcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgULvT8rarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr8zRTqs77lmRAbxhC?=
 =?us-ascii?q?kFKjE56njbhNFtjKJAuBKuuQBww5LNbIGRM/p/cL7WcdcaSGZEWMteUDBPDIOi?=
 =?us-ascii?q?YocWFuYPP/tXr5Pkq1UTsBu+HhGsC/3zxT9Um3T62bM23/gkHQzAwQcuHc8BsG?=
 =?us-ascii?q?7Modv1KqkcTO67wqrPwzrBYfNZ2zn96JPQch0juvyAQa58fNDNxUQ1Cw/JklOd?=
 =?us-ascii?q?opHlMTOP0eQNtnCW4fRnVeKqlmUoqBt+oj6yxsc3kYnJh58ex1fF9CpjxoY1OM?=
 =?us-ascii?q?a4SFV6YdO/E5tfqTuaN41oTcMmWW1ovzw6yrIftJO9YSMEy4wnygbBZ/Cbd4WE?=
 =?us-ascii?q?+A/vWeiPLTtimX5oe66ziwyz/EWi0uHxUsq53ExUoiZbjtXArG4B2hLQ58SdSf?=
 =?us-ascii?q?Zx40Gs0iuV2Q/J8OFLO0U0mLLbK5E/xr4wkYIesVrMHiDogkX6lqyWeVs++uiu?=
 =?us-ascii?q?9evnZq/qppiGN497kg3+M6IuldKjAekgLAQCQ2yW9f6h2LDt40H1WqhGg/4qnq?=
 =?us-ascii?q?XDsZ3XJ9wXpqujDA9U1oYj5Qy/DzCj0NkAmXkHLVRFeA+IjoTwOFHBPur4DfGh?=
 =?us-ascii?q?jFSoiTtrwP7HPrv/DZXXNXXDjrjhcqhn60JGywo808pf55RKBbEFOv7zXVXxtN?=
 =?us-ascii?q?PAAh8jLwO02/rnCMl61o4GXWKPA6yZP73IvV6H++IiOO2MZI4TuDbgJPkp/f/u?=
 =?us-ascii?q?jXklmVADeamlx4cYaHe9Hv5+OUWWfWLsgssdEWcNpgc+TPbliFyeUTFJYHa+Ra?=
 =?us-ascii?q?I85iwhB4KgAofOXYStgL2H3CemEZxafGFGClaQEXj2c4WIQesDaCWXIsV5iDwL?=
 =?us-ascii?q?SaChS5M91RGprAL6yb1nIfTO9i0bspLj0t515+rImBE29Dx0Cdmd0m6XQ2F1mG?=
 =?us-ascii?q?MIWyE53KRlrUNhzVeD1LByg+ZEGtxL+/NJTgA6OIbGwOxhC9DyXQHBcs2TSFm8?=
 =?us-ascii?q?QNWrGjUxTtM3w98TbEdxAdSijhbf3yW0B78ZjaCEBJsx8qjExXj+O959y2ra1K?=
 =?us-ascii?q?kml1QmQdFANWu8iq579gjcHYjJk0qCmqaudKQc2jPN9WiZwWqPukFYTBB/UaHf?=
 =?us-ascii?q?UX8DYUvWqMzz5lneQL+2FbQnLgxBxNafJaRQdN3mk09KRPf5N9TYeGK+hWGwCR?=
 =?us-ascii?q?GMxrOPaYrqf34Q3CHcCEgCjgAS8myKNQk4Bie9vW3eCCZiGk7oY0Pp6eN+sm+0?=
 =?us-ascii?q?TlcozwGWaE1sz6e69QQLhfOCUf8T3qgLuCE6qzpqGlawxNbWC9uGpwp8c6RQe9?=
 =?us-ascii?q?I94FFb1W3HswxxJICvL6dnhlQGaQR4o1vu1wlrCoVHicUqsHIqzA91KaKE0FNA?=
 =?us-ascii?q?dymU3YzqNr3QMGny+BGva6jZ2lzF1NaW+6EP6Ok3qln5vQGpEFYi/Gtj09VPz3?=
 =?us-ascii?q?Sc4ZDKBhIIUZ3tSkY36wR6p7bCbyYn44Pby3JtPre0szPYwN0pGfYqxQymf9dc?=
 =?us-ascii?q?N6OEChT/E8kbB8ioNewrlEKlbhMCPOBO6qE0O9mqeOeB2K6uJOxghi6pjXxb4I?=
 =?us-ascii?q?Bh1UKB7yp9SvPS05kZ2f2Z3wuHWC36jFeuqc33nYFEZTcPHmuw0yTkBYhRZrFs?=
 =?us-ascii?q?coYPE2uhP8q3xtBmjZ73R3FY7EKjB08B2MKxYxqSbkDy0hdK1UsKpnyrgy24wC?=
 =?us-ascii?q?JukzEot6aQwDbBw+D/exUZIG5LQ29igEzoIYi1idAaQUepYxIolBuj+Ub12axb?=
 =?us-ascii?q?qL5jIGnUREdCZzL2IH16UqusqrqCZNZC6ZMpsSlNUOWwe0uaSqP7oxYB1yPjHm?=
 =?us-ascii?q?1exC00dj2wu5X5mQB6h3yZLHppsHXZfsRwzw/F5NPAXf5RwiYGRC5ghDnVHFe8?=
 =?us-ascii?q?Jdqp/daTl5vZqeCxTWGhVp5ScSnt04yAsjC25WlrAR25gvCylcfrEQk80S/nyd?=
 =?us-ascii?q?ZqUT/Eowr7Yonuz666K/5oflF0BF/g7Mp3AoF/nZE3hJ0K23gah5OV8GEDkWfy?=
 =?us-ascii?q?N9VbxK3/YGAMRT4N397a/gzl1Fd/IXKOwoLzTm+dzdd5Z9mmfmMW3Tow78NQB6?=
 =?us-ascii?q?eV9rBEnTZ1rUC+rQLeevV9mjYdyf0z6H8Vme0JuQwtzjmDDbAWB0VXISvslxGQ?=
 =?us-ascii?q?5dCksKpXfHqvcaS31EdmmNChDbKCrRtGVHf3ZJgiBjNw4dtlMF3XznLz8I7kdc?=
 =?us-ascii?q?LUbdISsB2UjhjBg/JUKJI3ivoFmy5nNXjhsn0izu4xlQZu0o2ivIibN2Vt+7q0?=
 =?us-ascii?q?AgJfNj3wfc8S+yvijaBDnsaNxICvH45sGjEKXJvuUPKpHygetfXhNwaSDjI8rm?=
 =?us-ascii?q?2XFqbYHQ+a8E1mtW7AE4i3N3GLI3kU1c5tSwOaJExbnQAYRjE6noMiGwCuxczh?=
 =?us-ascii?q?dlp55z8L6l75rBtM1vxnNx3lXmjDoweoby8+SIKDIxpO8gFC+0DVPNSc7u1pGi?=
 =?us-ascii?q?FX4IahoBaRKmCBZARIEGIJWlGCB1/5Jbmj/t3A8+meBuqjIPrCe7SOqepCV/iW?=
 =?us-ascii?q?wZKjyJdp/zGJNs+XJHltE+U72lZfXXB+A8nYmzIPSzEOlyLQdcGbog2w+jZwrs?=
 =?us-ascii?q?C5//TmQwbv5YqJC7tPPtRj4RG2gaGfN+GOgCZ1MypX1pQJxXXQ0rgQwEYSiz1y?=
 =?us-ascii?q?dzmqCbkAtTDCTKPTmq9UDh4XcSBzNNFP76IzwAZNI9Pbisju2758j/41DUpFVF?=
 =?us-ascii?q?P7lsGoY8wKP3+yNFfdCEmXM7SGICXBw9vrbqOkVb1QkOJUugWqtjaGCEDjJCqM?=
 =?us-ascii?q?ljnzWxCrMOFBlyWbPB1YuIGgfRdhE2njTNT6ahKlNN97lyE5wboxhnnSL24TLS?=
 =?us-ascii?q?B8c19Rrr2X9S5YnvR/G2lb4nV5N+WLhyaZ4PfeKpsNtftrAyJ0l/9V4XggyrtV?=
 =?us-ascii?q?6j1ES+JxmCfIstFupFSmmPGVyjV7SBpOtipLhIWTsERiI6rZ8JxAWXfC/B0V7G?=
 =?us-ascii?q?SQCw4Fp91qCtD0v6BQy97PlL/8KTtY8tLU+9ccCNbQKM6dLHUhNh/pS3boC14f?=
 =?us-ascii?q?SiW3OG3Dr0Nal/2X92bTqYI1+bb2n59bdrheHG48EO4BEUUtSM4LJopsRTIMkr?=
 =?us-ascii?q?OBisMMo32ko0+CF41hopnbW6fKUr3UIzGDgOweOhY=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AYAAAnWRlch0O0hNFjHQEBBQEHBQGBU?=
 =?us-ascii?q?QgBCwGBWoIRJ4wWX4scgWglFJdGgWwcGBMBhx0iNAkNAQMBAQEBAQECARMBAQE?=
 =?us-ascii?q?KCwkIKSMMgjYMgnsDAwECJBkBATcBBQkBAR8xA1QZBYJSS4IBBaY1gWwzgnYBA?=
 =?us-ascii?q?QWBAIYnCId+gyWBHBeBf4ERM4Ixiw6JRASGDH6QVAmGT4sRGJFXmXOBRoIOTTA?=
 =?us-ascii?q?IgyeCGwwXiF6FXiEyAYEDAQEBO40lAQE?=
X-IPAS-Result: =?us-ascii?q?A0AYAAAnWRlch0O0hNFjHQEBBQEHBQGBUQgBCwGBWoIRJ4w?=
 =?us-ascii?q?WX4scgWglFJdGgWwcGBMBhx0iNAkNAQMBAQEBAQECARMBAQEKCwkIKSMMgjYMg?=
 =?us-ascii?q?nsDAwECJBkBATcBBQkBAR8xA1QZBYJSS4IBBaY1gWwzgnYBAQWBAIYnCId+gyW?=
 =?us-ascii?q?BHBeBf4ERM4Ixiw6JRASGDH6QVAmGT4sRGJFXmXOBRoIOTTAIgyeCGwwXiF6FX?=
 =?us-ascii?q?iEyAYEDAQEBO40lAQE?=
X-IronPort-AV: E=Sophos;i="5.56,370,1539673200"; 
   d="scan'208";a="55699349"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 18 Dec 2018 12:34:58 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727626AbeLRUex (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Tue, 18 Dec 2018 15:34:53 -0500
Received: from mail.kernel.org ([198.145.29.99]:56258 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726638AbeLRUet (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 18 Dec 2018 15:34:49 -0500
Received: from localhost.localdomain (c-98-220-238-81.hsd1.il.comcast.net [98.220.238.81])
        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 36051218AC;
        Tue, 18 Dec 2018 20:34:47 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1545165288;
        bh=gvCYudXhM7Q8PF7TxxsDHvaqiDmW3vVF8oABL9PSGvE=;
        h=From:To:Cc:Subject:Date:In-Reply-To:References:In-Reply-To:
         References:From;
        b=WEr51PO8GEz+BCOPK9Kp85+f5GjB5x3Z1i2yF5lQPUofbWr8stgGf3yK1CQol/LF0
         AhBXx56KNTZpxs/LhzDxqgfGXWxd+dUIs9tWH2RT7XrxX49KeArMM+dQj5QYjalitL
         nQE0a9XBsllk0R+wZcbUeHtXIMvS3bEWIWTEEqEE=
From: Tom Zanussi <zanussi@kernel.org>
To: rostedt@goodmis.org
Cc: tglx@linutronix.de, mhiramat@kernel.org, namhyung@kernel.org,
        vedang.patel@intel.com, bigeasy@linutronix.de,
        joel@joelfernandes.org, mathieu.desnoyers@efficios.com,
        julia@ni.com, linux-kernel@vger.kernel.org,
        linux-rt-users@vger.kernel.org
Subject: [PATCH v9 04/15] tracing: Generalize hist trigger onmax and save action
Date: Tue, 18 Dec 2018 14:34:03 -0600
Message-Id: <fdbf1dc248cc11b6fafa555dda3e730b79a6e561.1545161056.git.tom.zanussi@linux.intel.com>
X-Mailer: git-send-email 2.14.1
In-Reply-To: <cover.1545161056.git.tom.zanussi@linux.intel.com>
References: <cover.1545161056.git.tom.zanussi@linux.intel.com>
In-Reply-To: <cover.1545161056.git.tom.zanussi@linux.intel.com>
References: <cover.1545161056.git.tom.zanussi@linux.intel.com>
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: Tom Zanussi <tom.zanussi@linux.intel.com>

The action refactor code allowed actions and handlers to be separated,
but the existing onmax handler and save action code is still not
flexible enough to handle arbitrary coupling.  This change generalizes
them and in the process makes additional handlers and actions easier
to implement.

The onmax action can be broken up and thought of as two separate
components - a variable to be tracked (the parameter given to the
onmax($var_to_track) function) and an invisible variable created to
save the ongoing result of doing something with that variable, such as
saving the max value of that variable so far seen.

Separating it out like this and renaming it appropriately allows us to
use the same code for similar tracking functions such as
onchange($var_to_track), which would just track the last value seen
rather than the max seen so far, which is useful in some situations.

Additionally, because different handlers and actions may want to save
and access data differently e.g. save and retrieve tracking values as
local variables vs something more global, save_val() and get_val()
interface functions are introduced and max-specific implementations
are used instead.

The same goes for the code that checks whether a maximum has been hit
- a generic check_val() interface and max-checking implementation is
used instead, which allows future patches to make use of he same code
using their own implemetations of similar functionality.

Signed-off-by: Tom Zanussi <tom.zanussi@linux.intel.com>
---
 kernel/trace/trace_events_hist.c | 257 +++++++++++++++++++++++++++------------
 1 file changed, 181 insertions(+), 76 deletions(-)

diff --git a/kernel/trace/trace_events_hist.c b/kernel/trace/trace_events_hist.c
index 8430f15bc7ad..519125dac153 100644
--- a/kernel/trace/trace_events_hist.c
+++ b/kernel/trace/trace_events_hist.c
@@ -386,6 +386,15 @@ typedef void (*action_fn_t) (struct hist_trigger_data *hist_data,
 			     struct ring_buffer_event *rbe,
 			     struct action_data *data, u64 *var_ref_vals);
 
+typedef bool (*check_track_val_fn_t) (u64 track_val, u64 var_val);
+typedef void (*save_track_val_fn_t) (struct hist_trigger_data *hist_data,
+				     struct tracing_map_elt *elt,
+				     struct action_data *data,
+				     unsigned int track_var_idx, u64 var_val);
+typedef u64 (*get_track_val_fn_t) (struct hist_trigger_data *hist_data,
+				   struct tracing_map_elt *elt,
+				   struct action_data *data);
+
 enum handler_id {
 	HANDLER_ONMATCH = 1,
 	HANDLER_ONMAX,
@@ -423,15 +432,37 @@ struct action_data {
 		} match_data;
 
 		struct {
+			/*
+			 * var_str contains the $-unstripped variable
+			 * name referenced by var_ref, and used when
+			 * printing the action.  Because var_ref
+			 * creation is deferred to create_actions(),
+			 * we need a per-action way to save it until
+			 * then, thus var_str.
+			 */
 			char			*var_str;
-			unsigned int		max_var_ref_idx;
-			struct hist_field	*max_var;
-			struct hist_field	*var;
-		} onmax;
+
+			/*
+			 * var_ref refers to the variable being
+			 * tracked e.g onmax($var).
+			 */
+			struct hist_field	*var_ref;
+
+			/*
+			 * track_var contains the 'invisible' tracking
+			 * variable created to keep the current
+			 * e.g. max value.
+			 */
+			struct hist_field	*track_var;
+
+			check_track_val_fn_t	check_val;
+			save_track_val_fn_t	save_val;
+			action_fn_t		save_data;
+			get_track_val_fn_t	get_val;
+		} track_data;
 	};
 };
 
-
 static char last_hist_cmd[MAX_FILTER_STR_VAL];
 static char hist_err_str[MAX_FILTER_STR_VAL];
 
@@ -3241,10 +3272,10 @@ static void update_field_vars(struct hist_trigger_data *hist_data,
 			    hist_data->n_field_vars, 0);
 }
 
-static void update_max_vars(struct hist_trigger_data *hist_data,
-			    struct tracing_map_elt *elt,
-			    struct ring_buffer_event *rbe,
-			    void *rec)
+static void save_track_data_vars(struct hist_trigger_data *hist_data,
+				 struct tracing_map_elt *elt, void *rec,
+				 struct ring_buffer_event *rbe,
+				 struct action_data *data, u64 *var_ref_vals)
 {
 	__update_field_vars(elt, rbe, rec, hist_data->save_vars,
 			    hist_data->n_save_vars, hist_data->n_field_var_str);
@@ -3382,14 +3413,73 @@ create_target_field_var(struct hist_trigger_data *target_hist_data,
 	return create_field_var(target_hist_data, file, var_name);
 }
 
-static void onmax_print(struct seq_file *m,
-			struct hist_trigger_data *hist_data,
-			struct tracing_map_elt *elt,
-			struct action_data *data)
+static bool check_track_val_max(u64 track_val, u64 var_val)
+{
+	if (var_val <= track_val)
+		return false;
+
+	return true;
+}
+
+static u64 get_track_val_local(struct hist_trigger_data *hist_data,
+			       struct tracing_map_elt *elt,
+			       struct action_data *data)
+{
+	unsigned int track_var_idx = data->track_data.track_var->var.idx;
+	u64 track_val;
+
+	track_val = tracing_map_read_var(elt, track_var_idx);
+
+	return track_val;
+}
+
+static void save_track_val_local(struct hist_trigger_data *hist_data,
+				 struct tracing_map_elt *elt,
+				 struct action_data *data,
+				 unsigned int track_var_idx, u64 var_val)
+{
+	tracing_map_set_var(elt, track_var_idx, var_val);
+}
+
+static void save_track_val(struct hist_trigger_data *hist_data,
+			   struct tracing_map_elt *elt,
+			   struct action_data *data,
+			   u64 var_val)
+{
+	unsigned int track_var_idx = data->track_data.track_var->var.idx;
+
+	data->track_data.save_val(hist_data, elt, data, track_var_idx, var_val);
+}
+
+static void save_track_data(struct hist_trigger_data *hist_data,
+			    struct tracing_map_elt *elt, void *rec,
+			    struct ring_buffer_event *rbe,
+			    struct action_data *data, u64 *var_ref_vals)
+{
+	if (data->track_data.save_data)
+		data->track_data.save_data(hist_data, elt, rec, rbe, data, var_ref_vals);
+}
+
+static bool check_track_val(struct tracing_map_elt *elt,
+			    struct action_data *data,
+			    u64 var_val)
 {
-	unsigned int i, save_var_idx, max_idx = data->onmax.max_var->var.idx;
+	unsigned int track_var_idx = data->track_data.track_var->var.idx;
+	u64 track_val = tracing_map_read_var(elt, track_var_idx);
 
-	seq_printf(m, "\n\tmax: %10llu", tracing_map_read_var(elt, max_idx));
+	return data->track_data.check_val(track_val, var_val);
+}
+
+static void track_data_print(struct seq_file *m,
+			     struct hist_trigger_data *hist_data,
+			     struct tracing_map_elt *elt,
+			     struct action_data *data)
+{
+	u64 track_val = data->track_data.get_val(hist_data, elt, data);
+	unsigned int i, save_var_idx;
+
+	if (data->handler == HANDLER_ONMAX)
+		seq_printf(m, "\n\tmax: %10llu", track_val);
 
 	for (i = 0; i < hist_data->n_save_vars; i++) {
 		struct hist_field *save_val = hist_data->save_vars[i]->val;
@@ -3408,25 +3498,17 @@ static void onmax_print(struct seq_file *m,
 	}
 }
 
-static void onmax_save(struct hist_trigger_data *hist_data,
-		       struct tracing_map_elt *elt, void *rec,
-		       struct ring_buffer_event *rbe,
-		       struct action_data *data, u64 *var_ref_vals)
+static void ontrack_action(struct hist_trigger_data *hist_data,
+			   struct tracing_map_elt *elt, void *rec,
+			   struct ring_buffer_event *rbe,
+			   struct action_data *data, u64 *var_ref_vals)
 {
-	unsigned int max_idx = data->onmax.max_var->var.idx;
-	unsigned int max_var_ref_idx = data->onmax.max_var_ref_idx;
+	u64 var_val = var_ref_vals[data->track_data.var_ref->var_ref_idx];
 
-	u64 var_val, max_val;
-
-	var_val = var_ref_vals[max_var_ref_idx];
-	max_val = tracing_map_read_var(elt, max_idx);
-
-	if (var_val <= max_val)
-		return;
-
-	tracing_map_set_var(elt, max_idx, var_val);
-
-	update_max_vars(hist_data, elt, rbe, rec);
+	if (check_track_val(elt, data, var_val)) {
+		save_track_val(hist_data, elt, data, var_val);
+		save_track_data(hist_data, elt, rec, rbe, data, var_ref_vals);
+	}
 }
 
 static void action_data_destroy(struct action_data *data)
@@ -3446,12 +3528,13 @@ static void action_data_destroy(struct action_data *data)
 	kfree(data);
 }
 
-static void onmax_destroy(struct action_data *data)
+static void track_data_destroy(struct hist_trigger_data *hist_data,
+			       struct action_data *data)
 {
-	destroy_hist_field(data->onmax.max_var, 0);
-	destroy_hist_field(data->onmax.var, 0);
+	destroy_hist_field(data->track_data.track_var, 0);
+	destroy_hist_field(data->track_data.var_ref, 0);
 
-	kfree(data->onmax.var_str);
+	kfree(data->track_data.var_str);
 
 	action_data_destroy(data);
 }
@@ -3459,25 +3542,24 @@ static void onmax_destroy(struct action_data *data)
 static int action_create(struct hist_trigger_data *hist_data,
 			 struct action_data *data);
 
-static int onmax_create(struct hist_trigger_data *hist_data,
-			struct action_data *data)
+static int track_data_create(struct hist_trigger_data *hist_data,
+			     struct action_data *data)
 {
-	struct hist_field *var_field, *ref_field, *max_var = NULL;
+	struct hist_field *var_field, *ref_field, *track_var = NULL;
 	struct trace_event_file *file = hist_data->event_file;
-	unsigned int var_ref_idx = hist_data->n_var_refs;
-	char *onmax_var_str;
+	char *track_data_var_str;
 	int ret = 0;
 
-	onmax_var_str = data->onmax.var_str;
-	if (onmax_var_str[0] != '$') {
-		hist_err("onmax: For onmax(x), x must be a variable: ", onmax_var_str);
+	track_data_var_str = data->track_data.var_str;
+	if (track_data_var_str[0] != '$') {
+		hist_err("For onmax(x), x must be a variable: ", track_data_var_str);
 		return -EINVAL;
 	}
-	onmax_var_str++;
+	track_data_var_str++;
 
-	var_field = find_target_event_var(hist_data, NULL, NULL, onmax_var_str);
+	var_field = find_target_event_var(hist_data, NULL, NULL, track_data_var_str);
 	if (!var_field) {
-		hist_err("onmax: Couldn't find onmax variable: ", onmax_var_str);
+		hist_err("Couldn't find onmax variable: ", track_data_var_str);
 		return -EINVAL;
 	}
 
@@ -3485,17 +3567,16 @@ static int onmax_create(struct hist_trigger_data *hist_data,
 	if (!ref_field)
 		return -ENOMEM;
 
-	data->onmax.var = ref_field;
-
-	data->onmax.max_var_ref_idx = var_ref_idx;
+	data->track_data.var_ref = ref_field;
 
-	max_var = create_var(hist_data, file, "max", sizeof(u64), "u64");
-	if (IS_ERR(max_var)) {
-		hist_err("onmax: Couldn't create onmax variable: ", "max");
-		ret = PTR_ERR(max_var);
+	if (data->handler == HANDLER_ONMAX)
+		track_var = create_var(hist_data, file, "__max", sizeof(u64), "u64");
+	if (IS_ERR(track_var)) {
+		hist_err("Couldn't create onmax variable: ", "__max");
+		ret = PTR_ERR(track_var);
 		goto out;
 	}
-	data->onmax.max_var = max_var;
+	data->track_data.track_var = track_var;
 
 	ret = action_create(hist_data, data);
  out:
@@ -3573,7 +3654,18 @@ static int action_parse(char *str, struct action_data *data,
 			goto out;
 
 		if (handler == HANDLER_ONMAX)
-			data->fn = onmax_save;
+			data->track_data.check_val = check_track_val_max;
+		else {
+			hist_err("action parsing: Handler doesn't support action: ", action_name);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		data->track_data.save_val = save_track_val_local;
+		data->track_data.get_val = get_track_val_local;
+		data->track_data.save_data = save_track_data_vars;
+
+		data->fn = ontrack_action;
 
 		data->action = ACTION_SAVE;
 	} else {
@@ -3585,7 +3677,17 @@ static int action_parse(char *str, struct action_data *data,
 				goto out;
 		}
 
-		data->fn = action_trace;
+		if (handler == HANDLER_ONMAX)
+			data->track_data.check_val = check_track_val_max;
+
+		if (handler != HANDLER_ONMATCH) {
+			data->track_data.save_val = save_track_val_local;
+			data->track_data.get_val = get_track_val_local;
+			data->track_data.save_data = action_trace;
+			data->fn = ontrack_action;
+		} else
+			data->fn = action_trace;
+
 		data->action = ACTION_TRACE;
 	}
 
@@ -3600,24 +3702,25 @@ static int action_parse(char *str, struct action_data *data,
 	return ret;
 }
 
-static struct action_data *onmax_parse(char *str, enum handler_id handler)
+static struct action_data *track_data_parse(struct hist_trigger_data *hist_data,
+					    char *str, enum handler_id handler)
 {
 	struct action_data *data;
-	char *onmax_var_str;
 	int ret = -EINVAL;
+	char *var_str;
 
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return ERR_PTR(-ENOMEM);
 
-	onmax_var_str = strsep(&str, ")");
-	if (!onmax_var_str || !str) {
+	var_str = strsep(&str, ")");
+	if (!var_str || !str) {
 		ret = -EINVAL;
 		goto free;
 	}
 
-	data->onmax.var_str = kstrdup(onmax_var_str, GFP_KERNEL);
-	if (!data->onmax.var_str) {
+	data->track_data.var_str = kstrdup(var_str, GFP_KERNEL);
+	if (!data->track_data.var_str) {
 		ret = -ENOMEM;
 		goto free;
 	}
@@ -3628,7 +3731,7 @@ static struct action_data *onmax_parse(char *str, enum handler_id handler)
  out:
 	return data;
  free:
-	onmax_destroy(data);
+	track_data_destroy(hist_data, data);
 	data = ERR_PTR(ret);
 	goto out;
 }
@@ -4392,7 +4495,7 @@ static void destroy_actions(struct hist_trigger_data *hist_data)
 		if (data->handler == HANDLER_ONMATCH)
 			onmatch_destroy(data);
 		else if (data->handler == HANDLER_ONMAX)
-			onmax_destroy(data);
+			track_data_destroy(hist_data, data);
 		else
 			kfree(data);
 	}
@@ -4420,7 +4523,8 @@ static int parse_actions(struct hist_trigger_data *hist_data)
 		} else if (strncmp(str, "onmax(", sizeof("onmax(") - 1) == 0) {
 			char *action_str = str + sizeof("onmax(") - 1;
 
-			data = onmax_parse(action_str, HANDLER_ONMAX);
+			data = track_data_parse(hist_data, action_str,
+						HANDLER_ONMAX);
 			if (IS_ERR(data)) {
 				ret = PTR_ERR(data);
 				break;
@@ -4450,7 +4554,7 @@ static int create_actions(struct hist_trigger_data *hist_data)
 			if (ret)
 				break;
 		} else if (data->handler == HANDLER_ONMAX) {
-			ret = onmax_create(hist_data, data);
+			ret = track_data_create(hist_data, data);
 			if (ret)
 				break;
 		} else {
@@ -4472,7 +4576,7 @@ static void print_actions(struct seq_file *m,
 		struct action_data *data = hist_data->actions[i];
 
 		if (data->handler == HANDLER_ONMAX)
-			onmax_print(m, hist_data, elt, data);
+			track_data_print(m, hist_data, elt, data);
 	}
 }
 
@@ -4497,12 +4601,13 @@ static void print_action_spec(struct seq_file *m,
 	}
 }
 
-static void print_onmax_spec(struct seq_file *m,
-			     struct hist_trigger_data *hist_data,
-			     struct action_data *data)
+static void print_track_data_spec(struct seq_file *m,
+				  struct hist_trigger_data *hist_data,
+				  struct action_data *data)
 {
-	seq_puts(m, ":onmax(");
-	seq_printf(m, "%s", data->onmax.var_str);
+	if (data->handler == HANDLER_ONMAX)
+		seq_puts(m, ":onmax(");
+	seq_printf(m, "%s", data->track_data.var_str);
 	seq_printf(m, ").%s(", data->action_name);
 
 	print_action_spec(m, hist_data, data);
@@ -4560,8 +4665,8 @@ static bool actions_match(struct hist_trigger_data *hist_data,
 				   data_test->match_data.event) != 0)
 				return false;
 		} else if (data->handler == HANDLER_ONMAX) {
-			if (strcmp(data->onmax.var_str,
-				   data_test->onmax.var_str) != 0)
+			if (strcmp(data->track_data.var_str,
+				   data_test->track_data.var_str) != 0)
 				return false;
 		}
 	}
@@ -4581,7 +4686,7 @@ static void print_actions_spec(struct seq_file *m,
 		if (data->handler == HANDLER_ONMATCH)
 			print_onmatch_spec(m, hist_data, data);
 		else if (data->handler == HANDLER_ONMAX)
-			print_onmax_spec(m, hist_data, data);
+			print_track_data_spec(m, hist_data, data);
 	}
 }
 
-- 
2.14.1

