Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 22:12:31 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id A84A1580478
	for <like.xu@linux.intel.com>; Sat, 24 Nov 2018 23:35:15 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by fmsmga006-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 24 Nov 2018 23:35:15 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3ALeqDkx99kwpXBf9uRHKM819IXTAuvvDOBiVQ1KB+?=
 =?us-ascii?q?0+kQIJqq85mqBkHD//Il1AaPAd2Lraocw8Pt8InYEVQa5piAtH1QOLdtbDQizf?=
 =?us-ascii?q?ssogo7HcSeAlf6JvO5JwYzHcBFSUM3tyrjaRsdF8nxfUDdrWOv5jAOBBr/KRB1?=
 =?us-ascii?q?JuPoEYLOksi7ze+/94HQbglSmDaxfa55IQmrownWqsQYm5ZpJLwryhvOrHtIeu?=
 =?us-ascii?q?BWyn1tKFmOgRvy5dq+8YB6/ShItP0v68BPUaPhf6QlVrNYFygpM3o05MLwqxbO?=
 =?us-ascii?q?SxaE62YGXWUXlhpIBBXF7A3/U5zsvCb2qvZx1S+HNsDtU7s6RSqt4LtqSB/wiS?=
 =?us-ascii?q?cIKTg58H3MisdtiK5XuQ+tqwBjz4LRZoyeKfhwcb7Hfd4CS2RPXthfWS9PAoyz?=
 =?us-ascii?q?c4QAEugOMuhFoYnlpVYArxSzCRSiCe/z1DBInWT73bEm3+k7DQ3KwBYtE8wIvX?=
 =?us-ascii?q?/JrNv1LqASUeWtwabK0DXDcelZ2TPg44bVchAuu/CMUqhtesfWyUgvCh3FgU+U?=
 =?us-ascii?q?qYD/JDOV1v4Cs2mB4Od7UuKvkXQopB11ojex3Msjlo7JhocMx13C6C53zoE1Jd?=
 =?us-ascii?q?iiR056Z96pCJpQtyeUN4t3RMMiQnpntzw8yrIbpZ60ZjIGyJM9xx7QbfGMbouG?=
 =?us-ascii?q?4gr7WeqPPTt1h2hpdK+iixux60Ss1OPxW8mu3FpXrCdJisTAu38Q2xDJ98SKRf?=
 =?us-ascii?q?pw8l281TqS1g3f8ONJLEYpnqTBMZEh2KQ/lp8LvETDACD2nEL2gbeSdkUl4eio?=
 =?us-ascii?q?9//nbq/ppp+aKo94kAb+Mr4hmsCnAOQ4NBYBX3SD9OiiyLHu/lf1TKhXgvA1iK?=
 =?us-ascii?q?XVrp7XKMQBqqKkAQJZyoMj5Ay+Dzei3tQYh34HLFdddRKekYfpPkzOLOnlAvih?=
 =?us-ascii?q?nVSjjjNry+ndMb3mH5XNKGTMn6n6fbp6705cyQkzws5F65NbF7EMOPbzWk73tN?=
 =?us-ascii?q?zFAR41KQ20w+D7CNpj0oMSQ36AAqicMK7Jt1+I4eQvI+aKZI8Iojr9LOIl5/H2?=
 =?us-ascii?q?gX8jhVAdZbWp3YcQaH2gGvRmIkaZbmT2jtYODGcHpQ4+TO3siF2fXj9ffXeyX6?=
 =?us-ascii?q?Qg5j4lDIKqF5vMRoeogO/J4SGgA5cDZnxaEkveVjDsdp6YQLEKbySdJNInlSYL?=
 =?us-ascii?q?Er2oSosk3Bfpsxfmyr1hNa3N9ygF8J7uytVxtNDVjgw4oDl9DsCB1DOUQmRp22?=
 =?us-ascii?q?8FWTIymbpyuFFw0Uur169+jPpFU9tJ6KRSTw04OJXAmvF8EM34QQnbf92EG2qh?=
 =?us-ascii?q?F/CvGzo8SpoY29EDZ0x0BtDq2hXKxSGnB/kcj7KGAJY976f00H34JsI7wHHDgv?=
 =?us-ascii?q?oPlV4jF/pSK2SizpV//gnaT9rYjluQk+Cxda0d1QbK7m6IyWfIt0ZdBl0jGZ7Z?=
 =?us-ascii?q?VGwSMxOF5e/y4VnPGvr3Uewq?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAADfT/pbhxHrdtBhGQEBAQEBAQEBA?=
 =?us-ascii?q?QEBAQcBAQEBAQGBUQQBAQEBAQsBgTAqgQ+BKYwRX4sggg2JDIUJiSeBbxYBARg?=
 =?us-ascii?q?LCYhaIjQJDQEDAQEBAQEBAgETAQEBCgsJCBsOIwyCNgUCAxoBBoJcAQIDAQIkE?=
 =?us-ascii?q?wYBAQQKKQECAwECBgEBChIGCR0IAwELBQ0oFBMFgxwBgWkDFQEDAQqkFxEzgWw?=
 =?us-ascii?q?zgnYBAQWEdQ2CEQMFjAmBVz+BEYMSglaFXYImlTiJdycuBwKCHASLZIMgIwqBT?=
 =?us-ascii?q?4ULiiSOTYk8AgQCBAUCEwGBRoINMxoEH1CCbIIbCQMXfwEHgkOFFIVAcIEHinS?=
 =?us-ascii?q?BdwEB?=
X-IPAS-Result: =?us-ascii?q?A0ABAADfT/pbhxHrdtBhGQEBAQEBAQEBAQEBAQcBAQEBAQG?=
 =?us-ascii?q?BUQQBAQEBAQsBgTAqgQ+BKYwRX4sggg2JDIUJiSeBbxYBARgLCYhaIjQJDQEDA?=
 =?us-ascii?q?QEBAQEBAgETAQEBCgsJCBsOIwyCNgUCAxoBBoJcAQIDAQIkEwYBAQQKKQECAwE?=
 =?us-ascii?q?CBgEBChIGCR0IAwELBQ0oFBMFgxwBgWkDFQEDAQqkFxEzgWwzgnYBAQWEdQ2CE?=
 =?us-ascii?q?QMFjAmBVz+BEYMSglaFXYImlTiJdycuBwKCHASLZIMgIwqBT4ULiiSOTYk8AgQ?=
 =?us-ascii?q?CBAUCEwGBRoINMxoEH1CCbIIbCQMXfwEHgkOFFIVAcIEHinSBdwEB?=
X-IronPort-AV: E=Sophos;i="5.56,277,1539673200"; 
   d="scan'208";a="42119012"
X-Amp-Result: UNSCANNABLE
X-Amp-File-Uploaded: False
Unscannable: 2
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 24 Nov 2018 23:35:13 -0800
Received: from localhost ([::1]:58971 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQowj-0001We-Hq
	for like.xu@linux.intel.com; Sun, 25 Nov 2018 02:35:13 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:45555)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <yuval.shaia@oracle.com>) id 1gQowK-0001WY-5n
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 02:34:49 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <yuval.shaia@oracle.com>) id 1gQowG-0002ey-VK
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 02:34:48 -0500
Received: from userp2130.oracle.com ([156.151.31.86]:36236)
	by eggs.gnu.org with esmtps (TLS1.0:RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <yuval.shaia@oracle.com>)
	id 1gQowG-0002dx-LU
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 02:34:44 -0500
Received: from pps.filterd (userp2130.oracle.com [127.0.0.1])
	by userp2130.oracle.com (8.16.0.22/8.16.0.22) with SMTP id
	wAP6sbfw001426; Sun, 25 Nov 2018 07:34:41 GMT
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=oracle.com;
	h=date : from : to : cc
	: subject : message-id : references : mime-version : content-type :
	in-reply-to; s=corp-2018-07-02;
	bh=4GX73yjHCAmWD399hdDd7wC8JvBW5oY5tWc0ndQsPFk=;
	b=vgj2LNNoJ+M28yUfWlKDw1BafBc7MssjDGg3+RgLenyqOE11mU9gSMN5Aq3y620kjkD5
	i5jN2px/2WBgUvCSFznH8odnOE5mPpXeVmmEfFk7YXwCEJtiaGkSy6gZeZB+OHF/bLmE
	8ido41+Gq2BLr4+vvLePO8oNVhEObqABWT6fInDusQ7sxRAJwg0Yz48Daj+n/hP/nhF7
	L13KMLLD4eNtPtji1ra8nQTESyB18i9+zezuyAe2wyPSj3OLwH81mAvHNHVMwv4Di0Sz
	nSzMok7dYMgVi2AIQ0pMjI7sM8VXDp0X/cPi7gxlSfyXU2sEy3Pc6yk6XCceLItUhrrB
	cw== 
Received: from userv0021.oracle.com (userv0021.oracle.com [156.151.31.71])
	by userp2130.oracle.com with ESMTP id 2nxx2tsut2-1
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256 verify=OK);
	Sun, 25 Nov 2018 07:34:40 +0000
Received: from aserv0121.oracle.com (aserv0121.oracle.com [141.146.126.235])
	by userv0021.oracle.com (8.14.4/8.14.4) with ESMTP id wAP7YdRt011151
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256
	verify=OK); Sun, 25 Nov 2018 07:34:40 GMT
Received: from abhmp0001.oracle.com (abhmp0001.oracle.com [141.146.116.7])
	by aserv0121.oracle.com (8.14.4/8.13.8) with ESMTP id wAP7YdL7013238;
	Sun, 25 Nov 2018 07:34:39 GMT
Received: from lap1 (/77.138.186.148) by default (Oracle Beehive Gateway v4.0)
	with ESMTP ; Sat, 24 Nov 2018 23:27:29 -0800
Date: Sun, 25 Nov 2018 09:27:24 +0200
From: Yuval Shaia <yuval.shaia@oracle.com>
To: Marcel Apfelbaum <marcel.apfelbaum@gmail.com>
Message-ID: <20181125072723.GA2770@lap1>
References: <20181122121402.13764-1-yuval.shaia@oracle.com>
	<20181122121402.13764-6-yuval.shaia@oracle.com>
	<59e73ac7-baff-f3f7-bd67-5c4ebc8c9bc7@gmail.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <59e73ac7-baff-f3f7-bd67-5c4ebc8c9bc7@gmail.com>
User-Agent: Mutt/1.10.1 (2018-07-13)
X-Proofpoint-Virus-Version: vendor=nai engine=5900 definitions=9087
	signatures=668685
X-Proofpoint-Spam-Details: rule=notspam policy=default score=0 suspectscore=0
	malwarescore=0
	phishscore=0 bulkscore=0 spamscore=0 mlxscore=0 mlxlogscore=999
	adultscore=0 classifier=spam adjust=0 reason=mlx scancount=1
	engine=8.0.1-1810050000 definitions=main-1811250066
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 3.x [generic] [fuzzy]
X-Received-From: 156.151.31.86
Subject: Re: [Qemu-devel] [PATCH v5 05/24] hw/rdma: Add support for MAD
 packets
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: dmitry.fleytman@gmail.com, shamir.rabinovitch@oracle.com,
	jasowang@redhat.com, cohuck@redhat.com, armbru@redhat.com,
	yuval.shaia@oracle.com, qemu-devel@nongnu.org, pbonzini@redhat.com
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On Sun, Nov 25, 2018 at 09:05:17AM +0200, Marcel Apfelbaum wrote:
> 
> 
> On 11/22/18 2:13 PM, Yuval Shaia wrote:
> > MAD (Management Datagram) packets are widely used by various modules
> > both in kernel and in user space for example the rdma_* API which is
> > used to create and maintain "connection" layer on top of RDMA uses
> > several types of MAD packets.
> > 
> > For more information please refer to chapter 13.4 in Volume 1
> > Architecture Specification, Release 1.1 available here:
> > https://www.infinibandta.org/ibta-specifications-download/
> > 
> > To support MAD packets the device uses an external utility
> > (contrib/rdmacm-mux) to relay packets from and to the guest driver.
> > 
> > Signed-off-by: Yuval Shaia <yuval.shaia@oracle.com>
> > ---
> >   hw/rdma/rdma_backend.c      | 275 +++++++++++++++++++++++++++++++++++-
> >   hw/rdma/rdma_backend.h      |   4 +-
> >   hw/rdma/rdma_backend_defs.h |  10 +-
> >   hw/rdma/vmw/pvrdma.h        |   2 +
> >   hw/rdma/vmw/pvrdma_main.c   |   4 +-
> >   5 files changed, 285 insertions(+), 10 deletions(-)
> > 
> > diff --git a/hw/rdma/rdma_backend.c b/hw/rdma/rdma_backend.c
> > index 1e148398a2..7c220a5798 100644
> > --- a/hw/rdma/rdma_backend.c
> > +++ b/hw/rdma/rdma_backend.c
> > @@ -16,8 +16,13 @@
> >   #include "qemu/osdep.h"
> >   #include "qemu/error-report.h"
> >   #include "qapi/error.h"
> > +#include "qapi/qmp/qlist.h"
> > +#include "qapi/qmp/qnum.h"
> >   #include <infiniband/verbs.h>
> > +#include <infiniband/umad_types.h>
> > +#include <infiniband/umad.h>
> > +#include <rdma/rdma_user_cm.h>
> >   #include "trace.h"
> >   #include "rdma_utils.h"
> > @@ -33,16 +38,25 @@
> >   #define VENDOR_ERR_MAD_SEND         0x206
> >   #define VENDOR_ERR_INVLKEY          0x207
> >   #define VENDOR_ERR_MR_SMALL         0x208
> > +#define VENDOR_ERR_INV_MAD_BUFF     0x209
> > +#define VENDOR_ERR_INV_NUM_SGE      0x210
> >   #define THR_NAME_LEN 16
> >   #define THR_POLL_TO  5000
> > +#define MAD_HDR_SIZE sizeof(struct ibv_grh)
> > +
> >   typedef struct BackendCtx {
> > -    uint64_t req_id;
> >       void *up_ctx;
> >       bool is_tx_req;
> > +    struct ibv_sge sge; /* Used to save MAD recv buffer */
> >   } BackendCtx;
> > +struct backend_umad {
> > +    struct ib_user_mad hdr;
> > +    char mad[RDMA_MAX_PRIVATE_DATA];
> > +};
> > +
> >   static void (*comp_handler)(int status, unsigned int vendor_err, void *ctx);
> >   static void dummy_comp_handler(int status, unsigned int vendor_err, void *ctx)
> > @@ -286,6 +300,61 @@ static int build_host_sge_array(RdmaDeviceResources *rdma_dev_res,
> >       return 0;
> >   }
> > +static int mad_send(RdmaBackendDev *backend_dev, struct ibv_sge *sge,
> > +                    uint32_t num_sge)
> > +{
> > +    struct backend_umad umad = {0};
> > +    char *hdr, *msg;
> > +    int ret;
> > +
> > +    pr_dbg("num_sge=%d\n", num_sge);
> > +
> > +    if (num_sge != 2) {
> > +        return -EINVAL;
> > +    }
> > +
> > +    umad.hdr.length = sge[0].length + sge[1].length;
> > +    pr_dbg("msg_len=%d\n", umad.hdr.length);
> > +
> > +    if (umad.hdr.length > sizeof(umad.mad)) {
> > +        return -ENOMEM;
> > +    }
> > +
> > +    umad.hdr.addr.qpn = htobe32(1);
> > +    umad.hdr.addr.grh_present = 1;
> > +    umad.hdr.addr.gid_index = backend_dev->backend_gid_idx;
> > +    memcpy(umad.hdr.addr.gid, backend_dev->gid.raw, sizeof(umad.hdr.addr.gid));
> > +    umad.hdr.addr.hop_limit = 1;
> > +
> > +    hdr = rdma_pci_dma_map(backend_dev->dev, sge[0].addr, sge[0].length);
> > +    if (!hdr) {
> > +        pr_dbg("Fail to map to sge[0]\n");
> > +        return -ENOMEM;
> > +    }
> > +    msg = rdma_pci_dma_map(backend_dev->dev, sge[1].addr, sge[1].length);
> > +    if (!msg) {
> > +        pr_dbg("Fail to map to sge[1]\n");
> > +        rdma_pci_dma_unmap(backend_dev->dev, hdr, sge[0].length);
> > +        return -ENOMEM;
> > +    }
> > +
> > +    pr_dbg_buf("mad_hdr", hdr, sge[0].length);
> > +    pr_dbg_buf("mad_data", data, sge[1].length);
> > +
> > +    memcpy(&umad.mad[0], hdr, sge[0].length);
> > +    memcpy(&umad.mad[sge[0].length], msg, sge[1].length);
> > +
> > +    rdma_pci_dma_unmap(backend_dev->dev, msg, sge[1].length);
> > +    rdma_pci_dma_unmap(backend_dev->dev, hdr, sge[0].length);
> > +
> > +    ret = qemu_chr_fe_write(backend_dev->mad_chr_be, (const uint8_t *)&umad,
> > +                            sizeof(umad));
> > +
> > +    pr_dbg("qemu_chr_fe_write=%d\n", ret);
> > +
> > +    return (ret != sizeof(umad));
> > +}
> > +
> >   void rdma_backend_post_send(RdmaBackendDev *backend_dev,
> >                               RdmaBackendQP *qp, uint8_t qp_type,
> >                               struct ibv_sge *sge, uint32_t num_sge,
> > @@ -304,9 +373,13 @@ void rdma_backend_post_send(RdmaBackendDev *backend_dev,
> >               comp_handler(IBV_WC_GENERAL_ERR, VENDOR_ERR_QP0, ctx);
> >           } else if (qp_type == IBV_QPT_GSI) {
> >               pr_dbg("QP1\n");
> > -            comp_handler(IBV_WC_GENERAL_ERR, VENDOR_ERR_MAD_SEND, ctx);
> > +            rc = mad_send(backend_dev, sge, num_sge);
> > +            if (rc) {
> > +                comp_handler(IBV_WC_GENERAL_ERR, VENDOR_ERR_MAD_SEND, ctx);
> > +            } else {
> > +                comp_handler(IBV_WC_SUCCESS, 0, ctx);
> > +            }
> >           }
> > -        pr_dbg("qp->ibqp is NULL for qp_type %d!!!\n", qp_type);
> >           return;
> >       }
> > @@ -370,6 +443,48 @@ out_free_bctx:
> >       g_free(bctx);
> >   }
> > +static unsigned int save_mad_recv_buffer(RdmaBackendDev *backend_dev,
> > +                                         struct ibv_sge *sge, uint32_t num_sge,
> > +                                         void *ctx)
> > +{
> > +    BackendCtx *bctx;
> > +    int rc;
> > +    uint32_t bctx_id;
> > +
> > +    if (num_sge != 1) {
> > +        pr_dbg("Invalid num_sge (%d), expecting 1\n", num_sge);
> 
> Maybe not for this patch set, but please consider using
> QEMU error report facilities for errors instead of debug messages
> when necessary.
> 
> The same about using traces on normal flow instead pr_dbg,
> but this has a lower priority than error reporting.

Sure, this is next on my plate.

> 
> > +        return VENDOR_ERR_INV_NUM_SGE;
> > +    }
> > +
> > +    if (sge[0].length < RDMA_MAX_PRIVATE_DATA + sizeof(struct ibv_grh)) {
> > +        pr_dbg("Too small buffer for MAD\n");
> > +        return VENDOR_ERR_INV_MAD_BUFF;
> > +    }
> > +
> > +    pr_dbg("addr=0x%" PRIx64"\n", sge[0].addr);
> > +    pr_dbg("length=%d\n", sge[0].length);
> > +    pr_dbg("lkey=%d\n", sge[0].lkey);
> > +
> > +    bctx = g_malloc0(sizeof(*bctx));
> > +
> > +    rc = rdma_rm_alloc_cqe_ctx(backend_dev->rdma_dev_res, &bctx_id, bctx);
> > +    if (unlikely(rc)) {
> > +        g_free(bctx);
> > +        pr_dbg("Fail to allocate cqe_ctx\n");
> > +        return VENDOR_ERR_NOMEM;
> > +    }
> > +
> > +    pr_dbg("bctx_id %d, bctx %p, ctx %p\n", bctx_id, bctx, ctx);
> > +    bctx->up_ctx = ctx;
> > +    bctx->sge = *sge;
> > +
> > +    qemu_mutex_lock(&backend_dev->recv_mads_list.lock);
> > +    qlist_append_int(backend_dev->recv_mads_list.list, bctx_id);
> > +    qemu_mutex_unlock(&backend_dev->recv_mads_list.lock);
> > +
> > +    return 0;
> > +}
> > +
> >   void rdma_backend_post_recv(RdmaBackendDev *backend_dev,
> >                               RdmaDeviceResources *rdma_dev_res,
> >                               RdmaBackendQP *qp, uint8_t qp_type,
> > @@ -388,7 +503,10 @@ void rdma_backend_post_recv(RdmaBackendDev *backend_dev,
> >           }
> >           if (qp_type == IBV_QPT_GSI) {
> >               pr_dbg("QP1\n");
> > -            comp_handler(IBV_WC_GENERAL_ERR, VENDOR_ERR_MAD_SEND, ctx);
> > +            rc = save_mad_recv_buffer(backend_dev, sge, num_sge, ctx);
> > +            if (rc) {
> > +                comp_handler(IBV_WC_GENERAL_ERR, rc, ctx);
> > +            }
> >           }
> >           return;
> >       }
> > @@ -517,7 +635,6 @@ int rdma_backend_create_qp(RdmaBackendQP *qp, uint8_t qp_type,
> >       switch (qp_type) {
> >       case IBV_QPT_GSI:
> > -        pr_dbg("QP1 unsupported\n");
> >           return 0;
> >       case IBV_QPT_RC:
> > @@ -748,11 +865,146 @@ static int init_device_caps(RdmaBackendDev *backend_dev,
> >       return 0;
> >   }
> > +static inline void build_mad_hdr(struct ibv_grh *grh, union ibv_gid *sgid,
> > +                                 union ibv_gid *my_gid, int paylen)
> > +{
> > +    grh->paylen = htons(paylen);
> > +    grh->sgid = *sgid;
> > +    grh->dgid = *my_gid;
> > +
> > +    pr_dbg("paylen=%d (net=0x%x)\n", paylen, grh->paylen);
> > +    pr_dbg("my_gid=0x%llx\n", my_gid->global.interface_id);
> > +    pr_dbg("gid=0x%llx\n", sgid->global.interface_id);
> > +}
> > +
> > +static inline int mad_can_receieve(void *opaque)
> > +{
> > +    return sizeof(struct backend_umad);
> > +}
> > +
> > +static void mad_read(void *opaque, const uint8_t *buf, int size)
> > +{
> > +    RdmaBackendDev *backend_dev = (RdmaBackendDev *)opaque;
> > +    QObject *o_ctx_id;
> > +    unsigned long cqe_ctx_id;
> > +    BackendCtx *bctx;
> > +    char *mad;
> > +    struct backend_umad *umad;
> > +
> > +    assert(size != sizeof(umad));
> > +    umad = (struct backend_umad *)buf;
> > +
> > +    pr_dbg("Got %d bytes\n", size);
> > +    pr_dbg("umad->hdr.length=%d\n", umad->hdr.length);
> > +
> > +#ifdef PVRDMA_DEBUG
> > +    struct umad_hdr *hdr = (struct umad_hdr *)&msg->umad.mad;
> > +    pr_dbg("bv %x cls %x cv %x mtd %x st %d tid %" PRIx64 " at %x atm %x\n",
> > +           hdr->base_version, hdr->mgmt_class, hdr->class_version,
> > +           hdr->method, hdr->status, be64toh(hdr->tid),
> > +           hdr->attr_id, hdr->attr_mod);
> > +#endif
> > +
> > +    qemu_mutex_lock(&backend_dev->recv_mads_list.lock);
> > +    o_ctx_id = qlist_pop(backend_dev->recv_mads_list.list);
> > +    qemu_mutex_unlock(&backend_dev->recv_mads_list.lock);
> > +    if (!o_ctx_id) {
> > +        pr_dbg("No more free MADs buffers, waiting for a while\n");
> > +        sleep(THR_POLL_TO);
> > +        return;
> > +    }
> > +
> > +    cqe_ctx_id = qnum_get_uint(qobject_to(QNum, o_ctx_id));
> > +    bctx = rdma_rm_get_cqe_ctx(backend_dev->rdma_dev_res, cqe_ctx_id);
> > +    if (unlikely(!bctx)) {
> > +        pr_dbg("Error: Fail to find ctx for %ld\n", cqe_ctx_id);
> > +        return;
> > +    }
> > +
> > +    pr_dbg("id %ld, bctx %p, ctx %p\n", cqe_ctx_id, bctx, bctx->up_ctx);
> > +
> > +    mad = rdma_pci_dma_map(backend_dev->dev, bctx->sge.addr,
> > +                           bctx->sge.length);
> > +    if (!mad || bctx->sge.length < umad->hdr.length + MAD_HDR_SIZE) {
> > +        comp_handler(IBV_WC_GENERAL_ERR, VENDOR_ERR_INV_MAD_BUFF,
> > +                     bctx->up_ctx);
> > +    } else {
> > +        memset(mad, 0, bctx->sge.length);
> > +        build_mad_hdr((struct ibv_grh *)mad,
> > +                      (union ibv_gid *)&umad->hdr.addr.gid,
> > +                      &backend_dev->gid, umad->hdr.length);
> > +        memcpy(&mad[MAD_HDR_SIZE], umad->mad, umad->hdr.length);
> > +        rdma_pci_dma_unmap(backend_dev->dev, mad, bctx->sge.length);
> > +
> > +        comp_handler(IBV_WC_SUCCESS, 0, bctx->up_ctx);
> > +    }
> > +
> > +    g_free(bctx);
> > +    rdma_rm_dealloc_cqe_ctx(backend_dev->rdma_dev_res, cqe_ctx_id);
> > +}
> > +
> > +static int mad_init(RdmaBackendDev *backend_dev)
> > +{
> > +    struct backend_umad umad = {0};
> > +    int ret;
> > +
> > +    if (!qemu_chr_fe_backend_connected(backend_dev->mad_chr_be)) {
> > +        pr_dbg("Missing chardev for MAD multiplexer\n");
> > +        return -EIO;
> > +    }
> > +
> > +    qemu_chr_fe_set_handlers(backend_dev->mad_chr_be, mad_can_receieve,
> > +                             mad_read, NULL, NULL, backend_dev, NULL, true);
> > +
> > +    /* Register ourself */
> > +    memcpy(umad.hdr.addr.gid, backend_dev->gid.raw, sizeof(umad.hdr.addr.gid));
> > +    ret = qemu_chr_fe_write(backend_dev->mad_chr_be, (const uint8_t *)&umad,
> > +                            sizeof(umad.hdr));
> > +    if (ret != sizeof(umad.hdr)) {
> > +        pr_dbg("Fail to register to rdma_umadmux (%d)\n", ret);
> > +    }
> > +
> > +    qemu_mutex_init(&backend_dev->recv_mads_list.lock);
> > +    backend_dev->recv_mads_list.list = qlist_new();
> > +
> > +    return 0;
> > +}
> > +
> > +static void mad_stop(RdmaBackendDev *backend_dev)
> > +{
> > +    QObject *o_ctx_id;
> > +    unsigned long cqe_ctx_id;
> > +    BackendCtx *bctx;
> > +
> > +    pr_dbg("Closing MAD\n");
> > +
> > +    /* Clear MAD buffers list */
> > +    qemu_mutex_lock(&backend_dev->recv_mads_list.lock);
> > +    do {
> > +        o_ctx_id = qlist_pop(backend_dev->recv_mads_list.list);
> 
> I suppose you cal lock only the above line, but maybe it doesn't
> matter at this point.

Sorry, my bad, there is no need for this cleanup, will squash patch #23 to
this one.

> > +        if (o_ctx_id) {
> > +            cqe_ctx_id = qnum_get_uint(qobject_to(QNum, o_ctx_id));
> > +            bctx = rdma_rm_get_cqe_ctx(backend_dev->rdma_dev_res, cqe_ctx_id);
> > +            if (bctx) {
> > +                rdma_rm_dealloc_cqe_ctx(backend_dev->rdma_dev_res, cqe_ctx_id);
> > +                g_free(bctx);
> > +            }
> > +        }
> > +    } while (o_ctx_id);
> > +    qemu_mutex_unlock(&backend_dev->recv_mads_list.lock);
> > +}
> > +
> > +static void mad_fini(RdmaBackendDev *backend_dev)
> > +{
> > +    qlist_destroy_obj(QOBJECT(backend_dev->recv_mads_list.list));
> > +    qemu_mutex_destroy(&backend_dev->recv_mads_list.lock);
> > +}
> > +
> >   int rdma_backend_init(RdmaBackendDev *backend_dev, PCIDevice *pdev,
> >                         RdmaDeviceResources *rdma_dev_res,
> >                         const char *backend_device_name, uint8_t port_num,
> >                         uint8_t backend_gid_idx, struct ibv_device_attr *dev_attr,
> > -                      Error **errp)
> > +                      CharBackend *mad_chr_be, Error **errp)
> >   {
> >       int i;
> >       int ret = 0;
> > @@ -763,7 +1015,7 @@ int rdma_backend_init(RdmaBackendDev *backend_dev, PCIDevice *pdev,
> >       memset(backend_dev, 0, sizeof(*backend_dev));
> >       backend_dev->dev = pdev;
> > -
> > +    backend_dev->mad_chr_be = mad_chr_be;
> >       backend_dev->backend_gid_idx = backend_gid_idx;
> >       backend_dev->port_num = port_num;
> >       backend_dev->rdma_dev_res = rdma_dev_res;
> > @@ -854,6 +1106,13 @@ int rdma_backend_init(RdmaBackendDev *backend_dev, PCIDevice *pdev,
> >       pr_dbg("interface_id=0x%" PRIx64 "\n",
> >              be64_to_cpu(backend_dev->gid.global.interface_id));
> > +    ret = mad_init(backend_dev);
> > +    if (ret) {
> > +        error_setg(errp, "Fail to initialize mad");
> > +        ret = -EIO;
> > +        goto out_destroy_comm_channel;
> > +    }
> > +
> >       backend_dev->comp_thread.run = false;
> >       backend_dev->comp_thread.is_running = false;
> > @@ -885,11 +1144,13 @@ void rdma_backend_stop(RdmaBackendDev *backend_dev)
> >   {
> >       pr_dbg("Stopping rdma_backend\n");
> >       stop_backend_thread(&backend_dev->comp_thread);
> > +    mad_stop(backend_dev);
> >   }
> >   void rdma_backend_fini(RdmaBackendDev *backend_dev)
> >   {
> >       rdma_backend_stop(backend_dev);
> > +    mad_fini(backend_dev);
> >       g_hash_table_destroy(ah_hash);
> >       ibv_destroy_comp_channel(backend_dev->channel);
> >       ibv_close_device(backend_dev->context);
> > diff --git a/hw/rdma/rdma_backend.h b/hw/rdma/rdma_backend.h
> > index 3ccc9a2494..fc83330251 100644
> > --- a/hw/rdma/rdma_backend.h
> > +++ b/hw/rdma/rdma_backend.h
> > @@ -17,6 +17,8 @@
> >   #define RDMA_BACKEND_H
> >   #include "qapi/error.h"
> > +#include "chardev/char-fe.h"
> > +
> >   #include "rdma_rm_defs.h"
> >   #include "rdma_backend_defs.h"
> > @@ -50,7 +52,7 @@ int rdma_backend_init(RdmaBackendDev *backend_dev, PCIDevice *pdev,
> >                         RdmaDeviceResources *rdma_dev_res,
> >                         const char *backend_device_name, uint8_t port_num,
> >                         uint8_t backend_gid_idx, struct ibv_device_attr *dev_attr,
> > -                      Error **errp);
> > +                      CharBackend *mad_chr_be, Error **errp);
> >   void rdma_backend_fini(RdmaBackendDev *backend_dev);
> >   void rdma_backend_start(RdmaBackendDev *backend_dev);
> >   void rdma_backend_stop(RdmaBackendDev *backend_dev);
> > diff --git a/hw/rdma/rdma_backend_defs.h b/hw/rdma/rdma_backend_defs.h
> > index 7404f64002..2a7e667075 100644
> > --- a/hw/rdma/rdma_backend_defs.h
> > +++ b/hw/rdma/rdma_backend_defs.h
> > @@ -16,8 +16,9 @@
> >   #ifndef RDMA_BACKEND_DEFS_H
> >   #define RDMA_BACKEND_DEFS_H
> > -#include <infiniband/verbs.h>
> >   #include "qemu/thread.h"
> > +#include "chardev/char-fe.h"
> > +#include <infiniband/verbs.h>
> >   typedef struct RdmaDeviceResources RdmaDeviceResources;
> > @@ -28,6 +29,11 @@ typedef struct RdmaBackendThread {
> >       bool is_running; /* Set by the thread to report its status */
> >   } RdmaBackendThread;
> > +typedef struct RecvMadList {
> > +    QemuMutex lock;
> > +    QList *list;
> > +} RecvMadList;
> > +
> >   typedef struct RdmaBackendDev {
> >       struct ibv_device_attr dev_attr;
> >       RdmaBackendThread comp_thread;
> > @@ -39,6 +45,8 @@ typedef struct RdmaBackendDev {
> >       struct ibv_comp_channel *channel;
> >       uint8_t port_num;
> >       uint8_t backend_gid_idx;
> > +    RecvMadList recv_mads_list;
> > +    CharBackend *mad_chr_be;
> >   } RdmaBackendDev;
> >   typedef struct RdmaBackendPD {
> > diff --git a/hw/rdma/vmw/pvrdma.h b/hw/rdma/vmw/pvrdma.h
> > index e2d9f93cdf..e3742d893a 100644
> > --- a/hw/rdma/vmw/pvrdma.h
> > +++ b/hw/rdma/vmw/pvrdma.h
> > @@ -19,6 +19,7 @@
> >   #include "qemu/units.h"
> >   #include "hw/pci/pci.h"
> >   #include "hw/pci/msix.h"
> > +#include "chardev/char-fe.h"
> >   #include "../rdma_backend_defs.h"
> >   #include "../rdma_rm_defs.h"
> > @@ -83,6 +84,7 @@ typedef struct PVRDMADev {
> >       uint8_t backend_port_num;
> >       RdmaBackendDev backend_dev;
> >       RdmaDeviceResources rdma_dev_res;
> > +    CharBackend mad_chr;
> >   } PVRDMADev;
> >   #define PVRDMA_DEV(dev) OBJECT_CHECK(PVRDMADev, (dev), PVRDMA_HW_NAME)
> > diff --git a/hw/rdma/vmw/pvrdma_main.c b/hw/rdma/vmw/pvrdma_main.c
> > index ca5fa8d981..6c8c0154fa 100644
> > --- a/hw/rdma/vmw/pvrdma_main.c
> > +++ b/hw/rdma/vmw/pvrdma_main.c
> > @@ -51,6 +51,7 @@ static Property pvrdma_dev_properties[] = {
> >       DEFINE_PROP_INT32("dev-caps-max-qp-init-rd-atom", PVRDMADev,
> >                         dev_attr.max_qp_init_rd_atom, MAX_QP_INIT_RD_ATOM),
> >       DEFINE_PROP_INT32("dev-caps-max-ah", PVRDMADev, dev_attr.max_ah, MAX_AH),
> > +    DEFINE_PROP_CHR("mad-chardev", PVRDMADev, mad_chr),
> >       DEFINE_PROP_END_OF_LIST(),
> >   };
> > @@ -613,7 +614,8 @@ static void pvrdma_realize(PCIDevice *pdev, Error **errp)
> >       rc = rdma_backend_init(&dev->backend_dev, pdev, &dev->rdma_dev_res,
> >                              dev->backend_device_name, dev->backend_port_num,
> > -                           dev->backend_gid_idx, &dev->dev_attr, errp);
> > +                           dev->backend_gid_idx, &dev->dev_attr, &dev->mad_chr,
> > +                           errp);
> >       if (rc) {
> >           goto out;
> >       }
> 
> I only have a few minor comments, but it looks OK to me anyway.
> 
> Reviewed-by: Marcel Apfelbaum<marcel.apfelbaum@gmail.com>
> Thanks,
> Marcel

Thanks!

> 

