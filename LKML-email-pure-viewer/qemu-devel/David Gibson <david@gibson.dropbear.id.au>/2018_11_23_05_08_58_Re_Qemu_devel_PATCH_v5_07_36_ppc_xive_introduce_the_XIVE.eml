Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 15:31:33 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga005.jf.intel.com (orsmga005.jf.intel.com [10.7.209.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 1054358037D
	for <like.xu@linux.intel.com>; Thu, 22 Nov 2018 22:30:38 -0800 (PST)
Received: from fmsmga103.fm.intel.com ([10.1.193.90])
  by orsmga005-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 22:30:37 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AfvSwchWWDVKltLeNVgFX1KdE2rDV8LGtZVwlr6E/?=
 =?us-ascii?q?grcLSJyIuqrYZRSGuqdThVPEFb/W9+hDw7KP9fy4CSpYud6oizMrSNR0TRgLiM?=
 =?us-ascii?q?EbzUQLIfWuLgnFFsPsdDEwB89YVVVorDmROElRH9viNRWJ+iXhpTEdFQ/iOgVr?=
 =?us-ascii?q?O+/7BpDdj9it1+C15pbffxhEiCCybL9uLxi6txndutULioZ+N6g9zQfErGFVcO?=
 =?us-ascii?q?pM32NoIlyTnxf45siu+ZNo7jpdtfE8+cNeSKv2Z6s3Q6BWAzQgKGA1+dbktQLf?=
 =?us-ascii?q?QguV53sTSXsZnxxVCAXY9h76X5Pxsizntuph3SSRIMP7QawoVTmk8qxmTgLjhi?=
 =?us-ascii?q?UaOD4j6GzZhMx+grxYrhKvqBNw35Pbb4ObO/RjZqPQf9EUSGVcUstfSyBOHJi8?=
 =?us-ascii?q?YpAAD+YdJ+tVtZXxqkEToRa4GAKiBPnvyjhNhnLu06M1yfohEQDb0wc9HtwOsW?=
 =?us-ascii?q?/brM7yNKcUTOu4y7THwi/db/NXxDjw84fIchE6rvGXWrJwd9DdxlQ1FwPCllWf?=
 =?us-ascii?q?spLqMCmP1ugXsmiU8vBsWviyi2M+rQx6vzahxsApiobTh4IVzEjJ9SJ4wYYxP9?=
 =?us-ascii?q?K3U1V7bcSjEJtKuCGWL5Z5QtklQ2Fwoyk11KcJuYShcCgL1ZsqwQPUZf+fc4WQ?=
 =?us-ascii?q?/B7vSOWcLS1liH54e7+znQi+/Eagx+HmS8W50k5GojRKn9XQq3wA0hLe58ybRv?=
 =?us-ascii?q?dh+0qtxzOC2x3W5+xBP0w5k7fQJYQ7zb4qjJUTtFzOHi/ol0Xyi6+bbkEk+umz?=
 =?us-ascii?q?6+T7ebXqvJCcN4lpig3kNaQugMO/Dfw5MggIQWeb5fyx2KP/8UD6WrlGk+A6n6?=
 =?us-ascii?q?rDvJzEK8kWprS1DxJX34o77hawFTam0NAWnXkdK1JFfQqKj5H3NFHLPfD0FOqw?=
 =?us-ascii?q?jEqykDh1w/DKJ6buApLQLnjFjLjuY61950lYyAoyztBQ+YhYC74cIP/rXk/xtd?=
 =?us-ascii?q?rYDgI2MgCuwubnDsl92Z0aWW6VHqCZN6bSvESO5uIoJemMa4kVuCvnJ/gi/f7u?=
 =?us-ascii?q?gmc1mUUBcqmxwZsXdHe4E+xiI0WYYnrjnM0NEGgXvgclSOzqiVuCUSNcZnqoXq?=
 =?us-ascii?q?I84C07B5yiDYvZWo+th7mBj2+GGIZLbDVGFkyUCiWvMIGFQOsXLiSVJMBnj3oD?=
 =?us-ascii?q?T7fmToYg0RSnskj906ZmKezPvTQVsI+m2NVr6umAqBcp6DYhCs2c132KHXh5m3?=
 =?us-ascii?q?5NSzIo0aQ6u0Fk11qYzYB+hPpXE8EV4OlGBRwnP5zRxPAvFtbpRwjadc2IQlv1?=
 =?us-ascii?q?ftLzKrA9VNM6i/sDK2l6EsmvlFiX1C6lK7wckLDNA4Y7pPHyxX/0cup01XfKnI?=
 =?us-ascii?q?YghUIhRIMbOWS4h6JX+AnZHInP1UmDkL6geK0Gmi/Bsm6emznd9HpEWRJ9BP2W?=
 =?us-ascii?q?FUsUYVHb+Iz0?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAACxnfdbhxHrdtBiFgQBAQEBAQIBA?=
 =?us-ascii?q?QEBBwIBAQEBgVEFAQEBAQsBgTAqgQ+BKYwRX4sfgg2XO4F1AgsFGAcNiFIiNAk?=
 =?us-ascii?q?NAQMBAQEBAQECARMBAQEKCwkIKSMMgjYFAgMYCYJcAQIDAQIXDRkBAQQKKQECA?=
 =?us-ascii?q?wECBgEBChgJHQgDAQsFGDETBQSCTUsBggEBBKY7gWwzgnYBAQWHDAcIgm2IAIE?=
 =?us-ascii?q?cF4F/gRGDEogzgiaJIYV6kGkJgiCEXIooCxhfek2HYYcBkA+IIYFGgg0zGggXG?=
 =?us-ascii?q?YMnCYF3GwkDFxJtAQd9hlqFUi0xgQQDiVcrKYF3AQE?=
X-IPAS-Result: =?us-ascii?q?A0ABAACxnfdbhxHrdtBiFgQBAQEBAQIBAQEBBwIBAQEBgVE?=
 =?us-ascii?q?FAQEBAQsBgTAqgQ+BKYwRX4sfgg2XO4F1AgsFGAcNiFIiNAkNAQMBAQEBAQECA?=
 =?us-ascii?q?RMBAQEKCwkIKSMMgjYFAgMYCYJcAQIDAQIXDRkBAQQKKQECAwECBgEBChgJHQg?=
 =?us-ascii?q?DAQsFGDETBQSCTUsBggEBBKY7gWwzgnYBAQWHDAcIgm2IAIEcF4F/gRGDEogzg?=
 =?us-ascii?q?iaJIYV6kGkJgiCEXIooCxhfek2HYYcBkA+IIYFGgg0zGggXGYMnCYF3GwkDFxJ?=
 =?us-ascii?q?tAQd9hlqFUi0xgQQDiVcrKYF3AQE?=
X-IronPort-AV: E=Sophos;i="5.56,268,1539673200"; 
   d="asc'?scan'208";a="53046014"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 22 Nov 2018 22:30:36 -0800
Received: from localhost ([::1]:50616 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQ4z5-0001d6-EY
	for like.xu@linux.intel.com; Fri, 23 Nov 2018 01:30:35 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:52567)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <dgibson@ozlabs.org>) id 1gQ4re-0003G8-02
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 01:22:56 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <dgibson@ozlabs.org>) id 1gQ4ra-0002p5-4S
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 01:22:53 -0500
Received: from ozlabs.org ([2401:3900:2:1::2]:34593)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <dgibson@ozlabs.org>)
	id 1gQ4rZ-0002le-4i; Fri, 23 Nov 2018 01:22:49 -0500
Received: by ozlabs.org (Postfix, from userid 1007)
	id 431R7F3DxKz9sDB; Fri, 23 Nov 2018 17:22:33 +1100 (AEDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
	d=gibson.dropbear.id.au; s=201602; t=1542954153;
	bh=X3dbiLyllPjtFv/rwsO+U+UfaJbNMdUqFGeNKcmD7QA=;
	h=Date:From:To:Cc:Subject:References:In-Reply-To:From;
	b=bRFmM+AhkTkNPn29oj4KRAW6t/i+iUhwksGwdQanKXDsEBJlH2lLxL2rjzwSDbEfb
	4hddlkEeHPIe5wArTV6T4X9HXhqQiTZdHKrjnOKdzrp9VPar0sDXQPgmY3irIlvPgw
	m/96eCdr7WhTS8kRsc3Mh6aqWwW08KHaHn3Tzzo4=
Date: Fri, 23 Nov 2018 16:08:58 +1100
From: David Gibson <david@gibson.dropbear.id.au>
To: =?iso-8859-1?Q?C=E9dric?= Le Goater <clg@kaod.org>
Message-ID: <20181123050858.GA10448@umbus.fritz.box>
References: <20181116105729.23240-1-clg@kaod.org>
	<20181116105729.23240-8-clg@kaod.org>
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha256;
	protocol="application/pgp-signature"; boundary="9Q79yvCDNTHf0qBd"
Content-Disposition: inline
In-Reply-To: <20181116105729.23240-8-clg@kaod.org>
User-Agent: Mutt/1.10.1 (2018-07-13)
X-detected-operating-system: by eggs.gnu.org: Genre and OS details not
	recognized.
X-Received-From: 2401:3900:2:1::2
Subject: Re: [Qemu-devel] [PATCH v5 07/36] ppc/xive: introduce the XIVE
 interrupt thread context
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: qemu-ppc@nongnu.org, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>


--9Q79yvCDNTHf0qBd
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Fri, Nov 16, 2018 at 11:57:00AM +0100, C=E9dric Le Goater wrote:
> Each POWER9 processor chip has a XIVE presenter that can generate four
> different exceptions to its threads:
>=20
>   - hypervisor exception,
>   - O/S exception
>   - Event-Based Branch (EBB)
>   - msgsnd (doorbell).
>=20
> Each exception has a state independent from the others called a Thread
> Interrupt Management context. This context is a set of registers which
> lets the thread handle priority management and interrupt acknowledgment
> among other things. The most important ones being :
>=20
>   - Interrupt Priority Register  (PIPR)
>   - Interrupt Pending Buffer     (IPB)
>   - Current Processor Priority   (CPPR)
>   - Notification Source Register (NSR)
>=20
> These registers are accessible through a specific MMIO region, called
> the Thread Interrupt Management Area (TIMA), four aligned pages, each
> exposing a different view of the registers. First page (page address
> ending in 0b00) gives access to the entire context and is reserved for
> the ring 0 security monitor. The second (page address ending in 0b01)
> is for the hypervisor, ring 1. The third (page address ending in 0b10)
> is for the operating system, ring 2. The fourth (page address ending
> in 0b11) is for user level, ring 3.
>=20
> The thread interrupt context is modeled with a XiveTCTX object
> containing the values of the different exception registers. The TIMA
> region is mapped at the same address for each CPU.
>=20
> Signed-off-by: C=E9dric Le Goater <clg@kaod.org>
> ---
>  include/hw/ppc/xive.h      |  36 +++
>  include/hw/ppc/xive_regs.h |  82 +++++++
>  hw/intc/xive.c             | 443 +++++++++++++++++++++++++++++++++++++
>  3 files changed, 561 insertions(+)
>=20
> diff --git a/include/hw/ppc/xive.h b/include/hw/ppc/xive.h
> index 24301bf2076d..5987f26ddb98 100644
> --- a/include/hw/ppc/xive.h
> +++ b/include/hw/ppc/xive.h
> @@ -238,4 +238,40 @@ typedef struct XiveENDSource {
>  void xive_end_reset(XiveEND *end);
>  void xive_end_pic_print_info(XiveEND *end, uint32_t end_idx, Monitor *mo=
n);
> =20
> +/*
> + * XIVE Thread interrupt Management (TM) context
> + */
> +
> +#define TYPE_XIVE_TCTX "xive-tctx"
> +#define XIVE_TCTX(obj) OBJECT_CHECK(XiveTCTX, (obj), TYPE_XIVE_TCTX)
> +
> +/*
> + * XIVE Thread interrupt Management register rings :
> + *
> + *   QW-0  User       event-based exception state
> + *   QW-1  O/S        OS context for priority management, interrupt acks
> + *   QW-2  Pool       hypervisor context for virtual processor being dis=
patched
> + *   QW-3  Physical   for the security monitor to manage the entire cont=
ext

That last description is misleading, AIUI the hypervisor can and does
make use of the physical ring as well as the pool ring.

> + */
> +#define TM_RING_COUNT           4
> +#define TM_RING_SIZE            0x10
> +
> +typedef struct XiveTCTX {
> +    DeviceState parent_obj;
> +
> +    CPUState    *cs;
> +    qemu_irq    output;
> +
> +    uint8_t     regs[TM_RING_COUNT * TM_RING_SIZE];

I'm a bit dubious about representing the state with a full buffer like
this.  Isn't a fair bit of this space reserved or derived values which
aren't backed by real state?

> +
> +    XiveRouter  *xrtr;

What's this for?  AFAIK a TCTX isn't associated with a particular
routing unit.

> +} XiveTCTX;
> +
> +/*
> + * XIVE Thread Interrupt Management Aera (TIMA)

Typo s/Aera/Area/

> + */
> +extern const MemoryRegionOps xive_tm_ops;
> +
> +void xive_tctx_pic_print_info(XiveTCTX *tctx, Monitor *mon);
> +
>  #endif /* PPC_XIVE_H */
> diff --git a/include/hw/ppc/xive_regs.h b/include/hw/ppc/xive_regs.h
> index f97fb2b90bee..2e3d6cb507da 100644
> --- a/include/hw/ppc/xive_regs.h
> +++ b/include/hw/ppc/xive_regs.h
> @@ -10,6 +10,88 @@
>  #ifndef PPC_XIVE_REGS_H
>  #define PPC_XIVE_REGS_H
> =20
> +#define TM_SHIFT                16
> +
> +/* TM register offsets */
> +#define TM_QW0_USER             0x000 /* All rings */
> +#define TM_QW1_OS               0x010 /* Ring 0..2 */
> +#define TM_QW2_HV_POOL          0x020 /* Ring 0..1 */
> +#define TM_QW3_HV_PHYS          0x030 /* Ring 0..1 */
> +
> +/* Byte offsets inside a QW             QW0 QW1 QW2 QW3 */
> +#define TM_NSR                  0x0  /*  +   +   -   +  */
> +#define TM_CPPR                 0x1  /*  -   +   -   +  */
> +#define TM_IPB                  0x2  /*  -   +   +   +  */
> +#define TM_LSMFB                0x3  /*  -   +   +   +  */
> +#define TM_ACK_CNT              0x4  /*  -   +   -   -  */
> +#define TM_INC                  0x5  /*  -   +   -   +  */
> +#define TM_AGE                  0x6  /*  -   +   -   +  */
> +#define TM_PIPR                 0x7  /*  -   +   -   +  */
> +
> +#define TM_WORD0                0x0
> +#define TM_WORD1                0x4
> +
> +/*
> + * QW word 2 contains the valid bit at the top and other fields
> + * depending on the QW.
> + */
> +#define TM_WORD2                0x8
> +#define   TM_QW0W2_VU           PPC_BIT32(0)
> +#define   TM_QW0W2_LOGIC_SERV   PPC_BITMASK32(1, 31) /* XX 2,31 ? */
> +#define   TM_QW1W2_VO           PPC_BIT32(0)
> +#define   TM_QW1W2_OS_CAM       PPC_BITMASK32(8, 31)
> +#define   TM_QW2W2_VP           PPC_BIT32(0)
> +#define   TM_QW2W2_POOL_CAM     PPC_BITMASK32(8, 31)
> +#define   TM_QW3W2_VT           PPC_BIT32(0)
> +#define   TM_QW3W2_LP           PPC_BIT32(6)
> +#define   TM_QW3W2_LE           PPC_BIT32(7)
> +#define   TM_QW3W2_T            PPC_BIT32(31)
> +
> +/*
> + * In addition to normal loads to "peek" and writes (only when invalid)
> + * using 4 and 8 bytes accesses, the above registers support these
> + * "special" byte operations:
> + *
> + *   - Byte load from QW0[NSR] - User level NSR (EBB)
> + *   - Byte store to QW0[NSR] - User level NSR (EBB)
> + *   - Byte load/store to QW1[CPPR] and QW3[CPPR] - CPPR access
> + *   - Byte load from QW3[TM_WORD2] - Read VT||00000||LP||LE on thrd 0
> + *                                    otherwise VT||0000000
> + *   - Byte store to QW3[TM_WORD2] - Set VT bit (and LP/LE if present)
> + *
> + * Then we have all these "special" CI ops at these offset that trigger
> + * all sorts of side effects:
> + */
> +#define TM_SPC_ACK_EBB          0x800   /* Load8 ack EBB to reg*/
> +#define TM_SPC_ACK_OS_REG       0x810   /* Load16 ack OS irq to reg */
> +#define TM_SPC_PUSH_USR_CTX     0x808   /* Store32 Push/Validate user co=
ntext */
> +#define TM_SPC_PULL_USR_CTX     0x808   /* Load32 Pull/Invalidate user
> +                                         * context */
> +#define TM_SPC_SET_OS_PENDING   0x812   /* Store8 Set OS irq pending bit=
 */
> +#define TM_SPC_PULL_OS_CTX      0x818   /* Load32/Load64 Pull/Invalidate=
 OS
> +                                         * context to reg */
> +#define TM_SPC_PULL_POOL_CTX    0x828   /* Load32/Load64 Pull/Invalidate=
 Pool
> +                                         * context to reg*/
> +#define TM_SPC_ACK_HV_REG       0x830   /* Load16 ack HV irq to reg */
> +#define TM_SPC_PULL_USR_CTX_OL  0xc08   /* Store8 Pull/Inval usr ctx to =
odd
> +                                         * line */
> +#define TM_SPC_ACK_OS_EL        0xc10   /* Store8 ack OS irq to even lin=
e */
> +#define TM_SPC_ACK_HV_POOL_EL   0xc20   /* Store8 ack HV evt pool to even
> +                                         * line */
> +#define TM_SPC_ACK_HV_EL        0xc30   /* Store8 ack HV irq to even lin=
e */
> +/* XXX more... */
> +
> +/* NSR fields for the various QW ack types */
> +#define TM_QW0_NSR_EB           PPC_BIT8(0)
> +#define TM_QW1_NSR_EO           PPC_BIT8(0)
> +#define TM_QW3_NSR_HE           PPC_BITMASK8(0, 1)
> +#define  TM_QW3_NSR_HE_NONE     0
> +#define  TM_QW3_NSR_HE_POOL     1
> +#define  TM_QW3_NSR_HE_PHYS     2
> +#define  TM_QW3_NSR_HE_LSI      3
> +#define TM_QW3_NSR_I            PPC_BIT8(2)
> +#define TM_QW3_NSR_GRP_LVL      PPC_BIT8(3, 7)
> +
>  /* EAS (Event Assignment Structure)
>   *
>   * One per interrupt source. Targets an interrupt to a given Event
> diff --git a/hw/intc/xive.c b/hw/intc/xive.c
> index 5a8882d47a98..4c6cb5d52975 100644
> --- a/hw/intc/xive.c
> +++ b/hw/intc/xive.c
> @@ -15,6 +15,448 @@
>  #include "sysemu/dma.h"
>  #include "monitor/monitor.h"
>  #include "hw/ppc/xive.h"
> +#include "hw/ppc/xive_regs.h"
> +
> +/*
> + * XIVE Thread Interrupt Management context
> + */
> +
> +static uint64_t xive_tctx_accept(XiveTCTX *tctx, uint8_t ring)
> +{
> +    return 0;
> +}
> +
> +static void xive_tctx_set_cppr(XiveTCTX *tctx, uint8_t ring, uint8_t cpp=
r)
> +{
> +    if (cppr > XIVE_PRIORITY_MAX) {
> +        cppr =3D 0xff;
> +    }
> +
> +    tctx->regs[ring + TM_CPPR] =3D cppr;
> +}
> +
> +/*
> + * XIVE Thread Interrupt Management Area (TIMA)
> + *
> + * This region gives access to the registers of the thread interrupt
> + * management context. It is four page wide, each page providing a
> + * different view of the registers. The page with the lower offset is
> + * the most privileged and gives access to the entire context.
> + */
> +
> +#define XIVE_TM_HW_PAGE   0x0
> +#define XIVE_TM_HV_PAGE   0x1
> +#define XIVE_TM_OS_PAGE   0x2
> +#define XIVE_TM_USER_PAGE 0x3
> +
> +/*
> + * Define an access map for each page of the TIMA that we will use in
> + * the memory region ops to filter values when doing loads and stores
> + * of raw registers values
> + *
> + * Registers accessibility bits :
> + *
> + *    0x0 - no access
> + *    0x1 - write only
> + *    0x2 - read only
> + *    0x3 - read/write
> + */
> +
> +static const uint8_t xive_tm_hw_view[] =3D {
> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-1 OS   */   3, 3, 3, 3,   3, 3, 0, 3,   3, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-2 HV   */   0, 0, 3, 3,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-3 HW   */   3, 3, 3, 3,   0, 3, 0, 3,   3, 0, 0, 3,   3, 3, 3,=
 0,

Can we stick to the "Pool" / "Phys" names rather than inventing HV and
HW.  XIVE already has too many names for things.  To clarify that's
for the naming of the QWs, the view names are fine.

> +};
> +
> +static const uint8_t xive_tm_hv_view[] =3D {
> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-1 OS   */   3, 3, 3, 3,   3, 3, 0, 3,   3, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-2 HV   */   0, 0, 3, 3,   0, 0, 0, 0,   0, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-3 HW   */   3, 3, 3, 3,   0, 3, 0, 3,   3, 0, 0, 3,   0, 0, 0,=
 0,
> +};
> +
> +static const uint8_t xive_tm_os_view[] =3D {
> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0, 0,=
 0,
> +    /* QW-1 OS   */   2, 3, 2, 2,   2, 2, 0, 2,   0, 0, 0, 0,   0, 0, 0,=
 0,
> +    /* QW-2 HV   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0,=
 0,
> +    /* QW-3 HW   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 3, 3,=
 0,

Are those bytes near the end of QW-3 really accessible in OS but not
hypervisor view?

> +};
> +
> +static const uint8_t xive_tm_user_view[] =3D {
> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0,=
 0,
> +    /* QW-1 OS   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0,=
 0,
> +    /* QW-2 HV   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0,=
 0,
> +    /* QW-3 HW   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0,=
 0,
> +};
> +
> +/*
> + * Overall TIMA access map for the thread interrupt management context
> + * registers
> + */
> +static const uint8_t *xive_tm_views[] =3D {
> +    [XIVE_TM_HW_PAGE]   =3D xive_tm_hw_view,
> +    [XIVE_TM_HV_PAGE]   =3D xive_tm_hv_view,
> +    [XIVE_TM_OS_PAGE]   =3D xive_tm_os_view,
> +    [XIVE_TM_USER_PAGE] =3D xive_tm_user_view,
> +};
> +
> +/*
> + * Computes a register access mask for a given offset in the TIMA
> + */
> +static uint64_t xive_tm_mask(hwaddr offset, unsigned size, bool write)
> +{
> +    uint8_t page_offset =3D (offset >> TM_SHIFT) & 0x3;
> +    uint8_t reg_offset =3D offset & 0x3F;
> +    uint8_t reg_mask =3D write ? 0x1 : 0x2;
> +    uint64_t mask =3D 0x0;
> +    int i;
> +
> +    for (i =3D 0; i < size; i++) {
> +        if (xive_tm_views[page_offset][reg_offset + i] & reg_mask) {
> +            mask |=3D (uint64_t) 0xff << (8 * (size - i - 1));
> +        }
> +    }
> +
> +    return mask;
> +}
> +
> +static void xive_tm_raw_write(XiveTCTX *tctx, hwaddr offset, uint64_t va=
lue,
> +                              unsigned size)
> +{
> +    uint8_t ring_offset =3D offset & 0x30;
> +    uint8_t reg_offset =3D offset & 0x3F;
> +    uint64_t mask =3D xive_tm_mask(offset, size, true);
> +    int i;
> +
> +    /*
> +     * Only 4 or 8 bytes stores are allowed and the User ring is
> +     * excluded
> +     */
> +    if (size < 4 || !mask || ring_offset =3D=3D TM_QW0_USER) {
> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid write access at TI=
MA @%"
> +                      HWADDR_PRIx"\n", offset);
> +        return;
> +    }
> +
> +    /*
> +     * Use the register offset for the raw values and filter out
> +     * reserved values
> +     */
> +    for (i =3D 0; i < size; i++) {
> +        uint8_t byte_mask =3D (mask >> (8 * (size - i - 1)));
> +        if (byte_mask) {
> +            tctx->regs[reg_offset + i] =3D (value >> (8 * (size - i - 1)=
)) &
> +                byte_mask;
> +        }
> +    }
> +}
> +
> +static uint64_t xive_tm_raw_read(XiveTCTX *tctx, hwaddr offset, unsigned=
 size)
> +{
> +    uint8_t ring_offset =3D offset & 0x30;
> +    uint8_t reg_offset =3D offset & 0x3F;
> +    uint64_t mask =3D xive_tm_mask(offset, size, false);
> +    uint64_t ret;
> +    int i;
> +
> +    /*
> +     * Only 4 or 8 bytes loads are allowed and the User ring is
> +     * excluded
> +     */
> +    if (size < 4 || !mask || ring_offset =3D=3D TM_QW0_USER) {
> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid read access at TIM=
A @%"
> +                      HWADDR_PRIx"\n", offset);
> +        return -1;
> +    }
> +
> +    /* Use the register offset for the raw values */
> +    ret =3D 0;
> +    for (i =3D 0; i < size; i++) {
> +        ret |=3D (uint64_t) tctx->regs[reg_offset + i] << (8 * (size - i=
 - 1));
> +    }
> +
> +    /* filter out reserved values */
> +    return ret & mask;
> +}
> +
> +/*
> + * The TM context is mapped twice within each page. Stores and loads
> + * to the first mapping below 2K write and read the specified values
> + * without modification. The second mapping above 2K performs specific
> + * state changes (side effects) in addition to setting/returning the
> + * interrupt management area context of the processor thread.
> + */
> +static uint64_t xive_tm_ack_os_reg(XiveTCTX *tctx, hwaddr offset, unsign=
ed size)
> +{
> +    return xive_tctx_accept(tctx, TM_QW1_OS);
> +}
> +
> +static void xive_tm_set_os_cppr(XiveTCTX *tctx, hwaddr offset,
> +                                uint64_t value, unsigned size)
> +{
> +    xive_tctx_set_cppr(tctx, TM_QW1_OS, value & 0xff);
> +}
> +
> +/*
> + * Define a mapping of "special" operations depending on the TIMA page
> + * offset and the size of the operation.
> + */
> +typedef struct XiveTmOp {
> +    uint8_t  page_offset;
> +    uint32_t op_offset;
> +    unsigned size;
> +    void     (*write_handler)(XiveTCTX *tctx, hwaddr offset, uint64_t va=
lue,
> +                              unsigned size);
> +    uint64_t (*read_handler)(XiveTCTX *tctx, hwaddr offset, unsigned siz=
e);
> +} XiveTmOp;
> +
> +static const XiveTmOp xive_tm_operations[] =3D {
> +    /*
> +     * MMIOs below 2K : raw values and special operations without side
> +     * effects
> +     */
> +    { XIVE_TM_OS_PAGE, TM_QW1_OS + TM_CPPR,   1, xive_tm_set_os_cppr, NU=
LL },
> +
> +    /* MMIOs above 2K : special operations with side effects */
> +    { XIVE_TM_OS_PAGE, TM_SPC_ACK_OS_REG,     2, NULL, xive_tm_ack_os_re=
g },
> +};
> +
> +static const XiveTmOp *xive_tm_find_op(hwaddr offset, unsigned size, boo=
l write)
> +{
> +    uint8_t page_offset =3D (offset >> TM_SHIFT) & 0x3;
> +    uint32_t op_offset =3D offset & 0xFFF;
> +    int i;
> +
> +    for (i =3D 0; i < ARRAY_SIZE(xive_tm_operations); i++) {
> +        const XiveTmOp *xto =3D &xive_tm_operations[i];
> +
> +        /* Accesses done from a more privileged TIMA page is allowed */
> +        if (xto->page_offset >=3D page_offset &&
> +            xto->op_offset =3D=3D op_offset &&
> +            xto->size =3D=3D size &&
> +            ((write && xto->write_handler) || (!write && xto->read_handl=
er))) {
> +            return xto;
> +        }
> +    }
> +    return NULL;
> +}
> +
> +/*
> + * TIMA MMIO handlers
> + */
> +static void xive_tm_write(void *opaque, hwaddr offset,
> +                          uint64_t value, unsigned size)
> +{
> +    PowerPCCPU *cpu =3D POWERPC_CPU(current_cpu);
> +    XiveTCTX *tctx =3D XIVE_TCTX(cpu->intc);
> +    const XiveTmOp *xto;
> +
> +    /*
> +     * TODO: check V bit in Q[0-3]W2, check PTER bit associated with CPU
> +     */
> +
> +    /*
> +     * First, check for special operations in the 2K region
> +     */
> +    if (offset & 0x800) {
> +        xto =3D xive_tm_find_op(offset, size, true);
> +        if (!xto) {
> +            qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid write access a=
t TIMA"
> +                          "@%"HWADDR_PRIx"\n", offset);
> +        } else {
> +            xto->write_handler(tctx, offset, value, size);
> +        }
> +        return;
> +    }
> +
> +    /*
> +     * Then, for special operations in the region below 2K.
> +     */
> +    xto =3D xive_tm_find_op(offset, size, true);
> +    if (xto) {
> +        xto->write_handler(tctx, offset, value, size);
> +        return;
> +    }
> +
> +    /*
> +     * Finish with raw access to the register values
> +     */
> +    xive_tm_raw_write(tctx, offset, value, size);
> +}
> +
> +static uint64_t xive_tm_read(void *opaque, hwaddr offset, unsigned size)
> +{
> +    PowerPCCPU *cpu =3D POWERPC_CPU(current_cpu);
> +    XiveTCTX *tctx =3D XIVE_TCTX(cpu->intc);
> +    const XiveTmOp *xto;
> +
> +    /*
> +     * TODO: check V bit in Q[0-3]W2, check PTER bit associated with CPU
> +     */
> +
> +    /*
> +     * First, check for special operations in the 2K region
> +     */
> +    if (offset & 0x800) {
> +        xto =3D xive_tm_find_op(offset, size, false);
> +        if (!xto) {
> +            qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid read access to=
 TIMA"
> +                          "@%"HWADDR_PRIx"\n", offset);
> +            return -1;
> +        }
> +        return xto->read_handler(tctx, offset, size);
> +    }
> +
> +    /*
> +     * Then, for special operations in the region below 2K.
> +     */
> +    xto =3D xive_tm_find_op(offset, size, false);
> +    if (xto) {
> +        return xto->read_handler(tctx, offset, size);
> +    }
> +
> +    /*
> +     * Finish with raw access to the register values
> +     */
> +    return xive_tm_raw_read(tctx, offset, size);
> +}
> +
> +const MemoryRegionOps xive_tm_ops =3D {
> +    .read =3D xive_tm_read,
> +    .write =3D xive_tm_write,
> +    .endianness =3D DEVICE_BIG_ENDIAN,
> +    .valid =3D {
> +        .min_access_size =3D 1,
> +        .max_access_size =3D 8,
> +    },
> +    .impl =3D {
> +        .min_access_size =3D 1,
> +        .max_access_size =3D 8,
> +    },
> +};
> +
> +static char *xive_tctx_ring_print(uint8_t *ring)
> +{
> +    uint32_t w2 =3D be32_to_cpu(*((uint32_t *) &ring[TM_WORD2]));
> +
> +    return g_strdup_printf("%02x   %02x  %02x    %02x   %02x  "
> +                   "%02x  %02x   %02x  %08x",
> +                   ring[TM_NSR], ring[TM_CPPR], ring[TM_IPB], ring[TM_LS=
MFB],
> +                   ring[TM_ACK_CNT], ring[TM_INC], ring[TM_AGE], ring[TM=
_PIPR],
> +                   w2);
> +}
> +
> +static const struct {
> +    uint8_t    qw;
> +    const char *name;
> +} xive_tctx_ring_infos[TM_RING_COUNT] =3D {
> +    { TM_QW3_HV_PHYS, "HW"   },
> +    { TM_QW2_HV_POOL, "HV"   },
> +    { TM_QW1_OS,      "OS"   },
> +    { TM_QW0_USER,    "USER" },

Likewise here if we can stick to PHYS and POOL rather than HW and HV.

Also, the qw field takes exactly the values 0..3, why not just an
array of names indexed by the ring number.

> +};
> +
> +void xive_tctx_pic_print_info(XiveTCTX *tctx, Monitor *mon)
> +{
> +    int cpu_index =3D tctx->cs ? tctx->cs->cpu_index : -1;
> +    int i;
> +
> +    monitor_printf(mon, "CPU[%04x]:   QW   NSR CPPR IPB LSMFB ACK# INC A=
GE PIPR"
> +                   "  W2\n", cpu_index);
> +
> +    for (i =3D 0; i < TM_RING_COUNT; i++) {
> +        char *s =3D xive_tctx_ring_print(&tctx->regs[xive_tctx_ring_info=
s[i].qw]);
> +        monitor_printf(mon, "CPU[%04x]: %4s    %s\n", cpu_index,
> +                       xive_tctx_ring_infos[i].name, s);
> +        g_free(s);
> +    }
> +}
> +
> +static void xive_tctx_reset(void *dev)
> +{
> +    XiveTCTX *tctx =3D XIVE_TCTX(dev);
> +
> +    memset(tctx->regs, 0, sizeof(tctx->regs));
> +
> +    /* Set some defaults */
> +    tctx->regs[TM_QW1_OS + TM_LSMFB] =3D 0xFF;
> +    tctx->regs[TM_QW1_OS + TM_ACK_CNT] =3D 0xFF;
> +    tctx->regs[TM_QW1_OS + TM_AGE] =3D 0xFF;
> +}
> +
> +static void xive_tctx_realize(DeviceState *dev, Error **errp)
> +{
> +    XiveTCTX *tctx =3D XIVE_TCTX(dev);
> +    PowerPCCPU *cpu;
> +    CPUPPCState *env;
> +    Object *obj;
> +    Error *local_err =3D NULL;
> +
> +    obj =3D object_property_get_link(OBJECT(dev), "xive", &local_err);
> +    if (!obj) {
> +        error_propagate(errp, local_err);
> +        error_prepend(errp, "required link 'xive' not found: ");
> +        return;
> +    }
> +    tctx->xrtr =3D XIVE_ROUTER(obj);
> +
> +    obj =3D object_property_get_link(OBJECT(dev), "cpu", &local_err);
> +    if (!obj) {
> +        error_propagate(errp, local_err);
> +        error_prepend(errp, "required link 'cpu' not found: ");
> +        return;
> +    }
> +
> +    cpu =3D POWERPC_CPU(obj);
> +    tctx->cs =3D CPU(obj);
> +
> +    env =3D &cpu->env;
> +    switch (PPC_INPUT(env)) {
> +    case PPC_FLAGS_INPUT_POWER7:
> +        tctx->output =3D env->irq_inputs[POWER7_INPUT_INT];
> +        break;
> +
> +    default:
> +        error_setg(errp, "XIVE interrupt controller does not support "
> +                   "this CPU bus model");
> +        return;
> +    }
> +
> +    qemu_register_reset(xive_tctx_reset, dev);
> +}
> +
> +static void xive_tctx_unrealize(DeviceState *dev, Error **errp)
> +{
> +    qemu_unregister_reset(xive_tctx_reset, dev);
> +}
> +
> +static const VMStateDescription vmstate_xive_tctx =3D {
> +    .name =3D TYPE_XIVE_TCTX,
> +    .version_id =3D 1,
> +    .minimum_version_id =3D 1,
> +    .fields =3D (VMStateField[]) {
> +        VMSTATE_BUFFER(regs, XiveTCTX),
> +        VMSTATE_END_OF_LIST()
> +    },
> +};
> +
> +static void xive_tctx_class_init(ObjectClass *klass, void *data)
> +{
> +    DeviceClass *dc =3D DEVICE_CLASS(klass);
> +
> +    dc->realize =3D xive_tctx_realize;
> +    dc->unrealize =3D xive_tctx_unrealize;
> +    dc->desc =3D "XIVE Interrupt Thread Context";
> +    dc->vmsd =3D &vmstate_xive_tctx;
> +}
> +
> +static const TypeInfo xive_tctx_info =3D {
> +    .name          =3D TYPE_XIVE_TCTX,
> +    .parent        =3D TYPE_DEVICE,
> +    .instance_size =3D sizeof(XiveTCTX),
> +    .class_init    =3D xive_tctx_class_init,
> +};
> =20
>  /*
>   * XIVE ESB helpers
> @@ -876,6 +1318,7 @@ static void xive_register_types(void)
>      type_register_static(&xive_fabric_info);
>      type_register_static(&xive_router_info);
>      type_register_static(&xive_end_source_info);
> +    type_register_static(&xive_tctx_info);
>  }
> =20
>  type_init(xive_register_types)

--=20
David Gibson			| I'll have my music baroque, and my code
david AT gibson.dropbear.id.au	| minimalist, thank you.  NOT _the_ _other_
				| _way_ _around_!
http://www.ozlabs.org/~dgibson

--9Q79yvCDNTHf0qBd
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEdfRlhq5hpmzETofcbDjKyiDZs5IFAlv3i2gACgkQbDjKyiDZ
s5JSQw//b2JnRCkDJ19cp+H3CZEhdIN4/GhcCw9/h3C5UT2y3O+4FwPZSm9x284/
KwVxzEGDeiH0IJ5jysaMuCHzQ9NIbz6VSfonY7FxmtFkB/EkUlxrp7yYOFyugkS0
Egqy3spxjczylwnzKKQ+L+IyspU1h0iX4+1nMyz1XoueGUWty7lcS1dnvVzFaWgv
25PafH/eOsuGP9qFT05q2MvbETpJ07CsOPmNuS8at3PulEsRcqErRjnQral60FZd
/vtX426flBbV7jQAxkvMeNX7ZaZ+KyraESwCPg2bTpPCrofgaSpNUZecNgAQ8NoP
KemrO1QyIZYWrENaSPR7YADHKd0dGNhG2MDOnFz2NLwgbSLVoIsh9fo0Qn65fbuq
HR5zLpek3vX3eYEr1TG7rIlRanH/Ni2JC7PgjJxkCVWUa8npyCnMGfwJYBbT2LMj
OIvS+Fvm26vT7qZJ/vrL0GVMFLse2/JA/l9x0H0ZR2UaRwrfiZWtfX0ye/1u0BCv
wJq7m4iMxA/0NEYhfCJjpFN6MznU1VAWVV4C5DANPpx+KB1Vhcgg76BTQ4WsSNPw
SGaRZedNwiJht3YhcabqlmxQFgDWamj4yocGt2IyIH+FdBIwQffQADL5wwDyRVoV
XUOg+hE5HmcR2MX8hvFFb3syGJbVMjgy4q3dbNsSHtyeHONRX1Y=
=GuDP
-----END PGP SIGNATURE-----

--9Q79yvCDNTHf0qBd--

