Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 10:36:09 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id CF7BC580460
	for <like.xu@linux.intel.com>; Thu, 22 Nov 2018 17:04:30 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 17:04:30 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3Ak7PaChCU6TANDjVNXVW0UyQJP3N1i/DPJgcQr6Af?=
 =?us-ascii?q?oPdwSP37psuwAkXT6L1XgUPTWs2DsrQY07qQ6/iocFdDyK7JiGoFfp1IWk1Nou?=
 =?us-ascii?q?QttCtkPvS4D1bmJuXhdS0wEZcKflZk+3amLRodQ56mNBXdrXKo8DEdBAj0OxZr?=
 =?us-ascii?q?KeTpAI7SiNm82/yv95HJbAhEmDmwbaluIBmqsA7cqtQYjYx+J6gr1xDHuGFIe+?=
 =?us-ascii?q?NYxWNpIVKcgRPx7dqu8ZBg7ipdpesv+9ZPXqvmcas4S6dYDCk9PGAu+MLrrxjD?=
 =?us-ascii?q?QhCR6XYaT24bjwBHAwnB7BH9Q5fxri73vfdz1SWGIcH7S60/VDK/5KlpVRDokj?=
 =?us-ascii?q?8KOTA5/m/JicJwgq1Urw68qBN9zYHafZmVOfh8cK7SYN8XS3ZNUdhKVyFaDYOw?=
 =?us-ascii?q?c5ECAvAdMetCsoXwoUYFoxukBQmrAePi0jFGiWXo3a07zusqDADI3A07ENIVt3?=
 =?us-ascii?q?TUqsj+OaAPXu+v0qnIzCjMYuhZ2Tf884fIaRchofeWUb1ta8rRzlEvGBjbgVqK?=
 =?us-ascii?q?s4zpJTKV2fkXv2eB8uptTOSigHMppQF2pzig3MYsio/Ri4ISy1HE8T92z50uJd?=
 =?us-ascii?q?GiT057e9GkHINNuCGAMIt2WtgtTH9ytyYg0LEGuIO0cS4Xw5ok3x7Sc+KLf5SL?=
 =?us-ascii?q?7x75SeqdPDR1iGh7dL+xhxu+61Wsx+/kWsWq31tGsjdJn9zCu30JyxDf9s2KRu?=
 =?us-ascii?q?V480u83DuC0h7f5+dZKk4uj6XbMYQuwrsom5oTr0vDGij2lV3yjK+XbUUk5vOo?=
 =?us-ascii?q?5/7oYrXgu5+QLYh0ihvxMqg2m8y/B/o3MhQWUmSF5eix16fv8VDkTLhJlPE6jK?=
 =?us-ascii?q?fUvZDAKcgGpKO1GwpV3Zwi6xa7ATemytMYnXwfIVJcZh2HipXpN0jTL//mE/ew?=
 =?us-ascii?q?nVCsnC5wyPDBI73hBInCIWbYkLvmebZ96k1cxxQpwdFQ+pJZErUBIPP1Wk/su9?=
 =?us-ascii?q?3UFB45Mwqow+n5DNVxzJ8RWWWKAqKCNqPStlmI5u0pI+mRfoMVvyz9K/c96/70?=
 =?us-ascii?q?kXA5gUMdfbWu3ZYPbHC4H/dmLFuDbXvjn9cMCmMKvgs4TOz3h1yOSz9TZ3CuX6?=
 =?us-ascii?q?0i4jE3Ep6pDYDGRtPlvbqawS3uHoFKfnsUTReIEGz0bMOCXPEDbj/UJdVu1TkN?=
 =?us-ascii?q?VLykQolm0gmytQj80P1+I+/JvyEVq5/nh+Vz/PDZwBQ79DhoCJaE3mSQCm15gG?=
 =?us-ascii?q?4MAiU7xb1yulBVzFCF3q5lxftCGotI+vlLXwwmYIPa1PFwENvoWwjMLeuOHX0n?=
 =?us-ascii?q?Ts+nCnkVQ5oexNYSblw1T96mgTjA1i2mRbgPmOrYKoYz9/fw1mbwK45Synzd06?=
 =?us-ascii?q?9p21UvXMpDHWKnjLV48U7fHYnRmUiQjeCreeIVwXiepy+40WOSsRQAA0ZLWqLf?=
 =?us-ascii?q?UCVHaw=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAAAkUfdbhxHrdtBiFgQBAQEBAQIBA?=
 =?us-ascii?q?QEBBwIBAQEBgVEFAQEBAQsBgTAqgQ+BKYwRX40tepZBFIFhAgsFGAcNiFIiNAk?=
 =?us-ascii?q?NAQMBAQEBAQECARMBAQEKCwkIKSMMgjYFAgMYCYJbAQEBAQIBAQIXDRkBAQQKK?=
 =?us-ascii?q?QECAgEBAgYBAQoSBgkdCAMBCwUYHRQTBQSCTUsBgXkIAQSnCIFsM4J2AQEFhw0?=
 =?us-ascii?q?HCIJtiACBHBeBf4ERgl01hEMjAYVyiRMOhXkBEJBZCYIghFyDLYZ7Cxhfek2HY?=
 =?us-ascii?q?YQPgnKQD4ghgUaCDTMaCBcZgycJghIMFxKBcoZahVItMYEEA4pegXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ABAAAkUfdbhxHrdtBiFgQBAQEBAQIBAQEBBwIBAQEBgVE?=
 =?us-ascii?q?FAQEBAQsBgTAqgQ+BKYwRX40tepZBFIFhAgsFGAcNiFIiNAkNAQMBAQEBAQECA?=
 =?us-ascii?q?RMBAQEKCwkIKSMMgjYFAgMYCYJbAQEBAQIBAQIXDRkBAQQKKQECAgEBAgYBAQo?=
 =?us-ascii?q?SBgkdCAMBCwUYHRQTBQSCTUsBgXkIAQSnCIFsM4J2AQEFhw0HCIJtiACBHBeBf?=
 =?us-ascii?q?4ERgl01hEMjAYVyiRMOhXkBEJBZCYIghFyDLYZ7Cxhfek2HYYQPgnKQD4ghgUa?=
 =?us-ascii?q?CDTMaCBcZgycJghIMFxKBcoZahVItMYEEA4pegXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,267,1539673200"; 
   d="asc'?scan'208";a="41935281"
X-Amp-Result: UNSCANNABLE
X-Amp-File-Uploaded: False
Unscannable: 2
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 22 Nov 2018 17:04:29 -0800
Received: from localhost ([::1]:49952 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gPztU-000366-TL
	for like.xu@linux.intel.com; Thu, 22 Nov 2018 20:04:28 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:57812)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <dgibson@ozlabs.org>) id 1gPzsz-00035z-LO
	for qemu-devel@nongnu.org; Thu, 22 Nov 2018 20:04:00 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <dgibson@ozlabs.org>) id 1gPzsv-0001Yd-P2
	for qemu-devel@nongnu.org; Thu, 22 Nov 2018 20:03:57 -0500
Received: from ozlabs.org ([2401:3900:2:1::2]:38215)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <dgibson@ozlabs.org>)
	id 1gPzss-0001VV-5V; Thu, 22 Nov 2018 20:03:52 -0500
Received: by ozlabs.org (Postfix, from userid 1007)
	id 431J3N1ghkz9s29; Fri, 23 Nov 2018 12:03:44 +1100 (AEDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
	d=gibson.dropbear.id.au; s=201602; t=1542935024;
	bh=dxE6e927MNWPe3PM3u7rBuU/mL5Cx0aHz8qq+hr5SlE=;
	h=Date:From:To:Cc:Subject:References:In-Reply-To:From;
	b=WefkzgkTq53UDT5IQGvYK+bTyZJD7SizbKXT0DoWz+H2nyy5bzKyIAol+4mfNUVnw
	R6W0qp6+XBD0GHhZtGmGKsc5uvED05RR9NDlfhZs8HmxThKNyKqrvsz8j+HUZL8XcE
	fmePuhLJJv3tveTX1DGWxa7w6DriNktsJUlkFXc0=
Date: Fri, 23 Nov 2018 11:31:15 +1100
From: David Gibson <david@gibson.dropbear.id.au>
To: =?iso-8859-1?Q?C=E9dric?= Le Goater <clg@kaod.org>
Message-ID: <20181123003115.GR10448@umbus.fritz.box>
References: <20181116105729.23240-1-clg@kaod.org>
	<20181116105729.23240-2-clg@kaod.org>
	<20181122030516.GB10448@umbus.fritz.box>
	<658dc2ad-e862-4777-9ed5-1ba82a074aa6@kaod.org>
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha256;
	protocol="application/pgp-signature"; boundary="Hnpg0BSo5EvPlUVi"
Content-Disposition: inline
In-Reply-To: <658dc2ad-e862-4777-9ed5-1ba82a074aa6@kaod.org>
User-Agent: Mutt/1.10.1 (2018-07-13)
X-detected-operating-system: by eggs.gnu.org: Genre and OS details not
	recognized.
X-Received-From: 2401:3900:2:1::2
Subject: Re: [Qemu-devel] [PATCH v5 01/36] ppc/xive: introduce a XIVE
 interrupt source model
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: qemu-ppc@nongnu.org, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>


--Hnpg0BSo5EvPlUVi
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Thu, Nov 22, 2018 at 08:25:06AM +0100, C=E9dric Le Goater wrote:
> On 11/22/18 4:05 AM, David Gibson wrote:
> > On Fri, Nov 16, 2018 at 11:56:54AM +0100, C=E9dric Le Goater wrote:
> >> The first sub-engine of the overall XIVE architecture is the Interrupt
> >> Virtualization Source Engine (IVSE). An IVSE can be integrated into
> >> another logic, like in a PCI PHB or in the main interrupt controller
> >> to manage IPIs.
> >>
> >> Each IVSE instance is associated with an Event State Buffer (ESB) that
> >> contains a two bit state entry for each possible event source. When an
> >> event is signaled to the IVSE, by MMIO or some other means, the
> >> associated interrupt state bits are fetched from the ESB and
> >> modified. Depending on the resulting ESB state, the event is forwarded
> >> to the IVRE sub-engine of the controller doing the routing.
> >>
> >> Each supported ESB entry is associated with either a single or a
> >> even/odd pair of pages which provides commands to manage the source:
> >> to EOI, to turn off the source for instance.
> >>
> >> On a sPAPR machine, the O/S will obtain the page address of the ESB
> >> entry associated with a source and its characteristic using the
> >> H_INT_GET_SOURCE_INFO hcall. On PowerNV, a similar OPAL call is used.
> >>
> >> The xive_source_notify() routine is in charge forwarding the source
> >> event notification to the routing engine. It will be filled later on.
> >>
> >> Signed-off-by: C=E9dric Le Goater <clg@kaod.org>
> >=20
> > Ok, this is looking basically pretty good.  Few details to query
> > below.
> >=20
> >=20
> >> ---
> >>  default-configs/ppc64-softmmu.mak |   1 +
> >>  include/hw/ppc/xive.h             | 130 ++++++++++
> >>  hw/intc/xive.c                    | 379 ++++++++++++++++++++++++++++++
> >>  hw/intc/Makefile.objs             |   1 +
> >>  4 files changed, 511 insertions(+)
> >>  create mode 100644 include/hw/ppc/xive.h
> >>  create mode 100644 hw/intc/xive.c
> >>
> >> diff --git a/default-configs/ppc64-softmmu.mak b/default-configs/ppc64=
-softmmu.mak
> >> index aec2855750d6..2d1e7c5c4668 100644
> >> --- a/default-configs/ppc64-softmmu.mak
> >> +++ b/default-configs/ppc64-softmmu.mak
> >> @@ -16,6 +16,7 @@ CONFIG_VIRTIO_VGA=3Dy
> >>  CONFIG_XICS=3D$(CONFIG_PSERIES)
> >>  CONFIG_XICS_SPAPR=3D$(CONFIG_PSERIES)
> >>  CONFIG_XICS_KVM=3D$(call land,$(CONFIG_PSERIES),$(CONFIG_KVM))
> >> +CONFIG_XIVE=3D$(CONFIG_PSERIES)
> >>  CONFIG_MEM_DEVICE=3Dy
> >>  CONFIG_DIMM=3Dy
> >>  CONFIG_SPAPR_RNG=3Dy
> >> diff --git a/include/hw/ppc/xive.h b/include/hw/ppc/xive.h
> >> new file mode 100644
> >> index 000000000000..5fec4b08705d
> >> --- /dev/null
> >> +++ b/include/hw/ppc/xive.h
> >> @@ -0,0 +1,130 @@
> >> +/*
> >> + * QEMU PowerPC XIVE interrupt controller model
> >> + *
> >> + * Copyright (c) 2017-2018, IBM Corporation.
> >> + *
> >> + * This code is licensed under the GPL version 2 or later. See the
> >> + * COPYING file in the top-level directory.
> >=20
> > A cheat sheet in the top of this header with the old and new XIVE
> > terms would quite nice to have.
>=20
> Yes. It's a good place. I will put the XIVE acronyms here :
>     =20
>      EA		Event Assignment
>      EISN	Effective Interrupt Source Number
>      END	Event Notification Descriptor
>      ESB	Event State Buffer
>      EQ		Event Queue
>      LISN	Logical Interrupt Source Number
>      NVT	Notification Virtual Target
>      TIMA	Thread Interrupt Management Area
>      ...

That sounds good, but what I'd also like is showing that NVT =3D=3D VP and
EAS =3D=3D IVT and so forth.

> >> + */
> >> +
> >> +#ifndef PPC_XIVE_H
> >> +#define PPC_XIVE_H
> >> +
> >> +#include "hw/sysbus.h"
> >=20
> > So, I'm a bit dubious about making the XiveSource a SysBus device -
> > I'm concerned it won't play well with tying it into the other devices
> > like PHB that "own" it in real hardware.
>=20
> It does but I can take a look at changing it to a DeviceState. The=20
> reset handlers might be a concern.

As "non bus" device I think you'd need to register your own reset
handler rather than just setting dc->reset.  Otherwise, I think that
should work.

> > I think we'd be better off making it a direct descendent of
> > TYPE_DEVICE which constructs the MMIO region, but doesn't map it.
>=20
> At a moment, I started working on a XiveESB object doing what I think=20
> you are suggesting and I removed it. I am reluctant adding more=20
> complexity now, the patchset is just growing and growing ...=20
>=20
> But I agree there are fundamentals to get right for KVM. Let's talk=20
> about it after you have looked at the overall patchset, at least up=20
> to KVM initial support.

Hm, ok.

> > Then we can havea SysBusDevice (and/or other) wrapper which
> > instantiates the XiveSource core and maps it into somewhere
> > accessible.
>=20
> The XIVE controller model does the mapping of the source currently.

I'm.. I'm not sure what you mean by that.   We have a
sysbus_init_mmio() right here which effectively maps in the MMIO
region AFAICT.

> In the case of sPAPR, the controller model controls the TIMA and=20
> for PowerNV, there are quite few others MMIO regions to handle.
>=20
> >=20
> >> +
> >> +/*
> >> + * XIVE Interrupt Source
> >> + */
> >> +
> >> +#define TYPE_XIVE_SOURCE "xive-source"
> >> +#define XIVE_SOURCE(obj) OBJECT_CHECK(XiveSource, (obj), TYPE_XIVE_SO=
URCE)
> >> +
> >> +/*
> >> + * XIVE Interrupt Source characteristics, which define how the ESB are
> >> + * controlled.
> >> + */
> >> +#define XIVE_SRC_H_INT_ESB     0x1 /* ESB managed with hcall H_INT_ES=
B */
> >> +#define XIVE_SRC_STORE_EOI     0x2 /* Store EOI supported */
> >> +
> >> +typedef struct XiveSource {
> >> +    SysBusDevice parent;
> >> +
> >> +    /* IRQs */
> >> +    uint32_t        nr_irqs;
> >> +    qemu_irq        *qirqs;
> >> +
> >> +    /* PQ bits */
> >> +    uint8_t         *status;
> >> +
> >> +    /* ESB memory region */
> >> +    uint64_t        esb_flags;
> >> +    uint32_t        esb_shift;
> >> +    MemoryRegion    esb_mmio;
> >> +} XiveSource;
> >> +
> >> +/*
> >> + * ESB MMIO setting. Can be one page, for both source triggering and
> >> + * source management, or two different pages. See below for magic
> >> + * values.
> >> + */
> >> +#define XIVE_ESB_4K          12 /* PSI HB only */
> >> +#define XIVE_ESB_4K_2PAGE    13
> >> +#define XIVE_ESB_64K         16
> >> +#define XIVE_ESB_64K_2PAGE   17
> >> +
> >> +static inline bool xive_source_esb_has_2page(XiveSource *xsrc)
> >> +{
> >> +    return xsrc->esb_shift =3D=3D XIVE_ESB_64K_2PAGE ||
> >> +        xsrc->esb_shift =3D=3D XIVE_ESB_4K_2PAGE;
> >> +}
> >> +
> >> +/* The trigger page is always the first/even page */
> >> +static inline hwaddr xive_source_esb_page(XiveSource *xsrc, uint32_t =
srcno)
> >=20
> > This function doesn't appear to be used anywhere except..
>=20
> It's used in patch 16 adding the hcalls also.
>=20
> >> +{
> >> +    assert(srcno < xsrc->nr_irqs);
> >> +    return (1ull << xsrc->esb_shift) * srcno;
> >> +}
> >> +
> >> +/* In a two pages ESB MMIO setting, the odd page is for management */
> >> +static inline hwaddr xive_source_esb_mgmt(XiveSource *xsrc, int srcno)
> >=20
> >=20
> > ..here, and this function doesn't appear to be used anywhere.
>=20
> It's used in patch 16 adding the hcalls and patch 23 for KVM.
>=20
> This is basic ESB support which I thought belong to the patch on sources.
> =20
> >=20
> >> +{
> >> +    hwaddr addr =3D xive_source_esb_page(xsrc, srcno);
> >> +
> >> +    if (xive_source_esb_has_2page(xsrc)) {
> >> +        addr +=3D (1 << (xsrc->esb_shift - 1));
> >> +    }
> >> +
> >> +    return addr;
> >> +}
> >> +
> >> +/*
> >> + * Each interrupt source has a 2-bit state machine which can be
> >> + * controlled by MMIO. P indicates that an interrupt is pending (has
> >> + * been sent to a queue and is waiting for an EOI). Q indicates that
> >> + * the interrupt has been triggered while pending.
> >> + *
> >> + * This acts as a coalescing mechanism in order to guarantee that a
> >> + * given interrupt only occurs at most once in a queue.
> >> + *
> >> + * When doing an EOI, the Q bit will indicate if the interrupt
> >> + * needs to be re-triggered.
> >> + */
> >> +#define XIVE_ESB_VAL_P        0x2
> >> +#define XIVE_ESB_VAL_Q        0x1
> >> +
> >> +#define XIVE_ESB_RESET        0x0
> >> +#define XIVE_ESB_PENDING      XIVE_ESB_VAL_P
> >> +#define XIVE_ESB_QUEUED       (XIVE_ESB_VAL_P | XIVE_ESB_VAL_Q)
> >> +#define XIVE_ESB_OFF          XIVE_ESB_VAL_Q
> >> +
> >> +/*
> >> + * "magic" Event State Buffer (ESB) MMIO offsets.
> >> + *
> >> + * The following offsets into the ESB MMIO allow to read or manipulate
> >> + * the PQ bits. They must be used with an 8-byte load instruction.
> >> + * They all return the previous state of the interrupt (atomically).
> >> + *
> >> + * Additionally, some ESB pages support doing an EOI via a store and
> >> + * some ESBs support doing a trigger via a separate trigger page.
> >> + */
> >> +#define XIVE_ESB_STORE_EOI      0x400 /* Store */
> >> +#define XIVE_ESB_LOAD_EOI       0x000 /* Load */
> >> +#define XIVE_ESB_GET            0x800 /* Load */
> >> +#define XIVE_ESB_SET_PQ_00      0xc00 /* Load */
> >> +#define XIVE_ESB_SET_PQ_01      0xd00 /* Load */
> >> +#define XIVE_ESB_SET_PQ_10      0xe00 /* Load */
> >> +#define XIVE_ESB_SET_PQ_11      0xf00 /* Load */
> >> +
> >> +uint8_t xive_source_esb_get(XiveSource *xsrc, uint32_t srcno);
> >> +uint8_t xive_source_esb_set(XiveSource *xsrc, uint32_t srcno, uint8_t=
 pq);
> >> +
> >> +void xive_source_pic_print_info(XiveSource *xsrc, uint32_t offset,
> >> +                                Monitor *mon);
> >> +
> >> +static inline qemu_irq xive_source_qirq(XiveSource *xsrc, uint32_t sr=
cno)
> >> +{
> >> +    assert(srcno < xsrc->nr_irqs);
> >> +    return xsrc->qirqs[srcno];
> >> +}
> >> +
> >> +#endif /* PPC_XIVE_H */
> >> diff --git a/hw/intc/xive.c b/hw/intc/xive.c
> >> new file mode 100644
> >> index 000000000000..f7621f84828c
> >> --- /dev/null
> >> +++ b/hw/intc/xive.c
> >> @@ -0,0 +1,379 @@
> >> +/*
> >> + * QEMU PowerPC XIVE interrupt controller model
> >> + *
> >> + * Copyright (c) 2017-2018, IBM Corporation.
> >> + *
> >> + * This code is licensed under the GPL version 2 or later. See the
> >> + * COPYING file in the top-level directory.
> >> + */
> >> +
> >> +#include "qemu/osdep.h"
> >> +#include "qemu/log.h"
> >> +#include "qapi/error.h"
> >> +#include "target/ppc/cpu.h"
> >> +#include "sysemu/cpus.h"
> >> +#include "sysemu/dma.h"
> >> +#include "monitor/monitor.h"
> >> +#include "hw/ppc/xive.h"
> >> +
> >> +/*
> >> + * XIVE ESB helpers
> >> + */
> >> +
> >> +static uint8_t xive_esb_set(uint8_t *pq, uint8_t value)
> >> +{
> >> +    uint8_t old_pq =3D *pq & 0x3;
> >> +
> >> +    *pq &=3D ~0x3;
> >> +    *pq |=3D value & 0x3;
> >> +
> >> +    return old_pq;
> >> +}
> >> +
> >> +static bool xive_esb_trigger(uint8_t *pq)
> >> +{
> >> +    uint8_t old_pq =3D *pq & 0x3;
> >> +
> >> +    switch (old_pq) {
> >> +    case XIVE_ESB_RESET:
> >> +        xive_esb_set(pq, XIVE_ESB_PENDING);
> >> +        return true;
> >> +    case XIVE_ESB_PENDING:
> >> +    case XIVE_ESB_QUEUED:
> >> +        xive_esb_set(pq, XIVE_ESB_QUEUED);
> >> +        return false;
> >> +    case XIVE_ESB_OFF:
> >> +        xive_esb_set(pq, XIVE_ESB_OFF);
> >> +        return false;
> >> +    default:
> >> +         g_assert_not_reached();
> >> +    }
> >> +}
> >> +
> >> +static bool xive_esb_eoi(uint8_t *pq)
> >> +{
> >> +    uint8_t old_pq =3D *pq & 0x3;
> >> +
> >> +    switch (old_pq) {
> >> +    case XIVE_ESB_RESET:
> >> +    case XIVE_ESB_PENDING:
> >> +        xive_esb_set(pq, XIVE_ESB_RESET);
> >> +        return false;
> >> +    case XIVE_ESB_QUEUED:
> >> +        xive_esb_set(pq, XIVE_ESB_PENDING);
> >> +        return true;
> >> +    case XIVE_ESB_OFF:
> >> +        xive_esb_set(pq, XIVE_ESB_OFF);
> >> +        return false;
> >> +    default:
> >> +         g_assert_not_reached();
> >> +    }
> >> +}
> >> +
> >> +/*
> >> + * XIVE Interrupt Source (or IVSE)
> >> + */
> >> +
> >> +uint8_t xive_source_esb_get(XiveSource *xsrc, uint32_t srcno)
> >> +{
> >> +    assert(srcno < xsrc->nr_irqs);
> >> +
> >> +    return xsrc->status[srcno] & 0x3;
> >> +}
> >> +
> >> +uint8_t xive_source_esb_set(XiveSource *xsrc, uint32_t srcno, uint8_t=
 pq)
> >> +{
> >> +    assert(srcno < xsrc->nr_irqs);
> >> +
> >> +    return xive_esb_set(&xsrc->status[srcno], pq);
> >> +}
> >> +
> >> +/*
> >> + * Returns whether the event notification should be forwarded.
> >> + */
> >> +static bool xive_source_esb_trigger(XiveSource *xsrc, uint32_t srcno)
> >> +{
> >> +    assert(srcno < xsrc->nr_irqs);
> >> +
> >> +    return xive_esb_trigger(&xsrc->status[srcno]);
> >> +}
> >> +
> >> +/*
> >> + * Returns whether the event notification should be forwarded.
> >> + */
> >> +static bool xive_source_esb_eoi(XiveSource *xsrc, uint32_t srcno)
> >> +{
> >> +    assert(srcno < xsrc->nr_irqs);
> >> +
> >> +    return xive_esb_eoi(&xsrc->status[srcno]);
> >> +}
> >> +
> >> +/*
> >> + * Forward the source event notification to the Router
> >> + */
> >> +static void xive_source_notify(XiveSource *xsrc, int srcno)
> >> +{
> >> +
> >> +}
> >> +
> >> +/*
> >> + * In a two pages ESB MMIO setting, even page is the trigger page, odd
> >> + * page is for management
> >> + */
> >> +static inline bool addr_is_even(hwaddr addr, uint32_t shift)
> >> +{
> >> +    return !((addr >> shift) & 1);
> >> +}
> >> +
> >> +static inline bool xive_source_is_trigger_page(XiveSource *xsrc, hwad=
dr addr)
> >> +{
> >> +    return xive_source_esb_has_2page(xsrc) &&
> >> +        addr_is_even(addr, xsrc->esb_shift - 1);
> >> +}
> >> +
> >> +/*
> >> + * ESB MMIO loads
> >> + *                      Trigger page    Management/EOI page
> >> + * 2 pages setting      even            odd
> >> + *
> >> + * 0x000 .. 0x3FF       -1              EOI and return 0|1
> >> + * 0x400 .. 0x7FF       -1              EOI and return 0|1
> >> + * 0x800 .. 0xBFF       -1              return PQ
> >> + * 0xC00 .. 0xCFF       -1              return PQ and atomically PQ=
=3D0
> >> + * 0xD00 .. 0xDFF       -1              return PQ and atomically PQ=
=3D0
> >> + * 0xE00 .. 0xDFF       -1              return PQ and atomically PQ=
=3D1
> >> + * 0xF00 .. 0xDFF       -1              return PQ and atomically PQ=
=3D1
> >> + */
> >=20
> > I can't quite make sense of this table.  What do the -1s represent,
>=20
> the value returned by the load.
>=20
> > and how does it relate to the non-2page case?
>=20
> one page ESB support trigger and management on the same page. So for load=
s,
> the odd page behavior applies. =20
>=20
> >> +static uint64_t xive_source_esb_read(void *opaque, hwaddr addr, unsig=
ned size)
> >> +{
> >> +    XiveSource *xsrc =3D XIVE_SOURCE(opaque);
> >> +    uint32_t offset =3D addr & 0xFFF;
> >> +    uint32_t srcno =3D addr >> xsrc->esb_shift;
> >> +    uint64_t ret =3D -1;
> >> +
> >> +    /* In a two pages ESB MMIO setting, trigger page should not be re=
ad */
> >> +    if (xive_source_is_trigger_page(xsrc, addr)) {
> >> +        qemu_log_mask(LOG_GUEST_ERROR,
> >> +                      "XIVE: invalid load on IRQ %d trigger page at "
> >> +                      "0x%"HWADDR_PRIx"\n", srcno, addr);
> >> +        return -1;
> >> +    }
> >> +
> >> +    switch (offset) {
> >> +    case XIVE_ESB_LOAD_EOI ... XIVE_ESB_LOAD_EOI + 0x7FF:
> >> +        ret =3D xive_source_esb_eoi(xsrc, srcno);
> >> +
> >> +        /* Forward the source event notification for routing */
> >> +        if (ret) {
> >> +            xive_source_notify(xsrc, srcno);
> >> +        }
> >> +        break;
> >> +
> >> +    case XIVE_ESB_GET ... XIVE_ESB_GET + 0x3FF:
> >> +        ret =3D xive_source_esb_get(xsrc, srcno);
> >> +        break;
> >> +
> >> +    case XIVE_ESB_SET_PQ_00 ... XIVE_ESB_SET_PQ_00 + 0x0FF:
> >> +    case XIVE_ESB_SET_PQ_01 ... XIVE_ESB_SET_PQ_01 + 0x0FF:
> >> +    case XIVE_ESB_SET_PQ_10 ... XIVE_ESB_SET_PQ_10 + 0x0FF:
> >> +    case XIVE_ESB_SET_PQ_11 ... XIVE_ESB_SET_PQ_11 + 0x0FF:
> >> +        ret =3D xive_source_esb_set(xsrc, srcno, (offset >> 8) & 0x3);
> >> +        break;
> >> +    default:
> >> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid ESB load addr %=
x\n",
> >> +                      offset);
> >> +    }
> >> +
> >> +    return ret;
> >> +}
> >> +
> >> +/*
> >> + * ESB MMIO stores
> >> + *                      Trigger page    Management/EOI page
> >> + * 2 pages setting      even            odd
> >=20
> > As with the previous table, I don't quite understand what the headings
> > above mean.
>=20
> one page ESB support trigger and management on the same page. So for stor=
es,
> the odd page behavior applies.
>=20
> The headings can be improved. I will think of something.
>=20
> >> + * 0x000 .. 0x3FF       Trigger         Trigger
> >> + * 0x400 .. 0x7FF       Trigger         EOI
> >> + * 0x800 .. 0xBFF       Trigger         undefined
> >> + * 0xC00 .. 0xCFF       Trigger         PQ=3D00
> >> + * 0xD00 .. 0xDFF       Trigger         PQ=3D01
> >> + * 0xE00 .. 0xDFF       Trigger         PQ=3D10
> >> + * 0xF00 .. 0xDFF       Trigger         PQ=3D11
> >> + */
> >> +static void xive_source_esb_write(void *opaque, hwaddr addr,
> >> +                                  uint64_t value, unsigned size)
> >> +{
> >> +    XiveSource *xsrc =3D XIVE_SOURCE(opaque);
> >> +    uint32_t offset =3D addr & 0xFFF;
> >> +    uint32_t srcno =3D addr >> xsrc->esb_shift;
> >> +    bool notify =3D false;
> >> +
> >> +    /* In a two pages ESB MMIO setting, trigger page only triggers */
> >> +    if (xive_source_is_trigger_page(xsrc, addr)) {
> >> +        notify =3D xive_source_esb_trigger(xsrc, srcno);
> >> +        goto out;
> >> +    }
> >> +
> >> +    switch (offset) {
> >> +    case 0 ... 0x3FF:
> >> +        notify =3D xive_source_esb_trigger(xsrc, srcno);
> >> +        break;
> >> +
> >> +    case XIVE_ESB_STORE_EOI ... XIVE_ESB_STORE_EOI + 0x3FF:
> >> +        if (!(xsrc->esb_flags & XIVE_SRC_STORE_EOI)) {
> >> +            qemu_log_mask(LOG_GUEST_ERROR,
> >> +                          "XIVE: invalid Store EOI for IRQ %d\n", src=
no);
> >> +            return;
> >> +        }
> >> +
> >> +        notify =3D xive_source_esb_eoi(xsrc, srcno);
> >> +        break;
> >> +
> >> +    case XIVE_ESB_SET_PQ_00 ... XIVE_ESB_SET_PQ_00 + 0x0FF:
> >> +    case XIVE_ESB_SET_PQ_01 ... XIVE_ESB_SET_PQ_01 + 0x0FF:
> >> +    case XIVE_ESB_SET_PQ_10 ... XIVE_ESB_SET_PQ_10 + 0x0FF:
> >> +    case XIVE_ESB_SET_PQ_11 ... XIVE_ESB_SET_PQ_11 + 0x0FF:
> >> +        xive_source_esb_set(xsrc, srcno, (offset >> 8) & 0x3);
> >> +        break;
> >> +
> >> +    default:
> >> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid ESB write addr =
%x\n",
> >> +                      offset);
> >> +        return;
> >> +    }
> >> +
> >> +out:
> >> +    /* Forward the source event notification for routing */
> >> +    if (notify) {
> >> +        xive_source_notify(xsrc, srcno);
> >> +    }
> >> +}
> >> +
> >> +static const MemoryRegionOps xive_source_esb_ops =3D {
> >> +    .read =3D xive_source_esb_read,
> >> +    .write =3D xive_source_esb_write,
> >> +    .endianness =3D DEVICE_BIG_ENDIAN,
> >> +    .valid =3D {
> >> +        .min_access_size =3D 8,
> >> +        .max_access_size =3D 8,
> >> +    },
> >> +    .impl =3D {
> >> +        .min_access_size =3D 8,
> >> +        .max_access_size =3D 8,
> >> +    },
> >> +};
> >> +
> >> +static void xive_source_set_irq(void *opaque, int srcno, int val)
> >> +{
> >> +    XiveSource *xsrc =3D XIVE_SOURCE(opaque);
> >> +    bool notify =3D false;
> >> +
> >> +    if (val) {
> >> +        notify =3D xive_source_esb_trigger(xsrc, srcno);
> >> +    }
> >> +
> >> +    /* Forward the source event notification for routing */
> >> +    if (notify) {
> >> +        xive_source_notify(xsrc, srcno);
> >> +    }
> >> +}
> >> +
> >> +void xive_source_pic_print_info(XiveSource *xsrc, uint32_t offset, Mo=
nitor *mon)
> >> +{
> >> +    int i;
> >> +
> >> +    for (i =3D 0; i < xsrc->nr_irqs; i++) {
> >> +        uint8_t pq =3D xive_source_esb_get(xsrc, i);
> >> +
> >> +        if (pq =3D=3D XIVE_ESB_OFF) {
> >> +            continue;
> >> +        }
> >> +
> >> +        monitor_printf(mon, "  %08x %c%c\n", i + offset,
> >> +                       pq & XIVE_ESB_VAL_P ? 'P' : '-',
> >> +                       pq & XIVE_ESB_VAL_Q ? 'Q' : '-');
> >> +    }
> >> +}
> >> +
> >> +static void xive_source_reset(DeviceState *dev)
> >> +{
> >> +    XiveSource *xsrc =3D XIVE_SOURCE(dev);
> >> +
> >> +    /* PQs are initialized to 0b01 which corresponds to "ints off" */
> >> +    memset(xsrc->status, 0x1, xsrc->nr_irqs);
> >=20
> > You've already got XIVE_ESB_OFF defined to make this a little clearer.
>=20
> Sure.
>=20
> Thanks,
>=20
> C.=20
>=20
>=20
> >=20
> >> +}
> >> +
> >> +static void xive_source_realize(DeviceState *dev, Error **errp)
> >> +{
> >> +    XiveSource *xsrc =3D XIVE_SOURCE(dev);
> >> +
> >> +    if (!xsrc->nr_irqs) {
> >> +        error_setg(errp, "Number of interrupt needs to be greater tha=
n 0");
> >> +        return;
> >> +    }
> >> +
> >> +    if (xsrc->esb_shift !=3D XIVE_ESB_4K &&
> >> +        xsrc->esb_shift !=3D XIVE_ESB_4K_2PAGE &&
> >> +        xsrc->esb_shift !=3D XIVE_ESB_64K &&
> >> +        xsrc->esb_shift !=3D XIVE_ESB_64K_2PAGE) {
> >> +        error_setg(errp, "Invalid ESB shift setting");
> >> +        return;
> >> +    }
> >> +
> >> +    xsrc->qirqs =3D qemu_allocate_irqs(xive_source_set_irq, xsrc,
> >> +                                     xsrc->nr_irqs);
> >> +
> >> +    xsrc->status =3D g_malloc0(xsrc->nr_irqs);
> >> +
> >> +    memory_region_init_io(&xsrc->esb_mmio, OBJECT(xsrc),
> >> +                          &xive_source_esb_ops, xsrc, "xive.esb",
> >> +                          (1ull << xsrc->esb_shift) * xsrc->nr_irqs);
> >> +    sysbus_init_mmio(SYS_BUS_DEVICE(dev), &xsrc->esb_mmio);
> >> +}
> >> +
> >> +static const VMStateDescription vmstate_xive_source =3D {
> >> +    .name =3D TYPE_XIVE_SOURCE,
> >> +    .version_id =3D 1,
> >> +    .minimum_version_id =3D 1,
> >> +    .fields =3D (VMStateField[]) {
> >> +        VMSTATE_UINT32_EQUAL(nr_irqs, XiveSource, NULL),
> >> +        VMSTATE_VBUFFER_UINT32(status, XiveSource, 1, NULL, nr_irqs),
> >> +        VMSTATE_END_OF_LIST()
> >> +    },
> >> +};
> >> +
> >> +/*
> >> + * The default XIVE interrupt source setting for the ESB MMIOs is two
> >> + * 64k pages without Store EOI, to be in sync with KVM.
> >> + */
> >> +static Property xive_source_properties[] =3D {
> >> +    DEFINE_PROP_UINT64("flags", XiveSource, esb_flags, 0),
> >> +    DEFINE_PROP_UINT32("nr-irqs", XiveSource, nr_irqs, 0),
> >> +    DEFINE_PROP_UINT32("shift", XiveSource, esb_shift, XIVE_ESB_64K_2=
PAGE),
> >> +    DEFINE_PROP_END_OF_LIST(),
> >> +};
> >> +
> >> +static void xive_source_class_init(ObjectClass *klass, void *data)
> >> +{
> >> +    DeviceClass *dc =3D DEVICE_CLASS(klass);
> >> +
> >> +    dc->desc    =3D "XIVE Interrupt Source";
> >> +    dc->props   =3D xive_source_properties;
> >> +    dc->realize =3D xive_source_realize;
> >> +    dc->reset   =3D xive_source_reset;
> >> +    dc->vmsd    =3D &vmstate_xive_source;
> >> +}
> >> +
> >> +static const TypeInfo xive_source_info =3D {
> >> +    .name          =3D TYPE_XIVE_SOURCE,
> >> +    .parent        =3D TYPE_SYS_BUS_DEVICE,
> >> +    .instance_size =3D sizeof(XiveSource),
> >> +    .class_init    =3D xive_source_class_init,
> >> +};
> >> +
> >> +static void xive_register_types(void)
> >> +{
> >> +    type_register_static(&xive_source_info);
> >> +}
> >> +
> >> +type_init(xive_register_types)
> >> diff --git a/hw/intc/Makefile.objs b/hw/intc/Makefile.objs
> >> index 0e9963f5eecc..72a46ed91c31 100644
> >> --- a/hw/intc/Makefile.objs
> >> +++ b/hw/intc/Makefile.objs
> >> @@ -37,6 +37,7 @@ obj-$(CONFIG_SH4) +=3D sh_intc.o
> >>  obj-$(CONFIG_XICS) +=3D xics.o
> >>  obj-$(CONFIG_XICS_SPAPR) +=3D xics_spapr.o
> >>  obj-$(CONFIG_XICS_KVM) +=3D xics_kvm.o
> >> +obj-$(CONFIG_XIVE) +=3D xive.o
> >>  obj-$(CONFIG_POWERNV) +=3D xics_pnv.o
> >>  obj-$(CONFIG_ALLWINNER_A10_PIC) +=3D allwinner-a10-pic.o
> >>  obj-$(CONFIG_S390_FLIC) +=3D s390_flic.o
> >=20
>=20

--=20
David Gibson			| I'll have my music baroque, and my code
david AT gibson.dropbear.id.au	| minimalist, thank you.  NOT _the_ _other_
				| _way_ _around_!
http://www.ozlabs.org/~dgibson

--Hnpg0BSo5EvPlUVi
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEdfRlhq5hpmzETofcbDjKyiDZs5IFAlv3SlMACgkQbDjKyiDZ
s5IeaRAAhccpz1SfdTIl0Uy9RtRAgQO7fQnq9O8AlP3EcSeEigrs5XPcwoJA7+1L
S37r8W9YvZ3hEKlaH5a1H97lpNnJ6g6wKVrk8ddVymTwNJKGXMQw11LzYHeXfhXn
qA6y2kC9L5Js6pBRtnChj4nTMK67bVeP3EHHm/8QCE5UnIIwlQ1+6in8g4/3b7Bz
9qBpibRHUF3VQ6DaXrp8zJ2h8LhHRwiXBl4ewNTOIaeXQVYotNyd6+emzAp6qGI6
BPDXz1n3TPK/XVTDZFvX9+drBqcyrbHPE5eL/jRTcO8iY443fERGqGomypoiG8Xw
usid2YCwXW024x+vxKFd4avY4WAj6md4qAV/N+npc5p+kr444ID43eR7vhCIXnYX
+HePrVsuIIifaUkKXj0xy9qwICk0Myd59V4MSu2eubVX5pF8Y5t/NB6AaCu/SJFz
6S16tO4JC4/3fcWPor3yuSoWcNtZtum5JYwphdSBl0uCTW4eEAb8sU5haKor/7EF
WrxyYr5F2FBsEZ02IlrAb8X94E6OZ5KOFhogefLhpOw9YgyHf9hC58L4keekgePC
UepukI07I87kykEa0Ou1kQ1oHyga7X1Vu7R+D09dQZdMvAVLcZ9N84CLzmzmjtS0
SXDGyAqXwr9+ZCq806ECNHZW0Tt3yNOskXAihKIQfKW3xRW96k4=
=N+tF
-----END PGP SIGNATURE-----

--Hnpg0BSo5EvPlUVi--

