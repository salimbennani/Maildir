Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 26 Nov 2018 08:52:19 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 994455803C2
	for <like.xu@linux.intel.com>; Sun, 25 Nov 2018 13:26:14 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 25 Nov 2018 13:26:14 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AsZR/iRMntGfXwKKxns0l6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0K/z9rsbcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Qiqp4bt1RxD0iS?=
 =?us-ascii?q?cHLz85/3/Risxsl6JQvRatqwViz4LIfI2ZMfxzdb7fc9wHX2pMRthfVyJBDI2/?=
 =?us-ascii?q?YYUAAeUOMuREoIfyulUOtRmzCwujCe/yxDJEmmH53bYh3uQ9EgzLxhAsE84AvX?=
 =?us-ascii?q?nWqtj+KaccUfqyzKnN1TjNdfNW2Tb56IjJahAhue+DUqp3f8XL1UkvFwLFgUuN?=
 =?us-ascii?q?qYD8MT2azPkNvHWB6OF9Uu+vk24nqwB1ojiq28ghkZPJiZwIxVDE7yp53Jw5Ks?=
 =?us-ascii?q?G/SE5+eNOpFoZbuSKCN4ZuXM8uX2JltDwnxrEbupO3ZjYGxZonyhLFdvCKcZCE?=
 =?us-ascii?q?7gz5W+qNPDt1gWxqdby/ihu38kWv0PDwVsex3VlXsiVJj8XAu3UW2BPP7sWIVP?=
 =?us-ascii?q?5w/kmg1DqS2A3e7/9ILl01mKXALpMswKI/mYYXvEnFAyT4gl/5jLWMeUUh4uWo?=
 =?us-ascii?q?6/roYrHhppKEM490ixr+Mrg1msClDuQ4NBUOU3Kc+eSm273v5Uz5QLNUgf0qiq?=
 =?us-ascii?q?TVrozWKMcBqqKkHgNY0Zwv5wixAjqmytgUgHsKIEpAeB2djojpP1/OIOr/Dfe6?=
 =?us-ascii?q?m1msiSlkx/XbPrH4H5rCMGbDn6nlfbpk8EFczxczzdZD6J1KEbENJ/bzWk7ytN?=
 =?us-ascii?q?PGFBM4PBG0zv7jCNV80IMeRG2ODrWYMKPUrV+H+OYvL/OQa48SvTbwMP4l5/no?=
 =?us-ascii?q?jX82n18dYLOl3ZwNaHC3BvhmOVmWYWLwgtcdFmcHpg4+TO3piFKcSzJSaGuyUr?=
 =?us-ascii?q?k45jE6DoKmEIjCSpqsgLyHwCe0AJlWanpaBVCLFHe7P7iCQOoGPSKOPtd6wHtD?=
 =?us-ascii?q?Ubm6V5Rn0xaouwnnjb19Ia3R8ywcsJvlk99t++zUkwp17DFxEoGR3n+ASzJJmH?=
 =?us-ascii?q?gVTWoz1aF7vUsv01qGzO10juJVEZlJ6upUXxwmHZjbyeN8Fpb1QA2WZcqDSlut?=
 =?us-ascii?q?XoC7ByosRMk62d4EbhVBHICGkxuL+iuhA7IR3+iPGZdy96PX33X1D8lnxnvAz6?=
 =?us-ascii?q?4qlB8tRc4ZcSW/i6tisgTeGYPNu0OekamsaOIbxiGe2n2EyD+2vEBcURZoXJLg?=
 =?us-ascii?q?VGwfZ0bL6Pjw+09DB+u2CbUjNwdp08OOKqJWLNbuiAMVF7/YJN3CbjfpyC+LDh?=
 =?us-ascii?q?GSy+bJNdKydg=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0APAAD4EftbhxHrdtBhGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUwQBAQELAYEwgmKDeYh3ix+BYC2XPIFzEgEBGBSIWiI2Bw0BAwEBAQE?=
 =?us-ascii?q?BAQIBEwEBAQoLCQgbDi+CNgUCAxoBBoJcAQIDAQIgBAsBEwopAwMBAgYBAQoYA?=
 =?us-ascii?q?gIiBAICAwEwAQUBHAYBDAYCAQEBgxyBdQ0BBJoZPIsNfDOFQINKgQ0SeYp+F4F?=
 =?us-ascii?q?/gREngmuIAoJXAoh/hhqQaQmRKQYYiVGHN5gJAgQCBAUCBQ8hgSwFggEzIhsVg?=
 =?us-ascii?q?yeCJxeOHXGBByGKMoF3AQE?=
X-IPAS-Result: =?us-ascii?q?A0APAAD4EftbhxHrdtBhGwEBAQEDAQEBBwMBAQGBUwQBAQE?=
 =?us-ascii?q?LAYEwgmKDeYh3ix+BYC2XPIFzEgEBGBSIWiI2Bw0BAwEBAQEBAQIBEwEBAQoLC?=
 =?us-ascii?q?QgbDi+CNgUCAxoBBoJcAQIDAQIgBAsBEwopAwMBAgYBAQoYAgIiBAICAwEwAQU?=
 =?us-ascii?q?BHAYBDAYCAQEBgxyBdQ0BBJoZPIsNfDOFQINKgQ0SeYp+F4F/gREngmuIAoJXA?=
 =?us-ascii?q?oh/hhqQaQmRKQYYiVGHN5gJAgQCBAUCBQ8hgSwFggEzIhsVgyeCJxeOHXGBByG?=
 =?us-ascii?q?KMoF3AQE?=
X-IronPort-AV: E=Sophos;i="5.56,279,1539673200"; 
   d="scan'208";a="53618959"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 25 Nov 2018 13:26:13 -0800
Received: from localhost ([::1]:33162 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gR1uv-0006SR-05
	for like.xu@linux.intel.com; Sun, 25 Nov 2018 16:26:13 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:43765)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <philmd@redhat.com>) id 1gR1Tm-0006tY-Rx
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 15:58:11 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <philmd@redhat.com>) id 1gR1Ti-0002HF-KU
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 15:58:10 -0500
Received: from mail-wr1-f67.google.com ([209.85.221.67]:41014)
	by eggs.gnu.org with esmtps (TLS1.0:RSA_AES_128_CBC_SHA1:16)
	(Exim 4.71) (envelope-from <philmd@redhat.com>) id 1gR1Ti-0002GW-C3
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 15:58:06 -0500
Received: by mail-wr1-f67.google.com with SMTP id x10so16864516wrs.8
	for <qemu-devel@nongnu.org>; Sun, 25 Nov 2018 12:58:06 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:subject:to:cc:references:from:openpgp:message-id
	:date:user-agent:mime-version:in-reply-to:content-language
	:content-transfer-encoding;
	bh=KQIaSPkG6tLj0SqBEOlWs3aKmyQyyZoGO8dDXx+z4aw=;
	b=kTxkqgf62ul8M9MAV750KtDtcL/dY/tPEaOUr8jvelSX66k518NSSrthL9GO301RZL
	KGaIK4DOJwSOU2V1O2zO0v5vR7rnYfgdXCIS8nLaBgrBZzs4gqoyd/pMnDfnk1lE5j/A
	k1tsqWdrxOM5fF1/szY+/y3IuiHDm8rvHX9WXqHRJN6WoWCcjkwhITJLAlUpvs7l4VmH
	3Y29n8Vt1Z9eca4tVfZw1kK3ODPOHdP8XLbztPdZvHMup2DQMZ6X+viB4b6W3iIazsZy
	NUvbfJn+XbCFy0qP+afZy8HUrXMEdNQT6Uq+p3sJqzk1Wg1Ax+ws5maA1aBg1nMMh01r
	6kHA==
X-Gm-Message-State: AA+aEWbcyy+lgFLf1ioZpWCW75kyjk7o6+AFSUhlyL8RR3A1nxTnY+WL
	oh+mlY19SRGiPui/G9CaZujNTg==
X-Google-Smtp-Source: AFSGD/W05nSuAE437Db20m61+5i5eqhnpUH3FqUPlEQNfM97v51sdZ3tAvHw7R7VrcNMFez+RmKBuA==
X-Received: by 2002:adf:a357:: with SMTP id d23mr22055086wrb.195.1543179485287;
	Sun, 25 Nov 2018 12:58:05 -0800 (PST)
Received: from ?IPv6:2a01:e35:8a1f:dc10:bc9e:f614:2d6b:7cc9?
	([2a01:e35:8a1f:dc10:bc9e:f614:2d6b:7cc9])
	by smtp.gmail.com with ESMTPSA id
	g198sm16669466wmd.23.2018.11.25.12.58.02
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Sun, 25 Nov 2018 12:58:04 -0800 (PST)
To: Luc Michel <luc.michel@greensocs.com>, qemu-devel@nongnu.org
References: <20181123091729.29921-1-luc.michel@greensocs.com>
	<20181123091729.29921-3-luc.michel@greensocs.com>
From: =?UTF-8?Q?Philippe_Mathieu-Daud=c3=a9?= <philmd@redhat.com>
Openpgp: url=http://pgp.mit.edu/pks/lookup?op=get&search=0xA2A3FD6EDEADC0DE
Message-ID: <c9b126f0-2f2b-3fee-49f0-b04f11dac041@redhat.com>
Date: Sun, 25 Nov 2018 21:58:00 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
	Thunderbird/60.3.0
MIME-Version: 1.0
In-Reply-To: <20181123091729.29921-3-luc.michel@greensocs.com>
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: 8bit
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 209.85.221.67
Subject: Re: [Qemu-devel] [PATCH v7 02/16] gdbstub: introduce GDB processes
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Peter Maydell <peter.maydell@linaro.org>,
	Eduardo Habkost <ehabkost@redhat.com>, alistair@alistair23.me,
	mark.burton@greensocs.com,
	=?UTF-8?Q?Philippe_Mathieu-Daud=c3=a9?= <f4bug@amsat.org>,
	saipava@xilinx.com, edgari@xilinx.com, qemu-arm@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On 23/11/18 10:17, Luc Michel wrote:
> Add a structure GDBProcess that represent processes from the GDB
> semantic point of view.
> 
> CPUs can be split into different processes, by grouping them under
> different cpu-cluster objects.  Each occurrence of a cpu-cluster object
> implies the existence of the corresponding process in the GDB stub. The
> GDB process ID is derived from the corresponding cluster ID as follows:
> 
>   GDB PID = cluster ID + 1
> 
> This is because PIDs -1 and 0 are reserved in GDB and cannot be used by
> processes.
> 
> When no such container are found, all the CPUs are put in a unique GDB
> process (create_unique_process()). This is also the case when compiled
> in user mode, where multi-processes do not make much sense for now.
> 
> Signed-off-by: Luc Michel <luc.michel@greensocs.com>
> Acked-by: Alistair Francis <alistair.francis@wdc.com>
> Reviewed-by: Edgar E. Iglesias <edgar.iglesias@xilinx.com>
> ---
>  gdbstub.c | 87 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
>  1 file changed, 87 insertions(+)
> 
> diff --git a/gdbstub.c b/gdbstub.c
> index c4e4f9f082..26f5a7449a 100644
> --- a/gdbstub.c
> +++ b/gdbstub.c
> @@ -27,10 +27,11 @@
>  #include "monitor/monitor.h"
>  #include "chardev/char.h"
>  #include "chardev/char-fe.h"
>  #include "sysemu/sysemu.h"
>  #include "exec/gdbstub.h"
> +#include "hw/cpu/cluster.h"
>  #endif
>  
>  #define MAX_PACKET_LENGTH 4096
>  
>  #include "qemu/sockets.h"
> @@ -294,10 +295,15 @@ typedef struct GDBRegisterState {
>      gdb_reg_cb set_reg;
>      const char *xml;
>      struct GDBRegisterState *next;
>  } GDBRegisterState;
>  
> +typedef struct GDBProcess {
> +    uint32_t pid;
> +    bool attached;
> +} GDBProcess;
> +
>  enum RSState {
>      RS_INACTIVE,
>      RS_IDLE,
>      RS_GETLINE,
>      RS_GETLINE_ESC,
> @@ -322,10 +328,13 @@ typedef struct GDBState {
>      int running_state;
>  #else
>      CharBackend chr;
>      Chardev *mon_chr;
>  #endif
> +    bool multiprocess;
> +    GDBProcess *processes;
> +    int process_num;
>      char syscall_buf[256];
>      gdb_syscall_complete_cb current_syscall_cb;
>  } GDBState;
>  
>  /* By default use no IRQs and no timers while single stepping so as to
> @@ -1749,10 +1758,24 @@ void gdb_exit(CPUArchState *env, int code)
>  #ifndef CONFIG_USER_ONLY
>    qemu_chr_fe_deinit(&s->chr, true);
>  #endif
>  }
>  
> +/*
> + * Create a unique process containing all the CPUs.
> + */
> +static void create_unique_process(GDBState *s)
> +{
> +    GDBProcess *process;
> +
> +    s->processes = g_malloc0(sizeof(GDBProcess));

good place to use:

       s->processes = g_new0(GDBProcess, 1);

Regardless:
Reviewed-by: Philippe Mathieu-Daudé <philmd@redhat.com>

> +    s->process_num = 1;
> +    process = &s->processes[0];
> +
> +    process->pid = 1;
> +}
> +
>  #ifdef CONFIG_USER_ONLY
>  int
>  gdb_handlesig(CPUState *cpu, int sig)
>  {
>      GDBState *s;
> @@ -1846,10 +1869,11 @@ static bool gdb_accept(void)
>      }
>  
>      s = g_malloc0(sizeof(GDBState));
>      s->c_cpu = first_cpu;
>      s->g_cpu = first_cpu;
> +    create_unique_process(s);
>      s->fd = fd;
>      gdb_has_xml = false;
>  
>      gdbserver_state = s;
>      return true;
> @@ -2002,10 +2026,69 @@ static const TypeInfo char_gdb_type_info = {
>      .name = TYPE_CHARDEV_GDB,
>      .parent = TYPE_CHARDEV,
>      .class_init = char_gdb_class_init,
>  };
>  
> +static int find_cpu_clusters(Object *child, void *opaque)
> +{
> +    if (object_dynamic_cast(child, TYPE_CPU_CLUSTER)) {
> +        GDBState *s = (GDBState *) opaque;
> +        CPUClusterState *cluster = CPU_CLUSTER(child);
> +        GDBProcess *process;
> +
> +        s->processes = g_renew(GDBProcess, s->processes, ++s->process_num);
> +
> +        process = &s->processes[s->process_num - 1];
> +
> +        /*
> +         * GDB process IDs -1 and 0 are reserved. To avoid subtle errors at
> +         * runtime, we enforce here that the machine does not use a cluster ID
> +         * that would lead to PID 0. */
> +        assert(process->pid != UINT32_MAX);
> +        process->pid = cluster->cluster_id + 1;
> +        process->attached = false;
> +
> +        return 0;
> +    }
> +
> +    return object_child_foreach(child, find_cpu_clusters, opaque);
> +}
> +
> +static int pid_order(const void *a, const void *b)
> +{
> +    GDBProcess *pa = (GDBProcess *) a;
> +    GDBProcess *pb = (GDBProcess *) b;
> +
> +    if (pa->pid < pb->pid) {
> +        return -1;
> +    } else if (pa->pid > pb->pid) {
> +        return 1;
> +    } else {
> +        return 0;
> +    }
> +}
> +
> +static void create_processes(GDBState *s)
> +{
> +    object_child_foreach(object_get_root(), find_cpu_clusters, s);
> +
> +    if (!s->processes) {
> +        /* No CPU cluster specified by the machine */
> +        create_unique_process(s);
> +    } else {
> +        /* Sort by PID */
> +        qsort(s->processes, s->process_num, sizeof(s->processes[0]), pid_order);
> +    }
> +}
> +
> +static void cleanup_processes(GDBState *s)
> +{
> +    g_free(s->processes);
> +    s->process_num = 0;
> +    s->processes = NULL;
> +}
> +
>  int gdbserver_start(const char *device)
>  {
>      trace_gdbstub_op_start(device);
>  
>      GDBState *s;
> @@ -2058,15 +2141,19 @@ int gdbserver_start(const char *device)
>                                     NULL, &error_abort);
>          monitor_init(mon_chr, 0);
>      } else {
>          qemu_chr_fe_deinit(&s->chr, true);
>          mon_chr = s->mon_chr;
> +        cleanup_processes(s);
>          memset(s, 0, sizeof(GDBState));
>          s->mon_chr = mon_chr;
>      }
>      s->c_cpu = first_cpu;
>      s->g_cpu = first_cpu;
> +
> +    create_processes(s);
> +
>      if (chr) {
>          qemu_chr_fe_init(&s->chr, chr, &error_abort);
>          qemu_chr_fe_set_handlers(&s->chr, gdb_chr_can_receive, gdb_chr_receive,
>                                   gdb_chr_event, NULL, NULL, NULL, true);
>      }
> 

