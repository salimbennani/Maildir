Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 25 Nov 2018 14:43:06 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga008.fm.intel.com (fmsmga008.fm.intel.com [10.253.24.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 993835803C2
	for <like.xu@linux.intel.com>; Sat, 24 Nov 2018 16:25:53 -0800 (PST)
Received: from fmsmga105.fm.intel.com ([10.1.193.10])
  by fmsmga008-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 24 Nov 2018 16:25:53 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AfLN4Vx8/uyIzG/9uRHKM819IXTAuvvDOBiVQ1KB+?=
 =?us-ascii?q?0+gTIJqq85mqBkHD//Il1AaPAd2Lraocw8Pt8InYEVQa5piAtH1QOLdtbDQizf?=
 =?us-ascii?q?ssogo7HcSeAlf6JvO5JwYzHcBFSUM3tyrjaRsdF8nxfUDdrWOv5jAOBBr/KRB1?=
 =?us-ascii?q?JuPoEYLOksi7ze+/94HQbglSmDaxfa55IQmrownWqsQYm5ZpJLwryhvOrHtIeu?=
 =?us-ascii?q?BWyn1tKFmOgRvy5dq+8YB6/ShItP0v68BPUaPhf6QlVrNYFygpM3o05MLwqxbO?=
 =?us-ascii?q?SxaE62YGXWUXlhpIBBXF7A3/U5zsvCb2qvZx1S+HNsDtU7s6RSqt4LtqSB/wiS?=
 =?us-ascii?q?cIKTg58H3MisdtiK5XuQ+tqwBjz4LRZoyeKfhwcb7Hfd4CR2VBUMZfWSJCDI2i?=
 =?us-ascii?q?c4QBEvIBMORaoYTyulcDoweyChe3BO701j9EmmX70bEm3+g9EwzL2hErEdIUsH?=
 =?us-ascii?q?TTqdX4LLsfUeSrw6nL1jXMdfVW1irn54jSbxsvpuuDXahzccrW10kvFh/KhUiX?=
 =?us-ascii?q?pIP/OzOayOcNs3OB4OpmSO2gkXQnpxt0ojS1w8cjkIjJhoYOx1DL8CV22oc1Jd?=
 =?us-ascii?q?miREFnZt6kFYJduieHPIV1WsMvW39ktDo5x7EcpJK3YSsHxI45yxPRa/GLaZWE?=
 =?us-ascii?q?7xD7WOqPIDp0mHBodbexhxux6kes1ujxW8a33VtLoSdIl8fAumwI2hHW9MSLVO?=
 =?us-ascii?q?dy80G80jiVzQ/T8PtLIUUsmKrbNZEhxrkwm4IXsUTCBS/2hF72gLWZdkUi5+ik?=
 =?us-ascii?q?8ePnYq/pppOENo90jB/xMrg2l8ChHeg1MRICU3WG9em/zrHv40P0TbVQgvErkK?=
 =?us-ascii?q?TVqJXaKt4apq69DQ9VyIEj6xOnAje/ztsYmGQHIEtYdx2ZkYjmJVXOLOnjAve4?=
 =?us-ascii?q?nlSslitkyO7dPrHmBpXNL3vDn6n7cbdy9k5R0A4zzdFZ55JJBbANOvPzWknttN?=
 =?us-ascii?q?PGCh81KRC7w+HiCNhm0IMeXmSPAqCfMKPPq1OI4fgvI+aUaI8PpDn9M+Ql5+Lp?=
 =?us-ascii?q?jXIhnV8dfKqp0oUNZHG3A/RrOEGZYXvqgtccHmYGpAs+TOr2iFKcVT5ffWq9X6?=
 =?us-ascii?q?U55mJzNYS9EI2WRpyxmKfTm2C/H4ZKfSZADVaDF2qucJ+LHPIFaSaXK8kmlSQY?=
 =?us-ascii?q?VL+nUMg42BSz8QP31bdjfdfS4TAS4Jfq1dxp4L/KmBQvsDB5EcmZlnuAVnx5hX?=
 =?us-ascii?q?8gQTgw06Zi50tnxQCYzKJ6jvdEQMFV/O5DSQwgNJTRnNB9XprfXwPFf9DBZxDu?=
 =?us-ascii?q?adK6CHt5Gtk239YmaVx0Es3kiQrMiXmEGbgQwpWPCZ8v+6TQ1mK5As9nyHHY1a?=
 =?us-ascii?q?Jp21AiT8hUPGuqj7Q58k7WDo/Nu0qcnqeuM68b2Xiepy+40WOSsRQAA0ZLWqLf?=
 =?us-ascii?q?UCVaPxOOoA=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0A7BAAM6/lbhxHrdtBYCoIXgTGCYoN5i?=
 =?us-ascii?q?HeLISmBZHqJEY0xgWwbGBSBS4cPIjUIDQEDAQEBAQEBAgETAQEBCgsJCBsOIwy?=
 =?us-ascii?q?CNgUCAxoBBoJcAQICAQECIAQZAQUKDB0BAgEBAQECBgEBBQULDwIiBAICAwEeA?=
 =?us-ascii?q?REBBQEcBhMFgxyBaQEDDQgBBJhlPIsNfBYFAReCdwWELgoZJw1agTcCBhJ5in5?=
 =?us-ascii?q?6gRyBEYJdNYRTgy+CVwKIfxIShXaFNoszBwKCII8PGJEIlUCCYQ8hgScBggpNI?=
 =?us-ascii?q?4EBgjuCJxeDSopTQDGBB4pngXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0A7BAAM6/lbhxHrdtBYCoIXgTGCYoN5iHeLISmBZHqJEY0?=
 =?us-ascii?q?xgWwbGBSBS4cPIjUIDQEDAQEBAQEBAgETAQEBCgsJCBsOIwyCNgUCAxoBBoJcA?=
 =?us-ascii?q?QICAQECIAQZAQUKDB0BAgEBAQECBgEBBQULDwIiBAICAwEeAREBBQEcBhMFgxy?=
 =?us-ascii?q?BaQEDDQgBBJhlPIsNfBYFAReCdwWELgoZJw1agTcCBhJ5in56gRyBEYJdNYRTg?=
 =?us-ascii?q?y+CVwKIfxIShXaFNoszBwKCII8PGJEIlUCCYQ8hgScBggpNI4EBgjuCJxeDSop?=
 =?us-ascii?q?TQDGBB4pngXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,276,1539673200"; 
   d="scan'208";a="139426617"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 24 Nov 2018 16:25:52 -0800
Received: from localhost ([::1]:58244 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQiFD-0002n1-ND
	for like.xu@linux.intel.com; Sat, 24 Nov 2018 19:25:51 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:36660)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <aleksandar.m.mail@gmail.com>) id 1gQiEx-0002mf-2D
	for qemu-devel@nongnu.org; Sat, 24 Nov 2018 19:25:37 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <aleksandar.m.mail@gmail.com>) id 1gQiEu-0007FM-4x
	for qemu-devel@nongnu.org; Sat, 24 Nov 2018 19:25:34 -0500
Received: from mail-oi1-x22c.google.com ([2607:f8b0:4864:20::22c]:34572)
	by eggs.gnu.org with esmtps (TLS1.0:RSA_AES_128_CBC_SHA1:16)
	(Exim 4.71) (envelope-from <aleksandar.m.mail@gmail.com>)
	id 1gQiEr-00073A-77
	for qemu-devel@nongnu.org; Sat, 24 Nov 2018 19:25:31 -0500
Received: by mail-oi1-x22c.google.com with SMTP id h25so12805258oig.1
	for <qemu-devel@nongnu.org>; Sat, 24 Nov 2018 16:25:26 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20161025;
	h=mime-version:in-reply-to:references:from:date:message-id:subject:to
	:cc; bh=1JbSLwyLZreA0crC8ELWaHvFB+xm3YAmI4t39eIlo2E=;
	b=m+2g6wn2mLFnRVgyr/MWqF6TRgbzv/fgtU0CJZjEmUSYQi2GKDHtjRiyjq0+ThSCwT
	2GqxvBM7zYtm9aNgAsaMqnp5TkM/yrHhIe5CugSCWDKV/1PYHKGr070Y7YhmrS+YOBzG
	GlYI0OL8jxfbGwLv57IOAX3LnqylXM8KdSRU0rkzIXOxQg7Av2bUo2Dsy5gTEn/2TJGp
	dde2N8bxo0ai5MAl/2x7d6+j1Q1mYAHEa1BoGHW2lblIUvlpdKgEARH7cLa9uQ7w/7VH
	yshTs8BjWM93iqUZoj3w30VUtztPUO+g3v1hf1EcuWVvA0iIigN8UB0Ft/NHTQJx0S+4
	cViw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:mime-version:in-reply-to:references:from:date
	:message-id:subject:to:cc;
	bh=1JbSLwyLZreA0crC8ELWaHvFB+xm3YAmI4t39eIlo2E=;
	b=udNmo19sGHeLqqvHWnE89lLOwjdfTsFw0mNjrpy+uTMAAC75FXSOc/tSlTc2CS6/vD
	5md2Ypw2v99ETkDKkw6Y/yISmGvQDVkv6doy/ENp+fGrOgt4vuvskfsZerLHvZKaxrGq
	rMwTgWW9k9vNQvjp33ncSgyCzkjH8snCjDCE38pmY69CNFppI/+6DRCbZXwdL/Mx1tQB
	1pU5x2oUXLl9mD3DmS6A2znuPR39vSeZYdTrxsbJtam2NdFc+NeCVPaH0b33NCzavOaR
	nYqTxYlvcYoIc8l2YofnhSco8DOklDyISUxOM5dfqe/IZzqMMCst6b7C/9CldBsAZ3PJ
	ehzw==
X-Gm-Message-State: AGRZ1gIfr3AHz+7JLVhiSkaJ+DfoGwx1epAzUJdwzg61UZbc9JKOis9Z
	rBdaewkFfiRXHeInBmInbDqsz2KoHJ/eQ037EEc=
X-Google-Smtp-Source: AJdET5e8/5Ov5h+ot/WsdkqXCK8G4wbNvUQ4SsM0X4hZl/kfOUsNmuvaSWdjxtvIGj15UYWxsSLWggs1frbHniHXpFk=
X-Received: by 2002:aca:5344:: with SMTP id h65mr12179499oib.13.1543105525938; 
	Sat, 24 Nov 2018 16:25:25 -0800 (PST)
MIME-Version: 1.0
Received: by 2002:a05:6830:1504:0:0:0:0 with HTTP; Sat, 24 Nov 2018 16:25:25
	-0800 (PST)
Received: by 2002:a05:6830:1504:0:0:0:0 with HTTP; Sat, 24 Nov 2018 16:25:25
	-0800 (PST)
In-Reply-To: <20181124235553.17371-8-cota@braap.org>
References: <20181124235553.17371-1-cota@braap.org>
	<20181124235553.17371-8-cota@braap.org>
From: Aleksandar Markovic <aleksandar.m.mail@gmail.com>
Date: Sun, 25 Nov 2018 01:25:25 +0100
Message-ID: <CAL1e-=gL0s2-zLgBYQrW1=VSOB=LepzDgDS08P7qGNAiOynsyg@mail.gmail.com>
To: "Emilio G. Cota" <cota@braap.org>
X-detected-operating-system: by eggs.gnu.org: Genre and OS details not
	recognized.
X-Received-From: 2607:f8b0:4864:20::22c
Content-Type: text/plain; charset="UTF-8"
X-Content-Filtered-By: Mailman/MimeDel 2.1.21
Subject: Re: [Qemu-devel] [PATCH v6 07/13] fpu: introduce hardfloat
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: =?UTF-8?B?QWxleCBCZW5uw6ll?= <alex.bennee@linaro.org>,
	Richard Henderson <richard.henderson@linaro.org>, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

Hi, Emilio.

> Note: some architectures (at least PPC, there might be others) clear
> the status flags passed to softfloat before most FP operations. This
> precludes the use of hardfloat, so to avoid introducing a performance
> regression for those targets, we add a flag to disable hardfloat.
> In the long run though it would be good to fix the targets so that
> at least the inexact flag passed to softfloat is indeed sticky.

Can you elaborate more on this paragraph?

Thanks,
Aleksandar Markovic
On Nov 25, 2018 1:08 AM, "Emilio G. Cota" <cota@braap.org> wrote:

> The appended paves the way for leveraging the host FPU for a subset
> of guest FP operations. For most guest workloads (e.g. FP flags
> aren't ever cleared, inexact occurs often and rounding is set to the
> default [to nearest]) this will yield sizable performance speedups.
>
> The approach followed here avoids checking the FP exception flags register.
> See the added comment for details.
>
> This assumes that QEMU is running on an IEEE754-compliant FPU and
> that the rounding is set to the default (to nearest). The
> implementation-dependent specifics of the FPU should not matter; things
> like tininess detection and snan representation are still dealt with in
> soft-fp. However, this approach will break on most hosts if we compile
> QEMU with flags such as -ffast-math. We control the flags so this should
> be easy to enforce though.
>
> This patch just adds common code. Some operations will be migrated
> to hardfloat in subsequent patches to ease bisection.
>
> Note: some architectures (at least PPC, there might be others) clear
> the status flags passed to softfloat before most FP operations. This
> precludes the use of hardfloat, so to avoid introducing a performance
> regression for those targets, we add a flag to disable hardfloat.
> In the long run though it would be good to fix the targets so that
> at least the inexact flag passed to softfloat is indeed sticky.
>
> Signed-off-by: Emilio G. Cota <cota@braap.org>
> ---
>  fpu/softfloat.c | 315 ++++++++++++++++++++++++++++++++++++++++++++++++
>  1 file changed, 315 insertions(+)
>
> diff --git a/fpu/softfloat.c b/fpu/softfloat.c
> index ecdc00c633..306a12fa8d 100644
> --- a/fpu/softfloat.c
> +++ b/fpu/softfloat.c
> @@ -83,6 +83,7 @@ this code that are retained.
>   * target-dependent and needs the TARGET_* macros.
>   */
>  #include "qemu/osdep.h"
> +#include <math.h>
>  #include "qemu/bitops.h"
>  #include "fpu/softfloat.h"
>
> @@ -95,6 +96,320 @@ this code that are retained.
>  *-----------------------------------------------------------
> -----------------*/
>  #include "fpu/softfloat-macros.h"
>
> +/*
> + * Hardfloat
> + *
> + * Fast emulation of guest FP instructions is challenging for two reasons.
> + * First, FP instruction semantics are similar but not identical,
> particularly
> + * when handling NaNs. Second, emulating at reasonable speed the guest FP
> + * exception flags is not trivial: reading the host's flags register with
> a
> + * feclearexcept & fetestexcept pair is slow [slightly slower than
> soft-fp],
> + * and trapping on every FP exception is not fast nor pleasant to work
> with.
> + *
> + * We address these challenges by leveraging the host FPU for a subset of
> the
> + * operations. To do this we expand on the idea presented in this paper:
> + *
> + * Guo, Yu-Chuan, et al. "Translating the ARM Neon and VFP instructions
> in a
> + * binary translator." Software: Practice and Experience 46.12
> (2016):1591-1615.
> + *
> + * The idea is thus to leverage the host FPU to (1) compute FP operations
> + * and (2) identify whether FP exceptions occurred while avoiding
> + * expensive exception flag register accesses.
> + *
> + * An important optimization shown in the paper is that given that
> exception
> + * flags are rarely cleared by the guest, we can avoid recomputing some
> flags.
> + * This is particularly useful for the inexact flag, which is very
> frequently
> + * raised in floating-point workloads.
> + *
> + * We optimize the code further by deferring to soft-fp whenever FP
> exception
> + * detection might get hairy. Two examples: (1) when at least one operand
> is
> + * denormal/inf/NaN; (2) when operands are not guaranteed to lead to a 0
> result
> + * and the result is < the minimum normal.
> + */
> +#define GEN_INPUT_FLUSH__NOCHECK(name, soft_t)                          \
> +    static inline void name(soft_t *a, float_status *s)                 \
> +    {                                                                   \
> +        if (unlikely(soft_t ## _is_denormal(*a))) {                     \
> +            *a = soft_t ## _set_sign(soft_t ## _zero,                   \
> +                                     soft_t ## _is_neg(*a));            \
> +            s->float_exception_flags |= float_flag_input_denormal;      \
> +        }                                                               \
> +    }
> +
> +GEN_INPUT_FLUSH__NOCHECK(float32_input_flush__nocheck, float32)
> +GEN_INPUT_FLUSH__NOCHECK(float64_input_flush__nocheck, float64)
> +#undef GEN_INPUT_FLUSH__NOCHECK
> +
> +#define GEN_INPUT_FLUSH1(name, soft_t)                  \
> +    static inline void name(soft_t *a, float_status *s) \
> +    {                                                   \
> +        if (likely(!s->flush_inputs_to_zero)) {         \
> +            return;                                     \
> +        }                                               \
> +        soft_t ## _input_flush__nocheck(a, s);          \
> +    }
> +
> +GEN_INPUT_FLUSH1(float32_input_flush1, float32)
> +GEN_INPUT_FLUSH1(float64_input_flush1, float64)
> +#undef GEN_INPUT_FLUSH1
> +
> +#define GEN_INPUT_FLUSH2(name, soft_t)                                  \
> +    static inline void name(soft_t *a, soft_t *b, float_status *s)      \
> +    {                                                                   \
> +        if (likely(!s->flush_inputs_to_zero)) {                         \
> +            return;                                                     \
> +        }                                                               \
> +        soft_t ## _input_flush__nocheck(a, s);                          \
> +        soft_t ## _input_flush__nocheck(b, s);                          \
> +    }
> +
> +GEN_INPUT_FLUSH2(float32_input_flush2, float32)
> +GEN_INPUT_FLUSH2(float64_input_flush2, float64)
> +#undef GEN_INPUT_FLUSH2
> +
> +#define GEN_INPUT_FLUSH3(name, soft_t)                                  \
> +    static inline void name(soft_t *a, soft_t *b, soft_t *c, float_status
> *s) \
> +    {                                                                   \
> +        if (likely(!s->flush_inputs_to_zero)) {                         \
> +            return;                                                     \
> +        }                                                               \
> +        soft_t ## _input_flush__nocheck(a, s);                          \
> +        soft_t ## _input_flush__nocheck(b, s);                          \
> +        soft_t ## _input_flush__nocheck(c, s);                          \
> +    }
> +
> +GEN_INPUT_FLUSH3(float32_input_flush3, float32)
> +GEN_INPUT_FLUSH3(float64_input_flush3, float64)
> +#undef GEN_INPUT_FLUSH3
> +
> +/*
> + * Choose whether to use fpclassify or float32/64_* primitives in the
> generated
> + * hardfloat functions. Each combination of number of inputs and float
> size
> + * gets its own value.
> + */
> +#if defined(__x86_64__)
> +# define QEMU_HARDFLOAT_1F32_USE_FP 0
> +# define QEMU_HARDFLOAT_1F64_USE_FP 1
> +# define QEMU_HARDFLOAT_2F32_USE_FP 0
> +# define QEMU_HARDFLOAT_2F64_USE_FP 1
> +# define QEMU_HARDFLOAT_3F32_USE_FP 0
> +# define QEMU_HARDFLOAT_3F64_USE_FP 1
> +#else
> +# define QEMU_HARDFLOAT_1F32_USE_FP 0
> +# define QEMU_HARDFLOAT_1F64_USE_FP 0
> +# define QEMU_HARDFLOAT_2F32_USE_FP 0
> +# define QEMU_HARDFLOAT_2F64_USE_FP 0
> +# define QEMU_HARDFLOAT_3F32_USE_FP 0
> +# define QEMU_HARDFLOAT_3F64_USE_FP 0
> +#endif
> +
> +/*
> + * QEMU_HARDFLOAT_USE_ISINF chooses whether to use isinf() over
> + * float{32,64}_is_infinity when !USE_FP.
> + * On x86_64/aarch64, using the former over the latter can yield a ~6%
> speedup.
> + * On power64 however, using isinf() reduces fp-bench performance by up
> to 50%.
> + */
> +#if defined(__x86_64__) || defined(__aarch64__)
> +# define QEMU_HARDFLOAT_USE_ISINF   1
> +#else
> +# define QEMU_HARDFLOAT_USE_ISINF   0
> +#endif
> +
> +/*
> + * Some targets clear the FP flags before most FP operations. This
> prevents
> + * the use of hardfloat, since hardfloat relies on the inexact flag being
> + * already set.
> + */
> +#if defined(TARGET_PPC)
> +# define QEMU_NO_HARDFLOAT 1
> +# define QEMU_SOFTFLOAT_ATTR QEMU_FLATTEN
> +#else
> +# define QEMU_NO_HARDFLOAT 0
> +# define QEMU_SOFTFLOAT_ATTR QEMU_FLATTEN __attribute__((noinline))
> +#endif
> +
> +static inline bool can_use_fpu(const float_status *s)
> +{
> +    if (QEMU_NO_HARDFLOAT) {
> +        return false;
> +    }
> +    return likely(s->float_exception_flags & float_flag_inexact &&
> +                  s->float_rounding_mode == float_round_nearest_even);
> +}
> +
> +/*
> + * Hardfloat generation functions. Each operation can have two flavors:
> + * either using softfloat primitives (e.g. float32_is_zero_or_normal) for
> + * most condition checks, or native ones (e.g. fpclassify).
> + *
> + * The flavor is chosen by the callers. Instead of using macros, we rely
> on the
> + * compiler to propagate constants and inline everything into the callers.
> + *
> + * We only generate functions for operations with two inputs, since only
> + * these are common enough to justify consolidating them into common code.
> + */
> +
> +typedef union {
> +    float32 s;
> +    float h;
> +} union_float32;
> +
> +typedef union {
> +    float64 s;
> +    double h;
> +} union_float64;
> +
> +typedef bool (*f32_check_fn)(union_float32 a, union_float32 b);
> +typedef bool (*f64_check_fn)(union_float64 a, union_float64 b);
> +
> +typedef float32 (*soft_f32_op2_fn)(float32 a, float32 b, float_status *s);
> +typedef float64 (*soft_f64_op2_fn)(float64 a, float64 b, float_status *s);
> +typedef float   (*hard_f32_op2_fn)(float a, float b);
> +typedef double  (*hard_f64_op2_fn)(double a, double b);
> +
> +/* 2-input is-zero-or-normal */
> +static inline bool f32_is_zon2(union_float32 a, union_float32 b)
> +{
> +    if (QEMU_HARDFLOAT_2F32_USE_FP) {
> +        /*
> +         * Not using a temp variable for consecutive fpclassify calls
> ends up
> +         * generating faster code.
> +         */
> +        return (fpclassify(a.h) == FP_NORMAL || fpclassify(a.h) ==
> FP_ZERO) &&
> +               (fpclassify(b.h) == FP_NORMAL || fpclassify(b.h) ==
> FP_ZERO);
> +    }
> +    return float32_is_zero_or_normal(a.s) &&
> +           float32_is_zero_or_normal(b.s);
> +}
> +
> +static inline bool f64_is_zon2(union_float64 a, union_float64 b)
> +{
> +    if (QEMU_HARDFLOAT_2F64_USE_FP) {
> +        return (fpclassify(a.h) == FP_NORMAL || fpclassify(a.h) ==
> FP_ZERO) &&
> +               (fpclassify(b.h) == FP_NORMAL || fpclassify(b.h) ==
> FP_ZERO);
> +    }
> +    return float64_is_zero_or_normal(a.s) &&
> +           float64_is_zero_or_normal(b.s);
> +}
> +
> +/* 3-input is-zero-or-normal */
> +static inline
> +bool f32_is_zon3(union_float32 a, union_float32 b, union_float32 c)
> +{
> +    if (QEMU_HARDFLOAT_3F32_USE_FP) {
> +        return (fpclassify(a.h) == FP_NORMAL || fpclassify(a.h) ==
> FP_ZERO) &&
> +               (fpclassify(b.h) == FP_NORMAL || fpclassify(b.h) ==
> FP_ZERO) &&
> +               (fpclassify(c.h) == FP_NORMAL || fpclassify(c.h) ==
> FP_ZERO);
> +    }
> +    return float32_is_zero_or_normal(a.s) &&
> +           float32_is_zero_or_normal(b.s) &&
> +           float32_is_zero_or_normal(c.s);
> +}
> +
> +static inline
> +bool f64_is_zon3(union_float64 a, union_float64 b, union_float64 c)
> +{
> +    if (QEMU_HARDFLOAT_3F64_USE_FP) {
> +        return (fpclassify(a.h) == FP_NORMAL || fpclassify(a.h) ==
> FP_ZERO) &&
> +               (fpclassify(b.h) == FP_NORMAL || fpclassify(b.h) ==
> FP_ZERO) &&
> +               (fpclassify(c.h) == FP_NORMAL || fpclassify(c.h) ==
> FP_ZERO);
> +    }
> +    return float64_is_zero_or_normal(a.s) &&
> +           float64_is_zero_or_normal(b.s) &&
> +           float64_is_zero_or_normal(c.s);
> +}
> +
> +static inline bool f32_is_inf(union_float32 a)
> +{
> +    if (QEMU_HARDFLOAT_USE_ISINF) {
> +        return isinff(a.h);
> +    }
> +    return float32_is_infinity(a.s);
> +}
> +
> +static inline bool f64_is_inf(union_float64 a)
> +{
> +    if (QEMU_HARDFLOAT_USE_ISINF) {
> +        return isinf(a.h);
> +    }
> +    return float64_is_infinity(a.s);
> +}
> +
> +/* Note: @fast_test and @post can be NULL */
> +static inline float32
> +float32_gen2(float32 xa, float32 xb, float_status *s,
> +             hard_f32_op2_fn hard, soft_f32_op2_fn soft,
> +             f32_check_fn pre, f32_check_fn post,
> +             f32_check_fn fast_test, soft_f32_op2_fn fast_op)
> +{
> +    union_float32 ua, ub, ur;
> +
> +    ua.s = xa;
> +    ub.s = xb;
> +
> +    if (unlikely(!can_use_fpu(s))) {
> +        goto soft;
> +    }
> +
> +    float32_input_flush2(&ua.s, &ub.s, s);
> +    if (unlikely(!pre(ua, ub))) {
> +        goto soft;
> +    }
> +    if (fast_test && fast_test(ua, ub)) {
> +        return fast_op(ua.s, ub.s, s);
> +    }
> +
> +    ur.h = hard(ua.h, ub.h);
> +    if (unlikely(f32_is_inf(ur))) {
> +        s->float_exception_flags |= float_flag_overflow;
> +    } else if (unlikely(fabsf(ur.h) <= FLT_MIN)) {
> +        if (post == NULL || post(ua, ub)) {
> +            goto soft;
> +        }
> +    }
> +    return ur.s;
> +
> + soft:
> +    return soft(ua.s, ub.s, s);
> +}
> +
> +static inline float64
> +float64_gen2(float64 xa, float64 xb, float_status *s,
> +             hard_f64_op2_fn hard, soft_f64_op2_fn soft,
> +             f64_check_fn pre, f64_check_fn post,
> +             f64_check_fn fast_test, soft_f64_op2_fn fast_op)
> +{
> +    union_float64 ua, ub, ur;
> +
> +    ua.s = xa;
> +    ub.s = xb;
> +
> +    if (unlikely(!can_use_fpu(s))) {
> +        goto soft;
> +    }
> +
> +    float64_input_flush2(&ua.s, &ub.s, s);
> +    if (unlikely(!pre(ua, ub))) {
> +        goto soft;
> +    }
> +    if (fast_test && fast_test(ua, ub)) {
> +        return fast_op(ua.s, ub.s, s);
> +    }
> +
> +    ur.h = hard(ua.h, ub.h);
> +    if (unlikely(f64_is_inf(ur))) {
> +        s->float_exception_flags |= float_flag_overflow;
> +    } else if (unlikely(fabs(ur.h) <= DBL_MIN)) {
> +        if (post == NULL || post(ua, ub)) {
> +            goto soft;
> +        }
> +    }
> +    return ur.s;
> +
> + soft:
> +    return soft(ua.s, ub.s, s);
> +}
> +
>  /*----------------------------------------------------------
> ------------------
>  | Returns the fraction bits of the half-precision floating-point value
> `a'.
>  *-----------------------------------------------------------
> -----------------*/
> --
> 2.17.1
>
>
>
