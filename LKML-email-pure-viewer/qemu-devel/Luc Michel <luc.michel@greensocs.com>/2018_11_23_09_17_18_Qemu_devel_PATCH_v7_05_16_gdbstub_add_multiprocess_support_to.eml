Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:33:06 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga006.jf.intel.com (orsmga006.jf.intel.com [10.7.209.51])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 032D358037D
	for <like.xu@linux.intel.com>; Fri, 23 Nov 2018 01:28:27 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by orsmga006-1.jf.intel.com with ESMTP; 23 Nov 2018 01:28:26 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AhOKl4B2k9XiBqHDksmDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?seMQKfad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWpPUNhfWSJCBY2z?=
 =?us-ascii?q?bYUPAOUdMuhXsof9v1kDoxmxCAWxCu7j1iFHhmTt0K0myuQsCx3K0RY8E98Mtn?=
 =?us-ascii?q?nfsdX7NL0VUeCw1KTGyyjDYO9L0jn66YjHbhAhru+IXbltdsfRzVQvGB/fglWV?=
 =?us-ascii?q?qIzqIzOV2foJs2WA4OpgT/yghHAhqwFqpTig2twshpPViYISz1DJ7CN0y5s2K9?=
 =?us-ascii?q?2gUEN3f8KoHZhKuy2HKod7QdkuT39mtSs60LEKpJy2cDAOxZg73RLTduGLf5aS?=
 =?us-ascii?q?7h/hW+udOzR1iGxjdbminRi961Kgxff5VsSs0FZFsC5Fkt7Uu3AJ1hzT8dSHSu?=
 =?us-ascii?q?Bn8keu3zaPyhrf6uZeIUA7jabbKpghzaAslpcLr0jPAiz7lF/rgKOLdUgo4Pak?=
 =?us-ascii?q?5urnb7n8u5ORNZd4igTkPaQvnsy/D/44Mg8LX2WD4OSzyrjj/VDgTLpXkPI2jL?=
 =?us-ascii?q?fWsJTDKcsAoa65HglV3Zo95BakCDum1NUYnXoZI15fdxOHkpDkO1XPIPD+EPe+?=
 =?us-ascii?q?jE6gkDZtx/DaILLhBo/BIWTEkLfkZrt97UlcyAw8zdBZ+pJYELYBIOj8WkPprt?=
 =?us-ascii?q?zXEgc5MxCow+bgENh90oIeWWGRDaODP6LSrESF5uYuI+mKeY8UtyzxK/kj5/7y?=
 =?us-ascii?q?k3A5nUURcrWu3ZsSOziFGO97KRCZfWb0mYVGVmMLpRYlCurtjlKETHhUfXn1Wq?=
 =?us-ascii?q?s94jQyDsWhFZvCQYa2x6WM2Tr+EpBIa2QVN1aXDH29coyFX+sLOjufJ9IknjEa?=
 =?us-ascii?q?WLzkUYI4yBy1qCf8zLxoKPeS/TcX4on+3tp47PGGiBcp6DZvBN6c2Wzec2Yhh2?=
 =?us-ascii?q?4NWno60b5ypWR7zVGM17U+hOZXRvJJ4PYcdhoxfbvdxOx3D5imXh/KONKIQ1ar?=
 =?us-ascii?q?Rv2pGzw8SMk2yMRIaEF4TYbxxivf1janVudG34eAA4Y5p+eFhyD8?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AYAAA7x/dbhxHrdtBiHgEGBwaBUggLA?=
 =?us-ascii?q?YEwUIISg3mId4segweWQYFzFBgUiFUiNQgNAQMBAQEBAQECARMBAQEKCwkIKSM?=
 =?us-ascii?q?MgjYFAgMaAQaCXAMDAQIgBBkBAQQKKQECAwECBgEBJAIiBAICAwEoKxkFgxyCA?=
 =?us-ascii?q?gEDAaY3cHwzgnYBAQWCQ4RPCIELhlODD4EcgVc/gRGCXYg3glegBAcCghwEjwQ?=
 =?us-ascii?q?jkQiYMIEmIQGCC00jgzyCGwwXEoM4ilNxgQQDiiuBdwEB?=
X-IPAS-Result: =?us-ascii?q?A0AYAAA7x/dbhxHrdtBiHgEGBwaBUggLAYEwUIISg3mId4s?=
 =?us-ascii?q?egweWQYFzFBgUiFUiNQgNAQMBAQEBAQECARMBAQEKCwkIKSMMgjYFAgMaAQaCX?=
 =?us-ascii?q?AMDAQIgBBkBAQQKKQECAwECBgEBJAIiBAICAwEoKxkFgxyCAgEDAaY3cHwzgnY?=
 =?us-ascii?q?BAQWCQ4RPCIELhlODD4EcgVc/gRGCXYg3glegBAcCghwEjwQjkQiYMIEmIQGCC?=
 =?us-ascii?q?00jgzyCGwwXEoM4ilNxgQQDiiuBdwEB?=
X-IronPort-AV: E=Sophos;i="5.56,269,1539673200"; 
   d="scan'208";a="41279404"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 23 Nov 2018 01:28:26 -0800
Received: from localhost ([::1]:51209 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQ7lA-0000p3-Tk
	for like.xu@linux.intel.com; Fri, 23 Nov 2018 04:28:24 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:57967)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <luc.michel@greensocs.com>) id 1gQ7b2-0007vo-OR
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 04:17:59 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <luc.michel@greensocs.com>) id 1gQ7b1-0000k7-2P
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 04:17:56 -0500
Received: from greensocs.com ([193.104.36.180]:47081)
	by eggs.gnu.org with esmtp (Exim 4.71)
	(envelope-from <luc.michel@greensocs.com>)
	id 1gQ7au-0000Xy-58; Fri, 23 Nov 2018 04:17:48 -0500
Received: from localhost (localhost [127.0.0.1])
	by greensocs.com (Postfix) with ESMTP id 39D405C0259;
	Fri, 23 Nov 2018 10:17:36 +0100 (CET)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=greensocs.com;
	s=mail; t=1542964656;
	bh=WGwApLbecnlIWPCTr31Qe7wkqbNbnQf6q5Yo5WQ1aIc=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References;
	b=GSLU2dKncUyVP2JsnCEsMJaUPFyCXuqaAvxrppJA3ye1j0IS0CnI3ReNKNgKSknIe
	r4wT547JDOqYPCrFMdVi8OSoqM2tV0aNSDj1yO6WbqiHX1JGZ5ML7SIWIq31LJi3Ky
	+GmykpA5YNwA26kISSCGX9Jy9cb6+KfdHSti/iHE=
X-Virus-Scanned: amavisd-new at greensocs.com
Authentication-Results: gs-01.greensocs.com (amavisd-new);
	dkim=pass (1024-bit key) header.d=greensocs.com header.b=lJ4R/AiT;
	dkim=pass (1024-bit key) header.d=greensocs.com header.b=dbWChZ+6
Received: from greensocs.com ([127.0.0.1])
	by localhost (gs-01.greensocs.com [127.0.0.1]) (amavisd-new, port 10024)
	with ESMTP id DFMFmygzAPcl; Fri, 23 Nov 2018 10:17:35 +0100 (CET)
Received: by greensocs.com (Postfix, from userid 998)
	id 19A2B5C025D; Fri, 23 Nov 2018 10:17:34 +0100 (CET)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=greensocs.com;
	s=mail; t=1542964654;
	bh=WGwApLbecnlIWPCTr31Qe7wkqbNbnQf6q5Yo5WQ1aIc=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References;
	b=lJ4R/AiTSbiFy84gjHamHNTFbJw/7oVpwIjy6lXpBwO3t/oFLWJ9N3Jg1prcvJIpR
	wgDoL+/odwtkZE3duxpisZ1T03+gk/6TBPX9zyW5eTN4tgJICS8Bf3xoUxnPDIP9yA
	LWfGIAxWYjL2I0eIiV4hbjkGc4StAPcrOQVLk/YU=
Received: from michell-laptop.home.lmichel.fr
	(lfbn-1-8165-82.w90-112.abo.wanadoo.fr [90.112.74.82])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	(Authenticated sender: luc.michel@greensocs.com)
	by greensocs.com (Postfix) with ESMTPSA id 84F2B5C025C;
	Fri, 23 Nov 2018 10:17:33 +0100 (CET)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=greensocs.com;
	s=mail; t=1542964653;
	bh=WGwApLbecnlIWPCTr31Qe7wkqbNbnQf6q5Yo5WQ1aIc=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References;
	b=dbWChZ+6HxGil4m3JVdvmZumwXXhz13bnKxWGN5uiIyeTK/Fu6InkyCPv3IznfoI2
	MQiY02HWNydUU0EGDVQv3yQrsoOzGZgjjjqbOm5osWr631R600vLlzVUv77WqA7v2X
	fLatAU3TbNtMDScUNK+zrgGH+2nmDiMlS81eYREk=
From: Luc Michel <luc.michel@greensocs.com>
To: qemu-devel@nongnu.org
Date: Fri, 23 Nov 2018 10:17:18 +0100
Message-Id: <20181123091729.29921-6-luc.michel@greensocs.com>
X-Mailer: git-send-email 2.19.1
In-Reply-To: <20181123091729.29921-1-luc.michel@greensocs.com>
References: <20181123091729.29921-1-luc.michel@greensocs.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 3.x [fuzzy]
X-Received-From: 193.104.36.180
Subject: [Qemu-devel] [PATCH v7 05/16] gdbstub: add multiprocess support to
 vCont packets
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Peter Maydell <peter.maydell@linaro.org>,
	Eduardo Habkost <ehabkost@redhat.com>, alistair@alistair23.me,
	mark.burton@greensocs.com,
	=?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <f4bug@amsat.org>,
	saipava@xilinx.com, edgari@xilinx.com, qemu-arm@nongnu.org,
	Luc Michel <luc.michel@greensocs.com>
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

Add the gdb_first_attached_cpu() and gdb_next_attached_cpu() to iterate
over all the CPUs in currently attached processes.

Add the gdb_first_cpu_in_process() and gdb_next_cpu_in_process() to
iterate over CPUs of a given process.

Use them to add multiprocess extension support to vCont packets.

Signed-off-by: Luc Michel <luc.michel@greensocs.com>
Reviewed-by: Philippe Mathieu-Daud=C3=A9 <philmd@redhat.com>
Reviewed-by: Edgar E. Iglesias <edgar.iglesias@xilinx.com>
Acked-by: Alistair Francis <alistair.francis@wdc.com>
---
 gdbstub.c | 117 +++++++++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 102 insertions(+), 15 deletions(-)

diff --git a/gdbstub.c b/gdbstub.c
index 64a1db21b5..691b877aa8 100644
--- a/gdbstub.c
+++ b/gdbstub.c
@@ -716,10 +716,40 @@ static CPUState *find_cpu(uint32_t thread_id)
     }
=20
     return NULL;
 }
=20
+static CPUState *get_first_cpu_in_process(const GDBState *s,
+                                          GDBProcess *process)
+{
+    CPUState *cpu;
+
+    CPU_FOREACH(cpu) {
+        if (gdb_get_cpu_pid(s, cpu) =3D=3D process->pid) {
+            return cpu;
+        }
+    }
+
+    return NULL;
+}
+
+static CPUState *gdb_next_cpu_in_process(const GDBState *s, CPUState *cp=
u)
+{
+    uint32_t pid =3D gdb_get_cpu_pid(s, cpu);
+    cpu =3D CPU_NEXT(cpu);
+
+    while (cpu) {
+        if (gdb_get_cpu_pid(s, cpu) =3D=3D pid) {
+            break;
+        }
+
+        cpu =3D CPU_NEXT(cpu);
+    }
+
+    return cpu;
+}
+
 static CPUState *gdb_get_cpu(const GDBState *s, uint32_t pid, uint32_t t=
id)
 {
     GDBProcess *process;
     CPUState *cpu;
=20
@@ -745,10 +775,41 @@ static CPUState *gdb_get_cpu(const GDBState *s, uin=
t32_t pid, uint32_t tid)
     }
=20
     return cpu;
 }
=20
+/* Return the cpu following @cpu, while ignoring
+ * unattached processes.
+ */
+static CPUState *gdb_next_attached_cpu(const GDBState *s, CPUState *cpu)
+{
+    cpu =3D CPU_NEXT(cpu);
+
+    while (cpu) {
+        if (gdb_get_cpu_process(s, cpu)->attached) {
+            break;
+        }
+
+        cpu =3D CPU_NEXT(cpu);
+    }
+
+    return cpu;
+}
+
+/* Return the first attached cpu */
+static CPUState *gdb_first_attached_cpu(const GDBState *s)
+{
+    CPUState *cpu =3D first_cpu;
+    GDBProcess *process =3D gdb_get_cpu_process(s, cpu);
+
+    if (!process->attached) {
+        return gdb_next_attached_cpu(s, cpu);
+    }
+
+    return cpu;
+}
+
 static const char *get_feature_xml(const char *p, const char **newp,
                                    CPUClass *cc)
 {
     size_t len;
     int i;
@@ -1083,14 +1144,16 @@ static int is_query_packet(const char *p, const c=
har *query, char separator)
  * returns -ENOTSUP if a command is unsupported, -EINVAL or -ERANGE if t=
here is
  *         a format error, 0 on success.
  */
 static int gdb_handle_vcont(GDBState *s, const char *p)
 {
-    int res, idx, signal =3D 0;
+    int res, signal =3D 0;
     char cur_action;
     char *newstates;
     unsigned long tmp;
+    uint32_t pid, tid;
+    GDBProcess *process;
     CPUState *cpu;
 #ifdef CONFIG_USER_ONLY
     int max_cpus =3D 1; /* global variable max_cpus exists only in syste=
m mode */
=20
     CPU_FOREACH(cpu) {
@@ -1129,29 +1192,52 @@ static int gdb_handle_vcont(GDBState *s, const ch=
ar *p)
         } else if (cur_action !=3D 'c' && cur_action !=3D 's') {
             /* unknown/invalid/unsupported command */
             res =3D -ENOTSUP;
             goto out;
         }
-        /* thread specification. special values: (none), -1 =3D all; 0 =3D=
 any */
-        if ((p[0] =3D=3D ':' && p[1] =3D=3D '-' && p[2] =3D=3D '1') || (=
p[0] !=3D ':')) {
-            if (*p =3D=3D ':') {
-                p +=3D 3;
-            }
-            for (idx =3D 0; idx < max_cpus; idx++) {
-                if (newstates[idx] =3D=3D 1) {
-                    newstates[idx] =3D cur_action;
+
+        if (*p++ !=3D ':') {
+            res =3D -ENOTSUP;
+            goto out;
+        }
+
+        switch (read_thread_id(p, &p, &pid, &tid)) {
+        case GDB_READ_THREAD_ERR:
+            res =3D -EINVAL;
+            goto out;
+
+        case GDB_ALL_PROCESSES:
+            cpu =3D gdb_first_attached_cpu(s);
+            while (cpu) {
+                if (newstates[cpu->cpu_index] =3D=3D 1) {
+                    newstates[cpu->cpu_index] =3D cur_action;
                 }
+
+                cpu =3D gdb_next_attached_cpu(s, cpu);
             }
-        } else if (*p =3D=3D ':') {
-            p++;
-            res =3D qemu_strtoul(p, &p, 16, &tmp);
-            if (res) {
+            break;
+
+        case GDB_ALL_THREADS:
+            process =3D gdb_get_process(s, pid);
+
+            if (!process->attached) {
+                res =3D -EINVAL;
                 goto out;
             }
=20
-            /* 0 means any thread, so we pick the first valid CPU */
-            cpu =3D tmp ? find_cpu(tmp) : first_cpu;
+            cpu =3D get_first_cpu_in_process(s, process);
+            while (cpu) {
+                if (newstates[cpu->cpu_index] =3D=3D 1) {
+                    newstates[cpu->cpu_index] =3D cur_action;
+                }
+
+                cpu =3D gdb_next_cpu_in_process(s, cpu);
+            }
+            break;
+
+        case GDB_ONE_THREAD:
+            cpu =3D gdb_get_cpu(s, pid, tid);
=20
             /* invalid CPU/thread specified */
             if (!cpu) {
                 res =3D -EINVAL;
                 goto out;
@@ -1159,10 +1245,11 @@ static int gdb_handle_vcont(GDBState *s, const ch=
ar *p)
=20
             /* only use if no previous match occourred */
             if (newstates[cpu->cpu_index] =3D=3D 1) {
                 newstates[cpu->cpu_index] =3D cur_action;
             }
+            break;
         }
     }
     s->signal =3D signal;
     gdb_continue_partial(s, newstates);
=20
--=20
2.19.1


