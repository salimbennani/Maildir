Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:36:23 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga005.fm.intel.com (fmsmga005.fm.intel.com [10.253.24.32])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 7720058037D
	for <like.xu@linux.intel.com>; Fri, 23 Nov 2018 06:59:02 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by fmsmga005-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 06:59:02 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3A0OPSahZndjqAoI/L0mRcvwf/LSx+4OfEezUN459i?=
 =?us-ascii?q?sYplN5qZrsm7bnLW6fgltlLVR4KTs6sC17KG9fi4EUU7or+5+EgYd5JNUxJXwe?=
 =?us-ascii?q?43pCcHRPC/NEvgMfTxZDY7FskRHHVs/nW8LFQHUJ2mPw6arXK99yMdFQviPgRp?=
 =?us-ascii?q?OOv1BpTSj8Oq3Oyu5pHfeQpFiCa+bL9oMBm6sRjau9ULj4dlNqs/0AbCrGFSe+?=
 =?us-ascii?q?RRy2NoJFaTkAj568yt4pNt8Dletuw4+cJYXqr0Y6o3TbpDDDQ7KG81/9HktQPC?=
 =?us-ascii?q?TQSU+HQRVHgdnwdSDAjE6BH6WYrxsjf/u+Fg1iSWIdH6QLYpUjmk8qxlSgLniD?=
 =?us-ascii?q?0fOjA57m/ZhM9+gqVZrxKvuhJ/24zZboOaOfZjcK7RYc0VRXFaU8pNSyBMGJ+w?=
 =?us-ascii?q?YpETA+YdO+tTsonzp0EJrRu7HQSiGOLvxSNIhnDsx601zvkqHwPY0wwmAt0Brm?=
 =?us-ascii?q?7UrM7yNKcUTOu4y7PIzTTfYPNWwzj98pXHfgohof6SW7J/bNTeyVM0FwPCiFWd?=
 =?us-ascii?q?sojlPzKT1usXqWib6PBsVeW1i24osgx8pCWkyMQ0ioTRmI4Z1lPJ+T9kzIooJt?=
 =?us-ascii?q?C0UlB3bNCkHZdKqi2XNZN6Tt4mTmxooio3yL8LtYSlcCUFyZkr3R7SZ+CBfoOV?=
 =?us-ascii?q?+BzsTvyRLi19hH99eLKwmRKy8U+4x+34V8m0y0pKrjFfntnDsHANygbf6s+dSv?=
 =?us-ascii?q?ty5kuh2DCP2B7P6uxcP0w4ianWJ4Q8zrItlZcfq1rPEyH2lUnskaObdF0o+u2y?=
 =?us-ascii?q?5OTmZrXmqIWcN4hxigzmK6QhhMm/AfkhPgcTQWeb5/qz1Ln68ULiR7VKk/s2nb?=
 =?us-ascii?q?XHv5DBIsgboq+5AwxL3Yo55Be/Ei+r0NAZnXkBMVJEdwiLj4nvO1HSPv/4Ce2z?=
 =?us-ascii?q?jEirkDdu3P3GOLrhApPCLnjFjbftZ7F961RTyAYr19BQ+4pUCq0dIPL0QkLxsN?=
 =?us-ascii?q?3YDhwnPACuzOfnFc5w1ocfWWKJH6+YP7nesV6O5uIzPeaMYJUZtyr6K/ggtLbT?=
 =?us-ascii?q?i2QkkwodYbWxxslQL3S5Beh9ZUOeZ3Xqn5EGC2hNuwM/SOnjjhqFSSJSYHCpGL?=
 =?us-ascii?q?sx4yx+BI+4AIOQe4a2nbbU2S66GoFRNHlLD03JHXr2eoHBQfoVdS+JPudnlToL?=
 =?us-ascii?q?U6XnTJUuggqzvg33wKYyM+zP5ycDvoji3tUm2+qGjBw36Hl4AtqQ10mLSGd7mH?=
 =?us-ascii?q?5OQCU5j45lpkko8FaI0aFij7R4GNpf6ulSVQFyYYTdxOxzEdy0Wg/HctqTU1Gg?=
 =?us-ascii?q?atGnBzgrSZQ22dBYMBU1IMmrkh2Wh3niOLQSjbHeXJE=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ArAABQFfhbhxHrdtBjHgEGBwaBUQkLA?=
 =?us-ascii?q?YEwgmKMcIshgweWQYF2DwEBGBSIWiI0CQ0BAwEBAQEBAQIBEwEBAQoLCQgbDiM?=
 =?us-ascii?q?MgjYFAgMYCYJcAwMBAj0BAQQKKQECAwECBgEBPgoIAwEwAQUBHBkFgxyCAgEDA?=
 =?us-ascii?q?ZtCPIodgh+CdgEBBYJDhFEIEodMgw+BHIFXP4EQAYJdiw6gBAcCghwEjwQLGIl?=
 =?us-ascii?q?Rhzcsl10GAgkHDyGBJYINTTCDL4IbDBcSiEyFP3GBB4lUKiyBdwEB?=
X-IPAS-Result: =?us-ascii?q?A0ArAABQFfhbhxHrdtBjHgEGBwaBUQkLAYEwgmKMcIshgwe?=
 =?us-ascii?q?WQYF2DwEBGBSIWiI0CQ0BAwEBAQEBAQIBEwEBAQoLCQgbDiMMgjYFAgMYCYJcA?=
 =?us-ascii?q?wMBAj0BAQQKKQECAwECBgEBPgoIAwEwAQUBHBkFgxyCAgEDAZtCPIodgh+CdgE?=
 =?us-ascii?q?BBYJDhFEIEodMgw+BHIFXP4EQAYJdiw6gBAcCghwEjwQLGIlRhzcsl10GAgkHD?=
 =?us-ascii?q?yGBJYINTTCDL4IbDBcSiEyFP3GBB4lUKiyBdwEB?=
X-IronPort-AV: E=Sophos;i="5.56,270,1539673200"; 
   d="scan'208";a="52393143"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 23 Nov 2018 06:59:01 -0800
Received: from localhost ([::1]:52821 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQCv6-0004W0-RT
	for like.xu@linux.intel.com; Fri, 23 Nov 2018 09:59:00 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:43907)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <richard.henderson@linaro.org>) id 1gQCij-00080S-Pr
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 09:46:17 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <richard.henderson@linaro.org>) id 1gQCig-0003BO-9c
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 09:46:13 -0500
Received: from mail-wm1-x341.google.com ([2a00:1450:4864:20::341]:36671)
	by eggs.gnu.org with esmtps (TLS1.0:RSA_AES_128_CBC_SHA1:16)
	(Exim 4.71) (envelope-from <richard.henderson@linaro.org>)
	id 1gQCig-00039W-0i
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 09:46:10 -0500
Received: by mail-wm1-x341.google.com with SMTP id s11so12262538wmh.1
	for <qemu-devel@nongnu.org>; Fri, 23 Nov 2018 06:46:09 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=linaro.org; s=google;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=V5pHnTSnR5PCVaavqferbtjCEb5UujC1bIeJMyb+BuI=;
	b=TTqJjoplBL6nvqoXGZn52nCobTtG/K872FAjHK9FXpeH9dY6apOZZVUll6z4K/TTyp
	CmFAcH255lpwWYDN7QG1Mqc3+neLDQzE9Pv06Xsow5Q1qDx3h03ikgMRa8bssVNhV5oq
	7jmSmqXuUNjW3IvHvL4ocOvFUalPZYbjb+c90=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=V5pHnTSnR5PCVaavqferbtjCEb5UujC1bIeJMyb+BuI=;
	b=PyAmn63kXgTHqqo0R86fbLXd+5L2nhOJkgIyRN8iAHh6UFSbIz+fKONdzqkL3yBOfX
	Km7tdNln7uQIIU6Zymw9VBLBn5HBeIk1fw3tk9eTAmb2EtCDfF1zGYXjG2oP7/WkVuZU
	kv2xdg4xvTLKdBN4XmigYV8/tFJoO3AR3IVBs07TwImaPoknNaP42s38igjaiS3dYqTX
	DC2tnpjexYSLS1JBw7Gm3CHbKSllC3kotyfMI2f2FkEtfQpEeelD9+5oRZUsMaelzKZx
	/Feuzu7lN4S6RplojdgtEbyZ4vBM651aQpa9zN+3Q3xKIepfvo2oTh0LXivyx6tTKF0g
	uVRg==
X-Gm-Message-State: AGRZ1gLLor/gdQGQ6Z+3R270krK3mhJg0Nx9Vc3KEgjCCHyQDayHFv+a
	ffGza382hvvRgtZFWDWWP1S8Co2JhIdZuQ==
X-Google-Smtp-Source: AJdET5ffD8ifIa9N4pF3ZoBV59N4Fwyqqy+fw+qNq9Xd3Q48JpWXODKNRGgYIon9qF1mlHlYUSzbTg==
X-Received: by 2002:a1c:4108:: with SMTP id o8mr13548805wma.91.1542984368404; 
	Fri, 23 Nov 2018 06:46:08 -0800 (PST)
Received: from cloudburst.twiddle.net ([195.77.246.50])
	by smtp.gmail.com with ESMTPSA id
	p74sm10339630wmd.29.2018.11.23.06.46.07
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Fri, 23 Nov 2018 06:46:07 -0800 (PST)
From: Richard Henderson <richard.henderson@linaro.org>
To: qemu-devel@nongnu.org
Date: Fri, 23 Nov 2018 15:45:29 +0100
Message-Id: <20181123144558.5048-9-richard.henderson@linaro.org>
X-Mailer: git-send-email 2.17.2
In-Reply-To: <20181123144558.5048-1-richard.henderson@linaro.org>
References: <20181123144558.5048-1-richard.henderson@linaro.org>
X-detected-operating-system: by eggs.gnu.org: Genre and OS details not
	recognized.
X-Received-From: 2a00:1450:4864:20::341
Subject: [Qemu-devel] [PATCH for-4.0 v2 08/37] tcg/i386: Force qemu_ld/st
 arguments into fixed registers
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Alistair.Francis@wdc.com
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

This is an incremental step toward moving the qemu_ld/st
code sequence out of line.

Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
---
 tcg/i386/tcg-target.inc.c | 203 +++++++++++++++++++++++++++++++-------
 1 file changed, 169 insertions(+), 34 deletions(-)

diff --git a/tcg/i386/tcg-target.inc.c b/tcg/i386/tcg-target.inc.c
index 07df4b2b12..50e5dc31b3 100644
--- a/tcg/i386/tcg-target.inc.c
+++ b/tcg/i386/tcg-target.inc.c
@@ -171,6 +171,80 @@ static bool have_lzcnt;
 
 static tcg_insn_unit *tb_ret_addr;
 
+typedef enum {
+    ARG_ADDR,
+    ARG_STVAL,
+    ARG_LDVAL,
+} QemuMemArgType;
+
+#ifdef CONFIG_SOFTMMU
+/*
+ * Constraint to choose a particular register.  This is used for softmmu
+ * loads and stores.  Registers with no assignment get an empty string.
+ */
+static const char * const one_reg_constraint[TCG_TARGET_NB_REGS] = {
+    [TCG_REG_EAX] = "a",
+    [TCG_REG_EBX] = "b",
+    [TCG_REG_ECX] = "c",
+    [TCG_REG_EDX] = "d",
+    [TCG_REG_ESI] = "S",
+    [TCG_REG_EDI] = "D",
+#if TCG_TARGET_REG_BITS == 64
+    [TCG_REG_R8]  = "E",
+    [TCG_REG_R9]  = "N",
+#endif
+};
+
+/*
+ * Calling convention for the softmmu load and store thunks.
+ *
+ * For 64-bit, we mostly use the host calling convention, therefore the
+ * real first argument is reserved for the ENV parameter that is passed
+ * on to the slow path helpers.
+ *
+ * For 32-bit, the host calling convention is stack based; we invent a
+ * private convention that uses 4 of the 6 available host registers.
+ * We reserve EAX and EDX as temporaries for use by the thunk, we require
+ * INDEX_op_qemu_st_i32 to have a 'q' register from which to store, and
+ * further complicate this last by wanting a call-clobbered for that store.
+ * The 'q' requirement allows MO_8 stores at all; the call-clobbered part
+ * allows bswap to operate in-place, clobbering the input.
+ */
+static TCGReg softmmu_arg(QemuMemArgType type, bool is_64, int hi)
+{
+    switch (type) {
+    case ARG_ADDR:
+        tcg_debug_assert(!hi || TARGET_LONG_BITS > TCG_TARGET_REG_BITS);
+        if (TCG_TARGET_REG_BITS == 64) {
+            return tcg_target_call_iarg_regs[1];
+        } else {
+            return hi ? TCG_REG_EDI : TCG_REG_ESI;
+        }
+    case ARG_STVAL:
+        tcg_debug_assert(!hi || (TCG_TARGET_REG_BITS == 32 && is_64));
+        if (TCG_TARGET_REG_BITS == 64) {
+            return tcg_target_call_iarg_regs[2];
+        } else {
+            return hi ? TCG_REG_EBX : TCG_REG_ECX;
+        }
+    case ARG_LDVAL:
+        tcg_debug_assert(!hi || (TCG_TARGET_REG_BITS == 32 && is_64));
+        return tcg_target_call_oarg_regs[hi];
+    }
+    g_assert_not_reached();
+}
+
+static const char *constrain_memop_arg(QemuMemArgType type, bool is_64, int hi)
+{
+    return one_reg_constraint[softmmu_arg(type, is_64, hi)];
+}
+#else
+static const char *constrain_memop_arg(QemuMemArgType type, bool is_64, int hi)
+{
+    return "L";
+}
+#endif /* CONFIG_SOFTMMU */
+
 static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
                         intptr_t value, intptr_t addend)
 {
@@ -1680,11 +1754,15 @@ static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addrlo, TCGReg addrhi,
        copies the entire guest address for the slow path, while truncation
        for the 32-bit host happens with the fastpath ADDL below.  */
     if (TCG_TARGET_REG_BITS == 64) {
-        base = tcg_target_call_iarg_regs[1];
+        tcg_debug_assert(addrlo == tcg_target_call_iarg_regs[1]);
+        if (TARGET_LONG_BITS == 32) {
+            tcg_out_ext32u(s, addrlo, addrlo);
+        }
+        base = addrlo;
     } else {
         base = r1;
+        tcg_out_mov(s, ttype, base, addrlo);
     }
-    tcg_out_mov(s, ttype, base, addrlo);
 
     /* jne slow_path */
     tcg_out_opc(s, OPC_JCC_long + JCC_JNE, 0, 0, 0);
@@ -2009,16 +2087,22 @@ static void tcg_out_qemu_ld_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
    common. */
 static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
 {
-    TCGReg datalo, datahi, addrlo;
-    TCGReg addrhi __attribute__((unused));
+    TCGReg datalo, addrlo;
+    TCGReg datahi __attribute__((unused)) = -1;
+    TCGReg addrhi __attribute__((unused)) = -1;
     TCGMemOpIdx oi;
     TCGMemOp opc;
+    int i = -1;
 
-    datalo = *args++;
-    datahi = (TCG_TARGET_REG_BITS == 32 && is64 ? *args++ : 0);
-    addrlo = *args++;
-    addrhi = (TARGET_LONG_BITS > TCG_TARGET_REG_BITS ? *args++ : 0);
-    oi = *args++;
+    datalo = args[++i];
+    if (TCG_TARGET_REG_BITS == 32 && is64) {
+        datahi = args[++i];
+    }
+    addrlo = args[++i];
+    if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
+        addrhi = args[++i];
+    }
+    oi = args[++i];
     opc = get_memop(oi);
 
 #if defined(CONFIG_SOFTMMU)
@@ -2027,6 +2111,15 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is64)
         tcg_insn_unit *label_ptr[2];
         TCGReg base;
 
+        tcg_debug_assert(datalo == softmmu_arg(ARG_LDVAL, is64, 0));
+        if (TCG_TARGET_REG_BITS == 32 && is64) {
+            tcg_debug_assert(datahi == softmmu_arg(ARG_LDVAL, is64, 1));
+        }
+        tcg_debug_assert(addrlo == softmmu_arg(ARG_ADDR, 0, 0));
+        if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
+            tcg_debug_assert(addrhi == softmmu_arg(ARG_ADDR, 0, 1));
+        }
+
         base = tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,
                                 label_ptr, offsetof(CPUTLBEntry, addr_read));
 
@@ -2149,16 +2242,22 @@ static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
 
 static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
 {
-    TCGReg datalo, datahi, addrlo;
-    TCGReg addrhi __attribute__((unused));
+    TCGReg datalo, addrlo;
+    TCGReg datahi __attribute__((unused)) = -1;
+    TCGReg addrhi __attribute__((unused)) = -1;
     TCGMemOpIdx oi;
     TCGMemOp opc;
+    int i = -1;
 
-    datalo = *args++;
-    datahi = (TCG_TARGET_REG_BITS == 32 && is64 ? *args++ : 0);
-    addrlo = *args++;
-    addrhi = (TARGET_LONG_BITS > TCG_TARGET_REG_BITS ? *args++ : 0);
-    oi = *args++;
+    datalo = args[++i];
+    if (TCG_TARGET_REG_BITS == 32 && is64) {
+        datahi = args[++i];
+    }
+    addrlo = args[++i];
+    if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
+        addrhi = args[++i];
+    }
+    oi = args[++i];
     opc = get_memop(oi);
 
 #if defined(CONFIG_SOFTMMU)
@@ -2167,6 +2266,15 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is64)
         tcg_insn_unit *label_ptr[2];
         TCGReg base;
 
+        tcg_debug_assert(datalo == softmmu_arg(ARG_STVAL, is64, 0));
+        if (TCG_TARGET_REG_BITS == 32 && is64) {
+            tcg_debug_assert(datahi == softmmu_arg(ARG_STVAL, is64, 1));
+        }
+        tcg_debug_assert(addrlo == softmmu_arg(ARG_ADDR, 0, 0));
+        if (TARGET_LONG_BITS > TCG_TARGET_REG_BITS) {
+            tcg_debug_assert(addrhi == softmmu_arg(ARG_ADDR, 0, 1));
+        }
+
         base = tcg_out_tlb_load(s, addrlo, addrhi, mem_index, opc,
                                 label_ptr, offsetof(CPUTLBEntry, addr_write));
 
@@ -2836,15 +2944,6 @@ static const TCGTargetOpDef *tcg_target_op_def(TCGOpcode op)
     static const TCGTargetOpDef r_r_re = { .args_ct_str = { "r", "r", "re" } };
     static const TCGTargetOpDef r_0_re = { .args_ct_str = { "r", "0", "re" } };
     static const TCGTargetOpDef r_0_ci = { .args_ct_str = { "r", "0", "ci" } };
-    static const TCGTargetOpDef r_L = { .args_ct_str = { "r", "L" } };
-    static const TCGTargetOpDef L_L = { .args_ct_str = { "L", "L" } };
-    static const TCGTargetOpDef r_L_L = { .args_ct_str = { "r", "L", "L" } };
-    static const TCGTargetOpDef r_r_L = { .args_ct_str = { "r", "r", "L" } };
-    static const TCGTargetOpDef L_L_L = { .args_ct_str = { "L", "L", "L" } };
-    static const TCGTargetOpDef r_r_L_L
-        = { .args_ct_str = { "r", "r", "L", "L" } };
-    static const TCGTargetOpDef L_L_L_L
-        = { .args_ct_str = { "L", "L", "L", "L" } };
     static const TCGTargetOpDef x_x = { .args_ct_str = { "x", "x" } };
     static const TCGTargetOpDef x_x_x = { .args_ct_str = { "x", "x", "x" } };
     static const TCGTargetOpDef x_x_x_x
@@ -3026,17 +3125,53 @@ static const TCGTargetOpDef *tcg_target_op_def(TCGOpcode op)
         }
 
     case INDEX_op_qemu_ld_i32:
-        return TARGET_LONG_BITS <= TCG_TARGET_REG_BITS ? &r_L : &r_L_L;
-    case INDEX_op_qemu_st_i32:
-        return TARGET_LONG_BITS <= TCG_TARGET_REG_BITS ? &L_L : &L_L_L;
+        {
+            static TCGTargetOpDef ld32;
+            int i;
+
+            ld32.args_ct_str[0] = constrain_memop_arg(ARG_LDVAL, 0, 0);
+            for (i = 0; i * TCG_TARGET_REG_BITS < TARGET_LONG_BITS; ++i) {
+                ld32.args_ct_str[i + 1] = constrain_memop_arg(ARG_ADDR, 0, i);
+            }
+            return &ld32;
+        }
     case INDEX_op_qemu_ld_i64:
-        return (TCG_TARGET_REG_BITS == 64 ? &r_L
-                : TARGET_LONG_BITS <= TCG_TARGET_REG_BITS ? &r_r_L
-                : &r_r_L_L);
+        {
+            static TCGTargetOpDef ld64;
+            int i, j = 0;
+
+            for (i = 0; i * TCG_TARGET_REG_BITS < 64; ++i) {
+                ld64.args_ct_str[j++] = constrain_memop_arg(ARG_LDVAL, 1, i);
+            }
+            for (i = 0; i * TCG_TARGET_REG_BITS < TARGET_LONG_BITS; ++i) {
+                ld64.args_ct_str[j++] = constrain_memop_arg(ARG_ADDR, 0, i);
+            }
+            return &ld64;
+        }
+    case INDEX_op_qemu_st_i32:
+        {
+            static TCGTargetOpDef st32;
+            int i;
+
+            st32.args_ct_str[0] = constrain_memop_arg(ARG_STVAL, 0, 0);
+            for (i = 0; i * TCG_TARGET_REG_BITS < TARGET_LONG_BITS; ++i) {
+                st32.args_ct_str[i + 1] = constrain_memop_arg(ARG_ADDR, 0, i);
+            }
+            return &st32;
+        }
     case INDEX_op_qemu_st_i64:
-        return (TCG_TARGET_REG_BITS == 64 ? &L_L
-                : TARGET_LONG_BITS <= TCG_TARGET_REG_BITS ? &L_L_L
-                : &L_L_L_L);
+        {
+            static TCGTargetOpDef st64;
+            int i, j = 0;
+
+            for (i = 0; i * TCG_TARGET_REG_BITS < 64; ++i) {
+                st64.args_ct_str[j++] = constrain_memop_arg(ARG_STVAL, 1, i);
+            }
+            for (i = 0; i * TCG_TARGET_REG_BITS < TARGET_LONG_BITS; ++i) {
+                st64.args_ct_str[j++] = constrain_memop_arg(ARG_ADDR, 0, i);
+            }
+            return &st64;
+        }
 
     case INDEX_op_brcond2_i32:
         {
-- 
2.17.2


