Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:36:24 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga006.jf.intel.com (orsmga006.jf.intel.com [10.7.209.51])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 9198B5803EB
	for <like.xu@linux.intel.com>; Fri, 23 Nov 2018 07:00:23 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga006-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 07:00:23 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AHxOBbxTX7iQX/RV0l+eG5bUzYNpsv+yvbD5Q0YIu?=
 =?us-ascii?q?jvd0So/mwa6zYRWN2/xhgRfzUJnB7Loc0qyK6/CmATRIyK3CmUhKSIZLWR4BhJ?=
 =?us-ascii?q?detC0bK+nBN3fGKuX3ZTcxBsVIWQwt1Xi6NU9IBJS2PAWK8TW94jEIBxrwKxd+?=
 =?us-ascii?q?KPjrFY7OlcS30P2594HObwlSizexfbB/IA+qoQnNq8IbnZZsJqEtxxXTv3BGYf?=
 =?us-ascii?q?5WxWRmJVKSmxbz+MK994N9/ipTpvws6ddOXb31cKokQ7NYCi8mM30u683wqRbD?=
 =?us-ascii?q?VwqP6WACXWgQjxFFHhLK7BD+Xpf2ryv6qu9w0zSUMMHqUbw5Xymp4qF2QxHqlS?=
 =?us-ascii?q?gHLSY0/mHJhMJ+j6xVpxCupxJizY7MYoybNvVzcr7TcN8GW2VBRd1cWzBdDo6m?=
 =?us-ascii?q?c4cCFfYNMfpeooLgp1UOtxy+BQy0Ce3zyz9Hmn/20rcg0+s8DArI3hIvH9QTv3?=
 =?us-ascii?q?vKttX1L6ASUeaox6TP1zXDbu9Z2Tfn54jSbx8tu/GMUqx2ccXM10YvDRjFjlKW?=
 =?us-ascii?q?qYH+OzOV1+INvHKB7+pnT+6vjHQnqw5orzWp28wiiZHJi5oLxlzY9ih12ps5Kc?=
 =?us-ascii?q?C7RUJhf9KpHptduzuHO4Z0Ws8uXmVltSYgxrAEu5O3ZjYGxZsmyhLFa/GLb46F?=
 =?us-ascii?q?6Q/5WumLOzd3nndldaq/hxms9UigzfXxVs210FZRsipFicPAtn8L1xzO8MSHTe?=
 =?us-ascii?q?F9/ki51TaO0QDc9P1ELFgqmabHKJMt2KM8mocQvEjZACP7lkX7gLWLekgm4uSo?=
 =?us-ascii?q?7v7oYrTipp+SLY90jQT+P7w3msOhBOQ4LxECUHWF9uSiyrLj+VT1T65Njv0rlK?=
 =?us-ascii?q?nWrI7VJd8cqq69Ag9V0Zgs5wywDje7yNkYmXgHLFRYeBOIlYTpOlfOIOzmAve7?=
 =?us-ascii?q?mVijjDBrx/XdM73nBZXNKHfDkLH8fbpn7E5c0gUzwchF551IErEBPO7zWkjpud?=
 =?us-ascii?q?zcDx85MBK7z/zoCdVgzY4eXWOPAqmEMKLdq1OI5+QvI/WSa48RojryN/8l5/u9?=
 =?us-ascii?q?xUI/gkIXKKm1wYMMOjf/GvV9P17fZ33qjdEcV2AQsU07Re3ujVSEFjlLe3e1Wb?=
 =?us-ascii?q?l7/zw+FceqAJnOQtOQhqec1nK+F5xSemcUE12JDDLkepuJX7IWZTuPL9R9ujoD?=
 =?us-ascii?q?U7enVskmzx75rxLwybdsMr/J/DYFv4noztl/6r7vkkQr+DlpSsiQzWyJZ2dzmG?=
 =?us-ascii?q?wOWnkxxq8sj1Z6zwK50KN4iuZUXfxe4f9ESBw9M9aI1e1xC9noVkTBc9GFRUy9?=
 =?us-ascii?q?RdOOBTA3R8g2hdgUbBAuSJ2Zkhnf0n/yUPcunLuRCcls/w=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ChAABQFfhbhxHrdtBjHgEGBwaBUwcLA?=
 =?us-ascii?q?YEwgmKMcIshgweRSoR3gWwZAQEYFIMshS4iNgcNAQMBAQEBAQECARMBAQEKCwk?=
 =?us-ascii?q?IGw4jDII2BQIDGAmCXAMDAQIkGQEBBAopAQIDAQIGAQE+CggDATABBQEcGQWDH?=
 =?us-ascii?q?IICAQMBm0I8ih2BbDOCdgEBBYJDhFEIEodMgw+BHIFXP4EQAYJdiw6JJZZfBwK?=
 =?us-ascii?q?CHASPBAsYiVGHNyyXXQYCCQcPIYEsAoIETTCDL4IbDBcSiEyFP3GBB4oqgXcBA?=
 =?us-ascii?q?Q?=
X-IPAS-Result: =?us-ascii?q?A0ChAABQFfhbhxHrdtBjHgEGBwaBUwcLAYEwgmKMcIshgwe?=
 =?us-ascii?q?RSoR3gWwZAQEYFIMshS4iNgcNAQMBAQEBAQECARMBAQEKCwkIGw4jDII2BQIDG?=
 =?us-ascii?q?AmCXAMDAQIkGQEBBAopAQIDAQIGAQE+CggDATABBQEcGQWDHIICAQMBm0I8ih2?=
 =?us-ascii?q?BbDOCdgEBBYJDhFEIEodMgw+BHIFXP4EQAYJdiw6JJZZfBwKCHASPBAsYiVGHN?=
 =?us-ascii?q?yyXXQYCCQcPIYEsAoIETTCDL4IbDBcSiEyFP3GBB4oqgXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,270,1539673200"; 
   d="scan'208";a="52393270"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 23 Nov 2018 07:00:22 -0800
Received: from localhost ([::1]:52826 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gQCwP-0005b5-A8
	for like.xu@linux.intel.com; Fri, 23 Nov 2018 10:00:21 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:44202)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <richard.henderson@linaro.org>) id 1gQCj3-0000Ha-Ak
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 09:46:38 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <richard.henderson@linaro.org>) id 1gQCiz-0003dg-OM
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 09:46:32 -0500
Received: from mail-wm1-x342.google.com ([2a00:1450:4864:20::342]:34360)
	by eggs.gnu.org with esmtps (TLS1.0:RSA_AES_128_CBC_SHA1:16)
	(Exim 4.71) (envelope-from <richard.henderson@linaro.org>)
	id 1gQCiy-0003Wb-1E
	for qemu-devel@nongnu.org; Fri, 23 Nov 2018 09:46:29 -0500
Received: by mail-wm1-x342.google.com with SMTP id y185so7738001wmd.1
	for <qemu-devel@nongnu.org>; Fri, 23 Nov 2018 06:46:26 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=linaro.org; s=google;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=4SK9gU8naH9sM9NW9c9OPn3r+aLaMwI873v6N6J6XYs=;
	b=bXr8TcCxBNiwl89uiwDB17DpWVPGxfkg7I+44n99nwd3NCngvQ+NOrQKnf9jOXDXPA
	S1drTzZpmG3Pq5Uka0++8ONy6vx/NWVck6Gu2LxGmUXVIzZ1R2WgFSuFBOLkElCYZorz
	LGAkjZquiHOz/Od1zhu57Ys3Yts6gEFZpW0sY=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=4SK9gU8naH9sM9NW9c9OPn3r+aLaMwI873v6N6J6XYs=;
	b=OvE0+8Ct1aYe+HPux03JlY5OxCvKMFCTW2SsKCD42T1HvM0500YfYpcdgoV8YtdzuP
	bMzBuOJ/4+1EeC1A7wjrX8L0mv2tV10DU+oo6c1g3cpDZ870jqx1GPkN+nkzxscvRZJS
	3HA/QHAIJWBq/GCh+z2hOJBjPf7QLkqkXlZow4w4gqPg0hthS8a1pQl8FV2Bis664t6h
	VPXCqLfa+b71Y9f/3uCLcr2RFEMkpRPc9GUW9SQPpsuDmLySnd3uTnUk8vjVBNYr4cSl
	zuubCHrFcn4Re0J4EXb4H3vLhGrhjFoWhYA6M3e3NSr/nvzvL7PKCjavsBz0kqoQEzek
	Zrjw==
X-Gm-Message-State: AA+aEWb6u7suxAaKwd+yGZMQ1zxdsx1RiJOdWdrcl7DKb9Okp8bLSwOU
	Dpabg0XgyCAMc0Ieaqq6sXretfjI7eOfmA==
X-Google-Smtp-Source: AJdET5clkHzF/cepUmaCJd9ujCoEZQ7wzT46FUNWv1SirFUcd2KNzDYj/Y1Qdk4uNuINKBIkAQVqiw==
X-Received: by 2002:a1c:cb4c:: with SMTP id b73mr15074247wmg.69.1542984384861; 
	Fri, 23 Nov 2018 06:46:24 -0800 (PST)
Received: from cloudburst.twiddle.net ([195.77.246.50])
	by smtp.gmail.com with ESMTPSA id
	p74sm10339630wmd.29.2018.11.23.06.46.24
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Fri, 23 Nov 2018 06:46:24 -0800 (PST)
From: Richard Henderson <richard.henderson@linaro.org>
To: qemu-devel@nongnu.org
Date: Fri, 23 Nov 2018 15:45:46 +0100
Message-Id: <20181123144558.5048-26-richard.henderson@linaro.org>
X-Mailer: git-send-email 2.17.2
In-Reply-To: <20181123144558.5048-1-richard.henderson@linaro.org>
References: <20181123144558.5048-1-richard.henderson@linaro.org>
X-detected-operating-system: by eggs.gnu.org: Genre and OS details not
	recognized.
X-Received-From: 2a00:1450:4864:20::342
Subject: [Qemu-devel] [PATCH for-4.0 v2 25/37] tcg/ppc: Use
 TCG_TARGET_NEED_LDST_OOL_LABELS
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: Alistair.Francis@wdc.com
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

Signed-off-by: Richard Henderson <richard.henderson@linaro.org>
---
 tcg/ppc/tcg-target.h     |   2 +-
 tcg/ppc/tcg-target.inc.c | 326 +++++++++++++++++----------------------
 2 files changed, 141 insertions(+), 187 deletions(-)

diff --git a/tcg/ppc/tcg-target.h b/tcg/ppc/tcg-target.h
index be52ad1d2e..bbc49bb1be 100644
--- a/tcg/ppc/tcg-target.h
+++ b/tcg/ppc/tcg-target.h
@@ -130,7 +130,7 @@ void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t);
 #define TCG_TARGET_DEFAULT_MO (0)
 
 #ifdef CONFIG_SOFTMMU
-#define TCG_TARGET_NEED_LDST_LABELS
+#define TCG_TARGET_NEED_LDST_OOL_LABELS
 #endif
 #define TCG_TARGET_NEED_POOL_LABELS
 
diff --git a/tcg/ppc/tcg-target.inc.c b/tcg/ppc/tcg-target.inc.c
index c706b2cf53..fed7f5fe6e 100644
--- a/tcg/ppc/tcg-target.inc.c
+++ b/tcg/ppc/tcg-target.inc.c
@@ -1476,7 +1476,7 @@ static const uint32_t qemu_exts_opc[4] = {
 };
 
 #if defined (CONFIG_SOFTMMU)
-#include "tcg-ldst.inc.c"
+#include "tcg-ldst-ool.inc.c"
 
 /* helper signature: helper_ld_mmu(CPUState *env, target_ulong addr,
  *                                 int mmu_idx, uintptr_t ra)
@@ -1489,6 +1489,14 @@ static void * const qemu_ld_helpers[16] = {
     [MO_BEUW] = helper_be_lduw_mmu,
     [MO_BEUL] = helper_be_ldul_mmu,
     [MO_BEQ]  = helper_be_ldq_mmu,
+
+    [MO_SB]   = helper_ret_ldsb_mmu,
+    [MO_LESW] = helper_le_ldsw_mmu,
+    [MO_BESW] = helper_be_ldsw_mmu,
+#if TCG_TARGET_REG_BITS == 64
+    [MO_LESL] = helper_le_ldsl_mmu,
+    [MO_BESL] = helper_be_ldsl_mmu,
+#endif
 };
 
 /* helper signature: helper_st_mmu(CPUState *env, target_ulong addr,
@@ -1526,9 +1534,8 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, TCGMemOp opc,
     /* Extract the page index, shifted into place for tlb index.  */
     if (TCG_TARGET_REG_BITS == 64) {
         if (TARGET_LONG_BITS == 32) {
-            /* Zero-extend the address into a place helpful for further use. */
-            tcg_out_ext32u(s, t1, addrlo);
-            addrlo = t1;
+            /* Zero-extend the address now.  */
+            tcg_out_ext32u(s, addrlo, addrlo);
         } else {
             tcg_out_rld(s, RLDICL, t0, addrlo,
                         64 - TARGET_PAGE_BITS, 64 - CPU_TLB_BITS);
@@ -1625,122 +1632,6 @@ static TCGReg tcg_out_tlb_read(TCGContext *s, TCGMemOp opc,
     return addrlo;
 }
 
-/* Record the context of a call to the out of line helper code for the slow
-   path for a load or store, so that we can later generate the correct
-   helper code.  */
-static void add_qemu_ldst_label(TCGContext *s, bool is_ld, TCGMemOpIdx oi,
-                                TCGReg datalo_reg, TCGReg datahi_reg,
-                                TCGReg addrlo_reg, TCGReg addrhi_reg,
-                                tcg_insn_unit *raddr, tcg_insn_unit *lptr)
-{
-    TCGLabelQemuLdst *label = new_ldst_label(s);
-
-    label->is_ld = is_ld;
-    label->oi = oi;
-    label->datalo_reg = datalo_reg;
-    label->datahi_reg = datahi_reg;
-    label->addrlo_reg = addrlo_reg;
-    label->addrhi_reg = addrhi_reg;
-    label->raddr = raddr;
-    label->label_ptr[0] = lptr;
-}
-
-static void tcg_out_qemu_ld_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
-{
-    TCGMemOpIdx oi = lb->oi;
-    TCGMemOp opc = get_memop(oi);
-    TCGReg hi, lo, arg = TCG_REG_R3;
-
-    reloc_pc14(lb->label_ptr[0], s->code_ptr);
-
-    tcg_out_mov(s, TCG_TYPE_PTR, arg++, TCG_AREG0);
-
-    lo = lb->addrlo_reg;
-    hi = lb->addrhi_reg;
-    if (TCG_TARGET_REG_BITS < TARGET_LONG_BITS) {
-        arg |= TCG_TARGET_CALL_ALIGN_ARGS;
-        tcg_out_mov(s, TCG_TYPE_I32, arg++, hi);
-        tcg_out_mov(s, TCG_TYPE_I32, arg++, lo);
-    } else {
-        /* If the address needed to be zero-extended, we'll have already
-           placed it in R4.  The only remaining case is 64-bit guest.  */
-        tcg_out_mov(s, TCG_TYPE_TL, arg++, lo);
-    }
-
-    tcg_out_movi(s, TCG_TYPE_I32, arg++, oi);
-    tcg_out32(s, MFSPR | RT(arg) | LR);
-
-    tcg_out_call(s, qemu_ld_helpers[opc & (MO_BSWAP | MO_SIZE)]);
-
-    lo = lb->datalo_reg;
-    hi = lb->datahi_reg;
-    if (TCG_TARGET_REG_BITS == 32 && (opc & MO_SIZE) == MO_64) {
-        tcg_out_mov(s, TCG_TYPE_I32, lo, TCG_REG_R4);
-        tcg_out_mov(s, TCG_TYPE_I32, hi, TCG_REG_R3);
-    } else if (opc & MO_SIGN) {
-        uint32_t insn = qemu_exts_opc[opc & MO_SIZE];
-        tcg_out32(s, insn | RA(lo) | RS(TCG_REG_R3));
-    } else {
-        tcg_out_mov(s, TCG_TYPE_REG, lo, TCG_REG_R3);
-    }
-
-    tcg_out_b(s, 0, lb->raddr);
-}
-
-static void tcg_out_qemu_st_slow_path(TCGContext *s, TCGLabelQemuLdst *lb)
-{
-    TCGMemOpIdx oi = lb->oi;
-    TCGMemOp opc = get_memop(oi);
-    TCGMemOp s_bits = opc & MO_SIZE;
-    TCGReg hi, lo, arg = TCG_REG_R3;
-
-    reloc_pc14(lb->label_ptr[0], s->code_ptr);
-
-    tcg_out_mov(s, TCG_TYPE_PTR, arg++, TCG_AREG0);
-
-    lo = lb->addrlo_reg;
-    hi = lb->addrhi_reg;
-    if (TCG_TARGET_REG_BITS < TARGET_LONG_BITS) {
-        arg |= TCG_TARGET_CALL_ALIGN_ARGS;
-        tcg_out_mov(s, TCG_TYPE_I32, arg++, hi);
-        tcg_out_mov(s, TCG_TYPE_I32, arg++, lo);
-    } else {
-        /* If the address needed to be zero-extended, we'll have already
-           placed it in R4.  The only remaining case is 64-bit guest.  */
-        tcg_out_mov(s, TCG_TYPE_TL, arg++, lo);
-    }
-
-    lo = lb->datalo_reg;
-    hi = lb->datahi_reg;
-    if (TCG_TARGET_REG_BITS == 32) {
-        switch (s_bits) {
-        case MO_64:
-            arg |= TCG_TARGET_CALL_ALIGN_ARGS;
-            tcg_out_mov(s, TCG_TYPE_I32, arg++, hi);
-            /* FALLTHRU */
-        case MO_32:
-            tcg_out_mov(s, TCG_TYPE_I32, arg++, lo);
-            break;
-        default:
-            tcg_out_rlw(s, RLWINM, arg++, lo, 0, 32 - (8 << s_bits), 31);
-            break;
-        }
-    } else {
-        if (s_bits == MO_64) {
-            tcg_out_mov(s, TCG_TYPE_I64, arg++, lo);
-        } else {
-            tcg_out_rld(s, RLDICL, arg++, lo, 0, 64 - (8 << s_bits));
-        }
-    }
-
-    tcg_out_movi(s, TCG_TYPE_I32, arg++, oi);
-    tcg_out32(s, MFSPR | RT(arg) | LR);
-
-    tcg_out_call(s, qemu_st_helpers[opc & (MO_BSWAP | MO_SIZE)]);
-
-    tcg_out_b(s, 0, lb->raddr);
-}
-
 static TCGReg softmmu_args_2(TCGReg reg, TCGReg *lo, TCGReg *hi)
 {
 #ifdef HOST_WORDS_BIGENDIAN
@@ -1757,44 +1648,10 @@ static TCGReg softmmu_args_2(TCGReg reg, TCGReg *lo, TCGReg *hi)
 }
 #endif /* SOFTMMU */
 
-static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)
+static void tcg_out_qemu_ld_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
+                                   TCGReg addrlo, TCGReg rbase, TCGMemOp opc)
 {
-    TCGReg datalo, datahi, addrlo, rbase;
-    TCGReg addrhi __attribute__((unused));
-    TCGMemOpIdx oi;
-    TCGMemOp opc, s_bits;
-#ifdef CONFIG_SOFTMMU
-    int mem_index;
-    tcg_insn_unit *label_ptr;
-#endif
-
-    datalo = *args++;
-    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);
-    addrlo = *args++;
-    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);
-    oi = *args++;
-    opc = get_memop(oi);
-    s_bits = opc & MO_SIZE;
-
-#ifdef CONFIG_SOFTMMU
-    mem_index = get_mmuidx(oi);
-    rbase = TCG_REG_R9;
-    addrlo = tcg_out_tlb_read(s, opc, addrlo, addrhi, mem_index, true,
-                              rbase, TCG_REG_R10);
-
-    /* Load a pointer into the current opcode w/conditional branch-link. */
-    label_ptr = s->code_ptr;
-    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);
-
-#else  /* !CONFIG_SOFTMMU */
-    rbase = guest_base ? TCG_GUEST_BASE_REG : 0;
-    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {
-        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);
-        addrlo = TCG_REG_TMP1;
-    }
-#endif
-
-    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {
+    if (TCG_TARGET_REG_BITS == 32 && (opc & MO_SIZE) == MO_64) {
         if (opc & MO_BSWAP) {
             tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));
             tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));
@@ -1811,7 +1668,7 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)
             tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));
         }
     } else {
-        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];
+        uint32_t insn = qemu_ldx_opc[opc & (MO_SSIZE | MO_BSWAP)];
         if (!HAVE_ISA_2_06 && insn == LDBRX) {
             tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));
             tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));
@@ -1822,55 +1679,45 @@ static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)
         } else {
             insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];
             tcg_out32(s, insn | TAB(datalo, rbase, addrlo));
-            insn = qemu_exts_opc[s_bits];
+            insn = qemu_exts_opc[opc & MO_SIZE];
             tcg_out32(s, insn | RA(datalo) | RS(datalo));
         }
     }
-
-#ifdef CONFIG_SOFTMMU
-    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,
-                        s->code_ptr, label_ptr);
-#endif
 }
 
-static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
+static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)
 {
-    TCGReg datalo, datahi, addrlo, rbase;
+    TCGReg datalo __attribute__((unused));
+    TCGReg datahi __attribute__((unused));
+    TCGReg addrlo __attribute__((unused));
     TCGReg addrhi __attribute__((unused));
     TCGMemOpIdx oi;
-    TCGMemOp opc, s_bits;
-#ifdef CONFIG_SOFTMMU
-    int mem_index;
-    tcg_insn_unit *label_ptr;
-#endif
 
     datalo = *args++;
     datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);
     addrlo = *args++;
     addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);
     oi = *args++;
-    opc = get_memop(oi);
-    s_bits = opc & MO_SIZE;
 
 #ifdef CONFIG_SOFTMMU
-    mem_index = get_mmuidx(oi);
-    rbase = TCG_REG_R9;
-    addrlo = tcg_out_tlb_read(s, opc, addrlo, addrhi, mem_index, false,
-                              rbase, TCG_REG_R10);
+    add_ldst_ool_label(s, true, is_64, oi, R_PPC_REL24, 0);
+    tcg_out_b_noaddr(s, B | LK);
+#else
+    TCGMemOp opc = get_memop(oi);
+    TCGReg rbase = guest_base ? TCG_GUEST_BASE_REG : 0;
 
-    /* Load a pointer into the current opcode w/conditional branch-link. */
-    label_ptr = s->code_ptr;
-    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);
-
-#else  /* !CONFIG_SOFTMMU */
-    rbase = guest_base ? TCG_GUEST_BASE_REG : 0;
     if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {
         tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);
         addrlo = TCG_REG_TMP1;
     }
+    tcg_out_qemu_ld_direct(s, datalo, datahi, addrlo, rbase, opc);
 #endif
+}
 
-    if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) {
+static void tcg_out_qemu_st_direct(TCGContext *s, TCGReg datalo, TCGReg datahi,
+                                   TCGReg addrlo, TCGReg rbase, TCGMemOp opc)
+{
+    if (TCG_TARGET_REG_BITS == 32 && (opc & MO_SIZE) == MO_64) {
         if (opc & MO_BSWAP) {
             tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));
             tcg_out32(s, STWBRX | SAB(datalo, rbase, addrlo));
@@ -1894,10 +1741,34 @@ static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
             tcg_out32(s, insn | SAB(datalo, rbase, addrlo));
         }
     }
+}
+
+static void tcg_out_qemu_st(TCGContext *s, const TCGArg *args, bool is_64)
+{
+    TCGReg datalo __attribute__((unused));
+    TCGReg datahi __attribute__((unused));
+    TCGReg addrlo __attribute__((unused));
+    TCGReg addrhi __attribute__((unused));
+    TCGMemOpIdx oi;
+
+    datalo = *args++;
+    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);
+    addrlo = *args++;
+    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);
+    oi = *args++;
 
 #ifdef CONFIG_SOFTMMU
-    add_qemu_ldst_label(s, false, oi, datalo, datahi, addrlo, addrhi,
-                        s->code_ptr, label_ptr);
+    add_ldst_ool_label(s, false, is_64, oi, R_PPC_REL24, 0);
+    tcg_out_b_noaddr(s, B | LK);
+#else
+    TCGMemOp opc = get_memop(oi);
+    TCGReg rbase = guest_base ? TCG_GUEST_BASE_REG : 0;
+
+    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {
+        tcg_out_ext32u(s, TCG_REG_TMP1, addrlo);
+        addrlo = TCG_REG_TMP1;
+    }
+    tcg_out_qemu_st_direct(s, datalo, datahi, addrlo, rbase, opc);
 #endif
 }
 
@@ -1909,6 +1780,89 @@ static void tcg_out_nop_fill(tcg_insn_unit *p, int count)
     }
 }
 
+#ifdef CONFIG_SOFTMMU
+static tcg_insn_unit *tcg_out_qemu_ldst_ool(TCGContext *s, bool is_ld,
+                                            bool is_64, TCGMemOpIdx oi)
+{
+    TCGMemOp opc = get_memop(oi);
+    int mem_index = get_mmuidx(oi);
+    TCGReg addrlo, addrhi, datalo, datahi, rbase, nextarg;
+    tcg_insn_unit *thunk, *label;
+
+    /* Since we're amortizing the cost, align the thunk.  */
+    thunk = QEMU_ALIGN_PTR_UP(s->code_ptr, 16);
+    if (thunk != s->code_ptr) {
+        tcg_out_nop_fill(s->code_ptr, thunk - s->code_ptr);
+        s->code_ptr = thunk;
+    }
+
+    /* Discover where the inputs are held.  */
+    if (TCG_TARGET_REG_BITS == 64) {
+        addrhi = addrlo = tcg_target_call_iarg_regs[1];
+        if (is_ld) {
+            datahi = datalo = tcg_target_call_oarg_regs[0];
+            nextarg = addrlo + 1;
+        } else {
+            datahi = datalo = addrlo + 1;
+            nextarg = addrlo + 2;
+        }
+    } else {
+        nextarg = tcg_target_call_iarg_regs[1];
+        if (TARGET_LONG_BITS == 64) {
+            nextarg = softmmu_args_2(nextarg, &addrlo, &addrhi);
+        } else {
+            addrhi = addrlo = nextarg++;
+        }
+        if (is_ld) {
+            TCGReg arg = tcg_target_call_oarg_regs[0];
+            if (is_64) {
+                softmmu_args_2(arg, &datalo, &datahi);
+            } else {
+                addrhi = addrlo = arg;
+            }
+        } else {
+            if (is_64) {
+                nextarg = softmmu_args_2(nextarg, &datalo, &datahi);
+            } else {
+                addrhi = addrlo = nextarg++;
+            }
+        }
+    }
+
+    rbase = TCG_REG_R9;
+    tcg_out_tlb_read(s, opc, addrlo, addrhi, mem_index,
+                     is_ld, rbase, TCG_REG_R10);
+
+    label = s->code_ptr;
+    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE);
+
+    /* TLB Hit */
+    if (is_ld) {
+        tcg_out_qemu_ld_direct(s, datalo, datahi, addrlo, rbase, opc);
+    } else {
+        tcg_out_qemu_st_direct(s, datalo, datahi, addrlo, rbase, opc);
+    }
+    tcg_out32(s, BCLR | BO_ALWAYS);
+
+    /* TLB Miss */
+    reloc_pc14(label, s->code_ptr);
+
+    tcg_out_mov(s, TCG_TYPE_PTR, tcg_target_call_iarg_regs[0], TCG_AREG0);
+    /* The addrhi, addrlo, datahi, datalo registers are already in place.  */
+    tcg_out_movi(s, TCG_TYPE_I32, nextarg++, oi);
+    tcg_out32(s, MFSPR | RT(nextarg) | LR);
+
+    /* Tail call to the helper.  */
+    if (is_ld) {
+        tcg_out_call_int(s, qemu_ld_helpers[opc & (MO_BSWAP | MO_SSIZE)], 0);
+    } else {
+        tcg_out_call_int(s, qemu_st_helpers[opc & (MO_BSWAP | MO_SIZE)], 0);
+    }
+
+    return thunk;
+}
+#endif
+
 /* Parameters for function call generation, used in tcg.c.  */
 #define TCG_TARGET_STACK_ALIGN       16
 #define TCG_TARGET_EXTEND_ARGS       1
-- 
2.17.2


