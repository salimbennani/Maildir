Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 26 Nov 2018 08:51:47 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga003.jf.intel.com (orsmga003.jf.intel.com [10.7.209.27])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 6B16A5803C2
	for <like.xu@linux.intel.com>; Sun, 25 Nov 2018 12:35:49 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by orsmga003-1.jf.intel.com with ESMTP; 25 Nov 2018 12:35:48 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3Ag4r/yRxOmleLwITXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?2uweIJqq85mqBkHD//Il1AaPAd2Lraocw8Pt8InYEVQa5piAtH1QOLdtbDQizf?=
 =?us-ascii?q?ssogo7HcSeAlf6JvO5JwYzHcBFSUM3tyrjaRsdF8nxfUDdrWOv5jAOBBr/KRB1?=
 =?us-ascii?q?JuPoEYLOksi7ze+/94HQbglSmDaxfa55IQmrownWqsQYm5ZpJLwryhvOrHtIeu?=
 =?us-ascii?q?BWyn1tKFmOgRvy5dq+8YB6/ShItP0v68BPUaPhf6QlVrNYFygpM3o05MLwqxbO?=
 =?us-ascii?q?SxaE62YGXWUXlhpIBBXF7A3/U5zsvCb2qvZx1S+HNsDtU7s6RSqt4LtqSB/wiS?=
 =?us-ascii?q?cIKTg58H3MisdtiK5XuQ+tqwBjz4LRZoyeKfhwcb7Hfd4CW2RBUMZfWS9PDIyy?=
 =?us-ascii?q?YIQADfYOM+lFoYnlpVYArxSzCRSiCe/z1DBInWT73bEj0+k7DQ3KwAItEtIIvX?=
 =?us-ascii?q?/JrNv1LqASUeWtwaTW1zLMculW2Tbh54fQdB4uv+mDU7N3ccXL1UkgCRnFhUiX?=
 =?us-ascii?q?pIP5OzOV2f8As2uB4OpnSO2jkWknqxt+ojW2wMonl4rHhpoNx1za6Sl0w5w5Kc?=
 =?us-ascii?q?ClREN4e9KoDpVduiGAO4drQM4uW2VltDogxrAFvZO3ZjUGxZAmyhLFdvCLbpSE?=
 =?us-ascii?q?7xT+X+iLOzh4nmhqeLenihay70egzur8W9Gw0FZLtSpFjsLMumoC1xzV98iLUP?=
 =?us-ascii?q?x9/l2u2TqX1gDT7P9LIVwsmKbFN5IswaQ8mocOvUnABCP6hkv7ga+Mekk5+OWk?=
 =?us-ascii?q?8+Hnba/npp+YOY90kAb+MqE2l8ymH+s4NxUOU3GG9uuiyr3s40n5TKxRgf0xj6?=
 =?us-ascii?q?nZtozVKtoApqK+Bw9V04Uj5AilAzapzdQVhX0HLFNDeBKagInlIVDOIPbkDfih?=
 =?us-ascii?q?h1Sgiitkx/fDPrD6BJXNKX7DkLjnfbZg8UJczxAzzd9H65JOFr4BOO7zWlP2tN?=
 =?us-ascii?q?HACh85Mg+0zPj9BNRyy4MTQmaPAq6fMKPPvl6E/OMvI++QZIALvDbxMeQq5/nr?=
 =?us-ascii?q?jSxxpFkGYKP83YcLcGvqWbNiIl6FejzqhdEOF3pMuRAxC+njiVmHWDgUYG6uXq?=
 =?us-ascii?q?U6/XYiBYe7SIvOWI2p04GHxzqxS5hfZ2RaDQKVHHL1MomJRfoILTifO9JsiSAs?=
 =?us-ascii?q?U7+nRIk8kxa0u1jh1rBlI+HIrzAero/pz9Nv5ufexi01oBB9EcWRm06MRXpzmC?=
 =?us-ascii?q?tcSzYo3axXrk130VCFl6RihORSGNVJofJFFA4nY83y1et/XvtzVhjAdeCtRWGJ?=
 =?us-ascii?q?Rdy6DCt5Gtk1zPcNakFxXdK4gUaQjGKRH7YJmunTV9QP+aXG0i20fp4lxg=3D?=
 =?us-ascii?q?=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ADAAB5BvtbhxHrdtBhGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwEBgS8qgjiMEV+LH4FgLZc8FIFjEBgUhECEGiI0CQ0?=
 =?us-ascii?q?BAwEBAQEBAQIBEwEBAQoLCQgbDi9CARABgWIFAgMaAQaCWwEBAQECAQECFw0fC?=
 =?us-ascii?q?ikDAgEBAgYBAQoYHAoIAwE5GgYNBgIBAQGCUUuBeggBAwGmbjOFQINKgQ2MCRE?=
 =?us-ascii?q?GgX+BESeCa4RnF4VbAokfMoVIkGkJkSkGGIFZiC6HAZgwgUaCDU0wCIMnggAkA?=
 =?us-ascii?q?xcSbQEHjRZxgQQDhHWFCispgXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ADAAB5BvtbhxHrdtBhGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwEBgS8qgjiMEV+LH4FgLZc8FIFjEBgUhECEGiI0CQ0BAwEBAQEBAQIBE?=
 =?us-ascii?q?wEBAQoLCQgbDi9CARABgWIFAgMaAQaCWwEBAQECAQECFw0fCikDAgEBAgYBAQo?=
 =?us-ascii?q?YHAoIAwE5GgYNBgIBAQGCUUuBeggBAwGmbjOFQINKgQ2MCREGgX+BESeCa4RnF?=
 =?us-ascii?q?4VbAokfMoVIkGkJkSkGGIFZiC6HAZgwgUaCDU0wCIMnggAkAxcSbQEHjRZxgQQ?=
 =?us-ascii?q?DhHWFCispgXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,279,1539673200"; 
   d="scan'208";a="41458416"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 25 Nov 2018 12:35:48 -0800
Received: from localhost ([::1]:32904 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gR187-000253-D7
	for like.xu@linux.intel.com; Sun, 25 Nov 2018 15:35:47 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:35028)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <clg@kaod.org>) id 1gR17p-00024p-AS
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 15:35:31 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <clg@kaod.org>) id 1gR17l-0007Nl-2g
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 15:35:29 -0500
Received: from 2.mo177.mail-out.ovh.net ([178.33.109.80]:53801)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <clg@kaod.org>) id 1gR17k-0007L7-P2
	for qemu-devel@nongnu.org; Sun, 25 Nov 2018 15:35:25 -0500
Received: from player786.ha.ovh.net (unknown [10.109.160.76])
	by mo177.mail-out.ovh.net (Postfix) with ESMTP id 0CB5AD272E
	for <qemu-devel@nongnu.org>; Sun, 25 Nov 2018 21:35:15 +0100 (CET)
Received: from kaod.org (lfbn-1-10605-110.w90-89.abo.wanadoo.fr
	[90.89.196.110]) (Authenticated sender: postmaster@kaod.org)
	by player786.ha.ovh.net (Postfix) with ESMTPSA id 606AD4897F8;
	Sun, 25 Nov 2018 20:35:10 +0000 (UTC)
To: David Gibson <david@gibson.dropbear.id.au>
References: <20181116105729.23240-1-clg@kaod.org>
	<20181116105729.23240-8-clg@kaod.org>
	<20181123050858.GA10448@umbus.fritz.box>
From: =?UTF-8?Q?C=c3=a9dric_Le_Goater?= <clg@kaod.org>
Message-ID: <8f6de3b8-b1df-f5e6-cfd8-aeca93a521b6@kaod.org>
Date: Sun, 25 Nov 2018 21:35:08 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
	Thunderbird/60.3.0
MIME-Version: 1.0
In-Reply-To: <20181123050858.GA10448@umbus.fritz.box>
Content-Type: text/plain; charset=windows-1252
Content-Language: en-US
X-Ovh-Tracer-Id: 541276384301910897
X-VR-SPAMSTATE: OK
X-VR-SPAMSCORE: -100
X-VR-SPAMCAUSE: gggruggvucftvghtrhhoucdtuddrgedtkedrudduhedgudegfecutefuodetggdotefrodftvfcurfhrohhfihhlvgemucfqggfjpdevjffgvefmvefgnecuuegrihhlohhuthemucehtddtnecusecvtfgvtghiphhivghnthhsucdlqddutddtmd
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 178.33.109.80
Subject: Re: [Qemu-devel] [PATCH v5 07/36] ppc/xive: introduce the XIVE
 interrupt thread context
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: qemu-ppc@nongnu.org, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On 11/23/18 6:08 AM, David Gibson wrote:
> On Fri, Nov 16, 2018 at 11:57:00AM +0100, C=E9dric Le Goater wrote:
>> Each POWER9 processor chip has a XIVE presenter that can generate four
>> different exceptions to its threads:
>>
>>   - hypervisor exception,
>>   - O/S exception
>>   - Event-Based Branch (EBB)
>>   - msgsnd (doorbell).
>>
>> Each exception has a state independent from the others called a Thread
>> Interrupt Management context. This context is a set of registers which
>> lets the thread handle priority management and interrupt acknowledgmen=
t
>> among other things. The most important ones being :
>>
>>   - Interrupt Priority Register  (PIPR)
>>   - Interrupt Pending Buffer     (IPB)
>>   - Current Processor Priority   (CPPR)
>>   - Notification Source Register (NSR)
>>
>> These registers are accessible through a specific MMIO region, called
>> the Thread Interrupt Management Area (TIMA), four aligned pages, each
>> exposing a different view of the registers. First page (page address
>> ending in 0b00) gives access to the entire context and is reserved for
>> the ring 0 security monitor. The second (page address ending in 0b01)
>> is for the hypervisor, ring 1. The third (page address ending in 0b10)
>> is for the operating system, ring 2. The fourth (page address ending
>> in 0b11) is for user level, ring 3.
>>
>> The thread interrupt context is modeled with a XiveTCTX object
>> containing the values of the different exception registers. The TIMA
>> region is mapped at the same address for each CPU.
>>
>> Signed-off-by: C=E9dric Le Goater <clg@kaod.org>
>> ---
>>  include/hw/ppc/xive.h      |  36 +++
>>  include/hw/ppc/xive_regs.h |  82 +++++++
>>  hw/intc/xive.c             | 443 ++++++++++++++++++++++++++++++++++++=
+
>>  3 files changed, 561 insertions(+)
>>
>> diff --git a/include/hw/ppc/xive.h b/include/hw/ppc/xive.h
>> index 24301bf2076d..5987f26ddb98 100644
>> --- a/include/hw/ppc/xive.h
>> +++ b/include/hw/ppc/xive.h
>> @@ -238,4 +238,40 @@ typedef struct XiveENDSource {
>>  void xive_end_reset(XiveEND *end);
>>  void xive_end_pic_print_info(XiveEND *end, uint32_t end_idx, Monitor =
*mon);
>> =20
>> +/*
>> + * XIVE Thread interrupt Management (TM) context
>> + */
>> +
>> +#define TYPE_XIVE_TCTX "xive-tctx"
>> +#define XIVE_TCTX(obj) OBJECT_CHECK(XiveTCTX, (obj), TYPE_XIVE_TCTX)
>> +
>> +/*
>> + * XIVE Thread interrupt Management register rings :
>> + *
>> + *   QW-0  User       event-based exception state
>> + *   QW-1  O/S        OS context for priority management, interrupt a=
cks
>> + *   QW-2  Pool       hypervisor context for virtual processor being =
dispatched
>> + *   QW-3  Physical   for the security monitor to manage the entire c=
ontext
>=20
> That last description is misleading, AIUI the hypervisor can and does
> make use of the physical ring as well as the pool ring.

yes. The description is from the spec. I will rephrase.=20

>=20
>> + */
>> +#define TM_RING_COUNT           4
>> +#define TM_RING_SIZE            0x10
>> +
>> +typedef struct XiveTCTX {
>> +    DeviceState parent_obj;
>> +
>> +    CPUState    *cs;
>> +    qemu_irq    output;
>> +
>> +    uint8_t     regs[TM_RING_COUNT * TM_RING_SIZE];
>=20
> I'm a bit dubious about representing the state with a full buffer like
> this.  Isn't a fair bit of this space reserved or derived values which
> aren't backed by real state?

Under sPAPR only the TM_QW1_OS ring is accessed but the TM_QW0_USER=20
will also be when we support EBB.

When running under the PowerNV machine, all rings could be accessed.
Today only 2 and 3 are.

It seemed correct to expose all registers under the thread interrupt
context model and filter the accesses with the TIMA. It fits the HW
well.

>=20
>> +
>> +    XiveRouter  *xrtr;
>=20
> What's this for?  AFAIK a TCTX isn't associated with a particular
> routing unit.

I should have added the pointer in patch 11 where it is used. This is=20
to let the sPAPR XIVE controller model reset the OS CAM line with the=20
VP identifier.

The TCTX belong to the IVPE XIVE subengine and as the IVRE and IVPE are=20
modeled under the XiveRouter, it's not suprising to see this '*xrtr'=20
back pointer. But I agree we might not need.  Let's talk about it when=20
you reach patch 11.=20

>=20
>> +} XiveTCTX;
>> +
>> +/*
>> + * XIVE Thread Interrupt Management Aera (TIMA)
>=20
> Typo s/Aera/Area/

yep.

>=20
>> + */
>> +extern const MemoryRegionOps xive_tm_ops;
>> +
>> +void xive_tctx_pic_print_info(XiveTCTX *tctx, Monitor *mon);
>> +
>>  #endif /* PPC_XIVE_H */
>> diff --git a/include/hw/ppc/xive_regs.h b/include/hw/ppc/xive_regs.h
>> index f97fb2b90bee..2e3d6cb507da 100644
>> --- a/include/hw/ppc/xive_regs.h
>> +++ b/include/hw/ppc/xive_regs.h
>> @@ -10,6 +10,88 @@
>>  #ifndef PPC_XIVE_REGS_H
>>  #define PPC_XIVE_REGS_H
>> =20
>> +#define TM_SHIFT                16
>> +
>> +/* TM register offsets */
>> +#define TM_QW0_USER             0x000 /* All rings */
>> +#define TM_QW1_OS               0x010 /* Ring 0..2 */
>> +#define TM_QW2_HV_POOL          0x020 /* Ring 0..1 */
>> +#define TM_QW3_HV_PHYS          0x030 /* Ring 0..1 */
>> +
>> +/* Byte offsets inside a QW             QW0 QW1 QW2 QW3 */
>> +#define TM_NSR                  0x0  /*  +   +   -   +  */
>> +#define TM_CPPR                 0x1  /*  -   +   -   +  */
>> +#define TM_IPB                  0x2  /*  -   +   +   +  */
>> +#define TM_LSMFB                0x3  /*  -   +   +   +  */
>> +#define TM_ACK_CNT              0x4  /*  -   +   -   -  */
>> +#define TM_INC                  0x5  /*  -   +   -   +  */
>> +#define TM_AGE                  0x6  /*  -   +   -   +  */
>> +#define TM_PIPR                 0x7  /*  -   +   -   +  */
>> +
>> +#define TM_WORD0                0x0
>> +#define TM_WORD1                0x4
>> +
>> +/*
>> + * QW word 2 contains the valid bit at the top and other fields
>> + * depending on the QW.
>> + */
>> +#define TM_WORD2                0x8
>> +#define   TM_QW0W2_VU           PPC_BIT32(0)
>> +#define   TM_QW0W2_LOGIC_SERV   PPC_BITMASK32(1, 31) /* XX 2,31 ? */
>> +#define   TM_QW1W2_VO           PPC_BIT32(0)
>> +#define   TM_QW1W2_OS_CAM       PPC_BITMASK32(8, 31)
>> +#define   TM_QW2W2_VP           PPC_BIT32(0)
>> +#define   TM_QW2W2_POOL_CAM     PPC_BITMASK32(8, 31)
>> +#define   TM_QW3W2_VT           PPC_BIT32(0)
>> +#define   TM_QW3W2_LP           PPC_BIT32(6)
>> +#define   TM_QW3W2_LE           PPC_BIT32(7)
>> +#define   TM_QW3W2_T            PPC_BIT32(31)
>> +
>> +/*
>> + * In addition to normal loads to "peek" and writes (only when invali=
d)
>> + * using 4 and 8 bytes accesses, the above registers support these
>> + * "special" byte operations:
>> + *
>> + *   - Byte load from QW0[NSR] - User level NSR (EBB)
>> + *   - Byte store to QW0[NSR] - User level NSR (EBB)
>> + *   - Byte load/store to QW1[CPPR] and QW3[CPPR] - CPPR access
>> + *   - Byte load from QW3[TM_WORD2] - Read VT||00000||LP||LE on thrd =
0
>> + *                                    otherwise VT||0000000
>> + *   - Byte store to QW3[TM_WORD2] - Set VT bit (and LP/LE if present=
)
>> + *
>> + * Then we have all these "special" CI ops at these offset that trigg=
er
>> + * all sorts of side effects:
>> + */
>> +#define TM_SPC_ACK_EBB          0x800   /* Load8 ack EBB to reg*/
>> +#define TM_SPC_ACK_OS_REG       0x810   /* Load16 ack OS irq to reg *=
/
>> +#define TM_SPC_PUSH_USR_CTX     0x808   /* Store32 Push/Validate user=
 context */
>> +#define TM_SPC_PULL_USR_CTX     0x808   /* Load32 Pull/Invalidate use=
r
>> +                                         * context */
>> +#define TM_SPC_SET_OS_PENDING   0x812   /* Store8 Set OS irq pending =
bit */
>> +#define TM_SPC_PULL_OS_CTX      0x818   /* Load32/Load64 Pull/Invalid=
ate OS
>> +                                         * context to reg */
>> +#define TM_SPC_PULL_POOL_CTX    0x828   /* Load32/Load64 Pull/Invalid=
ate Pool
>> +                                         * context to reg*/
>> +#define TM_SPC_ACK_HV_REG       0x830   /* Load16 ack HV irq to reg *=
/
>> +#define TM_SPC_PULL_USR_CTX_OL  0xc08   /* Store8 Pull/Inval usr ctx =
to odd
>> +                                         * line */
>> +#define TM_SPC_ACK_OS_EL        0xc10   /* Store8 ack OS irq to even =
line */
>> +#define TM_SPC_ACK_HV_POOL_EL   0xc20   /* Store8 ack HV evt pool to =
even
>> +                                         * line */
>> +#define TM_SPC_ACK_HV_EL        0xc30   /* Store8 ack HV irq to even =
line */
>> +/* XXX more... */
>> +
>> +/* NSR fields for the various QW ack types */
>> +#define TM_QW0_NSR_EB           PPC_BIT8(0)
>> +#define TM_QW1_NSR_EO           PPC_BIT8(0)
>> +#define TM_QW3_NSR_HE           PPC_BITMASK8(0, 1)
>> +#define  TM_QW3_NSR_HE_NONE     0
>> +#define  TM_QW3_NSR_HE_POOL     1
>> +#define  TM_QW3_NSR_HE_PHYS     2
>> +#define  TM_QW3_NSR_HE_LSI      3
>> +#define TM_QW3_NSR_I            PPC_BIT8(2)
>> +#define TM_QW3_NSR_GRP_LVL      PPC_BIT8(3, 7)
>> +
>>  /* EAS (Event Assignment Structure)
>>   *
>>   * One per interrupt source. Targets an interrupt to a given Event
>> diff --git a/hw/intc/xive.c b/hw/intc/xive.c
>> index 5a8882d47a98..4c6cb5d52975 100644
>> --- a/hw/intc/xive.c
>> +++ b/hw/intc/xive.c
>> @@ -15,6 +15,448 @@
>>  #include "sysemu/dma.h"
>>  #include "monitor/monitor.h"
>>  #include "hw/ppc/xive.h"
>> +#include "hw/ppc/xive_regs.h"
>> +
>> +/*
>> + * XIVE Thread Interrupt Management context
>> + */
>> +
>> +static uint64_t xive_tctx_accept(XiveTCTX *tctx, uint8_t ring)
>> +{
>> +    return 0;
>> +}
>> +
>> +static void xive_tctx_set_cppr(XiveTCTX *tctx, uint8_t ring, uint8_t =
cppr)
>> +{
>> +    if (cppr > XIVE_PRIORITY_MAX) {
>> +        cppr =3D 0xff;
>> +    }
>> +
>> +    tctx->regs[ring + TM_CPPR] =3D cppr;
>> +}
>> +
>> +/*
>> + * XIVE Thread Interrupt Management Area (TIMA)
>> + *
>> + * This region gives access to the registers of the thread interrupt
>> + * management context. It is four page wide, each page providing a
>> + * different view of the registers. The page with the lower offset is
>> + * the most privileged and gives access to the entire context.
>> + */
>> +
>> +#define XIVE_TM_HW_PAGE   0x0
>> +#define XIVE_TM_HV_PAGE   0x1
>> +#define XIVE_TM_OS_PAGE   0x2
>> +#define XIVE_TM_USER_PAGE 0x3
>> +
>> +/*
>> + * Define an access map for each page of the TIMA that we will use in
>> + * the memory region ops to filter values when doing loads and stores
>> + * of raw registers values
>> + *
>> + * Registers accessibility bits :
>> + *
>> + *    0x0 - no access
>> + *    0x1 - write only
>> + *    0x2 - read only
>> + *    0x3 - read/write
>> + */
>> +
>> +static const uint8_t xive_tm_hw_view[] =3D {
>> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-1 OS   */   3, 3, 3, 3,   3, 3, 0, 3,   3, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-2 HV   */   0, 0, 3, 3,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-3 HW   */   3, 3, 3, 3,   0, 3, 0, 3,   3, 0, 0, 3,   3, 3,=
 3, 0,
>=20
> Can we stick to the "Pool" / "Phys" names rather than inventing HV and
> HW.  XIVE already has too many names for things.  To clarify that's
> for the naming of the QWs, the view names are fine.

sure. I will fix the names.
=20
>> +};
>> +
>> +static const uint8_t xive_tm_hv_view[] =3D {
>> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-1 OS   */   3, 3, 3, 3,   3, 3, 0, 3,   3, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-2 HV   */   0, 0, 3, 3,   0, 0, 0, 0,   0, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-3 HW   */   3, 3, 3, 3,   0, 3, 0, 3,   3, 0, 0, 3,   0, 0,=
 0, 0,
>> +};
>> +
>> +static const uint8_t xive_tm_os_view[] =3D {
>> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   3, 3, 3, 3,   0, 0,=
 0, 0,
>> +    /* QW-1 OS   */   2, 3, 2, 2,   2, 2, 0, 2,   0, 0, 0, 0,   0, 0,=
 0, 0,
>> +    /* QW-2 HV   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0,=
 0, 0,
>> +    /* QW-3 HW   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 3,=
 3, 0,
>=20
> Are those bytes near the end of QW-3 really accessible in OS but not
> hypervisor view?

No. It's copy/paste error. Thx.

>> +};
>> +
>> +static const uint8_t xive_tm_user_view[] =3D {
>> +    /* QW-0 User */   3, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0,=
 0, 0,
>> +    /* QW-1 OS   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0,=
 0, 0,
>> +    /* QW-2 HV   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0,=
 0, 0,
>> +    /* QW-3 HW   */   0, 0, 0, 0,   0, 0, 0, 0,   0, 0, 0, 0,   0, 0,=
 0, 0,
>> +};
>> +
>> +/*
>> + * Overall TIMA access map for the thread interrupt management contex=
t
>> + * registers
>> + */
>> +static const uint8_t *xive_tm_views[] =3D {
>> +    [XIVE_TM_HW_PAGE]   =3D xive_tm_hw_view,
>> +    [XIVE_TM_HV_PAGE]   =3D xive_tm_hv_view,
>> +    [XIVE_TM_OS_PAGE]   =3D xive_tm_os_view,
>> +    [XIVE_TM_USER_PAGE] =3D xive_tm_user_view,
>> +};
>> +
>> +/*
>> + * Computes a register access mask for a given offset in the TIMA
>> + */
>> +static uint64_t xive_tm_mask(hwaddr offset, unsigned size, bool write=
)
>> +{
>> +    uint8_t page_offset =3D (offset >> TM_SHIFT) & 0x3;
>> +    uint8_t reg_offset =3D offset & 0x3F;
>> +    uint8_t reg_mask =3D write ? 0x1 : 0x2;
>> +    uint64_t mask =3D 0x0;
>> +    int i;
>> +
>> +    for (i =3D 0; i < size; i++) {
>> +        if (xive_tm_views[page_offset][reg_offset + i] & reg_mask) {
>> +            mask |=3D (uint64_t) 0xff << (8 * (size - i - 1));
>> +        }
>> +    }
>> +
>> +    return mask;
>> +}
>> +
>> +static void xive_tm_raw_write(XiveTCTX *tctx, hwaddr offset, uint64_t=
 value,
>> +                              unsigned size)
>> +{
>> +    uint8_t ring_offset =3D offset & 0x30;
>> +    uint8_t reg_offset =3D offset & 0x3F;
>> +    uint64_t mask =3D xive_tm_mask(offset, size, true);
>> +    int i;
>> +
>> +    /*
>> +     * Only 4 or 8 bytes stores are allowed and the User ring is
>> +     * excluded
>> +     */
>> +    if (size < 4 || !mask || ring_offset =3D=3D TM_QW0_USER) {
>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid write access at=
 TIMA @%"
>> +                      HWADDR_PRIx"\n", offset);
>> +        return;
>> +    }
>> +
>> +    /*
>> +     * Use the register offset for the raw values and filter out
>> +     * reserved values
>> +     */
>> +    for (i =3D 0; i < size; i++) {
>> +        uint8_t byte_mask =3D (mask >> (8 * (size - i - 1)));
>> +        if (byte_mask) {
>> +            tctx->regs[reg_offset + i] =3D (value >> (8 * (size - i -=
 1))) &
>> +                byte_mask;
>> +        }
>> +    }
>> +}
>> +
>> +static uint64_t xive_tm_raw_read(XiveTCTX *tctx, hwaddr offset, unsig=
ned size)
>> +{
>> +    uint8_t ring_offset =3D offset & 0x30;
>> +    uint8_t reg_offset =3D offset & 0x3F;
>> +    uint64_t mask =3D xive_tm_mask(offset, size, false);
>> +    uint64_t ret;
>> +    int i;
>> +
>> +    /*
>> +     * Only 4 or 8 bytes loads are allowed and the User ring is
>> +     * excluded
>> +     */
>> +    if (size < 4 || !mask || ring_offset =3D=3D TM_QW0_USER) {
>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid read access at =
TIMA @%"
>> +                      HWADDR_PRIx"\n", offset);
>> +        return -1;
>> +    }
>> +
>> +    /* Use the register offset for the raw values */
>> +    ret =3D 0;
>> +    for (i =3D 0; i < size; i++) {
>> +        ret |=3D (uint64_t) tctx->regs[reg_offset + i] << (8 * (size =
- i - 1));
>> +    }
>> +
>> +    /* filter out reserved values */
>> +    return ret & mask;
>> +}
>> +
>> +/*
>> + * The TM context is mapped twice within each page. Stores and loads
>> + * to the first mapping below 2K write and read the specified values
>> + * without modification. The second mapping above 2K performs specifi=
c
>> + * state changes (side effects) in addition to setting/returning the
>> + * interrupt management area context of the processor thread.
>> + */
>> +static uint64_t xive_tm_ack_os_reg(XiveTCTX *tctx, hwaddr offset, uns=
igned size)
>> +{
>> +    return xive_tctx_accept(tctx, TM_QW1_OS);
>> +}
>> +
>> +static void xive_tm_set_os_cppr(XiveTCTX *tctx, hwaddr offset,
>> +                                uint64_t value, unsigned size)
>> +{
>> +    xive_tctx_set_cppr(tctx, TM_QW1_OS, value & 0xff);
>> +}
>> +
>> +/*
>> + * Define a mapping of "special" operations depending on the TIMA pag=
e
>> + * offset and the size of the operation.
>> + */
>> +typedef struct XiveTmOp {
>> +    uint8_t  page_offset;
>> +    uint32_t op_offset;
>> +    unsigned size;
>> +    void     (*write_handler)(XiveTCTX *tctx, hwaddr offset, uint64_t=
 value,
>> +                              unsigned size);
>> +    uint64_t (*read_handler)(XiveTCTX *tctx, hwaddr offset, unsigned =
size);
>> +} XiveTmOp;
>> +
>> +static const XiveTmOp xive_tm_operations[] =3D {
>> +    /*
>> +     * MMIOs below 2K : raw values and special operations without sid=
e
>> +     * effects
>> +     */
>> +    { XIVE_TM_OS_PAGE, TM_QW1_OS + TM_CPPR,   1, xive_tm_set_os_cppr,=
 NULL },
>> +
>> +    /* MMIOs above 2K : special operations with side effects */
>> +    { XIVE_TM_OS_PAGE, TM_SPC_ACK_OS_REG,     2, NULL, xive_tm_ack_os=
_reg },
>> +};
>> +
>> +static const XiveTmOp *xive_tm_find_op(hwaddr offset, unsigned size, =
bool write)
>> +{
>> +    uint8_t page_offset =3D (offset >> TM_SHIFT) & 0x3;
>> +    uint32_t op_offset =3D offset & 0xFFF;
>> +    int i;
>> +
>> +    for (i =3D 0; i < ARRAY_SIZE(xive_tm_operations); i++) {
>> +        const XiveTmOp *xto =3D &xive_tm_operations[i];
>> +
>> +        /* Accesses done from a more privileged TIMA page is allowed =
*/
>> +        if (xto->page_offset >=3D page_offset &&
>> +            xto->op_offset =3D=3D op_offset &&
>> +            xto->size =3D=3D size &&
>> +            ((write && xto->write_handler) || (!write && xto->read_ha=
ndler))) {
>> +            return xto;
>> +        }
>> +    }
>> +    return NULL;
>> +}
>> +
>> +/*
>> + * TIMA MMIO handlers
>> + */
>> +static void xive_tm_write(void *opaque, hwaddr offset,
>> +                          uint64_t value, unsigned size)
>> +{
>> +    PowerPCCPU *cpu =3D POWERPC_CPU(current_cpu);
>> +    XiveTCTX *tctx =3D XIVE_TCTX(cpu->intc);
>> +    const XiveTmOp *xto;
>> +
>> +    /*
>> +     * TODO: check V bit in Q[0-3]W2, check PTER bit associated with =
CPU
>> +     */
>> +
>> +    /*
>> +     * First, check for special operations in the 2K region
>> +     */
>> +    if (offset & 0x800) {
>> +        xto =3D xive_tm_find_op(offset, size, true);
>> +        if (!xto) {
>> +            qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid write acces=
s at TIMA"
>> +                          "@%"HWADDR_PRIx"\n", offset);
>> +        } else {
>> +            xto->write_handler(tctx, offset, value, size);
>> +        }
>> +        return;
>> +    }
>> +
>> +    /*
>> +     * Then, for special operations in the region below 2K.
>> +     */
>> +    xto =3D xive_tm_find_op(offset, size, true);
>> +    if (xto) {
>> +        xto->write_handler(tctx, offset, value, size);
>> +        return;
>> +    }
>> +
>> +    /*
>> +     * Finish with raw access to the register values
>> +     */
>> +    xive_tm_raw_write(tctx, offset, value, size);
>> +}
>> +
>> +static uint64_t xive_tm_read(void *opaque, hwaddr offset, unsigned si=
ze)
>> +{
>> +    PowerPCCPU *cpu =3D POWERPC_CPU(current_cpu);
>> +    XiveTCTX *tctx =3D XIVE_TCTX(cpu->intc);
>> +    const XiveTmOp *xto;
>> +
>> +    /*
>> +     * TODO: check V bit in Q[0-3]W2, check PTER bit associated with =
CPU
>> +     */
>> +
>> +    /*
>> +     * First, check for special operations in the 2K region
>> +     */
>> +    if (offset & 0x800) {
>> +        xto =3D xive_tm_find_op(offset, size, false);
>> +        if (!xto) {
>> +            qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid read access=
 to TIMA"
>> +                          "@%"HWADDR_PRIx"\n", offset);
>> +            return -1;
>> +        }
>> +        return xto->read_handler(tctx, offset, size);
>> +    }
>> +
>> +    /*
>> +     * Then, for special operations in the region below 2K.
>> +     */
>> +    xto =3D xive_tm_find_op(offset, size, false);
>> +    if (xto) {
>> +        return xto->read_handler(tctx, offset, size);
>> +    }
>> +
>> +    /*
>> +     * Finish with raw access to the register values
>> +     */
>> +    return xive_tm_raw_read(tctx, offset, size);
>> +}
>> +
>> +const MemoryRegionOps xive_tm_ops =3D {
>> +    .read =3D xive_tm_read,
>> +    .write =3D xive_tm_write,
>> +    .endianness =3D DEVICE_BIG_ENDIAN,
>> +    .valid =3D {
>> +        .min_access_size =3D 1,
>> +        .max_access_size =3D 8,
>> +    },
>> +    .impl =3D {
>> +        .min_access_size =3D 1,
>> +        .max_access_size =3D 8,
>> +    },
>> +};
>> +
>> +static char *xive_tctx_ring_print(uint8_t *ring)
>> +{
>> +    uint32_t w2 =3D be32_to_cpu(*((uint32_t *) &ring[TM_WORD2]));
>> +
>> +    return g_strdup_printf("%02x   %02x  %02x    %02x   %02x  "
>> +                   "%02x  %02x   %02x  %08x",
>> +                   ring[TM_NSR], ring[TM_CPPR], ring[TM_IPB], ring[TM=
_LSMFB],
>> +                   ring[TM_ACK_CNT], ring[TM_INC], ring[TM_AGE], ring=
[TM_PIPR],
>> +                   w2);
>> +}
>> +
>> +static const struct {
>> +    uint8_t    qw;
>> +    const char *name;
>> +} xive_tctx_ring_infos[TM_RING_COUNT] =3D {
>> +    { TM_QW3_HV_PHYS, "HW"   },
>> +    { TM_QW2_HV_POOL, "HV"   },
>> +    { TM_QW1_OS,      "OS"   },
>> +    { TM_QW0_USER,    "USER" },
>=20
> Likewise here if we can stick to PHYS and POOL rather than HW and HV.

I don't remember why I changed the names :/ I will fix.

> Also, the qw field takes exactly the values 0..3, why not just an
> array of names indexed by the ring number.

yes. There should be room for simplification.=20

Thanks,

C.

>> +};
>> +
>> +void xive_tctx_pic_print_info(XiveTCTX *tctx, Monitor *mon)
>> +{
>> +    int cpu_index =3D tctx->cs ? tctx->cs->cpu_index : -1;
>> +    int i;
>> +
>> +    monitor_printf(mon, "CPU[%04x]:   QW   NSR CPPR IPB LSMFB ACK# IN=
C AGE PIPR"
>> +                   "  W2\n", cpu_index);
>> +
>> +    for (i =3D 0; i < TM_RING_COUNT; i++) {
>> +        char *s =3D xive_tctx_ring_print(&tctx->regs[xive_tctx_ring_i=
nfos[i].qw]);
>> +        monitor_printf(mon, "CPU[%04x]: %4s    %s\n", cpu_index,
>> +                       xive_tctx_ring_infos[i].name, s);
>> +        g_free(s);
>> +    }
>> +}
>> +
>> +static void xive_tctx_reset(void *dev)
>> +{
>> +    XiveTCTX *tctx =3D XIVE_TCTX(dev);
>> +
>> +    memset(tctx->regs, 0, sizeof(tctx->regs));
>> +
>> +    /* Set some defaults */
>> +    tctx->regs[TM_QW1_OS + TM_LSMFB] =3D 0xFF;
>> +    tctx->regs[TM_QW1_OS + TM_ACK_CNT] =3D 0xFF;
>> +    tctx->regs[TM_QW1_OS + TM_AGE] =3D 0xFF;
>> +}
>> +
>> +static void xive_tctx_realize(DeviceState *dev, Error **errp)
>> +{
>> +    XiveTCTX *tctx =3D XIVE_TCTX(dev);
>> +    PowerPCCPU *cpu;
>> +    CPUPPCState *env;
>> +    Object *obj;
>> +    Error *local_err =3D NULL;
>> +
>> +    obj =3D object_property_get_link(OBJECT(dev), "xive", &local_err)=
;
>> +    if (!obj) {
>> +        error_propagate(errp, local_err);
>> +        error_prepend(errp, "required link 'xive' not found: ");
>> +        return;
>> +    }
>> +    tctx->xrtr =3D XIVE_ROUTER(obj);
>> +
>> +    obj =3D object_property_get_link(OBJECT(dev), "cpu", &local_err);
>> +    if (!obj) {
>> +        error_propagate(errp, local_err);
>> +        error_prepend(errp, "required link 'cpu' not found: ");
>> +        return;
>> +    }
>> +
>> +    cpu =3D POWERPC_CPU(obj);
>> +    tctx->cs =3D CPU(obj);
>> +
>> +    env =3D &cpu->env;
>> +    switch (PPC_INPUT(env)) {
>> +    case PPC_FLAGS_INPUT_POWER7:
>> +        tctx->output =3D env->irq_inputs[POWER7_INPUT_INT];
>> +        break;
>> +
>> +    default:
>> +        error_setg(errp, "XIVE interrupt controller does not support =
"
>> +                   "this CPU bus model");
>> +        return;
>> +    }
>> +
>> +    qemu_register_reset(xive_tctx_reset, dev);
>> +}
>> +
>> +static void xive_tctx_unrealize(DeviceState *dev, Error **errp)
>> +{
>> +    qemu_unregister_reset(xive_tctx_reset, dev);
>> +}
>> +
>> +static const VMStateDescription vmstate_xive_tctx =3D {
>> +    .name =3D TYPE_XIVE_TCTX,
>> +    .version_id =3D 1,
>> +    .minimum_version_id =3D 1,
>> +    .fields =3D (VMStateField[]) {
>> +        VMSTATE_BUFFER(regs, XiveTCTX),
>> +        VMSTATE_END_OF_LIST()
>> +    },
>> +};
>> +
>> +static void xive_tctx_class_init(ObjectClass *klass, void *data)
>> +{
>> +    DeviceClass *dc =3D DEVICE_CLASS(klass);
>> +
>> +    dc->realize =3D xive_tctx_realize;
>> +    dc->unrealize =3D xive_tctx_unrealize;
>> +    dc->desc =3D "XIVE Interrupt Thread Context";
>> +    dc->vmsd =3D &vmstate_xive_tctx;
>> +}
>> +
>> +static const TypeInfo xive_tctx_info =3D {
>> +    .name          =3D TYPE_XIVE_TCTX,
>> +    .parent        =3D TYPE_DEVICE,
>> +    .instance_size =3D sizeof(XiveTCTX),
>> +    .class_init    =3D xive_tctx_class_init,
>> +};
>> =20
>>  /*
>>   * XIVE ESB helpers
>> @@ -876,6 +1318,7 @@ static void xive_register_types(void)
>>      type_register_static(&xive_fabric_info);
>>      type_register_static(&xive_router_info);
>>      type_register_static(&xive_end_source_info);
>> +    type_register_static(&xive_tctx_info);
>>  }
>> =20
>>  type_init(xive_register_types)
>=20


