Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 22 Nov 2018 16:37:39 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga006.fm.intel.com (fmsmga006.fm.intel.com [10.253.24.20])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 7AFEC580474
	for <like.xu@linux.intel.com>; Wed, 21 Nov 2018 23:53:51 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by fmsmga006-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 21 Nov 2018 23:53:51 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AZJ6OJhIgTvfH1UgdxNmcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgfLPrxwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfFjfK3SYMkaSHJfUMZfVyJPAY2y?=
 =?us-ascii?q?YIUAAOUDIelWspH9qlkMoxaxGAWhCv/jxSFThnLt2K02z/4sHBva0AEuH98Dtm?=
 =?us-ascii?q?nfotXvNKcVVOC41LfFyi/eYPNM2Dfy9JDHfBY/rv6UXLxwdtDeyVUxGAPfk16d?=
 =?us-ascii?q?rpDqPzea1ukWsGiU9e1gWv+1h24gsQFxrSGiy8ExgYfKnoIY0k7I+Tl6zYovON?=
 =?us-ascii?q?G0VU12bcS6HJZetyyWLZZ6T8E6T2xspCo20L4LtJqhcCQXzJkqxgTTZ+Gaf4SU?=
 =?us-ascii?q?5B/oSfyfLi1ihH1/fbKynxay/lakyu37TsS01FdKrjFZktnXrHwN2BrT6tWdRv?=
 =?us-ascii?q?t65Eeh1i6D1wHV6u5aPUA5jbTXJ4Iiz7Iqi5YfrEfOEjXolEj4jKKabFgo9+qw?=
 =?us-ascii?q?5+TieLrmp5ucN4FuigH5N6QjgtW/Dvo9MggTRmSU5Pqz1KP98k39WblFlfo2kr?=
 =?us-ascii?q?TfsJ/GO8sbvam1AwtU0oYg9RmzFTin0MkAkHkDLVJFfg+HjofzN1HPJvD4Eemw?=
 =?us-ascii?q?g1C2nDh3wPDGO6bsApPKLnjFn7fhe6t951RbyAopwtBT/4hUBa0ZIPLvRk/xs8?=
 =?us-ascii?q?TVDhs4Mwy33enrEtp81p4FVGKLA6+ZNr7SsFCS6uIuJemMeJEauDLnJ/c54P7u?=
 =?us-ascii?q?iCxxpFkGYKP83YcLcGvqWbNiIl6FejzqhdEOF3pMuRAxC+njiVmHWDgUYG6uXq?=
 =?us-ascii?q?U6/XYiBYe7SIvOWI2p04GHxzqxS5hfZ2RaDQKVHHL1MomJRfoILTifO9JsiSAs?=
 =?us-ascii?q?U7+nRIk8kxa0u1jh1rBlI+HIrzAero/pz9Nv5ufexi01oBB9EcWRm06MRXpzmC?=
 =?us-ascii?q?tcSzYo3axXrk130VCFl6RihORSGNVJofJFFA4nY83y1et/XvtzVhjAdeCtRWGJ?=
 =?us-ascii?q?Rdy6DCt5Gtk1zPcNakFxXdK4gUaQjGKRH7YJmunTV9QP+aXG0i20fp4lxg=3D?=
 =?us-ascii?q?=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AJAAB1X/ZbhxHrdtBYChwBAQEEAQEHB?=
 =?us-ascii?q?AEBgVEHAQELAYEwKoI4jBBfiyKCDXqWQBSBYxAYEgKEQIQMIjQJDQEDAQEBAQE?=
 =?us-ascii?q?BAgETAQEBCgsJCCkvgjYFAgMaAQaCWwEBAQEDAQIXDR8KKQMDAQIGAQEKEQECA?=
 =?us-ascii?q?QIBHAoIAwE5DAYIBgoDBgIBAQGCUUsBggEBAwGqfTOFQINZfg+MCREGgX+BESe?=
 =?us-ascii?q?CNjWEQxAUAzSFOwKPGRCQWQmEIY0IBhiBWYguhwGJbYtTgnCBRoINTTAIgyeCJ?=
 =?us-ascii?q?xeOHXGBBAOKUFWBdwEB?=
X-IPAS-Result: =?us-ascii?q?A0AJAAB1X/ZbhxHrdtBYChwBAQEEAQEHBAEBgVEHAQELAYE?=
 =?us-ascii?q?wKoI4jBBfiyKCDXqWQBSBYxAYEgKEQIQMIjQJDQEDAQEBAQEBAgETAQEBCgsJC?=
 =?us-ascii?q?CkvgjYFAgMaAQaCWwEBAQEDAQIXDR8KKQMDAQIGAQEKEQECAQIBHAoIAwE5DAY?=
 =?us-ascii?q?IBgoDBgIBAQGCUUsBggEBAwGqfTOFQINZfg+MCREGgX+BESeCNjWEQxAUAzSFO?=
 =?us-ascii?q?wKPGRCQWQmEIY0IBhiBWYguhwGJbYtTgnCBRoINTTAIgyeCJxeOHXGBBAOKUFW?=
 =?us-ascii?q?BdwEB?=
X-IronPort-AV: E=Sophos;i="5.56,264,1539673200"; 
   d="scan'208,223";a="52253579"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 21 Nov 2018 23:53:49 -0800
Received: from localhost ([::1]:44576 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gPjo5-0000qs-6K
	for like.xu@linux.intel.com; Thu, 22 Nov 2018 02:53:49 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:45471)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <clg@kaod.org>) id 1gPjnW-0000oR-Vd
	for qemu-devel@nongnu.org; Thu, 22 Nov 2018 02:53:17 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <clg@kaod.org>) id 1gPjnR-0007zm-NM
	for qemu-devel@nongnu.org; Thu, 22 Nov 2018 02:53:14 -0500
Received: from 6.mo4.mail-out.ovh.net ([188.165.36.253]:38160)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <clg@kaod.org>) id 1gPjnR-0007yC-6j
	for qemu-devel@nongnu.org; Thu, 22 Nov 2018 02:53:09 -0500
Received: from player693.ha.ovh.net (unknown [10.109.143.3])
	by mo4.mail-out.ovh.net (Postfix) with ESMTP id 868F51BE17D
	for <qemu-devel@nongnu.org>; Thu, 22 Nov 2018 08:53:07 +0100 (CET)
Received: from kaod.org (lfbn-1-10605-110.w90-89.abo.wanadoo.fr
	[90.89.196.110]) (Authenticated sender: postmaster@kaod.org)
	by player693.ha.ovh.net (Postfix) with ESMTPSA id 0EF69FFA4F;
	Thu, 22 Nov 2018 07:53:01 +0000 (UTC)
To: David Gibson <david@gibson.dropbear.id.au>
References: <20181116105729.23240-1-clg@kaod.org>
	<20181116105729.23240-5-clg@kaod.org>
	<20181122041119.GD10448@umbus.fritz.box>
From: =?UTF-8?Q?C=c3=a9dric_Le_Goater?= <clg@kaod.org>
Message-ID: <5e4a0824-a014-c0c3-89f5-40aab83268f9@kaod.org>
Date: Thu, 22 Nov 2018 08:53:00 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
	Thunderbird/60.3.0
MIME-Version: 1.0
In-Reply-To: <20181122041119.GD10448@umbus.fritz.box>
Content-Type: multipart/mixed; boundary="------------54B1BC5AF801A1843592F4B0"
Content-Language: en-US
X-Ovh-Tracer-Id: 6945395051163126641
X-VR-SPAMSTATE: OK
X-VR-SPAMSCORE: -100
X-VR-SPAMCAUSE: gggruggvucftvghtrhhoucdtuddrgedtkedruddtkedguddufecutefuodetggdotefrodftvfcurfhrohhfihhlvgemucfqggfjpdevjffgvefmvefgnecuuegrihhlohhuthemucehtddtnecusecvtfgvtghiphhivghnthhsucdlqddutddtmd
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 188.165.36.253
Subject: Re: [Qemu-devel] [PATCH v5 04/36] ppc/xive: introduce the
 XiveRouter model
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: qemu-ppc@nongnu.org, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

This is a multi-part message in MIME format.
--------------54B1BC5AF801A1843592F4B0
Content-Type: text/plain; charset=windows-1252
Content-Transfer-Encoding: quoted-printable

On 11/22/18 5:11 AM, David Gibson wrote:
> On Fri, Nov 16, 2018 at 11:56:57AM +0100, C=E9dric Le Goater wrote:
>> The XiveRouter models the second sub-engine of the overall XIVE
>> architecture : the Interrupt Virtualization Routing Engine (IVRE).
>>
>> The IVRE handles event notifications of the IVSE through MMIO stores
>> and performs the interrupt routing process. For this purpose, it uses
>> a set of table stored in system memory, the first of which being the
>> Event Assignment Structure (EAS) table.
>>
>> The EAT associates an interrupt source number with an Event Notificati=
on
>> Descriptor (END) which will be used in a second phase of the routing
>> process to identify a Notification Virtual Target.
>>
>> The XiveRouter is an abstract class which needs to be inherited from
>> to define a storage for the EAT, and other upcoming tables. The
>> 'chip-id' atttribute is not strictly necessary for the sPAPR and
>> PowerNV machines but it's a good way to test the routing algorithm.
>> Without this atttribute, the XiveRouter could be a simple QOM
>> interface.
>>
>> Signed-off-by: C=E9dric Le Goater <clg@kaod.org>
>> ---
>>  include/hw/ppc/xive.h      | 32 ++++++++++++++
>>  include/hw/ppc/xive_regs.h | 31 ++++++++++++++
>>  hw/intc/xive.c             | 86 +++++++++++++++++++++++++++++++++++++=
+
>>  3 files changed, 149 insertions(+)
>>  create mode 100644 include/hw/ppc/xive_regs.h
>>
>> diff --git a/include/hw/ppc/xive.h b/include/hw/ppc/xive.h
>> index be93fae6317b..5a0696366577 100644
>> --- a/include/hw/ppc/xive.h
>> +++ b/include/hw/ppc/xive.h
>> @@ -11,6 +11,7 @@
>>  #define PPC_XIVE_H
>> =20
>>  #include "hw/sysbus.h"
>=20
> Again, I don't think making this a SysBusDevice is quite right.
> Even more so for the router than the source, because at least for PAPR
> it might not have any MMIO presence at all.

The controller model inherits from the XiveRouter and manages the TIMA.

>> +#include "hw/ppc/xive_regs.h"
>> =20
>>  /*
>>   * XIVE Fabric (Interface between Source and Router)
>> @@ -168,4 +169,35 @@ static inline void xive_source_irq_set(XiveSource=
 *xsrc, uint32_t srcno,
>>      }
>>  }
>> =20
>> +/*
>> + * XIVE Router
>> + */
>> +
>> +typedef struct XiveRouter {
>> +    SysBusDevice    parent;
>> +
>> +    uint32_t        chip_id;
>=20
> I don't think this belongs in the base class.  The PowerNV specific
> variants will need it, but it doesn't make sense for the PAPR version.

yeah. I am using it as a END and NVT block identifier but it's not=20
required for sPAPR, it could just be zero.=20

It was good to test the routing algo which should not assume that the=20
block id is zero.=20
=20
>=20
>> +} XiveRouter;
>> +
>> +#define TYPE_XIVE_ROUTER "xive-router"
>> +#define XIVE_ROUTER(obj)                                \
>> +    OBJECT_CHECK(XiveRouter, (obj), TYPE_XIVE_ROUTER)
>> +#define XIVE_ROUTER_CLASS(klass)                                     =
   \
>> +    OBJECT_CLASS_CHECK(XiveRouterClass, (klass), TYPE_XIVE_ROUTER)
>> +#define XIVE_ROUTER_GET_CLASS(obj)                              \
>> +    OBJECT_GET_CLASS(XiveRouterClass, (obj), TYPE_XIVE_ROUTER)
>> +
>> +typedef struct XiveRouterClass {
>> +    SysBusDeviceClass parent;
>> +
>> +    /* XIVE table accessors */
>> +    int (*get_eas)(XiveRouter *xrtr, uint32_t lisn, XiveEAS *eas);
>> +    int (*set_eas)(XiveRouter *xrtr, uint32_t lisn, XiveEAS *eas);
>> +} XiveRouterClass;
>> +
>> +void xive_eas_pic_print_info(XiveEAS *eas, uint32_t lisn, Monitor *mo=
n);
>> +
>> +int xive_router_get_eas(XiveRouter *xrtr, uint32_t lisn, XiveEAS *eas=
);
>> +int xive_router_set_eas(XiveRouter *xrtr, uint32_t lisn, XiveEAS *eas=
);
>> +
>>  #endif /* PPC_XIVE_H */
>> diff --git a/include/hw/ppc/xive_regs.h b/include/hw/ppc/xive_regs.h
>> new file mode 100644
>> index 000000000000..12499b33614c
>> --- /dev/null
>> +++ b/include/hw/ppc/xive_regs.h
>> @@ -0,0 +1,31 @@
>> +/*
>> + * QEMU PowerPC XIVE interrupt controller model
>> + *
>> + * Copyright (c) 2016-2018, IBM Corporation.
>> + *
>> + * This code is licensed under the GPL version 2 or later. See the
>> + * COPYING file in the top-level directory.
>> + */
>> +
>> +#ifndef PPC_XIVE_REGS_H
>> +#define PPC_XIVE_REGS_H
>> +
>> +/* EAS (Event Assignment Structure)
>> + *
>> + * One per interrupt source. Targets an interrupt to a given Event
>> + * Notification Descriptor (END) and provides the corresponding
>> + * logical interrupt number (END data)
>> + */
>> +typedef struct XiveEAS {
>> +        /* Use a single 64-bit definition to make it easier to
>> +         * perform atomic updates
>> +         */
>> +        uint64_t        w;
>> +#define EAS_VALID       PPC_BIT(0)
>> +#define EAS_END_BLOCK   PPC_BITMASK(4, 7)        /* Destination END b=
lock# */
>> +#define EAS_END_INDEX   PPC_BITMASK(8, 31)       /* Destination END i=
ndex */
>> +#define EAS_MASKED      PPC_BIT(32)              /* Masked */
>> +#define EAS_END_DATA    PPC_BITMASK(33, 63)      /* Data written to t=
he END */
>> +} XiveEAS;
>> +
>> +#endif /* PPC_XIVE_REGS_H */
>> diff --git a/hw/intc/xive.c b/hw/intc/xive.c
>> index 014a2e41f71f..c4c90a25758e 100644
>> --- a/hw/intc/xive.c
>> +++ b/hw/intc/xive.c
>> @@ -442,6 +442,91 @@ static const TypeInfo xive_source_info =3D {
>>      .class_init    =3D xive_source_class_init,
>>  };
>> =20
>> +/*
>> + * XIVE Router (aka. Virtualization Controller or IVRE)
>> + */
>> +
>> +int xive_router_get_eas(XiveRouter *xrtr, uint32_t lisn, XiveEAS *eas=
)
>> +{
>> +    XiveRouterClass *xrc =3D XIVE_ROUTER_GET_CLASS(xrtr);
>> +
>> +    return xrc->get_eas(xrtr, lisn, eas);
>> +}
>> +
>> +int xive_router_set_eas(XiveRouter *xrtr, uint32_t lisn, XiveEAS *eas=
)
>> +{
>> +    XiveRouterClass *xrc =3D XIVE_ROUTER_GET_CLASS(xrtr);
>> +
>> +    return xrc->set_eas(xrtr, lisn, eas);
>> +}
>> +
>> +static void xive_router_notify(XiveFabric *xf, uint32_t lisn)
>> +{
>> +    XiveRouter *xrtr =3D XIVE_ROUTER(xf);
>> +    XiveEAS eas;
>> +
>> +    /* EAS cache lookup */
>> +    if (xive_router_get_eas(xrtr, lisn, &eas)) {
>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: Unknown LISN %x\n", lis=
n);
>> +        return;
>> +    }
>=20
> AFAICT a bad LISN here means a qemu error (in the source, probably),
> not a user or guest error, so an assert() would be more appropriate.

hmm, I would say no because in the case of PowerNV, the firmware could
have badly configured the ISN offset of a source which would notify the=20
router with a bad notification event data. =20


>> +
>> +    /* The IVRE has a State Bit Cache for its internal sources which
>> +     * is also involed at this point. We skip the SBC lookup because
>> +     * the state bits of the sources are modeled internally in QEMU.
>> +     */
>> +
>> +    if (!(eas.w & EAS_VALID)) {
>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid LISN %x\n", lis=
n);
>> +        return;
>> +    }
>> +
>> +    if (eas.w & EAS_MASKED) {
>> +        /* Notification completed */
>> +        return;
>> +    }
>> +}
>> +
>> +static Property xive_router_properties[] =3D {
>> +    DEFINE_PROP_UINT32("chip-id", XiveRouter, chip_id, 0),
>> +    DEFINE_PROP_END_OF_LIST(),
>> +};
>> +
>> +static void xive_router_class_init(ObjectClass *klass, void *data)
>> +{
>> +    DeviceClass *dc =3D DEVICE_CLASS(klass);
>> +    XiveFabricClass *xfc =3D XIVE_FABRIC_CLASS(klass);
>> +
>> +    dc->desc    =3D "XIVE Router Engine";
>> +    dc->props   =3D xive_router_properties;
>> +    xfc->notify =3D xive_router_notify;
>> +}
>> +
>> +static const TypeInfo xive_router_info =3D {
>> +    .name          =3D TYPE_XIVE_ROUTER,
>> +    .parent        =3D TYPE_SYS_BUS_DEVICE,
>> +    .abstract      =3D true,
>> +    .class_size    =3D sizeof(XiveRouterClass),
>> +    .class_init    =3D xive_router_class_init,
>> +    .interfaces    =3D (InterfaceInfo[]) {
>> +        { TYPE_XIVE_FABRIC },
>=20
> So as far as I can see so far, the XiveFabric interface will
> essentially have to be implemented on the router object, so I'm not
> seeing much point to having the interface rather than just a direct
> call on the router object.  But I haven't read the whole series yet,
> so maybe I'm missing something.

The PSIHB and PHB4 models are using it but there are not in the series.

I can send the PSIHB patch in the next version if you like, it's the=20
patch right after PnvXive. It's attached below for the moment. Look at=20
pnv_psi_notify().

Thanks,

C.

>> +        { }
>> +    }
>> +};
>> +
>> +void xive_eas_pic_print_info(XiveEAS *eas, uint32_t lisn, Monitor *mo=
n)
>> +{
>> +    if (!(eas->w & EAS_VALID)) {
>> +        return;
>> +    }
>> +
>> +    monitor_printf(mon, "  %08x %s end:%02x/%04x data:%08x\n",
>> +                   lisn, eas->w & EAS_MASKED ? "M" : " ",
>> +                   (uint8_t)  GETFIELD(EAS_END_BLOCK, eas->w),
>> +                   (uint32_t) GETFIELD(EAS_END_INDEX, eas->w),
>> +                   (uint32_t) GETFIELD(EAS_END_DATA, eas->w));
>> +}
>> +
>>  /*
>>   * XIVE Fabric
>>   */
>> @@ -455,6 +540,7 @@ static void xive_register_types(void)
>>  {
>>      type_register_static(&xive_source_info);
>>      type_register_static(&xive_fabric_info);
>> +    type_register_static(&xive_router_info);
>>  }
>> =20
>>  type_init(xive_register_types)
>=20


--------------54B1BC5AF801A1843592F4B0
Content-Type: text/x-patch;
 name="0001-ppc-pnv-add-a-PSI-bridge-model-for-POWER9-processor.patch"
Content-Disposition: attachment;
 filename*0="0001-ppc-pnv-add-a-PSI-bridge-model-for-POWER9-processor.pat";
 filename*1="ch"
Content-Transfer-Encoding: quoted-printable

From 680fd6ff7c99e669708fbc5cfdbfcd95e83e7c07 Mon Sep 17 00:00:00 2001
From: =3D?UTF-8?q?C=3DC3=3DA9dric=3D20Le=3D20Goater?=3D <clg@kaod.org>
Date: Wed, 21 Nov 2018 10:29:45 +0100
Subject: [PATCH] ppc/pnv: add a PSI bridge model for POWER9 processor
MIME-Version: 1.0
Content-Type: text/plain; charset=3DUTF-8
Content-Transfer-Encoding: 8bit

The PSI bridge on POWER9 is very similar to POWER8. The BAR is still
set through XSCOM but the controls are now entirely done with MMIOs.
More interrupts are defined and the interrupt controller interface has
changed to XIVE. The POWER9 model is a first example of the usage of
the notify() handler of the XiveFabric interface, linking the PSI
XiveSource to its owning device model.

Signed-off-by: C=C3=A9dric Le Goater <clg@kaod.org>
---
 include/hw/ppc/pnv.h       |   6 +
 include/hw/ppc/pnv_psi.h   |  50 ++++-
 include/hw/ppc/pnv_xscom.h |   3 +
 hw/ppc/pnv.c               |  20 +-
 hw/ppc/pnv_psi.c           | 390 ++++++++++++++++++++++++++++++++++---
 5 files changed, 444 insertions(+), 25 deletions(-)

diff --git a/include/hw/ppc/pnv.h b/include/hw/ppc/pnv.h
index c402e5d5844b..8be1147481f9 100644
--- a/include/hw/ppc/pnv.h
+++ b/include/hw/ppc/pnv.h
@@ -88,6 +88,7 @@ typedef struct Pnv9Chip {
=20
     /*< public >*/
     PnvXive      xive;
+    PnvPsi       psi;
 } Pnv9Chip;
=20
 typedef struct PnvChipClass {
@@ -250,11 +251,16 @@ void pnv_bmc_powerdown(IPMIBmc *bmc);
 #define PNV9_XIVE_PC_SIZE            0x0000001000000000ull
 #define PNV9_XIVE_PC_BASE(chip)      PNV9_CHIP_BASE(chip, 0x000601800000=
0000ull)
=20
+#define PNV9_PSIHB_SIZE              0x0000000000100000ull
+#define PNV9_PSIHB_BASE(chip)        PNV9_CHIP_BASE(chip, 0x000603020300=
0000ull)
+
 #define PNV9_XIVE_IC_SIZE            0x0000000000080000ull
 #define PNV9_XIVE_IC_BASE(chip)      PNV9_CHIP_BASE(chip, 0x000603020310=
0000ull)
=20
 #define PNV9_XIVE_TM_SIZE            0x0000000000040000ull
 #define PNV9_XIVE_TM_BASE(chip)      PNV9_CHIP_BASE(chip, 0x000603020318=
0000ull)
=20
+#define PNV9_PSIHB_ESB_SIZE          0x0000000000010000ull
+#define PNV9_PSIHB_ESB_BASE(chip)    PNV9_CHIP_BASE(chip, 0x00060302031c=
0000ull)
=20
 #endif /* _PPC_PNV_H */
diff --git a/include/hw/ppc/pnv_psi.h b/include/hw/ppc/pnv_psi.h
index f6af5eae1fa8..b8f8d082bcf9 100644
--- a/include/hw/ppc/pnv_psi.h
+++ b/include/hw/ppc/pnv_psi.h
@@ -21,10 +21,35 @@
=20
 #include "hw/sysbus.h"
 #include "hw/ppc/xics.h"
+#include "hw/ppc/xive.h"
=20
 #define TYPE_PNV_PSI "pnv-psi"
 #define PNV_PSI(obj) \
      OBJECT_CHECK(PnvPsi, (obj), TYPE_PNV_PSI)
+#define PNV_PSI_CLASS(klass) \
+     OBJECT_CLASS_CHECK(PnvPsiClass, (klass), TYPE_PNV_PSI)
+#define PNV_PSI_GET_CLASS(obj) \
+     OBJECT_GET_CLASS(PnvPsiClass, (obj), TYPE_PNV_PSI)
+
+typedef struct PnvPsi PnvPsi;
+typedef struct PnvChip PnvChip;
+typedef struct PnvPsiClass {
+    SysBusDeviceClass parent_class;
+
+    int chip_type;
+    uint32_t xscom_pcba;
+    uint32_t xscom_size;
+
+    void (*irq_set)(PnvPsi *psi, int, bool state);
+} PnvPsiClass;
+
+#define TYPE_PNV_PSI_POWER8 TYPE_PNV_PSI "-POWER8"
+#define PNV_PSI_POWER8(obj) \
+    OBJECT_CHECK(PnvPsi, (obj), TYPE_PNV_PSI_POWER8)
+
+#define TYPE_PNV_PSI_POWER9 TYPE_PNV_PSI "-POWER9"
+#define PNV_PSI_POWER9(obj) \
+    OBJECT_CHECK(PnvPsi, (obj), TYPE_PNV_PSI_POWER9)
=20
 #define PSIHB_XSCOM_MAX         0x20
=20
@@ -38,9 +63,12 @@ typedef struct PnvPsi {
     /* MemoryRegion fsp_mr; */
     uint64_t fsp_bar;
=20
-    /* Interrupt generation */
+    /* P8 Interrupt generation */
     ICSState ics;
=20
+    /* P9 Interrupt generation */
+    XiveSource source;
+
     /* Registers */
     uint64_t regs[PSIHB_XSCOM_MAX];
=20
@@ -60,6 +88,24 @@ typedef enum PnvPsiIrq {
=20
 #define PSI_NUM_INTERRUPTS 6
=20
-extern void pnv_psi_irq_set(PnvPsi *psi, PnvPsiIrq irq, bool state);
+/* P9 PSI Interrupts */
+#define PSIHB9_IRQ_PSI          0
+#define PSIHB9_IRQ_OCC          1
+#define PSIHB9_IRQ_FSI          2
+#define PSIHB9_IRQ_LPCHC        3
+#define PSIHB9_IRQ_LOCAL_ERR    4
+#define PSIHB9_IRQ_GLOBAL_ERR   5
+#define PSIHB9_IRQ_TPM          6
+#define PSIHB9_IRQ_LPC_SIRQ0    7
+#define PSIHB9_IRQ_LPC_SIRQ1    8
+#define PSIHB9_IRQ_LPC_SIRQ2    9
+#define PSIHB9_IRQ_LPC_SIRQ3    10
+#define PSIHB9_IRQ_SBE_I2C      11
+#define PSIHB9_IRQ_DIO          12
+#define PSIHB9_IRQ_PSU          13
+#define PSIHB9_NUM_IRQS         14
+
+void pnv_psi_irq_set(PnvPsi *psi, int irq, bool state);
+void pnv_psi_pic_print_info(PnvPsi *psi, Monitor *mon);
=20
 #endif /* _PPC_PNV_PSI_H */
diff --git a/include/hw/ppc/pnv_xscom.h b/include/hw/ppc/pnv_xscom.h
index 5bd43467a1ab..019b45bf9189 100644
--- a/include/hw/ppc/pnv_xscom.h
+++ b/include/hw/ppc/pnv_xscom.h
@@ -82,6 +82,9 @@ typedef struct PnvXScomInterfaceClass {
 #define PNV_XSCOM_PBCQ_SPCI_BASE  0x9013c00
 #define PNV_XSCOM_PBCQ_SPCI_SIZE  0x5
=20
+#define PNV9_XSCOM_PSIHB_BASE     0x5012900
+#define PNV9_XSCOM_PSIHB_SIZE     0x100
+
 #define PNV9_XSCOM_XIVE_BASE      0x5013000
 #define PNV9_XSCOM_XIVE_SIZE      0x300
=20
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index b6af896c30e4..e67c9d7d3995 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -743,7 +743,7 @@ static void pnv_chip_power8_instance_init(Object *obj=
)
     PnvChipClass *pcc =3D PNV_CHIP_GET_CLASS(obj);
     int i;
=20
-    object_initialize(&chip8->psi, sizeof(chip8->psi), TYPE_PNV_PSI);
+    object_initialize(&chip8->psi, sizeof(chip8->psi), TYPE_PNV_PSI_POWE=
R8);
     object_property_add_child(obj, "psi", OBJECT(&chip8->psi), NULL);
     object_property_add_const_link(OBJECT(&chip8->psi), "xics",
                                    OBJECT(qdev_get_machine()), &error_ab=
ort);
@@ -923,6 +923,11 @@ static void pnv_chip_power9_instance_init(Object *ob=
j)
     object_property_add_child(obj, "xive", OBJECT(&chip9->xive), NULL);
     object_property_add_const_link(OBJECT(&chip9->xive), "chip", obj,
                                    &error_abort);
+
+    object_initialize(&chip9->psi, sizeof(chip9->psi), TYPE_PNV_PSI_POWE=
R9);
+    object_property_add_child(obj, "psi", OBJECT(&chip9->psi), NULL);
+    object_property_add_const_link(OBJECT(&chip9->psi), "chip", obj,
+                                   &error_abort);
 }
=20
 static void pnv_chip_power9_realize(DeviceState *dev, Error **errp)
@@ -955,6 +960,18 @@ static void pnv_chip_power9_realize(DeviceState *dev=
, Error **errp)
     qdev_set_parent_bus(DEVICE(&chip9->xive), sysbus_get_default());
     pnv_xscom_add_subregion(chip, PNV9_XSCOM_XIVE_BASE,
                             &chip9->xive.xscom_regs);
+
+    /* Processor Service Interface (PSI) Host Bridge */
+    object_property_set_int(OBJECT(&chip9->psi), PNV9_PSIHB_BASE(chip),
+                            "bar", &error_fatal);
+    object_property_set_bool(OBJECT(&chip9->psi), true, "realized", &loc=
al_err);
+    if (local_err) {
+        error_propagate(errp, local_err);
+        return;
+    }
+    qdev_set_parent_bus(DEVICE(&chip9->psi), sysbus_get_default());
+    pnv_xscom_add_subregion(chip, PNV9_XSCOM_PSIHB_BASE,
+                            &chip9->psi.xscom_regs);
 }
=20
 static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)
@@ -1188,6 +1205,7 @@ static void pnv_pic_print_info(InterruptStatsProvid=
er *obj,
             Pnv9Chip *chip9 =3D PNV9_CHIP(chip);
=20
              pnv_xive_pic_print_info(&chip9->xive, mon);
+             pnv_psi_pic_print_info(&chip9->psi, mon);
         } else {
             Pnv8Chip *chip8 =3D PNV8_CHIP(chip);
=20
diff --git a/hw/ppc/pnv_psi.c b/hw/ppc/pnv_psi.c
index 5b969127c303..8b85dd9555e8 100644
--- a/hw/ppc/pnv_psi.c
+++ b/hw/ppc/pnv_psi.c
@@ -22,6 +22,7 @@
 #include "target/ppc/cpu.h"
 #include "qemu/log.h"
 #include "qapi/error.h"
+#include "monitor/monitor.h"
=20
 #include "exec/address-spaces.h"
=20
@@ -114,12 +115,14 @@
 #define PSIHB_BAR_MASK                  0x0003fffffff00000ull
 #define PSIHB_FSPBAR_MASK               0x0003ffff00000000ull
=20
+#define PSIHB_REG(addr) (((addr) >> 3) + PSIHB_XSCOM_BAR)
+
 static void pnv_psi_set_bar(PnvPsi *psi, uint64_t bar)
 {
     MemoryRegion *sysmem =3D get_system_memory();
     uint64_t old =3D psi->regs[PSIHB_XSCOM_BAR];
=20
-    psi->regs[PSIHB_XSCOM_BAR] =3D bar & (PSIHB_BAR_MASK | PSIHB_BAR_EN)=
;
+    psi->regs[PSIHB_XSCOM_BAR] =3D bar;
=20
     /* Update MR, always remove it first */
     if (old & PSIHB_BAR_EN) {
@@ -128,7 +131,7 @@ static void pnv_psi_set_bar(PnvPsi *psi, uint64_t bar=
)
=20
     /* Then add it back if needed */
     if (bar & PSIHB_BAR_EN) {
-        uint64_t addr =3D bar & PSIHB_BAR_MASK;
+        uint64_t addr =3D bar & ~PSIHB_BAR_EN;
         memory_region_add_subregion(sysmem, addr, &psi->regs_mr);
     }
 }
@@ -205,7 +208,12 @@ static const uint64_t stat_bits[] =3D {
     [PSIHB_IRQ_EXTERNAL]  =3D PSIHB_IRQ_STAT_EXT,
 };
=20
-void pnv_psi_irq_set(PnvPsi *psi, PnvPsiIrq irq, bool state)
+void pnv_psi_irq_set(PnvPsi *psi, int irq, bool state)
+{
+    PNV_PSI_GET_CLASS(psi)->irq_set(psi, irq, state);
+}
+
+static void pnv_psi_power8_irq_set(PnvPsi *psi, int irq, bool state)
 {
     ICSState *ics =3D &psi->ics;
     uint32_t xivr_reg;
@@ -324,7 +332,7 @@ static uint64_t pnv_psi_reg_read(PnvPsi *psi, uint32_=
t offset, bool mmio)
         val =3D psi->regs[offset];
         break;
     default:
-        qemu_log_mask(LOG_UNIMP, "PSI: read at Ox%" PRIx32 "\n", offset)=
;
+        qemu_log_mask(LOG_UNIMP, "PSI: read at 0x%" PRIx32 "\n", offset)=
;
     }
     return val;
 }
@@ -383,7 +391,7 @@ static void pnv_psi_reg_write(PnvPsi *psi, uint32_t o=
ffset, uint64_t val,
         pnv_psi_set_irsn(psi, val);
         break;
     default:
-        qemu_log_mask(LOG_UNIMP, "PSI: write at Ox%" PRIx32 "\n", offset=
);
+        qemu_log_mask(LOG_UNIMP, "PSI: write at 0x%" PRIx32 "\n", offset=
);
     }
 }
=20
@@ -393,13 +401,13 @@ static void pnv_psi_reg_write(PnvPsi *psi, uint32_t=
 offset, uint64_t val,
  */
 static uint64_t pnv_psi_mmio_read(void *opaque, hwaddr addr, unsigned si=
ze)
 {
-    return pnv_psi_reg_read(opaque, (addr >> 3) + PSIHB_XSCOM_BAR, true)=
;
+    return pnv_psi_reg_read(opaque, PSIHB_REG(addr), true);
 }
=20
 static void pnv_psi_mmio_write(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
 {
-    pnv_psi_reg_write(opaque, (addr >> 3) + PSIHB_XSCOM_BAR, val, true);
+    pnv_psi_reg_write(opaque, PSIHB_REG(addr), val, true);
 }
=20
 static const MemoryRegionOps psi_mmio_ops =3D {
@@ -441,7 +449,7 @@ static const MemoryRegionOps pnv_psi_xscom_ops =3D {
     }
 };
=20
-static void pnv_psi_init(Object *obj)
+static void pnv_psi_power8_instance_init(Object *obj)
 {
     PnvPsi *psi =3D PNV_PSI(obj);
=20
@@ -458,7 +466,7 @@ static const uint8_t irq_to_xivr[] =3D {
     PSIHB_XSCOM_XIVR_EXT,
 };
=20
-static void pnv_psi_realize(DeviceState *dev, Error **errp)
+static void pnv_psi_power8_realize(DeviceState *dev, Error **errp)
 {
     PnvPsi *psi =3D PNV_PSI(dev);
     ICSState *ics =3D &psi->ics;
@@ -510,28 +518,34 @@ static void pnv_psi_realize(DeviceState *dev, Error=
 **errp)
     }
 }
=20
+static const char compat_p8[] =3D "ibm,power8-psihb-x\0ibm,psihb-x";
+static const char compat_p9[] =3D "ibm,power9-psihb-x\0ibm,psihb-x";
+
 static int pnv_psi_dt_xscom(PnvXScomInterface *dev, void *fdt, int xscom=
_offset)
 {
-    const char compat[] =3D "ibm,power8-psihb-x\0ibm,psihb-x";
+    PnvPsiClass *ppc =3D PNV_PSI_GET_CLASS(dev);
     char *name;
     int offset;
-    uint32_t lpc_pcba =3D PNV_XSCOM_PSIHB_BASE;
     uint32_t reg[] =3D {
-        cpu_to_be32(lpc_pcba),
-        cpu_to_be32(PNV_XSCOM_PSIHB_SIZE)
+        cpu_to_be32(ppc->xscom_pcba),
+        cpu_to_be32(ppc->xscom_size)
     };
=20
-    name =3D g_strdup_printf("psihb@%x", lpc_pcba);
+    name =3D g_strdup_printf("psihb@%x", ppc->xscom_pcba);
     offset =3D fdt_add_subnode(fdt, xscom_offset, name);
     _FDT(offset);
     g_free(name);
=20
-    _FDT((fdt_setprop(fdt, offset, "reg", reg, sizeof(reg))));
-
-    _FDT((fdt_setprop_cell(fdt, offset, "#address-cells", 2)));
-    _FDT((fdt_setprop_cell(fdt, offset, "#size-cells", 1)));
-    _FDT((fdt_setprop(fdt, offset, "compatible", compat,
-                      sizeof(compat))));
+    _FDT(fdt_setprop(fdt, offset, "reg", reg, sizeof(reg)));
+    _FDT(fdt_setprop_cell(fdt, offset, "#address-cells", 2));
+    _FDT(fdt_setprop_cell(fdt, offset, "#size-cells", 1));
+    if (ppc->chip_type =3D=3D PNV_CHIP_POWER9) {
+        _FDT(fdt_setprop(fdt, offset, "compatible", compat_p9,
+                         sizeof(compat_p9)));
+    } else {
+        _FDT(fdt_setprop(fdt, offset, "compatible", compat_p8,
+                         sizeof(compat_p8)));
+    }
     return 0;
 }
=20
@@ -541,6 +555,324 @@ static Property pnv_psi_properties[] =3D {
     DEFINE_PROP_END_OF_LIST(),
 };
=20
+static void pnv_psi_power8_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc =3D DEVICE_CLASS(klass);
+    PnvPsiClass *ppc =3D PNV_PSI_CLASS(klass);
+
+    dc->desc    =3D "PowerNV PSI Controller POWER8";
+    dc->realize =3D pnv_psi_power8_realize;
+
+    ppc->chip_type =3D  PNV_CHIP_POWER8;
+    ppc->xscom_pcba =3D PNV_XSCOM_PSIHB_BASE;
+    ppc->xscom_size =3D PNV_XSCOM_PSIHB_SIZE;
+    ppc->irq_set    =3D pnv_psi_power8_irq_set;
+}
+
+static const TypeInfo pnv_psi_power8_info =3D {
+    .name          =3D TYPE_PNV_PSI_POWER8,
+    .parent        =3D TYPE_PNV_PSI,
+    .instance_init =3D pnv_psi_power8_instance_init,
+    .class_init    =3D pnv_psi_power8_class_init,
+};
+
+/* Common registers */
+
+#define PSIHB9_CR                       0x20
+#define PSIHB9_SEMR                     0x28
+
+/* P9 registers */
+
+#define PSIHB9_INTERRUPT_CONTROL        0x58
+#define   PSIHB9_IRQ_METHOD             PPC_BIT(0)
+#define   PSIHB9_IRQ_RESET              PPC_BIT(1)
+#define PSIHB9_ESB_CI_BASE              0x60
+#define   PSIHB9_ESB_CI_VALID           1
+#define PSIHB9_ESB_NOTIF_ADDR           0x68
+#define   PSIHB9_ESB_NOTIF_VALID        1
+#define PSIHB9_IVT_OFFSET               0x70
+#define   PSIHB9_IVT_OFF_SHIFT          32
+
+#define PSIHB9_IRQ_LEVEL                0x78 /* assertion */
+#define   PSIHB9_IRQ_LEVEL_PSI          PPC_BIT(0)
+#define   PSIHB9_IRQ_LEVEL_OCC          PPC_BIT(1)
+#define   PSIHB9_IRQ_LEVEL_FSI          PPC_BIT(2)
+#define   PSIHB9_IRQ_LEVEL_LPCHC        PPC_BIT(3)
+#define   PSIHB9_IRQ_LEVEL_LOCAL_ERR    PPC_BIT(4)
+#define   PSIHB9_IRQ_LEVEL_GLOBAL_ERR   PPC_BIT(5)
+#define   PSIHB9_IRQ_LEVEL_TPM          PPC_BIT(6)
+#define   PSIHB9_IRQ_LEVEL_LPC_SIRQ1    PPC_BIT(7)
+#define   PSIHB9_IRQ_LEVEL_LPC_SIRQ2    PPC_BIT(8)
+#define   PSIHB9_IRQ_LEVEL_LPC_SIRQ3    PPC_BIT(9)
+#define   PSIHB9_IRQ_LEVEL_LPC_SIRQ4    PPC_BIT(10)
+#define   PSIHB9_IRQ_LEVEL_SBE_I2C      PPC_BIT(11)
+#define   PSIHB9_IRQ_LEVEL_DIO          PPC_BIT(12)
+#define   PSIHB9_IRQ_LEVEL_PSU          PPC_BIT(13)
+#define   PSIHB9_IRQ_LEVEL_I2C_C        PPC_BIT(14)
+#define   PSIHB9_IRQ_LEVEL_I2C_D        PPC_BIT(15)
+#define   PSIHB9_IRQ_LEVEL_I2C_E        PPC_BIT(16)
+#define   PSIHB9_IRQ_LEVEL_SBE          PPC_BIT(19)
+
+#define PSIHB9_IRQ_STAT                 0x80 /* P bit */
+#define   PSIHB9_IRQ_STAT_PSI           PPC_BIT(0)
+#define   PSIHB9_IRQ_STAT_OCC           PPC_BIT(1)
+#define   PSIHB9_IRQ_STAT_FSI           PPC_BIT(2)
+#define   PSIHB9_IRQ_STAT_LPCHC         PPC_BIT(3)
+#define   PSIHB9_IRQ_STAT_LOCAL_ERR     PPC_BIT(4)
+#define   PSIHB9_IRQ_STAT_GLOBAL_ERR    PPC_BIT(5)
+#define   PSIHB9_IRQ_STAT_TPM           PPC_BIT(6)
+#define   PSIHB9_IRQ_STAT_LPC_SIRQ1     PPC_BIT(7)
+#define   PSIHB9_IRQ_STAT_LPC_SIRQ2     PPC_BIT(8)
+#define   PSIHB9_IRQ_STAT_LPC_SIRQ3     PPC_BIT(9)
+#define   PSIHB9_IRQ_STAT_LPC_SIRQ4     PPC_BIT(10)
+#define   PSIHB9_IRQ_STAT_SBE_I2C       PPC_BIT(11)
+#define   PSIHB9_IRQ_STAT_DIO           PPC_BIT(12)
+#define   PSIHB9_IRQ_STAT_PSU           PPC_BIT(13)
+
+static void pnv_psi_notify(XiveFabric *xf, uint32_t srcno)
+{
+    PnvPsi *psi =3D PNV_PSI(xf);
+    uint64_t notif_port =3D psi->regs[PSIHB_REG(PSIHB9_ESB_NOTIF_ADDR)];
+    bool valid =3D notif_port & PSIHB9_ESB_NOTIF_VALID;
+    uint64_t notify_addr =3D notif_port & ~PSIHB9_ESB_NOTIF_VALID;
+
+    uint32_t offset =3D
+        (psi->regs[PSIHB_REG(PSIHB9_IVT_OFFSET)] >> PSIHB9_IVT_OFF_SHIFT=
);
+    uint64_t lisn =3D cpu_to_be64(offset + srcno);
+
+    if (valid) {
+        cpu_physical_memory_write(notify_addr, &lisn, sizeof(lisn));
+    }
+}
+
+/*
+ * TODO : move to parent class
+ */
+static void pnv_psi_reset(DeviceState *dev)
+{
+    PnvPsi *psi =3D PNV_PSI(dev);
+
+    memset(psi->regs, 0x0, sizeof(psi->regs));
+
+    psi->regs[PSIHB_XSCOM_BAR] =3D psi->bar | PSIHB_BAR_EN;
+}
+
+static uint64_t pnv_psi_p9_mmio_read(void *opaque, hwaddr addr, unsigned=
 size)
+{
+    PnvPsi *psi =3D PNV_PSI(opaque);
+    uint32_t reg =3D PSIHB_REG(addr);
+    uint64_t val =3D -1;
+
+    switch (addr) {
+    case PSIHB9_CR:
+    case PSIHB9_SEMR:
+        /* FSP stuff */
+    case PSIHB9_INTERRUPT_CONTROL:
+    case PSIHB9_ESB_CI_BASE:
+    case PSIHB9_ESB_NOTIF_ADDR:
+    case PSIHB9_IVT_OFFSET:
+        val =3D psi->regs[reg];
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR, "PSI: read at 0x%" PRIx64 "\n", a=
ddr);
+    }
+
+    return val;
+}
+
+static void pnv_psi_p9_mmio_write(void *opaque, hwaddr addr,
+                                  uint64_t val, unsigned size)
+{
+    PnvPsi *psi =3D PNV_PSI(opaque);
+    uint32_t reg =3D PSIHB_REG(addr);
+    MemoryRegion *sysmem =3D get_system_memory();
+
+    switch (addr) {
+    case PSIHB9_CR:
+    case PSIHB9_SEMR:
+        /* FSP stuff */
+        break;
+    case PSIHB9_INTERRUPT_CONTROL:
+        if (val & PSIHB9_IRQ_RESET) {
+            device_reset(DEVICE(&psi->source));
+        }
+        psi->regs[reg] =3D val;
+        break;
+
+    case PSIHB9_ESB_CI_BASE:
+        if (!(val & PSIHB9_ESB_CI_VALID)) {
+            if (psi->regs[reg] & PSIHB9_ESB_CI_VALID) {
+                memory_region_del_subregion(sysmem, &psi->source.esb_mmi=
o);
+            }
+        } else {
+            if (!(psi->regs[reg] & PSIHB9_ESB_CI_VALID)) {
+                memory_region_add_subregion(sysmem,
+                                        val & ~PSIHB9_ESB_CI_VALID,
+                                        &psi->source.esb_mmio);
+            }
+        }
+        psi->regs[reg] =3D val;
+        break;
+
+    case PSIHB9_ESB_NOTIF_ADDR:
+        psi->regs[reg] =3D val;
+        break;
+    case PSIHB9_IVT_OFFSET:
+        psi->regs[reg] =3D val;
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR, "PSI: write at 0x%" PRIx64 "\n", =
addr);
+    }
+}
+
+static const MemoryRegionOps pnv_psi_p9_mmio_ops =3D {
+    .read =3D pnv_psi_p9_mmio_read,
+    .write =3D pnv_psi_p9_mmio_write,
+    .endianness =3D DEVICE_BIG_ENDIAN,
+    .valid =3D {
+        .min_access_size =3D 8,
+        .max_access_size =3D 8,
+    },
+    .impl =3D {
+        .min_access_size =3D 8,
+        .max_access_size =3D 8,
+    },
+};
+
+static uint64_t pnv_psi_p9_xscom_read(void *opaque, hwaddr addr, unsigne=
d size)
+{
+    /* No read are expected */
+    qemu_log_mask(LOG_GUEST_ERROR, "PSI: xscom read at 0x%" PRIx64 "\n",=
 addr);
+    return -1;
+}
+
+static void pnv_psi_p9_xscom_write(void *opaque, hwaddr addr,
+                                uint64_t val, unsigned size)
+{
+    PnvPsi *psi =3D PNV_PSI(opaque);
+
+    /* XSCOM is only used to set the PSIHB MMIO region */
+    switch (addr >> 3) {
+    case PSIHB_XSCOM_BAR:
+        pnv_psi_set_bar(psi, val);
+        break;
+    default:
+        qemu_log_mask(LOG_GUEST_ERROR, "PSI: xscom write at 0x%" PRIx64 =
"\n",
+                      addr);
+    }
+}
+
+static const MemoryRegionOps pnv_psi_p9_xscom_ops =3D {
+    .read =3D pnv_psi_p9_xscom_read,
+    .write =3D pnv_psi_p9_xscom_write,
+    .endianness =3D DEVICE_BIG_ENDIAN,
+    .valid =3D {
+        .min_access_size =3D 8,
+        .max_access_size =3D 8,
+    },
+    .impl =3D {
+        .min_access_size =3D 8,
+        .max_access_size =3D 8,
+    }
+};
+
+static void pnv_psi_power9_irq_set(PnvPsi *psi, int irq, bool state)
+{
+    uint32_t irq_method =3D psi->regs[PSIHB_REG(PSIHB9_INTERRUPT_CONTROL=
)];
+
+    if (irq > PSIHB9_NUM_IRQS) {
+        qemu_log_mask(LOG_GUEST_ERROR, "PSI: Unsupported irq %d\n", irq)=
;
+        return;
+    }
+
+    if (irq_method & PSIHB9_IRQ_METHOD) {
+        qemu_log_mask(LOG_GUEST_ERROR, "PSI: LSI IRQ method no supported=
\n");
+        return;
+    }
+
+    /* Update LSI levels */
+    if (state) {
+        psi->regs[PSIHB_REG(PSIHB9_IRQ_LEVEL)] |=3D PPC_BIT(irq);
+    } else {
+        psi->regs[PSIHB_REG(PSIHB9_IRQ_LEVEL)] &=3D ~PPC_BIT(irq);
+    }
+
+    qemu_set_irq(xive_source_qirq(&psi->source, irq), state);
+}
+
+static void pnv_psi_power9_instance_init(Object *obj)
+{
+    PnvPsi *psi =3D PNV_PSI(obj);
+
+    object_initialize(&psi->source, sizeof(psi->source), TYPE_XIVE_SOURC=
E);
+    object_property_add_child(obj, "source", OBJECT(&psi->source), NULL)=
;
+}
+
+static void pnv_psi_power9_realize(DeviceState *dev, Error **errp)
+{
+    PnvPsi *psi =3D PNV_PSI(dev);
+    XiveSource *xsrc =3D &psi->source;
+    Error *local_err =3D NULL;
+    int i;
+
+    /* This is the only device with 4k ESB pages */
+    object_property_set_int(OBJECT(xsrc), XIVE_ESB_4K, "shift",
+                            &error_fatal);
+    object_property_set_int(OBJECT(xsrc), PSIHB9_NUM_IRQS, "nr-irqs",
+                            &error_fatal);
+    object_property_add_const_link(OBJECT(xsrc), "xive", OBJECT(psi),
+                                   &error_fatal);
+    object_property_set_bool(OBJECT(xsrc), true, "realized", &local_err)=
;
+    if (local_err) {
+        error_propagate(errp, local_err);
+        return;
+    }
+    qdev_set_parent_bus(DEVICE(xsrc), sysbus_get_default());
+
+    for (i =3D 0; i < xsrc->nr_irqs; i++) {
+        xive_source_irq_set(xsrc, i, true);
+    }
+
+    /* XSCOM region for PSI registers */
+    pnv_xscom_region_init(&psi->xscom_regs, OBJECT(dev), &pnv_psi_p9_xsc=
om_ops,
+                psi, "xscom-psi", PNV9_XSCOM_PSIHB_SIZE);
+
+    /* Initialize MMIO region */
+    memory_region_init_io(&psi->regs_mr, OBJECT(dev), &pnv_psi_p9_mmio_o=
ps, psi,
+                          "psihb", PNV9_PSIHB_SIZE);
+
+    /* Default BAR for MMIO region */
+    pnv_psi_set_bar(psi, psi->bar | PSIHB_BAR_EN);
+}
+
+static void pnv_psi_power9_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc =3D DEVICE_CLASS(klass);
+    PnvPsiClass *ppc =3D PNV_PSI_CLASS(klass);
+    XiveFabricClass *xfc =3D XIVE_FABRIC_CLASS(klass);
+
+    dc->desc    =3D "PowerNV PSI Controller POWER9";
+    dc->realize =3D pnv_psi_power9_realize;
+
+    ppc->chip_type  =3D PNV_CHIP_POWER9;
+    ppc->xscom_pcba =3D PNV9_XSCOM_PSIHB_BASE;
+    ppc->xscom_size =3D PNV9_XSCOM_PSIHB_SIZE;
+    ppc->irq_set    =3D pnv_psi_power9_irq_set;
+
+    xfc->notify      =3D pnv_psi_notify;
+}
+
+static const TypeInfo pnv_psi_power9_info =3D {
+    .name          =3D TYPE_PNV_PSI_POWER9,
+    .parent        =3D TYPE_PNV_PSI,
+    .instance_init =3D pnv_psi_power9_instance_init,
+    .class_init    =3D pnv_psi_power9_class_init,
+    .interfaces =3D (InterfaceInfo[]) {
+            { TYPE_XIVE_FABRIC },
+            { },
+    },
+};
+
 static void pnv_psi_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc =3D DEVICE_CLASS(klass);
@@ -548,16 +880,18 @@ static void pnv_psi_class_init(ObjectClass *klass, =
void *data)
=20
     xdc->dt_xscom =3D pnv_psi_dt_xscom;
=20
-    dc->realize =3D pnv_psi_realize;
+    dc->desc =3D "PowerNV PSI Controller";
     dc->props =3D pnv_psi_properties;
+    dc->reset  =3D pnv_psi_reset;
 }
=20
 static const TypeInfo pnv_psi_info =3D {
     .name          =3D TYPE_PNV_PSI,
     .parent        =3D TYPE_SYS_BUS_DEVICE,
     .instance_size =3D sizeof(PnvPsi),
-    .instance_init =3D pnv_psi_init,
     .class_init    =3D pnv_psi_class_init,
+    .class_size    =3D sizeof(PnvPsiClass),
+    .abstract      =3D true,
     .interfaces    =3D (InterfaceInfo[]) {
         { TYPE_PNV_XSCOM_INTERFACE },
         { }
@@ -567,6 +901,18 @@ static const TypeInfo pnv_psi_info =3D {
 static void pnv_psi_register_types(void)
 {
     type_register_static(&pnv_psi_info);
+    type_register_static(&pnv_psi_power8_info);
+    type_register_static(&pnv_psi_power9_info);
 }
=20
 type_init(pnv_psi_register_types)
+
+void pnv_psi_pic_print_info(PnvPsi *psi, Monitor *mon)
+{
+    uint32_t offset =3D
+        (psi->regs[PSIHB_REG(PSIHB9_IVT_OFFSET)] >> PSIHB9_IVT_OFF_SHIFT=
);
+
+    monitor_printf(mon, "PSIHB Source %08x .. %08x\n",
+                  offset, offset + psi->source.nr_irqs - 1);
+    xive_source_pic_print_info(&psi->source, offset, mon);
+}
--=20
2.17.2


--------------54B1BC5AF801A1843592F4B0--

