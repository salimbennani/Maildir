Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 23:34:12 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga001.fm.intel.com (fmsmga001.fm.intel.com [10.253.24.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 4C0D758037D;
	Fri, 23 Nov 2018 02:51:12 -0800 (PST)
Received: from orsmga102-1.jf.intel.com (HELO mga09.intel.com) ([10.7.208.27])
  by fmsmga001-1.fm.intel.com with ESMTP; 23 Nov 2018 02:51:11 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AtT4QNB0qHG8et9hlsmDT+DRfVm0co7zxezQtwd8Z?=
 =?us-ascii?q?segRKvTxwZ3uMQTl6Ol3ixeRBMOHs6IC07KempujcFRI2YyGvnEGfc4EfD4+ou?=
 =?us-ascii?q?JSoTYdBtWYA1bwNv/gYn9yNs1DUFh44yPzahANS47xaFLIv3K98yMZFAnhOgpp?=
 =?us-ascii?q?POT1HZPZg9iq2+yo9JDffwZFiCChbb9uMR67sRjfus4KjIV4N60/0AHJonxGe+?=
 =?us-ascii?q?RXwWNnO1eelAvi68mz4ZBu7T1et+ou+MBcX6r6eb84TaFDAzQ9L281/szrugLd?=
 =?us-ascii?q?QgaJ+3ART38ZkhtMAwjC8RH6QpL8uTb0u+ZhxCWXO9D9QKsqUjq+8ahkVB7oiD?=
 =?us-ascii?q?8GNzEn9mHXltdwh79frB64uhBz35LYbISTOfVwZKPdec4RS3RHUMhfSidNBp6w?=
 =?us-ascii?q?YoUKA+cHIO1WrZTyp0EWoBW+GAeiGu3vxDxGiHD40qI10fguHw7d3Aw4Hd8Dq2?=
 =?us-ascii?q?jUodfvOasOTey4wqvFwDPeZP1Wwzf9743Ifwg9rPGRUrJ/b9DRwlQgGQPfj1Wf?=
 =?us-ascii?q?tZHuMjSL2eQXsmiU8/BsWviyi24otQ5xuCOixt0yhYbUhoIa0EzE+T9lz4YyIN?=
 =?us-ascii?q?21UUh2asOqHptXsiGVLYp2QsU6TmFzpCk6yqAJtYS1fSgR0Jgnwx3fa/mDc4SS?=
 =?us-ascii?q?5RLjTumRLS95hHJjZLKwmRKy/VK8xe37U8m51ktBoCldktTUqHwByxje5tKaRv?=
 =?us-ascii?q?Zz4EutwyuD2gPP5u1eIE05l7LXJ4A9zrM0jJYfrErOEjHslEnrj6KbeF8o9var?=
 =?us-ascii?q?5unhf77ovIWTN5VuhQH7KqkumtKwAeA/MgUWQWib9vqz1Kf58U36XrpKlPs2nb?=
 =?us-ascii?q?fdsJzAIsQbvKG5DxdU0oYl9Rm/Ey+r3MoEkXQDNl5JZRyKg5bzN13TI/30Ee2z?=
 =?us-ascii?q?jlWunTtzwvDJJLzhApHDLnjZl7fheK5w60pdyAo10NBe6ItYCrIfL/LpXE/+qt?=
 =?us-ascii?q?jYAgY+Mw26xeboFs9925gAWWKAHKCZKrnesVyW6eI1JemDeosVtCz6K/g/6P7i?=
 =?us-ascii?q?lWU5lkMFfam1wZsXb2i1HvBnI0Waf3XgmNgAEXoRswo6TezqjkCCUDFJa3azWa?=
 =?us-ascii?q?I8+i80CIa8AYjfQYCthaSL3D2nEZ1OemBGFleMHG/od4qeWvcMdDidIsh7njwE?=
 =?us-ascii?q?SLiuUYkh1R61uQ/+yrpnKPfU+yICuZLi0th1+/PclRUo+TNoCMSd1nmHT3tokW?=
 =?us-ascii?q?MQWz82wKd/rFR/yleEz6d0mf9YFdtV5/NPVQc3Lprcz+18C9DvVQPNZNaJSFC6?=
 =?us-ascii?q?Qtq4BTE9VM4+w9gLY0xlAdWtkgjD3za2A78Sj7GEHoc08qLb33jyPcp90WzJ1K?=
 =?us-ascii?q?s6glkiQ8tPM3Cmh6Fl+wjSAY7Jj1uWl6KweasA2y7N8X+JzXCSs0FATA5wTaLF?=
 =?us-ascii?q?UGgcZkTMq9T1/EfCT760BrQhPQtM0sqCKqpMat30glRKXvbjONLCY22vn2e8Hw?=
 =?us-ascii?q?qHxrSJbIDyYWUSwD3dCFQYkwAU5XuJKBIxBjm/rG7EDDxhD1TvY1jy/ul4r3+7?=
 =?us-ascii?q?Skw0zwSOb0B607q1+xgVheGTSv8J37IEvjshpCtwHFqnw93WDN+ArRJ7fKpAed?=
 =?us-ascii?q?M9/EtH1WXBugNgJJOgMb5tikQecwttuUPuzAt4CoNbnMgurXMqyhdyKK2C3FNA?=
 =?us-ascii?q?cTOYwY7/OrnNJmbu+xCvbrbc2kvC39aO5qcP9PM4pk3/vAGoE0oi9Gln09lV0n?=
 =?us-ascii?q?eG+pXGFg0SUYj1UkY28Rh6qKrXYi0854PSyH1tPrO4sj7E29I1GuQlzgyscMtY?=
 =?us-ascii?q?MKOBDAXyCdEVB9CyKOw2nFikdggLPORM+687Icynd+GK17W2POl9hj2mi2dH4I?=
 =?us-ascii?q?dj0k+X8yp8S+jI34sKwv2C3wuHUSv8g0mlsszthY9EYjQSFHKlySf4HI5RerFy?=
 =?us-ascii?q?fYETBGauPs273Mlxi4TsWn5Y7lGjAVwG1dSteRqTaVz9wAJR2V4WoXyhhSu30T?=
 =?us-ascii?q?h0nys1oaqY2SzE2/7iewYfOm5XWGliik/hIZK1j98GRkeodRUmlBy/6Ub82adb?=
 =?us-ascii?q?vqV/I3DPTkhSeyj5Mn9tUrG3trqEeMNP7JIosSNKUOWze1yaS7j9owcE3CPnBW?=
 =?us-ascii?q?dR2Dc7dzSysJXjgxN6kH6dLGp0rHfBecBwxA3T5dzGSf5KwzoGQjJ1iT3WBli6?=
 =?us-ascii?q?Itmo8s+Yl5bFsuCiSW2hUodffjXszYOFrCG7/3FlAQWjn/Cvnd3qCQo63jXh19?=
 =?us-ascii?q?lpViXIqwzwYpLx2KS5MuJnf09oC0H668dhHoF+k40whIwf2HQAh5WV+2YHnnn3?=
 =?us-ascii?q?MdlBxa3+a38NTyYRw9HJ+AjlxFFjLnWRyoP5THqdxdFtZ9u7YmMQwS8968FKCK?=
 =?us-ascii?q?GJ7L1Lhyd1o1y4rR7Pbvh5hDsS1fwu6HsCieETpAUt1jmdAqwVHURAPizjjRWI?=
 =?us-ascii?q?48q+rKVKfmmvd7ew2VF6ndCgCrGCvw5dVGz4epckAS9/8MF/PEjQ333074HuYM?=
 =?us-ascii?q?PQYs4Lth2IjxfAiPBYKJcwlvoJnyVrI2z8smM+y+4nkxNux4q1s5adK2Vi56+5?=
 =?us-ascii?q?Bh9YNjvoZ8Ic4D3tjKBentqI0ICrBJluBjILXJ7wR/KyDD0SrejnNxqJEDAktn?=
 =?us-ascii?q?ebHr/fERWe6Uh8qXLPDourN2qWJHQCydViRR+dJFFQgQwOXTU6mII5GR6uxMD7?=
 =?us-ascii?q?bEh54TUR7EbiqhRQ0uJoKwX/UmDHqQizcDg0T5yfLAdM4gFG+kfYKsie7uN1Hy?=
 =?us-ascii?q?FF8Zyttg2NKmqHZwtWCWEFQFCLB1fmPrO2/9nP7/CYBvaiL/vJebiOq/ZRV/KW?=
 =?us-ascii?q?ypK0yIdm4yyANsaSPnlhEv073FBMXWtiFsTdmjUPTTEXli3XY86aohe85jN4rs?=
 =?us-ascii?q?Sl/Pv3XwLv4JOFC6FOPtV35xC2naCDOvaQhSZ+NDZYz44MymXOyLQFx14SjCdu?=
 =?us-ascii?q?dza2HLQEtC7NSr/Qm6BNAx4abSNzKNVH76Ym0gZRPs7bj8v/1qRkgf4tF1dFSV?=
 =?us-ascii?q?vhl9mpZcMUImG9N1DHBEeROLSFPz3LxM73br2mSb1Nl+VZrBmwuTedE0/+MTWP?=
 =?us-ascii?q?jTjpVxazMe5SiCGXJgBRuIa4chx1E2jsUMrmagGnMN9wlTA526A0iWjQNWECMT?=
 =?us-ascii?q?lwaUdNrryL4CNcg/V/HXFB73V/IemFnSaZ8/fXKpIMvfR3BSR0kvpQ4G4mxLtN?=
 =?us-ascii?q?8CFEWPt1lTPOrt5vplGqiPWAxiB7XxpOtDlLgpmGvUFjOaXf65lBVmzI/BML7W?=
 =?us-ascii?q?WMFRsKo8FpBcHou6BV0tLPjr78KC9e89LI+ssRH8jVJ9iBMHokMBrpHibbDQoF?=
 =?us-ascii?q?TTGxM2HfiFdQkPWT9n2Ts5g7pYLgmJsISr9HSlM1EukWBVhiHNwHc99LWWYAjP?=
 =?us-ascii?q?axhckM+DLqphDWQNgcuo3vUvOUHOWpKTCFgL0CbBwNl/ewD4MeLIKz4UtvZlR+?=
 =?us-ascii?q?1NDIHFDXdYBHszFsdUkzukobtDBSR3My1wrabQSh4HgODvP8yhIpjxQkSeUr+i?=
 =?us-ascii?q?3l71o+KhzNviRm1AEYndj1yQ+QdDrwJaKrWoceXyPwulh3LZL/Rwd8aBa1m2R+?=
 =?us-ascii?q?OTvETq4XhLxlIyQjqw7GpZoHJvdaTq1JbBJYkfKIbvMr0VlQpw2h205L5OKDAp?=
 =?us-ascii?q?xnwlgEa5mp+ltd1A95JPMvJKeYcKdTz1MWj7+BszWAzO09wAYCYU0K9TXBK2Yz?=
 =?us-ascii?q?pEUUO+x+dGKT9et25FnHy2RO?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ABAAAs2vdbh0O0hNFiGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwGCaYECJ4N5iBhfix6BYAglFGaWQYF2ERgPBAGBS4c?=
 =?us-ascii?q?KIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjDII2JIJjAQIBAgECIARNBQYJAQEKE?=
 =?us-ascii?q?gYCAiYCAgNGDgYBDAYCAQEBgxwBggEFCqVYEYEjfDOEAgEqARYPhT8FgQuHGIN?=
 =?us-ascii?q?mghaBEScMgioHLoMCGQOEZIJXAo9ckCYHAoZ8gy2HAAYCFl6IcxCHJ4J5iTKBG?=
 =?us-ascii?q?IptgUaCDTMaI10NglIfgggXg0qDa4EpgzeBUQE2PgEBMQEBgQMBARyMBQEB?=
X-IPAS-Result: =?us-ascii?q?A0ABAAAs2vdbh0O0hNFiGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwGCaYECJ4N5iBhfix6BYAglFGaWQYF2ERgPBAGBS4cKIjQJDQEDAQEBA?=
 =?us-ascii?q?QEBAgETAQEBCA0JCCkjDII2JIJjAQIBAgECIARNBQYJAQEKEgYCAiYCAgNGDgY?=
 =?us-ascii?q?BDAYCAQEBgxwBggEFCqVYEYEjfDOEAgEqARYPhT8FgQuHGINmghaBEScMgioHL?=
 =?us-ascii?q?oMCGQOEZIJXAo9ckCYHAoZ8gy2HAAYCFl6IcxCHJ4J5iTKBGIptgUaCDTMaI10?=
 =?us-ascii?q?NglIfgggXg0qDa4EpgzeBUQE2PgEBMQEBgQMBARyMBQEB?=
X-IronPort-AV: E=Sophos;i="5.56,269,1539673200"; 
   d="scan'208";a="54519197"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 23 Nov 2018 02:50:19 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2503492AbeKWVeC (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Fri, 23 Nov 2018 16:34:02 -0500
Received: from mx1.redhat.com ([209.132.183.28]:52472 "EHLO mx1.redhat.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S2387655AbeKWVeC (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 23 Nov 2018 16:34:02 -0500
Received: from smtp.corp.redhat.com (int-mx05.intmail.prod.int.phx2.redhat.com [10.5.11.15])
        (using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
        (No client certificate requested)
        by mx1.redhat.com (Postfix) with ESMTPS id C0E7D80F79;
        Fri, 23 Nov 2018 10:50:14 +0000 (UTC)
Received: from [10.36.116.235] (ovpn-116-235.ams2.redhat.com [10.36.116.235])
        by smtp.corp.redhat.com (Postfix) with ESMTPS id 990045D763;
        Fri, 23 Nov 2018 10:50:07 +0000 (UTC)
From: Auger Eric <eric.auger@redhat.com>
Subject: Re: [PATCH v4 1/8] iommu: Add APIs for multiple domains per device
To: Lu Baolu <baolu.lu@linux.intel.com>,
        Joerg Roedel <joro@8bytes.org>,
        David Woodhouse <dwmw2@infradead.org>,
        Alex Williamson <alex.williamson@redhat.com>,
        Kirti Wankhede <kwankhede@nvidia.com>
Cc: kevin.tian@intel.com, ashok.raj@intel.com, tiwei.bie@intel.com,
        Jean-Philippe Brucker <jean-philippe.brucker@arm.com>,
        sanjay.k.kumar@intel.com, iommu@lists.linux-foundation.org,
        linux-kernel@vger.kernel.org, yi.y.sun@intel.com,
        jacob.jun.pan@intel.com, kvm@vger.kernel.org
References: <20181105073408.21815-1-baolu.lu@linux.intel.com>
 <20181105073408.21815-2-baolu.lu@linux.intel.com>
Message-ID: <51871885-05d2-febc-1dba-4d74108d0f46@redhat.com>
Date: Fri, 23 Nov 2018 11:50:06 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
 Thunderbird/60.3.0
MIME-Version: 1.0
In-Reply-To: <20181105073408.21815-2-baolu.lu@linux.intel.com>
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: 7bit
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.15
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16 (mx1.redhat.com [10.5.110.27]); Fri, 23 Nov 2018 10:50:15 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Hi Lu,

On 11/5/18 8:34 AM, Lu Baolu wrote:
> Sharing a physical PCI device in a finer-granularity way
> is becoming a consensus in the industry. IOMMU vendors
> are also engaging efforts to support such sharing as well
> as possible. Among the efforts, the capability of support
> finer-granularity DMA isolation is a common requirement
> due to the security consideration. With finer-granularity
> DMA isolation, all DMA requests out of or to a subset of
> a physical PCI device can be protected by the IOMMU. As a
> result, there is a request in software to attach multiple
> domains to a physical PCI device. One example of such use
> model is the Intel Scalable IOV [1] [2]. The Intel vt-d
> 3.0 spec [3] introduces the scalable mode which enables
> PASID granularity DMA isolation.
> 
> This adds the APIs to support multiple domains per device.
> In order to ease the discussions, we call it 'a domain in
> auxiliary mode' or simply 'auxiliary domain' when multiple
> domains are attached to a physical device.
> 
> The APIs includes:
> 
> * iommu_get_dev_attr(dev, IOMMU_DEV_ATTR_AUXD_CAPABILITY)
>   - Represents the ability of supporting multiple domains
>     per device.
> 
> * iommu_get_dev_attr(dev, IOMMU_DEV_ATTR_AUXD_ENABLED)
>   - Checks whether the device identified by @dev is working
>     in auxiliary mode.
> 
> * iommu_set_dev_attr(dev, IOMMU_DEV_ATTR_AUXD_ENABLE)
>   - Enables the multiple domains capability for the device
>     referenced by @dev.
> 
> * iommu_set_dev_attr(dev, IOMMU_DEV_ATTR_AUXD_DISABLE)
>   - Disables the multiple domains capability for the device
>     referenced by @dev.
> 
> * iommu_attach_device_aux(domain, dev)
>   - Attaches @domain to @dev in the auxiliary mode. Multiple
>     domains could be attached to a single device in the
>     auxiliary mode with each domain representing an isolated
>     address space for an assignable subset of the device.
> 
> * iommu_detach_device_aux(domain, dev)
>   - Detach @domain which has been attached to @dev in the
>     auxiliary mode.
> 
> * iommu_domain_get_attr(domain, DOMAIN_ATTR_AUXD_ID)
>   - Return ID used for finer-granularity DMA translation.
>     For the Intel Scalable IOV usage model, this will be
>     a PASID. The device which supports Scalalbe IOV needs
s/Scalalbe/Scalable
>     to writes this ID to the device register so that DMA
s/writes/write
>     requests could be tagged with a right PASID prefix.
This is not crystal clear to me as the intel implementation returns the
default PASID and not the PASID of the aux domain.
> 
> Many people involved in discussions of this design.
> 
> Kevin Tian <kevin.tian@intel.com>
> Liu Yi L <yi.l.liu@intel.com>
> Ashok Raj <ashok.raj@intel.com>
> Sanjay Kumar <sanjay.k.kumar@intel.com>
> Jacob Pan <jacob.jun.pan@linux.intel.com>
> Alex Williamson <alex.williamson@redhat.com>
> Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
> 
> and some discussions can be found here [4].
> 
> [1] https://software.intel.com/en-us/download/intel-scalable-io-virtualization-technical-specification
> [2] https://schd.ws/hosted_files/lc32018/00/LC3-SIOV-final.pdf
> [3] https://software.intel.com/en-us/download/intel-virtualization-technology-for-directed-io-architecture-specification
> [4] https://lkml.org/lkml/2018/7/26/4
> 
> Cc: Ashok Raj <ashok.raj@intel.com>
> Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
> Cc: Kevin Tian <kevin.tian@intel.com>
> Cc: Liu Yi L <yi.l.liu@intel.com>
> Suggested-by: Kevin Tian <kevin.tian@intel.com>
> Suggested-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
> Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
> ---
>  drivers/iommu/iommu.c | 52 +++++++++++++++++++++++++++++++++++++++++++
>  include/linux/iommu.h | 52 +++++++++++++++++++++++++++++++++++++++++++
>  2 files changed, 104 insertions(+)
> 
> diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
> index edbdf5d6962c..0b7c96d1425e 100644
> --- a/drivers/iommu/iommu.c
> +++ b/drivers/iommu/iommu.c
> @@ -2030,3 +2030,55 @@ int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids)
>  	return 0;
>  }
>  EXPORT_SYMBOL_GPL(iommu_fwspec_add_ids);
> +
> +/*
> + * Generic interfaces to get or set per device IOMMU attributions.
> + */
> +int iommu_get_dev_attr(struct device *dev, enum iommu_dev_attr attr, void *data)
> +{
> +	const struct iommu_ops *ops = dev->bus->iommu_ops;
> +
> +	if (ops && ops->get_dev_attr)
> +		return ops->get_dev_attr(dev, attr, data);
> +
> +	return -EINVAL;
> +}
> +EXPORT_SYMBOL_GPL(iommu_get_dev_attr);
> +
> +int iommu_set_dev_attr(struct device *dev, enum iommu_dev_attr attr, void *data)
> +{
> +	const struct iommu_ops *ops = dev->bus->iommu_ops;
> +
> +	if (ops && ops->set_dev_attr)
> +		return ops->set_dev_attr(dev, attr, data);
> +
> +	return -EINVAL;
> +}
> +EXPORT_SYMBOL_GPL(iommu_set_dev_attr);
> +
> +/*
> + * APIs to attach/detach a domain to/from a device in the
> + * auxiliary mode.
> + */
> +int iommu_attach_device_aux(struct iommu_domain *domain, struct device *dev)
> +{
> +	int ret = -ENODEV;
> +
> +	if (domain->ops->attach_dev_aux)
> +		ret = domain->ops->attach_dev_aux(domain, dev);
> +
> +	if (!ret)
> +		trace_attach_device_to_domain(dev);
> +
> +	return ret;
> +}
> +EXPORT_SYMBOL_GPL(iommu_attach_device_aux);
> +
> +void iommu_detach_device_aux(struct iommu_domain *domain, struct device *dev)
> +{
> +	if (domain->ops->detach_dev_aux) {
> +		domain->ops->detach_dev_aux(domain, dev);
> +		trace_detach_device_from_domain(dev);
> +	}
> +}
> +EXPORT_SYMBOL_GPL(iommu_detach_device_aux);
> diff --git a/include/linux/iommu.h b/include/linux/iommu.h
> index a1d28f42cb77..9bf1b3f2457a 100644
> --- a/include/linux/iommu.h
> +++ b/include/linux/iommu.h
> @@ -126,6 +126,7 @@ enum iommu_attr {
>  	DOMAIN_ATTR_NESTING,	/* two stages of translation */
>  	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
>  	DOMAIN_ATTR_MAX,
> +	DOMAIN_ATTR_AUXD_ID,
>  };
>  
>  /* These are the possible reserved region types */
> @@ -156,6 +157,14 @@ struct iommu_resv_region {
>  	enum iommu_resv_type	type;
>  };
>  
> +/* Per device IOMMU attributions */
> +enum iommu_dev_attr {
> +	IOMMU_DEV_ATTR_AUXD_CAPABILITY,
> +	IOMMU_DEV_ATTR_AUXD_ENABLED,
> +	IOMMU_DEV_ATTR_AUXD_ENABLE,
> +	IOMMU_DEV_ATTR_AUXD_DISABLE,
> +};
> +
>  #ifdef CONFIG_IOMMU_API
>  
>  /**
> @@ -183,6 +192,8 @@ struct iommu_resv_region {
>   * @domain_window_enable: Configure and enable a particular window for a domain
>   * @domain_window_disable: Disable a particular window for a domain
>   * @of_xlate: add OF master IDs to iommu grouping
> + * @get_dev_attr: get per device IOMMU attributions
s/attributions/attributes here and other locations?
> + * @set_dev_attr: set per device IOMMU attributions
>   * @pgsize_bitmap: bitmap of all possible supported page sizes
>   */
>  struct iommu_ops {
> @@ -226,6 +237,15 @@ struct iommu_ops {
>  	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
>  	bool (*is_attach_deferred)(struct iommu_domain *domain, struct device *dev);
>  
> +	/* Get/set per device IOMMU attributions */
> +	int (*get_dev_attr)(struct device *dev,
> +			    enum iommu_dev_attr attr, void *data);
> +	int (*set_dev_attr)(struct device *dev,
> +			    enum iommu_dev_attr attr, void *data);
> +	/* Attach/detach aux domain */
> +	int (*attach_dev_aux)(struct iommu_domain *domain, struct device *dev);
> +	void (*detach_dev_aux)(struct iommu_domain *domain, struct device *dev);
> +
>  	unsigned long pgsize_bitmap;
>  };
>  
> @@ -398,6 +418,16 @@ void iommu_fwspec_free(struct device *dev);
>  int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids);
>  const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode);
>  
> +int iommu_get_dev_attr(struct device *dev,
> +		       enum iommu_dev_attr attr, void *data);
> +int iommu_set_dev_attr(struct device *dev,
> +		       enum iommu_dev_attr attr, void *data);
> +
> +extern int iommu_attach_device_aux(struct iommu_domain *domain,
> +				   struct device *dev);
> +extern void iommu_detach_device_aux(struct iommu_domain *domain,
> +				    struct device *dev);
> +
>  #else /* CONFIG_IOMMU_API */
>  
>  struct iommu_ops {};
> @@ -682,6 +712,28 @@ const struct iommu_ops *iommu_ops_from_fwnode(struct fwnode_handle *fwnode)
>  	return NULL;
>  }
>  
> +static inline int
> +iommu_get_dev_attr(struct device *dev, enum iommu_dev_attr attr, void *data)
> +{
> +	return -EINVAL;
> +}
> +
> +static inline int
> +iommu_set_dev_attr(struct device *dev, enum iommu_dev_attr attr, void *data)
> +{
> +	return -EINVAL;
> +}
> +
> +static inline int
> +iommu_attach_device_aux(struct iommu_domain *domain, struct device *dev)
> +{
> +	return -ENODEV;
> +}
> +
> +static inline void
> +iommu_detach_device_aux(struct iommu_domain *domain, struct device *dev)
> +{
> +}
>  #endif /* CONFIG_IOMMU_API */
>  
>  #ifdef CONFIG_IOMMU_DEBUGFS
> 

Thanks

Eric
