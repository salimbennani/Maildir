Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 23 Nov 2018 08:28:53 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga004.jf.intel.com (orsmga004.jf.intel.com [10.7.209.38])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 1F01258040F;
	Thu, 22 Nov 2018 07:13:00 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga004-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 22 Nov 2018 07:13:00 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ANdlFrhPuZaYopQ3eCX0l6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0KPr6r8bcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Qiqp4bt1RxD0iS?=
 =?us-ascii?q?cHLz85/3/Risxsl6JQvRatqwViz4LIfI2ZMfxzdb7fc9wHX2pMRshfWSxfDI2h?=
 =?us-ascii?q?bIUPAeUOMvpFoIb/qVQOtgO+CAu3CePz1jNEmmP60bEg3ug/FwzNwQwuH8gJsH?=
 =?us-ascii?q?TRtNj7KLoSUfuuzKbWyTXDa+5d1zL86IjOfRAqvOiAVq9sfMTNzkckCgXLjlSW?=
 =?us-ascii?q?qYz4MDKey+MAs2ya7+pmSOKuhHUqpBtrojiqwscsi4/Jhp8ay1ze8iV52ok1Kc?=
 =?us-ascii?q?elSE54eNOpFoZbuS+dN4tzWMwiQmdotT4gxb0cvJ67eCkKyJI6xx/QcfCHdJKI?=
 =?us-ascii?q?4h35WOaMIjd0nGlleKqhiBms7Eeg1vPzVtKo0FpQqCpKjMXMu3YQ3BLQ8siKUu?=
 =?us-ascii?q?Vx8lul1DqVygze5P9ILVopmafYN5It2L89m5gLvUjdAiP6hFv6gaqZe0o65OSk?=
 =?us-ascii?q?9+Hqbqj4qZCBLYB5jxzyP6EwlsCiDuk1NwYOUHWV+eSy0bDj81P2TKhWgvAzna?=
 =?us-ascii?q?TZvpPXKMUdq6WkGQFayJwj5Ay6Dzq+0NQXg30HLFVddRKZgIjmJUvOLOr7Dfih?=
 =?us-ascii?q?mVSslilkx/TcMr3mGJXNIWDPkLbnfblj905R0BQ/wcxb6p5OF70MLuz/VlXsuN?=
 =?us-ascii?q?HbEhM1KQ25zuT/BNV4zIweWGaPAqGDMKPVtF+F/uYvI+iKZI8ItzfxMvsl6OD0?=
 =?us-ascii?q?jX8/h1AdebCl3ZwZaXC+APtmOV6UYWTjgtgfC2cGpAk+Q/LwiF2ETzFTY2y+X6?=
 =?us-ascii?q?Um5jE0EI6mF5vMRpixgLyd2ye2BplWZmFFCl+SC3vpeJiEVuwIaCKTJM9hjzMF?=
 =?us-ascii?q?WaKgS48nyRGhqgv6x6B7IerT/y0SrYjj28Rt5+3PiREy8iR5D8SH3GGMU2F7hG?=
 =?us-ascii?q?QISyU23KBiu0N9zFiD3LN8g/xZE9xT+vxIXh07NZ7a0+x1FdTyVhjdcdeOTVas?=
 =?us-ascii?q?Ws+mDi0pTtIt398OZF5wG9eljh/dxSaqALgVl7qNBJwz6a/c23nxJ8Bgy3fJzq?=
 =?us-ascii?q?Uhjl8mQtdROm2inKJw6w/TB4vRmUWDi6mqbbgc3DLK9Gqb12WOp0FYUAlzUanf?=
 =?us-ascii?q?R3AQfEnWoM/95kPDSb+uFLsmPhFAyc6ENqtFdNnpgU9aS/fkPdTUe3ixlHuoBR?=
 =?us-ascii?q?aU2rOMa5Lne2YH0yXbEkQElwET8myANQgxHSqhp2PeDDpzFVPgeU/s8O9+qG+l?=
 =?us-ascii?q?QU8w1Q2Fc0ph17+t8B4PmfOcU+8T3q4DuCo5tjp7Bki90MzMB9qAvQVher5cbs?=
 =?us-ascii?q?074FtA0WLZtAl9Ppi7IqBmh14edRl3vkz02xV2DIVAjdYlrHcwwAVuLqKY1UtL?=
 =?us-ascii?q?dymE0pDoJr3XNm7y8QiyZKHMxFHRzsya+qcV5/Q+sFXsogepG1Em83Vm1dlVzn?=
 =?us-ascii?q?Sd6o/LDAoUTZL+TEI3+wJmqLHdZyk3/5nU2mF0Mamorj/C3MokBPckyhaleNdf?=
 =?us-ascii?q?LKOEFQ/oH80GHcSuL/Yqm1yobhICM+Bf76o0P8Kgd/ub16+nJudgnDS6jWtZ5I?=
 =?us-ascii?q?BxyF6D9y15SuTQxZYK3+mY3hebVzf7lFquqMT3lp5LZD4MHmuz0zPrBJNMaaJo?=
 =?us-ascii?q?e4YLCmCuI9Osy9V6hp7tXWNY9VG5C1MH3s+pZQSdb1jn0QJM0kQXpGStmTGkwD?=
 =?us-ascii?q?xsjzEpsq2f0TTOwuT/bhYIJnRHRWhijVj2J4i0gMsXXEypbwgviRuk6lz2x6ld?=
 =?us-ascii?q?pKRjMWbTRV1EcDTxL2FnSqGwrKaNY9ZT6JM0tiVaSP68YVGGRbHnuRsVziTjE3?=
 =?us-ascii?q?FYxD8lbTGqu4z1kABgh2KZMXl8smDZecZ2xRrE4NzcRPhR3icJRSViiDnXAES8?=
 =?us-ascii?q?MMet/dmOi5jDteW+XXq7VpJPaSnr0Z+AtCyj6GxqAB2zhfCylsf8EQgn1y/2zN?=
 =?us-ascii?q?1qVSTOrBbhbYjnzaW6MeR7fkZ2AF/w8dZ1GoZ7koEonpEfxWAahomJ/XoAiWrz?=
 =?us-ascii?q?M89U2bj9bHoOQj4H2cXV7xLm2E1gL3KJwZz2VnOGz8tlZtm6ZH4W2y0n48BLDq?=
 =?us-ascii?q?eU8KJLnS9vrlWkqgLRZOB3ni0Bxvs29H4an+YJtRItzyqHBbAeB0tYPS3qlxmT?=
 =?us-ascii?q?69C+raNXZHugcLSq1Up+m8yhA6+Gog1GRHn5fZIiFzdq7spjKFLMzGHz6ob8dd?=
 =?us-ascii?q?nTd90TtweYkxfdj+dPLpIxmeEHhS5mOWL7oH0kxPQ3jR1o3ZGmooeHL39h876+?=
 =?us-ascii?q?Ah5dLjf1fd8c+inxjaZCmcabx4WvHpRiGjoRRpfpQ+ynECkOtfv5LQaBCyMzqm?=
 =?us-ascii?q?2UGbfEGQ+f6UFmr2/AEpyxNnGXImUZwstmRBWHOENfhwUUVi0gnpElDgCq2NDh?=
 =?us-ascii?q?cEBh6zAN4V74rwFAy+NyOBn5T2ffvxyoajYvRZibLRpW6BxC5kjPPcyf6OJzAz?=
 =?us-ascii?q?9X/pm7oAORLWybYhxCDXsVVUycG1DjIr6u6MHb/OeCAeq+K+bOba+KqexDTPqI?=
 =?us-ascii?q?wZOv0o17/zeDLMmPP39iD+El1UpHR3x2B8PZmzAXQSwNiy3Nd9KbpAu7+iBvrM?=
 =?us-ascii?q?Cw6vHrVxz05YeVF7teK9Zv+w21gaeeMe6fnj15JC1c1pMNw3/I1bce0EQTiyFo?=
 =?us-ascii?q?azmiD7AAuTTRQ6LXn69dFwQbZD9rNMtU86I82RFAOM7citPoz754k+Q6C1FfWV?=
 =?us-ascii?q?z6ncGpY8MKLnq5NFPGAkaLKbuHKSfKw8HxfaOzV7lQgP9IuB23vDaRC1XjMSib?=
 =?us-ascii?q?lzn1SxCvNvlBjCGFMxxfu4G9cRdtBXLgTNL8bR27P8F4jScrwb0vnX7KMW8cMT?=
 =?us-ascii?q?5hc0JCtLGQ7CVYgulhFGxF9HZqMe6EmyOB5enCNpkWqedrAjhzl+9C+ns61qBa?=
 =?us-ascii?q?7DtaS/11gifSqt9urkqikumOzDpnTRVPpixKhIKNoUVtJ6HZ+oNcVnbD+RIH9X?=
 =?us-ascii?q?+QBAgSp9t5Ft3vvLhdysTOlKL2MjtN78jY8tccB8fKLsKKK34hMRvvGD7JAwoJ?=
 =?us-ascii?q?Vz+rNWfDh0NDlPGe7GGarp8/qpL0gpoBVqdbVEApFvMdEklkHMYNIJFyXjMll7?=
 =?us-ascii?q?6UlM8J5XqkoxnXS8VXpZTHVvOUAfXyJzeVl7hEZx0UwbzmKYQfLJH020tnagoy?=
 =?us-ascii?q?oIOfMkPKWphupTZibwk5pg0Z+XFkSSsw3FnmawWg5lcSFv/ykB9g2SVkZuF4zi?=
 =?us-ascii?q?r3+FozIhLppS0/2Ax5sO/AyRSQdiPhZPO0XIdLGwL9rU01M5XmU0BydwL0gE8y?=
 =?us-ascii?q?Z2SMfK5Yk7Y1LTMjswTbo5YaXKcEFaA=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ACAAAixvZbh0O0hNFiGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwGBMIE5gQInBIwMjAGCDRRmlkCBdhEYCwgBiFIiNAk?=
 =?us-ascii?q?NAQMBAQEBAQECARMBAQEIDQkIKSMMgjYkAYJiAQIDAQIkEwYBATcBBQkBAQoYC?=
 =?us-ascii?q?SUDDAUoIQoOFoMGAYIBAQMBCqhRgWwzgnYBAQWHHwiMCRc+gUGBEYJdNYMQhSO?=
 =?us-ascii?q?CJo8bkGkJkSQLGIFZhQuIdoEuLIlBjkOBRoINMxoILASDJwmCEgkDF4tEglhAM?=
 =?us-ascii?q?oEFAQGMVAEB?=
X-IPAS-Result: =?us-ascii?q?A0ACAAAixvZbh0O0hNFiGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwGBMIE5gQInBIwMjAGCDRRmlkCBdhEYCwgBiFIiNAkNAQMBAQEBAQECA?=
 =?us-ascii?q?RMBAQEIDQkIKSMMgjYkAYJiAQIDAQIkEwYBATcBBQkBAQoYCSUDDAUoIQoOFoM?=
 =?us-ascii?q?GAYIBAQMBCqhRgWwzgnYBAQWHHwiMCRc+gUGBEYJdNYMQhSOCJo8bkGkJkSQLG?=
 =?us-ascii?q?IFZhQuIdoEuLIlBjkOBRoINMxoILASDJwmCEgkDF4tEglhAMoEFAQGMVAEB?=
X-IronPort-AV: E=Sophos;i="5.56,266,1539673200"; 
   d="scan'208";a="53365450"
X-Amp-Result: UNSCANNABLE
X-Amp-File-Uploaded: False
Unscannable: 2
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 22 Nov 2018 07:12:58 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2405767AbeKWBwl (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 22 Nov 2018 20:52:41 -0500
Received: from pandora.armlinux.org.uk ([78.32.30.218]:36482 "EHLO
        pandora.armlinux.org.uk" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726758AbeKWBwk (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Nov 2018 20:52:40 -0500
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
        d=armlinux.org.uk; s=pandora-2014; h=Sender:In-Reply-To:Content-Type:
        MIME-Version:References:Message-ID:Subject:Cc:To:From:Date:Reply-To:
        Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:
        Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:List-Id:
        List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive;
         bh=Rs3WOtH+MutufIT9Q0jsj53sh9J1xB46dA7ai4Z+Mu4=; b=ide9l5SM6UdwWfmLvx79s5fwm
        +rnqmQiPrZG5Rz1cZe7zP2geLPP5eAU2WQG4DA/FL/xFH4PdNXy+vVEeNedg6UHBMczQl7GEI/NNv
        i2zDu2wM22YjeqilbnLjS5tZm6+P7zVMKEVXQW1R7Lx+tQZzs6JEDgqDQO1IDqQ2eaxbk=;
Received: from n2100.armlinux.org.uk ([2002:4e20:1eda:1:214:fdff:fe10:4f86]:39355)
        by pandora.armlinux.org.uk with esmtpsa (TLSv1.2:ECDHE-RSA-AES128-GCM-SHA256:128)
        (Exim 4.90_1)
        (envelope-from <linux@armlinux.org.uk>)
        id 1gPqen-0002es-6m; Thu, 22 Nov 2018 15:12:41 +0000
Received: from linux by n2100.armlinux.org.uk with local (Exim 4.90_1)
        (envelope-from <linux@n2100.armlinux.org.uk>)
        id 1gPqek-0002fU-9j; Thu, 22 Nov 2018 15:12:38 +0000
Date: Thu, 22 Nov 2018 15:12:36 +0000
From: Russell King - ARM Linux <linux@armlinux.org.uk>
To: Aaro Koskinen <aaro.koskinen@iki.fi>
Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>, vkoul@kernel.org,
        dan.j.williams@intel.com, dmaengine@vger.kernel.org,
        linux-kernel@vger.kernel.org, tony@atomide.com,
        linux-omap@vger.kernel.org
Subject: Re: [PATCH] dmaengine: ti: omap-dma: Configure LCH_TYPE for OMAP1
Message-ID: <20181122151236.GA9611@n2100.armlinux.org.uk>
References: <20181119104040.12885-1-peter.ujfalusi@ti.com>
 <20181119184649.GE16897@darkstar.musicnaut.iki.fi>
 <6af8c6e7-bf5c-5555-161b-5d3fb7ecae43@ti.com>
 <20181120210406.GB24888@darkstar.musicnaut.iki.fi>
 <20181122102948.GN6920@n2100.armlinux.org.uk>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20181122102948.GN6920@n2100.armlinux.org.uk>
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Thu, Nov 22, 2018 at 10:29:48AM +0000, Russell King - ARM Linux wrote:
> On Tue, Nov 20, 2018 at 11:04:06PM +0200, Aaro Koskinen wrote:
> > I had switched to PIO mode in 2015 since the WARNs about legacy DMA
> > API were too annoying and flooding the console. And now that I tried
> > using DMA again with g_ether, it doesn't work anymore. The device get's
> > recognized on host side, but no traffic goes through. Switching back to
> > PIO makes it to work again.
> 
> A solution to that would be to do what the warning message says, and
> update the driver to the DMAengine API.

Here's a partial conversion (not even build tested) - it only supports
OUT transfers with dmaengine at the moment.

There's at least one thing that doesn't make sense - the driver
apparently can transfer more than req->length bytes, surely if it does
that, it's a serious problem - shouldn't it be noisy about that?

Also we can't deal with the omap_set_dma_dest_burst_mode() setting -
DMAengine always uses a 64 byte burst, but udc wants a smaller burst
setting.  Does this matter?

I've kept the old code for reference (and the driver will fall back if
we can't get a dmaengine channel.)  I haven't been through and checked
that we result in the channel setup largely the same either.

There will be one major difference - UDC uses element sync, where
an element is 16bits, ep->ep.maxpacket/2 in a frame, and "packets"
frames.  DMAengine is using frame sync, with a 16bit element, one
element in a frame, and packets*ep->ep.maxpacket/2 frames.  This
should be functionally equivalent but I'd like confirmation of that.

I'm also not sure about this:

        if (cpu_is_omap15xx())
                end++;

in dma_dest_len() - is that missing from the omap-dma driver?  It looks
like a work-around for some problem on OMAP15xx, but I can't make sense
about why it's in the UDC driver rather than the legacy DMA driver.

I'm also confused by:

        end |= start & (0xffff << 16);

also in dma_dest_len() - omap_get_dma_dst_pos() returns in the high 16
bits the full address:

        if (dma_omap1())
                offset |= (p->dma_read(CDSA, lch) & 0xFFFF0000);

so if the address crosses a 64k physical address boundary, surely orring
in the start address is wrong?  The more I look at dma_dest_len(), the
more I wonder whether that and dma_src_len() are anywhere near correct,
and whether that is a source of breakage for Aaro.

As I've already said, I've no way to test this on hardware.

Please review and let me know whether I missed anything on the OUT
handling path.

Fixing the IN path is going to be a bit more head-scratching.

 drivers/usb/gadget/udc/omap_udc.c | 154 +++++++++++++++++++++++++++++---------
 drivers/usb/gadget/udc/omap_udc.h |   2 +
 2 files changed, 120 insertions(+), 36 deletions(-)

diff --git a/drivers/usb/gadget/udc/omap_udc.c b/drivers/usb/gadget/udc/omap_udc.c
index 3a16431da321..a37e1d2f0f3e 100644
--- a/drivers/usb/gadget/udc/omap_udc.c
+++ b/drivers/usb/gadget/udc/omap_udc.c
@@ -204,6 +204,7 @@ static int omap_ep_enable(struct usb_ep *_ep,
 	ep->dma_channel = 0;
 	ep->has_dma = 0;
 	ep->lch = -1;
+	ep->dma = NULL;
 	use_ep(ep, UDC_EP_SEL);
 	omap_writew(udc->clr_halt, UDC_CTRL);
 	ep->ackwait = 0;
@@ -576,21 +577,49 @@ static void finish_in_dma(struct omap_ep *ep, struct omap_req *req, int status)
 static void next_out_dma(struct omap_ep *ep, struct omap_req *req)
 {
 	unsigned packets = req->req.length - req->req.actual;
-	int dma_trigger = 0;
+	struct dma_async_tx_descriptor *tx;
+	struct dma_chan *dma = ep->dma;
+	dma_cookie_t cookie;
 	u16 w;
 
-	/* set up this DMA transfer, enable the fifo, start */
-	packets /= ep->ep.maxpacket;
-	packets = min(packets, (unsigned)UDC_RXN_TC + 1);
+	packets = min_t(unsigned, packets / ep->ep.maxpacket, UDC_RXN_TC + 1);
 	req->dma_bytes = packets * ep->ep.maxpacket;
-	omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,
-			ep->ep.maxpacket >> 1, packets,
-			OMAP_DMA_SYNC_ELEMENT,
-			dma_trigger, 0);
-	omap_set_dma_dest_params(ep->lch, OMAP_DMA_PORT_EMIFF,
-		OMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,
-		0, 0);
-	ep->dma_counter = omap_get_dma_dst_pos(ep->lch);
+
+	if (dma) {
+		struct dma_slave_config cfg = {
+			.direction = DMA_DEV_TO_MEM,
+			.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTE,
+			/*
+			 * DMAengine uses frame sync mode, setting maxburst=1
+			 * is equivalent to element sync mode.
+			 */
+			.src_maxburst = 1,
+			.src_addr = UDC_DATA_DMA,
+		};
+
+		if (WARN_ON(dmaengine_slave_config(dma, &cfg)))
+			return;
+
+		tx = dmaengine_prep_slave_single(dma,
+						 req->req.dma + req->req.actual,
+						 req->dma_bytes,
+						 DMA_DEV_TO_MEM, 0);
+		if (WARN_ON(!tx))
+			return;
+	} else {
+		int dma_trigger = 0;
+
+		/* set up this DMA transfer, enable the fifo, start */
+		/* dt = S16, cen = ep->ep.maxpacket / 2, cfn = packets */
+		omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,
+				ep->ep.maxpacket >> 1, packets,
+				OMAP_DMA_SYNC_ELEMENT,
+				dma_trigger, 0);
+		omap_set_dma_dest_params(ep->lch, OMAP_DMA_PORT_EMIFF,
+			OMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,
+			0, 0);
+		ep->dma_counter = omap_get_dma_dst_pos(ep->lch);
+	}
 
 	omap_writew(UDC_RXN_STOP | (packets - 1), UDC_RXDMA(ep->dma_channel));
 	w = omap_readw(UDC_DMA_IRQ_EN);
@@ -599,7 +628,15 @@ static void next_out_dma(struct omap_ep *ep, struct omap_req *req)
 	omap_writew(ep->bEndpointAddress & 0xf, UDC_EP_NUM);
 	omap_writew(UDC_SET_FIFO_EN, UDC_CTRL);
 
-	omap_start_dma(ep->lch);
+	if (dma) {
+		cookie = dmaengine_submit(tx);
+		if (WARN_ON(dma_submit_error(cookie)))
+			return;
+		ep->dma_cookie = cookie;
+		dma_async_issue_pending(dma);
+	} else {
+		omap_start_dma(ep->lch);
+	}
 }
 
 static void
@@ -607,21 +644,39 @@ finish_out_dma(struct omap_ep *ep, struct omap_req *req, int status, int one)
 {
 	u16	count, w;
 
-	if (status == 0)
-		ep->dma_counter = (u16) (req->req.dma + req->req.actual);
-	count = dma_dest_len(ep, req->req.dma + req->req.actual);
+	if (ep->dma) {
+		struct dma_tx_state state;
+
+		dmaengine_tx_status(ep->dma, ep->dma_cookie, &state);
+
+		count = req->dma_bytes - state.residual;
+	} else {
+		if (status == 0)
+			ep->dma_counter = (u16) (req->req.dma + req->req.actual);
+		count = dma_dest_len(ep, req->req.dma + req->req.actual);
+	}
+
 	count += req->req.actual;
 	if (one)
 		count--;
+
+	/*
+	 * FIXME: Surely if count > req->req.length, something has gone
+	 * seriously wrong and we've scribbled over memory we should not...
+	 * so surely we should be a WARN_ON() at the very least?
+	 */
 	if (count <= req->req.length)
 		req->req.actual = count;
 
-	if (count != req->dma_bytes || status)
-		omap_stop_dma(ep->lch);
-
+	if (count != req->dma_bytes || status) {
+		if (ep->dma)
+			dmaengine_terminate_async(ep->dma);
+		else
+			omap_stop_dma(ep->lch);
 	/* if this wasn't short, request may need another transfer */
-	else if (req->req.actual < req->req.length)
+	} else if (req->req.actual < req->req.length) {
 		return;
+	}
 
 	/* rx completion */
 	w = omap_readw(UDC_DMA_IRQ_EN);
@@ -709,6 +764,7 @@ static void dma_channel_claim(struct omap_ep *ep, unsigned channel)
 
 	ep->dma_channel = 0;
 	ep->lch = -1;
+	ep->dma = NULL;
 	if (channel == 0 || channel > 3) {
 		if ((reg & 0x0f00) == 0)
 			channel = 3;
@@ -742,26 +798,44 @@ static void dma_channel_claim(struct omap_ep *ep, unsigned channel)
 				0, 0);
 		}
 	} else {
+		struct dma_chan *dma;
+
 		dma_channel = OMAP_DMA_USB_W2FC_RX0 - 1 + channel;
-		status = omap_request_dma(dma_channel,
-			ep->ep.name, dma_error, ep, &ep->lch);
-		if (status == 0) {
+
+		dma = __dma_request_channel(&mask, omap_dma_filter_fn,
+					    (void *)dma_channel);
+		if (dma) {
+			ep->dma = dma;
 			omap_writew(reg, UDC_RXDMA_CFG);
-			/* TIPB */
-			omap_set_dma_src_params(ep->lch,
-				OMAP_DMA_PORT_TIPB,
-				OMAP_DMA_AMODE_CONSTANT,
-				UDC_DATA_DMA,
-				0, 0);
-			/* EMIFF or SDRC */
-			omap_set_dma_dest_burst_mode(ep->lch,
-						OMAP_DMA_DATA_BURST_4);
-			omap_set_dma_dest_data_pack(ep->lch, 1);
+		} else {
+			status = omap_request_dma(dma_channel,
+				ep->ep.name, dma_error, ep, &ep->lch);
+			if (status == 0) {
+				omap_writew(reg, UDC_RXDMA_CFG);
+				/* TIPB */
+				omap_set_dma_src_params(ep->lch,
+					OMAP_DMA_PORT_TIPB,
+					OMAP_DMA_AMODE_CONSTANT,
+					UDC_DATA_DMA,
+					0, 0);
+				/* EMIFF or SDRC */
+				/*
+				 * not ok - CSDP_DST_BURST_64 selected, but this selects
+				 * CSDP_DST_BURST_16 on omap2+ and CSDP_DST_BURST_32 on
+				 * omap1.
+				 */
+				omap_set_dma_dest_burst_mode(ep->lch,
+							OMAP_DMA_DATA_BURST_4);
+				/* ok - CSDP_DST_PACKED set for dmaengine */
+				omap_set_dma_dest_data_pack(ep->lch, 1);
+			}
 		}
 	}
-	if (status)
+	if (d->dma) {
+		ep->has_dma = 1;
+	} else if (status) {
 		ep->dma_channel = 0;
-	else {
+	} else {
 		ep->has_dma = 1;
 		omap_disable_dma_irq(ep->lch, OMAP_DMA_BLOCK_IRQ);
 
@@ -777,6 +851,10 @@ static void dma_channel_claim(struct omap_ep *ep, unsigned channel)
 	if (status)
 		DBG("%s no dma channel: %d%s\n", ep->ep.name, status,
 			restart ? " (restart)" : "");
+	else if (d->dma)
+		DBG("%s claimed %cxdma%d dmaengine %s%s\n", ep->ep.name,
+			is_in ? 't' : 'r', ep->dma_channel - 1,
+			dma_chan_name(d->dma), restart ? " (restart)" : "");
 	else
 		DBG("%s claimed %cxdma%d lch %d%s\n", ep->ep.name,
 			is_in ? 't' : 'r',
@@ -850,9 +928,13 @@ static void dma_channel_release(struct omap_ep *ep)
 		if (req)
 			finish_out_dma(ep, req, -ECONNRESET, 0);
 	}
-	omap_free_dma(ep->lch);
+	if (ep->dma)
+		dma_release_channel(ep->dma);
+	else
+		omap_free_dma(ep->lch);
 	ep->dma_channel = 0;
 	ep->lch = -1;
+	ep->dma = NULL;
 	/* has_dma still set, till endpoint is fully quiesced */
 }
 
diff --git a/drivers/usb/gadget/udc/omap_udc.h b/drivers/usb/gadget/udc/omap_udc.h
index 00f9e608e755..68857ae8d763 100644
--- a/drivers/usb/gadget/udc/omap_udc.h
+++ b/drivers/usb/gadget/udc/omap_udc.h
@@ -153,6 +153,8 @@ struct omap_ep {
 	u8				dma_channel;
 	u16				dma_counter;
 	int				lch;
+	struct dma_chan			*dma;
+	dma_cookie_t			dma_cookie;
 	struct omap_udc			*udc;
 	struct timer_list		timer;
 };

-- 
RMK's Patch system: http://www.armlinux.org.uk/developer/patches/
FTTC broadband for 0.8mile line in suburbia: sync at 12.1Mbps down 622kbps up
According to speedtest.net: 11.9Mbps down 500kbps up
