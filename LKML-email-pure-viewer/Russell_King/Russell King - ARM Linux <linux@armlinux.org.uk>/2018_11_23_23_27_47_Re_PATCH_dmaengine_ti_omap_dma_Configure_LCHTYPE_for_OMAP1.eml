Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 24 Nov 2018 12:37:49 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from fmsmga007.fm.intel.com (fmsmga007.fm.intel.com [10.253.24.52])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 108FB580460;
	Fri, 23 Nov 2018 15:28:15 -0800 (PST)
Received: from fmsmga101.fm.intel.com ([10.1.193.65])
  by fmsmga007-1.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 23 Nov 2018 15:28:14 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AwvO5/BICFv/pD8UgOtmcpTZWNBhigK39O0sv0rFi?=
 =?us-ascii?q?tYgULP77rarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0vRz+s87lkRwPpiC?=
 =?us-ascii?q?cfNj427mfXitBrjKlGpB6tvgFzz5LIbI2QMvd1Y6HTcs4ARWdZUMhfVzJPDJ6/?=
 =?us-ascii?q?YYsBAOUOIftXoIvzqFsVtRuzBxKhBP/zxjNUmnP6wbc33/onHArb3AIgBdUOsH?=
 =?us-ascii?q?HModvpKacSSvu1w7fMzTXHcvhY3Db96I7Hchs8uP2HQK59f9bWx0IyEQ3Fj1OQ?=
 =?us-ascii?q?qZHqPjiI0ekNt2mb7+x9VeOgkGMosRtxoj2rxsctjInJm40UxkrD9SVjz4Y5P8?=
 =?us-ascii?q?C4SE1ibNOiDZBeuSaaN45sTcMjRWFloDw1yqcDuZ6/fSgKzoknxhHFZ/yAaYiI?=
 =?us-ascii?q?7QjvVPuSITtgn3JlYKywiAiv/ki81OL8TdW03ExMriVbjtnBsG0G2R/L6sWfVP?=
 =?us-ascii?q?dx4kOs1SyS2w3d9O1IO104mKnHJ5I7w7M9lIIfvVrfEiPqhkn7iaCbeVs69uS0?=
 =?us-ascii?q?7unrf6vpqYKGOIJxlw3zN7oiltGwDOk9PAgBQmab+eq52b3t40L1XalGg/g5n6?=
 =?us-ascii?q?nXs53XJMIWrbOjDQBPyIYs8RO/Ai+m0NsGmXkHK0pIeAyIj4f3IVHCOvP4Auml?=
 =?us-ascii?q?g1Sqjjhrw+rKPrr7ApXCNnTDkbHhcqhh60NE1gY/0dRS64hJBrwPPv7/QFL9ud?=
 =?us-ascii?q?/EAhMjMgG5wf7rCNBn2YMfXWKPDLWZMKTXsVKQ4uIvIu+MZJIauTrkKPgq+eTu?=
 =?us-ascii?q?jXknll8ZZKWp2pUWaHamEfR8OEiZf3XsjckbEWsQvQoxUvbqiFucXj5XfXqyWL?=
 =?us-ascii?q?g85j4jBIK8EYjDXpytgKCG3CqjGp1WZ2NGBU6WHXbnaoWJQPMMaCOUIs98nT0I?=
 =?us-ascii?q?T7mhS4k91R6wsA/20aZoLu3R+icAr5LsyMB15/HPlRE17TF0D96S02CRT25umW?=
 =?us-ascii?q?MEXT823L1lrkx7xVeOyqx4g/1eFdxO6PJFSAY6NZjAz+NkD9D+QB7OftCMSFy+?=
 =?us-ascii?q?WNWpHSkxTs4tw98Je0t9GdKigQ7Z0yqpBL8VkbqLBJsv/6LY3njxIdt9ynnc2K?=
 =?us-ascii?q?kgiVkmXtVANWm8iqFj8AjTApbDk1+FmKayaaQcwCnN+X+ZwmqVvEFYVw1wXb/f?=
 =?us-ascii?q?XX8FZEvbttD55kLET7+zBrUrKApBycieKqRUbt3ll0lJRPDmON7GeWK+h3+wBQ?=
 =?us-ascii?q?qUxrOLdIfqeH8S3CPHBEgAkgAc53CGNQclCyelomLeCiFuFF31b0Pt9+l+tG20?=
 =?us-ascii?q?Tksuww6WaE1h0qK/+gQJivyEV/MTwrUEtT88pDpuAlaywcjaC9qaqApnZ6VTf9?=
 =?us-ascii?q?U97FBD1WLasgx9OoetL6Rjhl4YbgR2sFni1xRxCoVcj8cqqGkmwxZ1KaKdyFlB?=
 =?us-ascii?q?bS+X3YjsOr3LLWn/5A2gZLTI2l7AytqW+r0A6PIjq1r9ugGkDU4i83Rh09lI3H?=
 =?us-ascii?q?qQ/JTKDAwOUZ3vVkY77QR1p7bfYiMl/YPbyWVsMbWosj/Fw98pGOolyhOnf9dD?=
 =?us-ascii?q?MKOFFBX+E9EAC8ipMuwqn1mpbhQLPO1J8K40PsWmd+aJ2aKxPeZgmi6mgnpD4I?=
 =?us-ascii?q?xnzk2M8C98QPbS35kZ2/GYwheHVzDkgVi7tsD4h49Fai8SH2al0ifkGZNeabd0?=
 =?us-ascii?q?fYYIDmeuPda6xtF/h57rRn5Z+0SvB1IA2M+1ZxWSa0bx0hFX1UQSuXangze3zy?=
 =?us-ascii?q?RokzE1qaqSxCzPw/n4eBUbIGJKRWligk3qIYi7lN0aWEmobw40lBqq/0r6xq5b?=
 =?us-ascii?q?pLhhIGnXW0tHYy/2L2R6WKuqqrWCe9JP6I8vsShPSuS8YEyVRaTnoxQH1CPvBW?=
 =?us-ascii?q?1eyy4hdzGro5n2gwZ1iGaAI3lttnrZfsdwyAzb5NzdQ/5RwzUHSDN5iTnRGliz?=
 =?us-ascii?q?Id2p8c+ImJfEt+C0T3ihWYFLcSn30YOAszO25G1rARGln/G/gMbnERU80SLg09?=
 =?us-ascii?q?lqVCPIrAvzY4Xx1qS6N/5ncVdsBFPm98V6HYR+mJMqhJ4MwXgamomV/X0fnGfx?=
 =?us-ascii?q?K9pbw6H+bHkKRTIR2N7a+gvl2E5iLnKP2Y35UG6Qws9gZ9m8f2MX1Tgx78FMCK?=
 =?us-ascii?q?eI8rNEmTF5rUa/rQLUefJ9hCsSyeMy6H4GhOEEoAoswT+aArwIH0lYPCrsmg+M?=
 =?us-ascii?q?79C/qqVXeWmufaKx1Ep4gdCuErWCrhtAV3b+f5coBTVw4dlnMFLQzH3z7ZnpeN?=
 =?us-ascii?q?rKYtISrBGUkwrAgPJTKJI+jfcKgStnOWTgvXwq0eI7jBpu3Y2ks4iDMWli4KW5?=
 =?us-ascii?q?AhtAPD3ve8wT4i3tjbpZnsuO2oCvH5ZhFS8RUJrmU/2oCy4Suur9NwmVDjI8sH?=
 =?us-ascii?q?ibFKHbHQ+e7kdmsn3OH4qqN3GROHkW09FiSAOBK0xYhQAeRC86kYIhFgC22Mzh?=
 =?us-ascii?q?d1905iwW5l79sBdNy/hnNx/iUmfEvweoayw5SJyeLBpQ8wFD6F3ZMc2Y7uJvAS?=
 =?us-ascii?q?5Y+oetoxCKKmyefw5IF30GWlSYB1D/Obmj/cLP/PKfBuq6MvvCe7GOqfFFWveM?=
 =?us-ascii?q?xJKv1JZm/jmWOsWOOHliE+M02k5ZUX9lHMTZni0FSzYLmCLVc86buBC89zV1rs?=
 =?us-ascii?q?+l9fTkRhnv6ZGTC7dIMtVv5hO2gbqFN+GKnyZ0MjJY1pIKxX/Vx7kTxl8Siydy?=
 =?us-ascii?q?dzazFbQMrzLCTKXVmqVPFR4UdztzNNdU76I7xgRMOcnbis7s1r5llPE1DU1JVU?=
 =?us-ascii?q?fmmsGvaswHOGW9NFLBBEaWO7WKPzzLw8frYayiTb1clvlbtxq1uTyDCU/sIiyD?=
 =?us-ascii?q?lyX1VxCoKexMjD+UPB1duIG+cxZhE2vjTMjhah20LtB3lyA2waYvi3PONG4cNy?=
 =?us-ascii?q?V8ckxXor2R6yNYnutwG2hb4nV5KumEnj6T7/PEJZYOrftrHiN0mvpA73Qn0LRV?=
 =?us-ascii?q?9j9LRfxvlCvWr95juFWmkuiJyjp6XxtCsDdLhISXvUp8PaXV7IVPWXHB/BgV92?=
 =?us-ascii?q?WfFwwKp8d5Ct3oo61Q1tnPlKfpJDhe6d7b4cscCNbSKM+cNHohMBzpGCPbDQcf?=
 =?us-ascii?q?TD6rM33fiFJZkP2I6nKVqZ06oID2mJUSUr9bSEA1FvQCB0VlBtMCJpJ3XjIikb?=
 =?us-ascii?q?GDjc8I5WCxrB/eRMhBupDHV/SSAejgKTqDjLlEYQcIzq38LYgJKoL73EliORFG?=
 =?us-ascii?q?m9HyFlbdR5hwoCNoahIvoQ0Z6HViQ3d1xkDrYwew+347Cf/ylRkz3FhQe+MooQ?=
 =?us-ascii?q?3x+Ew6Il6Chyo2nwF00fzfpHi1cTjsPO/kWYBQFjrcvlI0NpL9XhYzahe921Fn?=
 =?us-ascii?q?YmSXD4lNhqdtIDg4wDTXvoFCTLsFFfVJ?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ARAADMjPhbh0O0hNFjGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUwQBAQELAYEwgTmBAicEmA2CDRSXJ4FsGxgLCAGIWiI2Bw0BAwEBAQE?=
 =?us-ascii?q?BAQIBEwEBAQgNCQgpIwyCNiQBgmIBAgMBAiQTBgEBNwEFCQEBChgJJQMMBSghC?=
 =?us-ascii?q?g6DHAGCAQEDAQqlboFsM4J2AQEFhxYIjAkXPoFBgRGDEoMQhSOCJokbCoV2gUW?=
 =?us-ascii?q?PJAmRJAsYkQgsmASBTQOCAzMaCCwEgycJghIJAxeLRIJYQDKBBQEBjCEBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ARAADMjPhbh0O0hNFjGwEBAQEDAQEBBwMBAQGBUwQBAQE?=
 =?us-ascii?q?LAYEwgTmBAicEmA2CDRSXJ4FsGxgLCAGIWiI2Bw0BAwEBAQEBAQIBEwEBAQgNC?=
 =?us-ascii?q?QgpIwyCNiQBgmIBAgMBAiQTBgEBNwEFCQEBChgJJQMMBSghCg6DHAGCAQEDAQq?=
 =?us-ascii?q?lboFsM4J2AQEFhxYIjAkXPoFBgRGDEoMQhSOCJokbCoV2gUWPJAmRJAsYkQgsm?=
 =?us-ascii?q?ASBTQOCAzMaCCwEgycJghIJAxeLRIJYQDKBBQEBjCEBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,271,1539673200"; 
   d="scan'208";a="63737044"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mga01b.intel.com with ESMTP; 23 Nov 2018 15:28:13 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727778AbeKXKOU (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sat, 24 Nov 2018 05:14:20 -0500
Received: from pandora.armlinux.org.uk ([78.32.30.218]:58622 "EHLO
        pandora.armlinux.org.uk" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727607AbeKXKOU (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sat, 24 Nov 2018 05:14:20 -0500
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
        d=armlinux.org.uk; s=pandora-2014; h=Sender:In-Reply-To:Content-Type:
        MIME-Version:References:Message-ID:Subject:Cc:To:From:Date:Reply-To:
        Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:
        Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:List-Id:
        List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive;
         bh=o8yDe7vbzHoLqz+qXKDkzMq4TGCWv5kGZmREGEKzMpw=; b=T4TpvZ+Zkzd9e8wNKP6eJ6GZR
        KTT5sZqG1WVJc7ZtdUFuQdpnZHqemrAlTPCg9MeCIF5kghnWnoPA8odiOBcWOkhsLWXG9JCbzq4kb
        6/QFv9ZX5PM1UMJsiz6g1fqiCLuwiUt2FHO8Sm8HrDZ46fcLTprSLKBzla0SE9WAKP5bk=;
Received: from n2100.armlinux.org.uk ([2002:4e20:1eda:1:214:fdff:fe10:4f86]:34092)
        by pandora.armlinux.org.uk with esmtpsa (TLSv1.2:ECDHE-RSA-AES128-GCM-SHA256:128)
        (Exim 4.90_1)
        (envelope-from <linux@armlinux.org.uk>)
        id 1gQKra-00026w-8u; Fri, 23 Nov 2018 23:27:54 +0000
Received: from linux by n2100.armlinux.org.uk with local (Exim 4.90_1)
        (envelope-from <linux@n2100.armlinux.org.uk>)
        id 1gQKrV-0004uW-Rv; Fri, 23 Nov 2018 23:27:49 +0000
Date: Fri, 23 Nov 2018 23:27:47 +0000
From: Russell King - ARM Linux <linux@armlinux.org.uk>
To: Peter Ujfalusi <peter.ujfalusi@ti.com>
Cc: Aaro Koskinen <aaro.koskinen@iki.fi>, vkoul@kernel.org,
        dan.j.williams@intel.com, dmaengine@vger.kernel.org,
        linux-kernel@vger.kernel.org, tony@atomide.com,
        linux-omap@vger.kernel.org
Subject: Re: [PATCH] dmaengine: ti: omap-dma: Configure LCH_TYPE for OMAP1
Message-ID: <20181123232746.GA18875@n2100.armlinux.org.uk>
References: <20181119104040.12885-1-peter.ujfalusi@ti.com>
 <20181119184649.GE16897@darkstar.musicnaut.iki.fi>
 <6af8c6e7-bf5c-5555-161b-5d3fb7ecae43@ti.com>
 <20181120210406.GB24888@darkstar.musicnaut.iki.fi>
 <20181122102948.GN6920@n2100.armlinux.org.uk>
 <20181122151236.GA9611@n2100.armlinux.org.uk>
 <6ed280af-edb6-4be7-82f4-7fc00378103e@ti.com>
 <20181123154311.GP6920@n2100.armlinux.org.uk>
 <20181123161659.GA3019@n2100.armlinux.org.uk>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20181123161659.GA3019@n2100.armlinux.org.uk>
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Fri, Nov 23, 2018 at 04:16:59PM +0000, Russell King - ARM Linux wrote:
> Hi Peter,
> 
> Here's the patch, which should now support IN as well as OUT.
> Completely untested, as mentioned before.

Now compile tested...

 drivers/usb/gadget/udc/omap_udc.c | 291 ++++++++++++++++++--------------------
 drivers/usb/gadget/udc/omap_udc.h |   3 +-
 2 files changed, 137 insertions(+), 157 deletions(-)

diff --git a/drivers/usb/gadget/udc/omap_udc.c b/drivers/usb/gadget/udc/omap_udc.c
index 3a16431da321..dd85476ec234 100644
--- a/drivers/usb/gadget/udc/omap_udc.c
+++ b/drivers/usb/gadget/udc/omap_udc.c
@@ -28,6 +28,7 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg.h>
+#include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/err.h>
@@ -203,7 +204,7 @@ static int omap_ep_enable(struct usb_ep *_ep,
 	/* set endpoint to initial state */
 	ep->dma_channel = 0;
 	ep->has_dma = 0;
-	ep->lch = -1;
+	ep->dma = NULL;
 	use_ep(ep, UDC_EP_SEL);
 	omap_writew(udc->clr_halt, UDC_CTRL);
 	ep->ackwait = 0;
@@ -468,43 +469,6 @@ static int read_fifo(struct omap_ep *ep, struct omap_req *req)
 
 /*-------------------------------------------------------------------------*/
 
-static u16 dma_src_len(struct omap_ep *ep, dma_addr_t start)
-{
-	dma_addr_t	end;
-
-	/* IN-DMA needs this on fault/cancel paths, so 15xx misreports
-	 * the last transfer's bytecount by more than a FIFO's worth.
-	 */
-	if (cpu_is_omap15xx())
-		return 0;
-
-	end = omap_get_dma_src_pos(ep->lch);
-	if (end == ep->dma_counter)
-		return 0;
-
-	end |= start & (0xffff << 16);
-	if (end < start)
-		end += 0x10000;
-	return end - start;
-}
-
-static u16 dma_dest_len(struct omap_ep *ep, dma_addr_t start)
-{
-	dma_addr_t	end;
-
-	end = omap_get_dma_dst_pos(ep->lch);
-	if (end == ep->dma_counter)
-		return 0;
-
-	end |= start & (0xffff << 16);
-	if (cpu_is_omap15xx())
-		end++;
-	if (end < start)
-		end += 0x10000;
-	return end - start;
-}
-
-
 /* Each USB transfer request using DMA maps to one or more DMA transfers.
  * When DMA completion isn't request completion, the UDC continues with
  * the next DMA transfer for that USB transfer.
@@ -512,34 +476,53 @@ static u16 dma_dest_len(struct omap_ep *ep, dma_addr_t start)
 
 static void next_in_dma(struct omap_ep *ep, struct omap_req *req)
 {
-	u16		txdma_ctrl, w;
-	unsigned	length = req->req.length - req->req.actual;
-	const int	sync_mode = cpu_is_omap15xx()
-				? OMAP_DMA_SYNC_FRAME
-				: OMAP_DMA_SYNC_ELEMENT;
-	int		dma_trigger = 0;
+	struct dma_async_tx_descriptor *tx;
+	struct dma_chan *dma = ep->dma;
+	dma_cookie_t cookie;
+	unsigned burst, length;
+	u16 txdma_ctrl, w;
+	struct dma_slave_config omap_udc_in_cfg = {
+		.direction = DMA_MEM_TO_DEV,
+		.dst_addr = UDC_DATA_DMA,
+	};
+
+	length = req->req.length - req->req.actual;
 
 	/* measure length in either bytes or packets */
-	if ((cpu_is_omap16xx() && length <= UDC_TXN_TSC)
-			|| (cpu_is_omap15xx() && length < ep->maxpacket)) {
+	if ((cpu_is_omap16xx() && length <= UDC_TXN_TSC) ||
+	    (cpu_is_omap15xx() && length < ep->maxpacket)) {
+		omap_udc_in_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 		txdma_ctrl = UDC_TXN_EOT | length;
-		omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S8,
-				length, 1, sync_mode, dma_trigger, 0);
+		burst = length;
 	} else {
-		length = min(length / ep->maxpacket,
-				(unsigned) UDC_TXN_TSC + 1);
+		omap_udc_in_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		length = min_t(unsigned, length / ep->maxpacket,
+		               UDC_TXN_TSC + 1);
 		txdma_ctrl = length;
-		omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,
-				ep->ep.maxpacket >> 1, length, sync_mode,
-				dma_trigger, 0);
 		length *= ep->maxpacket;
+		burst = ep->ep.maxpacket >> 1;
 	}
-	omap_set_dma_src_params(ep->lch, OMAP_DMA_PORT_EMIFF,
-		OMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,
-		0, 0);
 
-	omap_start_dma(ep->lch);
-	ep->dma_counter = omap_get_dma_src_pos(ep->lch);
+	if (!cpu_is_omap15xx())
+		burst = 1;
+
+	omap_udc_in_cfg.dst_maxburst = burst;
+
+	if (WARN_ON(dmaengine_slave_config(dma, &omap_udc_in_cfg)))
+		return;
+
+	tx = dmaengine_prep_slave_single(dma, req->req.dma + req->req.actual,
+					 length, DMA_MEM_TO_DEV, 0);
+	if (WARN_ON(!tx))
+		return;
+
+	cookie = dmaengine_submit(tx);
+	if (WARN_ON(dma_submit_error(cookie)))
+		return;
+
+	ep->dma_cookie = cookie;
+	dma_async_issue_pending(dma);
+
 	w = omap_readw(UDC_DMA_IRQ_EN);
 	w |= UDC_TX_DONE_IE(ep->dma_channel);
 	omap_writew(w, UDC_DMA_IRQ_EN);
@@ -549,11 +532,14 @@ static void next_in_dma(struct omap_ep *ep, struct omap_req *req)
 
 static void finish_in_dma(struct omap_ep *ep, struct omap_req *req, int status)
 {
+	struct dma_tx_state state;
 	u16 w;
 
-	if (status == 0) {
-		req->req.actual += req->dma_bytes;
+	dmaengine_tx_status(ep->dma, ep->dma_cookie, &state);
+
+	req->req.actual += req->dma_bytes - state.residue;
 
+	if (status == 0) {
 		/* return if this request needs to send data or zlp */
 		if (req->req.actual < req->req.length)
 			return;
@@ -561,36 +547,47 @@ static void finish_in_dma(struct omap_ep *ep, struct omap_req *req, int status)
 				&& req->dma_bytes != 0
 				&& (req->req.actual % ep->maxpacket) == 0)
 			return;
-	} else
-		req->req.actual += dma_src_len(ep, req->req.dma
-							+ req->req.actual);
+	}
 
 	/* tx completion */
-	omap_stop_dma(ep->lch);
+	dmaengine_terminate_async(ep->dma);
+
 	w = omap_readw(UDC_DMA_IRQ_EN);
 	w &= ~UDC_TX_DONE_IE(ep->dma_channel);
 	omap_writew(w, UDC_DMA_IRQ_EN);
 	done(ep, req, status);
 }
 
+static struct dma_slave_config omap_udc_out_cfg = {
+	.direction = DMA_DEV_TO_MEM,
+	.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES,
+	/*
+	 * DMAengine uses frame sync mode, setting maxburst=1
+	 * is equivalent to element sync mode.
+	 */
+	.src_maxburst = 1,
+	.src_addr = UDC_DATA_DMA,
+};
+
 static void next_out_dma(struct omap_ep *ep, struct omap_req *req)
 {
-	unsigned packets = req->req.length - req->req.actual;
-	int dma_trigger = 0;
+	struct dma_async_tx_descriptor *tx;
+	struct dma_chan *dma = ep->dma;
+	dma_cookie_t cookie;
+	unsigned packets, length;
 	u16 w;
 
-	/* set up this DMA transfer, enable the fifo, start */
-	packets /= ep->ep.maxpacket;
-	packets = min(packets, (unsigned)UDC_RXN_TC + 1);
-	req->dma_bytes = packets * ep->ep.maxpacket;
-	omap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,
-			ep->ep.maxpacket >> 1, packets,
-			OMAP_DMA_SYNC_ELEMENT,
-			dma_trigger, 0);
-	omap_set_dma_dest_params(ep->lch, OMAP_DMA_PORT_EMIFF,
-		OMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,
-		0, 0);
-	ep->dma_counter = omap_get_dma_dst_pos(ep->lch);
+	length = req->req.length - req->req.actual;
+	packets = min_t(unsigned, length / ep->ep.maxpacket, UDC_RXN_TC + 1);
+	length = packets * ep->ep.maxpacket;
+
+	if (WARN_ON(dmaengine_slave_config(dma, &omap_udc_out_cfg)))
+		return;
+
+	tx = dmaengine_prep_slave_single(dma, req->req.dma + req->req.actual,
+					 length, DMA_DEV_TO_MEM, 0);
+	if (WARN_ON(!tx))
+		return;
 
 	omap_writew(UDC_RXN_STOP | (packets - 1), UDC_RXDMA(ep->dma_channel));
 	w = omap_readw(UDC_DMA_IRQ_EN);
@@ -599,29 +596,42 @@ static void next_out_dma(struct omap_ep *ep, struct omap_req *req)
 	omap_writew(ep->bEndpointAddress & 0xf, UDC_EP_NUM);
 	omap_writew(UDC_SET_FIFO_EN, UDC_CTRL);
 
-	omap_start_dma(ep->lch);
+	cookie = dmaengine_submit(tx);
+	if (WARN_ON(dma_submit_error(cookie)))
+		return;
+
+	ep->dma_cookie = cookie;
+	dma_async_issue_pending(dma);
+	req->dma_bytes = length;
 }
 
 static void
 finish_out_dma(struct omap_ep *ep, struct omap_req *req, int status, int one)
 {
+	struct dma_tx_state state;
 	u16	count, w;
 
-	if (status == 0)
-		ep->dma_counter = (u16) (req->req.dma + req->req.actual);
-	count = dma_dest_len(ep, req->req.dma + req->req.actual);
+	dmaengine_tx_status(ep->dma, ep->dma_cookie, &state);
+
+	count = req->dma_bytes - state.residue;
 	count += req->req.actual;
 	if (one)
 		count--;
+
+	/*
+	 * FIXME: Surely if count > req->req.length, something has gone
+	 * seriously wrong and we've scribbled over memory we should not...
+	 * so surely we should be a WARN_ON() at the very least?
+	 */
 	if (count <= req->req.length)
 		req->req.actual = count;
 
-	if (count != req->dma_bytes || status)
-		omap_stop_dma(ep->lch);
-
+	if (count != req->dma_bytes || status) {
+		dmaengine_terminate_async(ep->dma);
 	/* if this wasn't short, request may need another transfer */
-	else if (req->req.actual < req->req.length)
+	} else if (req->req.actual < req->req.length) {
 		return;
+	}
 
 	/* rx completion */
 	w = omap_readw(UDC_DMA_IRQ_EN);
@@ -683,32 +693,25 @@ static void dma_irq(struct omap_udc *udc, u16 irq_src)
 	}
 }
 
-static void dma_error(int lch, u16 ch_status, void *data)
-{
-	struct omap_ep	*ep = data;
-
-	/* if ch_status & OMAP_DMA_DROP_IRQ ... */
-	/* if ch_status & OMAP1_DMA_TOUT_IRQ ... */
-	ERR("%s dma error, lch %d status %02x\n", ep->ep.name, lch, ch_status);
-
-	/* complete current transfer ... */
-}
-
 static void dma_channel_claim(struct omap_ep *ep, unsigned channel)
 {
+	dma_cap_mask_t mask;
+	struct dma_chan *dma;
+	u32 dma_cfg;
 	u16	reg;
 	int	status, restart, is_in;
 	int	dma_channel;
 
 	is_in = ep->bEndpointAddress & USB_DIR_IN;
 	if (is_in)
-		reg = omap_readw(UDC_TXDMA_CFG);
+		dma_cfg = UDC_TXDMA_CFG;
 	else
-		reg = omap_readw(UDC_RXDMA_CFG);
+		dma_cfg = UDC_RXDMA_CFG;
+	reg = omap_readw(dma_cfg);
 	reg |= UDC_DMA_REQ;		/* "pulse" activated */
 
 	ep->dma_channel = 0;
-	ep->lch = -1;
+	ep->dma = NULL;
 	if (channel == 0 || channel > 3) {
 		if ((reg & 0x0f00) == 0)
 			channel = 3;
@@ -722,65 +725,38 @@ static void dma_channel_claim(struct omap_ep *ep, unsigned channel)
 		}
 	}
 	reg |= (0x0f & ep->bEndpointAddress) << (4 * (channel - 1));
-	ep->dma_channel = channel;
 
-	if (is_in) {
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	if (is_in)
 		dma_channel = OMAP_DMA_USB_W2FC_TX0 - 1 + channel;
-		status = omap_request_dma(dma_channel,
-			ep->ep.name, dma_error, ep, &ep->lch);
-		if (status == 0) {
-			omap_writew(reg, UDC_TXDMA_CFG);
-			/* EMIFF or SDRC */
-			omap_set_dma_src_burst_mode(ep->lch,
-						OMAP_DMA_DATA_BURST_4);
-			omap_set_dma_src_data_pack(ep->lch, 1);
-			/* TIPB */
-			omap_set_dma_dest_params(ep->lch,
-				OMAP_DMA_PORT_TIPB,
-				OMAP_DMA_AMODE_CONSTANT,
-				UDC_DATA_DMA,
-				0, 0);
-		}
-	} else {
+	else
 		dma_channel = OMAP_DMA_USB_W2FC_RX0 - 1 + channel;
-		status = omap_request_dma(dma_channel,
-			ep->ep.name, dma_error, ep, &ep->lch);
-		if (status == 0) {
-			omap_writew(reg, UDC_RXDMA_CFG);
-			/* TIPB */
-			omap_set_dma_src_params(ep->lch,
-				OMAP_DMA_PORT_TIPB,
-				OMAP_DMA_AMODE_CONSTANT,
-				UDC_DATA_DMA,
-				0, 0);
-			/* EMIFF or SDRC */
-			omap_set_dma_dest_burst_mode(ep->lch,
-						OMAP_DMA_DATA_BURST_4);
-			omap_set_dma_dest_data_pack(ep->lch, 1);
-		}
-	}
-	if (status)
-		ep->dma_channel = 0;
-	else {
-		ep->has_dma = 1;
-		omap_disable_dma_irq(ep->lch, OMAP_DMA_BLOCK_IRQ);
 
-		/* channel type P: hw synch (fifo) */
-		if (!cpu_is_omap15xx())
-			omap_set_dma_channel_mode(ep->lch, OMAP_DMA_LCH_P);
+	dma = __dma_request_channel(&mask, omap_dma_filter_fn,
+				    (void *)dma_channel);
+	if (dma) {
+		omap_writew(reg, dma_cfg);
+		ep->dma_channel = channel;
+		ep->dma = dma;
+		ep->has_dma = 1;
+		status = 0;
+	} else {
+		ep->dma_channel = 0;
+		status = -EINVAL;
 	}
 
 just_restart:
 	/* restart any queue, even if the claim failed  */
 	restart = !ep->stopped && !list_empty(&ep->queue);
 
-	if (status)
-		DBG("%s no dma channel: %d%s\n", ep->ep.name, status,
-			restart ? " (restart)" : "");
+	if (ep->dma)
+		DBG("%s claimed %cxdma%d dmaengine %s%s\n", ep->ep.name,
+			is_in ? 't' : 'r', ep->dma_channel - 1,
+			dma_chan_name(ep->dma), restart ? " (restart)" : "");
 	else
-		DBG("%s claimed %cxdma%d lch %d%s\n", ep->ep.name,
-			is_in ? 't' : 'r',
-			ep->dma_channel - 1, ep->lch,
+		DBG("%s no dma channel: %d%s\n", ep->ep.name, status,
 			restart ? " (restart)" : "");
 
 	if (restart) {
@@ -814,7 +790,8 @@ static void dma_channel_release(struct omap_ep *ep)
 	else
 		req = NULL;
 
-	active = omap_get_dma_active_status(ep->lch);
+	active = dma_async_is_tx_complete(ep->dma, ep->dma_cookie, NULL, NULL)
+			== DMA_IN_PROGRESS;
 
 	DBG("%s release %s %cxdma%d %p\n", ep->ep.name,
 			active ? "active" : "idle",
@@ -850,9 +827,9 @@ static void dma_channel_release(struct omap_ep *ep)
 		if (req)
 			finish_out_dma(ep, req, -ECONNRESET, 0);
 	}
-	omap_free_dma(ep->lch);
+	dma_release_channel(ep->dma);
 	ep->dma_channel = 0;
-	ep->lch = -1;
+	ep->dma = NULL;
 	/* has_dma still set, till endpoint is fully quiesced */
 }
 
@@ -2146,9 +2123,9 @@ static void proc_ep_show(struct seq_file *s, struct omap_ep *ep)
 	use_ep(ep, 0);
 
 	if (use_dma && ep->has_dma)
-		snprintf(buf, sizeof buf, "(%cxdma%d lch%d) ",
+		snprintf(buf, sizeof buf, "(%cxdma%d dma %s) ",
 			(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',
-			ep->dma_channel - 1, ep->lch);
+			ep->dma_channel - 1, dma_chan_name(ep->dma));
 	else
 		buf[0] = 0;
 
@@ -2194,9 +2171,11 @@ static void proc_ep_show(struct seq_file *s, struct omap_ep *ep)
 			unsigned	length = req->req.actual;
 
 			if (use_dma && buf[0]) {
-				length += ((ep->bEndpointAddress & USB_DIR_IN)
-						? dma_src_len : dma_dest_len)
-					(ep, req->req.dma + length);
+				struct dma_tx_state state;
+
+				dmaengine_tx_status(ep->dma, ep->dma_cookie,
+						    &state);
+				length += req->dma_bytes - state.residue;
 				buf[0] = 0;
 			}
 			seq_printf(s, "\treq %p len %d/%d buf %p\n",
diff --git a/drivers/usb/gadget/udc/omap_udc.h b/drivers/usb/gadget/udc/omap_udc.h
index 00f9e608e755..e04c48f669ed 100644
--- a/drivers/usb/gadget/udc/omap_udc.h
+++ b/drivers/usb/gadget/udc/omap_udc.h
@@ -152,7 +152,8 @@ struct omap_ep {
 	u8				ackwait;
 	u8				dma_channel;
 	u16				dma_counter;
-	int				lch;
+	struct dma_chan			*dma;
+	dma_cookie_t			dma_cookie;
 	struct omap_udc			*udc;
 	struct timer_list		timer;
 };


-- 
RMK's Patch system: http://www.armlinux.org.uk/developer/patches/
FTTC broadband for 0.8mile line in suburbia: sync at 12.1Mbps down 622kbps up
According to speedtest.net: 11.9Mbps down 500kbps up
