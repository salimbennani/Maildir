Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 10 Dec 2018 18:13:46 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga002.jf.intel.com (orsmga002.jf.intel.com [10.7.209.21])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id AA16D5804A8
	for <like.xu@linux.intel.com>; Sun,  9 Dec 2018 21:21:10 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga002-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 09 Dec 2018 21:21:10 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3AfJQbQBPiXFaklwy/F5Al6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0K/z9osbcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Qiqp4bt1RxD0iS?=
 =?us-ascii?q?cHLz85/3/Risxsl6JQvRatqwViz4LIfI2ZMfxzdb7fc9wHX2pMRshfWSxfDI2/?=
 =?us-ascii?q?YYsAAPYOMvtaoIbzulUOtRmzCwujCe/yxDJEmmH53bYh3uQuDQ3LxhYtE84UvX?=
 =?us-ascii?q?jKqtj+KaccUfqyzKnN1TjNYelZ2Sn86IfVbxsvoPCMUqlrccrWz0kkCgTIgUiK?=
 =?us-ascii?q?poz7PjOay/8As2ea7+V7TuKvjGgnpxtsrTi1wccskpLGiZwPxVDe7yl5wZs6Kc?=
 =?us-ascii?q?eiR05meNOpFoZbuS+dN4tzWMwiQmdotT49yrwHvZ60ZjMFyI89yx7YcfyHfJCE?=
 =?us-ascii?q?7Q/5VOaWOTd3n2xqd6ilhxqo8Eiv1+vxXdS33lZStidJjMXAu3MX2xDO98SKSe?=
 =?us-ascii?q?Fx8lmv1DuPzQzf9+NJLVgqmabHJZMt2KM8mocJvUnBAyP6glj6gamLfUs+4Oeo?=
 =?us-ascii?q?8f7oYrD+q5+cKYB0jgb+P7wqmsy+GuQ4LhMOU3KU+eS6yb3v50r5QK9FjvEuk6?=
 =?us-ascii?q?nZto7VJdgDq6KnHwNY0Zwv5wuiAzqlytgUg3cKIVJfdB6ajYXlI1TOL+r5Dfe7?=
 =?us-ascii?q?jVSsijBrx/XeM734HJrNK2XDnK78crlj9U5T1g4zwclE6JJTF7EBJu78VVHqtN?=
 =?us-ascii?q?DfCh85Mg+0zPj9BNRyy4MTQWaPAq6fMKPPvl6E/OMvI++QZIALvDbxMeQq5/nr?=
 =?us-ascii?q?jXIin18deq+p3ZQRaHClBPhmJF+ZYXX0jtcbDWgKphY+TPDtiFCaVT5TZnWyUL?=
 =?us-ascii?q?wm6jA0FYKrFoPDRoGrgLyc0ya3BJxWZmZaCl+SFXfkbZmLW/AJaHHaH8l6jzZR?=
 =?us-ascii?q?VaS9U5RzklaqtRTm0PxhKezb/DBesojsk9185unWnBd18iRoDsObyCaUQmRp22?=
 =?us-ascii?q?8FWTIyj515ulF3n1KK0KxkhK5BGNlOov9ETAo+cITR1vF3EMzaXAXHcdGUDlG8?=
 =?us-ascii?q?TYK9HDszQ9ktlsIIeFt3AN64jxrOjBatVpocjb/DL5Uq/+f1znz4Ico1n3PPzq?=
 =?us-ascii?q?pnhFA4T45GJGmvgKJX9gzaAYLE1U6e0bupI/cyxinIoUuK02uC9G5ZWhV3V+2R?=
 =?us-ascii?q?UXkBZ0f+otXz/UTECbO0DqwtPwJbj8+ObKJXPI66xW5aTevubYyNK1m6nH29UF?=
 =?us-ascii?q?PRnuuB?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ACAACx9g1cmBHrdtBjFgQBAQEBAQIBA?=
 =?us-ascii?q?QEBBwIBAQEBgVEFAQEBAQsBgTCBOYEpjBNfiy6CDZdRgXUCCwUYBw2HXSI0CQ0?=
 =?us-ascii?q?BAwEBAQEBAQIBEwEBAQEBCAsLBhsOIwyCNgUCAxoBBoJbAQEBAQIBAQIXAQwZA?=
 =?us-ascii?q?QEECikBAgMBAgYBAQoYCRoDCAMBCwUYMRMFBIMYAYF5BwEBBKQbgWwzgnYBAQW?=
 =?us-ascii?q?HEwcIgm2IGIEcF4F/g241hDuGIY8/kTgJgiWEY4o8CxhgfE2PFCyJe4ZZiDCBR?=
 =?us-ascii?q?oIOMxoIFxmDJwmCEgwXEoFyhlqFUy0xgQQDihcPFwQsgXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ACAACx9g1cmBHrdtBjFgQBAQEBAQIBAQEBBwIBAQEBgVE?=
 =?us-ascii?q?FAQEBAQsBgTCBOYEpjBNfiy6CDZdRgXUCCwUYBw2HXSI0CQ0BAwEBAQEBAQIBE?=
 =?us-ascii?q?wEBAQEBCAsLBhsOIwyCNgUCAxoBBoJbAQEBAQIBAQIXAQwZAQEECikBAgMBAgY?=
 =?us-ascii?q?BAQoYCRoDCAMBCwUYMRMFBIMYAYF5BwEBBKQbgWwzgnYBAQWHEwcIgm2IGIEcF?=
 =?us-ascii?q?4F/g241hDuGIY8/kTgJgiWEY4o8CxhgfE2PFCyJe4ZZiDCBRoIOMxoIFxmDJwm?=
 =?us-ascii?q?CEgwXEoFyhlqFUy0xgQQDihcPFwQsgXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,337,1539673200"; 
   d="asc'?scan'208";a="54496944"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 09 Dec 2018 21:21:09 -0800
Received: from localhost ([::1]:59206 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gWE0C-0003LA-5B
	for like.xu@linux.intel.com; Mon, 10 Dec 2018 00:21:08 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:60680)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <dgibson@ozlabs.org>) id 1gWDyt-0002XL-Sz
	for qemu-devel@nongnu.org; Mon, 10 Dec 2018 00:19:52 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <dgibson@ozlabs.org>) id 1gWDyo-0001qz-4o
	for qemu-devel@nongnu.org; Mon, 10 Dec 2018 00:19:47 -0500
Received: from ozlabs.org ([203.11.71.1]:48455)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <dgibson@ozlabs.org>)
	id 1gWDyl-0001mK-Uw; Mon, 10 Dec 2018 00:19:41 -0500
Received: by ozlabs.org (Postfix, from userid 1007)
	id 43CrwX2Fngz9s7T; Mon, 10 Dec 2018 16:19:24 +1100 (AEDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
	d=gibson.dropbear.id.au; s=201602; t=1544419164;
	bh=Ywhgexe4NjE9XfvwHfDPg3sBQusIKUtgjwjvJM/Kvpo=;
	h=Date:From:To:Cc:Subject:References:In-Reply-To:From;
	b=WBjCuhnsxzsxK+xeWLTg+lx3QGndvbX+JVKYYZa73V89V5j+PBLlbFE+FjDtVZd1v
	Jt0GW86ogerlv7PBTkN2ciOyz37SXxE6qQf03eU46uQrzPiBOhhwyTF/8HqgC+D9+b
	ltyxpHmli7mijjgb9zuXZelXeagRxgEfPNJuIXn8=
Date: Mon, 10 Dec 2018 16:17:30 +1100
From: David Gibson <david@gibson.dropbear.id.au>
To: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>
Message-ID: <20181210051730.GQ4261@umbus.fritz.box>
References: <20181207085635.4291-1-mark.cave-ayland@ilande.co.uk>
	<20181207085635.4291-2-mark.cave-ayland@ilande.co.uk>
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha256;
	protocol="application/pgp-signature"; boundary="pwWdILMQNxDD/Cps"
Content-Disposition: inline
In-Reply-To: <20181207085635.4291-2-mark.cave-ayland@ilande.co.uk>
User-Agent: Mutt/1.10.1 (2018-07-13)
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 203.11.71.1
Subject: Re: [Qemu-devel] [RFC PATCH 1/6] target/ppc: introduce get_fpr()
 and set_fpr() helpers for FP register access
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: richard.henderson@linaro.org, qemu-ppc@nongnu.org, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>


--pwWdILMQNxDD/Cps
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Fri, Dec 07, 2018 at 08:56:30AM +0000, Mark Cave-Ayland wrote:
> These helpers allow us to move FP register values to/from the specified T=
CGv_i64
> argument.
>=20
> To prevent FP helpers accessing the cpu_fpr array directly, add extra TCG
> temporaries as required.

It's not obvious to me why that's a desirable thing.  I'm assuming
it's somehow necessary for the stuff later in the series, but I think
we need a brief rationale here to explain why this isn't just adding
extra reg copies for the sake of it.

>=20
> Signed-off-by: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>
> ---
>  target/ppc/translate.c             |  10 +
>  target/ppc/translate/fp-impl.inc.c | 492 ++++++++++++++++++++++++++++---=
------
>  2 files changed, 392 insertions(+), 110 deletions(-)
>=20
> diff --git a/target/ppc/translate.c b/target/ppc/translate.c
> index 2b37910248..1d4bf624a3 100644
> --- a/target/ppc/translate.c
> +++ b/target/ppc/translate.c
> @@ -6694,6 +6694,16 @@ static inline void gen_##name(DisasContext *ctx)  =
             \
>  GEN_TM_PRIV_NOOP(treclaim);
>  GEN_TM_PRIV_NOOP(trechkpt);
> =20
> +static inline void get_fpr(TCGv_i64 dst, int regno)
> +{
> +    tcg_gen_mov_i64(dst, cpu_fpr[regno]);
> +}
> +
> +static inline void set_fpr(int regno, TCGv_i64 src)
> +{
> +    tcg_gen_mov_i64(cpu_fpr[regno], src);
> +}
> +
>  #include "translate/fp-impl.inc.c"
> =20
>  #include "translate/vmx-impl.inc.c"
> diff --git a/target/ppc/translate/fp-impl.inc.c b/target/ppc/translate/fp=
-impl.inc.c
> index 08770ba9f5..923fb7550f 100644
> --- a/target/ppc/translate/fp-impl.inc.c
> +++ b/target/ppc/translate/fp-impl.inc.c
> @@ -34,24 +34,39 @@ static void gen_set_cr1_from_fpscr(DisasContext *ctx)
>  #define _GEN_FLOAT_ACB(name, op, op1, op2, isfloat, set_fprf, type)     =
      \
>  static void gen_f##name(DisasContext *ctx)                              =
      \
>  {                                                                       =
      \
> +    TCGv_i64 t0;                                                        =
      \
> +    TCGv_i64 t1;                                                        =
      \
> +    TCGv_i64 t2;                                                        =
      \
> +    TCGv_i64 t3;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
> +    t1 =3D tcg_temp_new_i64();                                          =
        \
> +    t2 =3D tcg_temp_new_i64();                                          =
        \
> +    t3 =3D tcg_temp_new_i64();                                          =
        \
>      gen_reset_fpstatus();                                               =
      \
> -    gen_helper_f##op(cpu_fpr[rD(ctx->opcode)], cpu_env,                 =
      \
> -                     cpu_fpr[rA(ctx->opcode)],                          =
      \
> -                     cpu_fpr[rC(ctx->opcode)], cpu_fpr[rB(ctx->opcode)])=
;     \
> +    get_fpr(t0, rA(ctx->opcode));                                       =
      \
> +    get_fpr(t1, rC(ctx->opcode));                                       =
      \
> +    get_fpr(t2, rB(ctx->opcode));                                       =
      \
> +    gen_helper_f##op(t3, cpu_env, t0, t1, t2);                          =
      \
> +    set_fpr(rD(ctx->opcode), t3);                                       =
      \
>      if (isfloat) {                                                      =
      \
> -        gen_helper_frsp(cpu_fpr[rD(ctx->opcode)], cpu_env,              =
      \
> -                        cpu_fpr[rD(ctx->opcode)]);                      =
      \
> +        get_fpr(t0, rD(ctx->opcode));                                   =
      \
> +        gen_helper_frsp(t3, cpu_env, t0);                               =
      \
> +        set_fpr(rD(ctx->opcode), t3);                                   =
      \
>      }                                                                   =
      \
>      if (set_fprf) {                                                     =
      \
> -        gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);             =
      \
> +        gen_compute_fprf_float64(t3);                                   =
      \
>      }                                                                   =
      \
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {                             =
        \
>          gen_set_cr1_from_fpscr(ctx);                                    =
      \
>      }                                                                   =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
> +    tcg_temp_free_i64(t1);                                              =
      \
> +    tcg_temp_free_i64(t2);                                              =
      \
> +    tcg_temp_free_i64(t3);                                              =
      \
>  }
> =20
>  #define GEN_FLOAT_ACB(name, op2, set_fprf, type)                        =
      \
> @@ -61,24 +76,35 @@ _GEN_FLOAT_ACB(name##s, name, 0x3B, op2, 1, set_fprf,=
 type);
>  #define _GEN_FLOAT_AB(name, op, op1, op2, inval, isfloat, set_fprf, type=
)     \
>  static void gen_f##name(DisasContext *ctx)                              =
      \
>  {                                                                       =
      \
> +    TCGv_i64 t0;                                                        =
      \
> +    TCGv_i64 t1;                                                        =
      \
> +    TCGv_i64 t2;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
> +    t1 =3D tcg_temp_new_i64();                                          =
        \
> +    t2 =3D tcg_temp_new_i64();                                          =
        \
>      gen_reset_fpstatus();                                               =
      \
> -    gen_helper_f##op(cpu_fpr[rD(ctx->opcode)], cpu_env,                 =
      \
> -                     cpu_fpr[rA(ctx->opcode)],                          =
      \
> -                     cpu_fpr[rB(ctx->opcode)]);                         =
      \
> +    get_fpr(t0, rA(ctx->opcode));                                       =
      \
> +    get_fpr(t1, rB(ctx->opcode));                                       =
      \
> +    gen_helper_f##op(t2, cpu_env, t0, t1);                              =
      \
> +    set_fpr(rD(ctx->opcode), t2);                                       =
      \
>      if (isfloat) {                                                      =
      \
> -        gen_helper_frsp(cpu_fpr[rD(ctx->opcode)], cpu_env,              =
      \
> -                        cpu_fpr[rD(ctx->opcode)]);                      =
      \
> +        get_fpr(t0, rD(ctx->opcode));                                   =
      \
> +        gen_helper_frsp(t2, cpu_env, t0);                               =
      \
> +        set_fpr(rD(ctx->opcode), t2);                                   =
      \
>      }                                                                   =
      \
>      if (set_fprf) {                                                     =
      \
> -        gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);             =
      \
> +        gen_compute_fprf_float64(t2);                                   =
      \
>      }                                                                   =
      \
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {                             =
        \
>          gen_set_cr1_from_fpscr(ctx);                                    =
      \
>      }                                                                   =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
> +    tcg_temp_free_i64(t1);                                              =
      \
> +    tcg_temp_free_i64(t2);                                              =
      \
>  }
>  #define GEN_FLOAT_AB(name, op2, inval, set_fprf, type)                  =
      \
>  _GEN_FLOAT_AB(name, name, 0x3F, op2, inval, 0, set_fprf, type);         =
      \
> @@ -87,24 +113,35 @@ _GEN_FLOAT_AB(name##s, name, 0x3B, op2, inval, 1, se=
t_fprf, type);
>  #define _GEN_FLOAT_AC(name, op, op1, op2, inval, isfloat, set_fprf, type=
)     \
>  static void gen_f##name(DisasContext *ctx)                              =
      \
>  {                                                                       =
      \
> +    TCGv_i64 t0;                                                        =
      \
> +    TCGv_i64 t1;                                                        =
      \
> +    TCGv_i64 t2;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
> +    t1 =3D tcg_temp_new_i64();                                          =
        \
> +    t2 =3D tcg_temp_new_i64();                                          =
        \
>      gen_reset_fpstatus();                                               =
      \
> -    gen_helper_f##op(cpu_fpr[rD(ctx->opcode)], cpu_env,                 =
      \
> -                     cpu_fpr[rA(ctx->opcode)],                          =
      \
> -                     cpu_fpr[rC(ctx->opcode)]);                         =
      \
> +    get_fpr(t0, rA(ctx->opcode));                                       =
      \
> +    get_fpr(t1, rC(ctx->opcode));                                       =
      \
> +    gen_helper_f##op(t2, cpu_env, t0, t1);                              =
      \
> +    set_fpr(rD(ctx->opcode), t2);                                       =
      \
>      if (isfloat) {                                                      =
      \
> -        gen_helper_frsp(cpu_fpr[rD(ctx->opcode)], cpu_env,              =
      \
> -                        cpu_fpr[rD(ctx->opcode)]);                      =
      \
> +        get_fpr(t0, rD(ctx->opcode));                                   =
      \
> +        gen_helper_frsp(t2, cpu_env, t0);                               =
      \
> +        set_fpr(rD(ctx->opcode), t2);                                   =
      \
>      }                                                                   =
      \
>      if (set_fprf) {                                                     =
      \
> -        gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);             =
      \
> +        gen_compute_fprf_float64(t2);                                   =
      \
>      }                                                                   =
      \
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {                             =
        \
>          gen_set_cr1_from_fpscr(ctx);                                    =
      \
>      }                                                                   =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
> +    tcg_temp_free_i64(t1);                                              =
      \
> +    tcg_temp_free_i64(t2);                                              =
      \
>  }
>  #define GEN_FLOAT_AC(name, op2, inval, set_fprf, type)                  =
      \
>  _GEN_FLOAT_AC(name, name, 0x3F, op2, inval, 0, set_fprf, type);         =
      \
> @@ -113,37 +150,51 @@ _GEN_FLOAT_AC(name##s, name, 0x3B, op2, inval, 1, s=
et_fprf, type);
>  #define GEN_FLOAT_B(name, op2, op3, set_fprf, type)                     =
      \
>  static void gen_f##name(DisasContext *ctx)                              =
      \
>  {                                                                       =
      \
> +    TCGv_i64 t0;                                                        =
      \
> +    TCGv_i64 t1;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
> +    t1 =3D tcg_temp_new_i64();                                          =
        \
>      gen_reset_fpstatus();                                               =
      \
> -    gen_helper_f##name(cpu_fpr[rD(ctx->opcode)], cpu_env,               =
      \
> -                       cpu_fpr[rB(ctx->opcode)]);                       =
      \
> +    get_fpr(t0, rB(ctx->opcode));                                       =
      \
> +    gen_helper_f##name(t1, cpu_env, t0);                                =
      \
> +    set_fpr(rD(ctx->opcode), t1);                                       =
      \
>      if (set_fprf) {                                                     =
      \
> -        gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);             =
      \
> +        gen_compute_fprf_float64(t1);                                   =
      \
>      }                                                                   =
      \
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {                             =
        \
>          gen_set_cr1_from_fpscr(ctx);                                    =
      \
>      }                                                                   =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
> +    tcg_temp_free_i64(t1);                                              =
      \
>  }
> =20
>  #define GEN_FLOAT_BS(name, op1, op2, set_fprf, type)                    =
      \
>  static void gen_f##name(DisasContext *ctx)                              =
      \
>  {                                                                       =
      \
> +    TCGv_i64 t0;                                                        =
      \
> +    TCGv_i64 t1;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
> +    t1 =3D tcg_temp_new_i64();                                          =
        \
>      gen_reset_fpstatus();                                               =
      \
> -    gen_helper_f##name(cpu_fpr[rD(ctx->opcode)], cpu_env,               =
      \
> -                       cpu_fpr[rB(ctx->opcode)]);                       =
      \
> +    get_fpr(t0, rB(ctx->opcode));                                       =
      \
> +    gen_helper_f##name(t1, cpu_env, t0);                                =
      \
> +    set_fpr(rD(ctx->opcode), t1);                                       =
      \
>      if (set_fprf) {                                                     =
      \
> -        gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);             =
      \
> +        gen_compute_fprf_float64(t1);                                   =
      \
>      }                                                                   =
      \
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {                             =
        \
>          gen_set_cr1_from_fpscr(ctx);                                    =
      \
>      }                                                                   =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
> +    tcg_temp_free_i64(t1);                                              =
      \
>  }
> =20
>  /* fadd - fadds */
> @@ -165,19 +216,25 @@ GEN_FLOAT_BS(rsqrte, 0x3F, 0x1A, 1, PPC_FLOAT_FRSQR=
TE);
>  /* frsqrtes */
>  static void gen_frsqrtes(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
>      gen_reset_fpstatus();
> -    gen_helper_frsqrte(cpu_fpr[rD(ctx->opcode)], cpu_env,
> -                       cpu_fpr[rB(ctx->opcode)]);
> -    gen_helper_frsp(cpu_fpr[rD(ctx->opcode)], cpu_env,
> -                    cpu_fpr[rD(ctx->opcode)]);
> -    gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);
> +    get_fpr(t0, rB(ctx->opcode));
> +    gen_helper_frsqrte(t1, cpu_env, t0);
> +    set_fpr(rD(ctx->opcode), t1);
> +    gen_helper_frsp(t1, cpu_env, t1);
> +    gen_compute_fprf_float64(t1);
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* fsel */
> @@ -189,34 +246,47 @@ GEN_FLOAT_AB(sub, 0x14, 0x000007C0, 1, PPC_FLOAT);
>  /* fsqrt */
>  static void gen_fsqrt(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
>      gen_reset_fpstatus();
> -    gen_helper_fsqrt(cpu_fpr[rD(ctx->opcode)], cpu_env,
> -                     cpu_fpr[rB(ctx->opcode)]);
> -    gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);
> +    get_fpr(t0, rB(ctx->opcode));
> +    gen_helper_fsqrt(t1, cpu_env, t0);
> +    set_fpr(rD(ctx->opcode), t1);
> +    gen_compute_fprf_float64(t1);
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  static void gen_fsqrts(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
>      gen_reset_fpstatus();
> -    gen_helper_fsqrt(cpu_fpr[rD(ctx->opcode)], cpu_env,
> -                     cpu_fpr[rB(ctx->opcode)]);
> -    gen_helper_frsp(cpu_fpr[rD(ctx->opcode)], cpu_env,
> -                    cpu_fpr[rD(ctx->opcode)]);
> -    gen_compute_fprf_float64(cpu_fpr[rD(ctx->opcode)]);
> +    get_fpr(t0, rB(ctx->opcode));
> +    gen_helper_fsqrt(t1, cpu_env, t0);
> +    set_fpr(rD(ctx->opcode), t1);
> +    gen_helper_frsp(t1, cpu_env, t1);
> +    gen_compute_fprf_float64(t1);
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /***                     Floating-Point multiply-and-add                =
   ***/
> @@ -268,21 +338,32 @@ GEN_FLOAT_B(rim, 0x08, 0x0F, 1, PPC_FLOAT_EXT);
> =20
>  static void gen_ftdiv(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    gen_helper_ftdiv(cpu_crf[crfD(ctx->opcode)], cpu_fpr[rA(ctx->opcode)=
],
> -                     cpu_fpr[rB(ctx->opcode)]);
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rA(ctx->opcode));
> +    get_fpr(t1, rB(ctx->opcode));
> +    gen_helper_ftdiv(cpu_crf[crfD(ctx->opcode)], t0, t1);
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  static void gen_ftsqrt(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    gen_helper_ftsqrt(cpu_crf[crfD(ctx->opcode)], cpu_fpr[rB(ctx->opcode=
)]);
> +    t0 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    gen_helper_ftsqrt(cpu_crf[crfD(ctx->opcode)], t0);
> +    tcg_temp_free_i64(t0);
>  }
> =20
> =20
> @@ -293,32 +374,46 @@ static void gen_ftsqrt(DisasContext *ctx)
>  static void gen_fcmpo(DisasContext *ctx)
>  {
>      TCGv_i32 crf;
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
>      gen_reset_fpstatus();
>      crf =3D tcg_const_i32(crfD(ctx->opcode));
> -    gen_helper_fcmpo(cpu_env, cpu_fpr[rA(ctx->opcode)],
> -                     cpu_fpr[rB(ctx->opcode)], crf);
> +    get_fpr(t0, rA(ctx->opcode));
> +    get_fpr(t1, rB(ctx->opcode));
> +    gen_helper_fcmpo(cpu_env, t0, t1, crf);
>      tcg_temp_free_i32(crf);
>      gen_helper_float_check_status(cpu_env);
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* fcmpu */
>  static void gen_fcmpu(DisasContext *ctx)
>  {
>      TCGv_i32 crf;
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
>      gen_reset_fpstatus();
>      crf =3D tcg_const_i32(crfD(ctx->opcode));
> -    gen_helper_fcmpu(cpu_env, cpu_fpr[rA(ctx->opcode)],
> -                     cpu_fpr[rB(ctx->opcode)], crf);
> +    get_fpr(t0, rA(ctx->opcode));
> +    get_fpr(t1, rB(ctx->opcode));
> +    gen_helper_fcmpu(cpu_env, t0, t1, crf);
>      tcg_temp_free_i32(crf);
>      gen_helper_float_check_status(cpu_env);
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /***                         Floating-point move                        =
   ***/
> @@ -326,100 +421,153 @@ static void gen_fcmpu(DisasContext *ctx)
>  /* XXX: beware that fabs never checks for NaNs nor update FPSCR */
>  static void gen_fabs(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    tcg_gen_andi_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpr[rB(ctx->opcode)],
> -                     ~(1ULL << 63));
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    tcg_gen_andi_i64(t1, t0, ~(1ULL << 63));
> +    set_fpr(rD(ctx->opcode), t1);
>      if (unlikely(Rc(ctx->opcode))) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* fmr  - fmr. */
>  /* XXX: beware that fmr never checks for NaNs nor update FPSCR */
>  static void gen_fmr(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    tcg_gen_mov_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpr[rB(ctx->opcode)]);
> +    t0 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    set_fpr(rD(ctx->opcode), t0);
>      if (unlikely(Rc(ctx->opcode))) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* fnabs */
>  /* XXX: beware that fnabs never checks for NaNs nor update FPSCR */
>  static void gen_fnabs(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    tcg_gen_ori_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpr[rB(ctx->opcode)],
> -                    1ULL << 63);
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    tcg_gen_ori_i64(t1, t0, 1ULL << 63);
> +    set_fpr(rD(ctx->opcode), t1);
>      if (unlikely(Rc(ctx->opcode))) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* fneg */
>  /* XXX: beware that fneg never checks for NaNs nor update FPSCR */
>  static void gen_fneg(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    tcg_gen_xori_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpr[rB(ctx->opcode)],
> -                     1ULL << 63);
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    tcg_gen_xori_i64(t1, t0, 1ULL << 63);
> +    set_fpr(rD(ctx->opcode), t1);
>      if (unlikely(Rc(ctx->opcode))) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* fcpsgn: PowerPC 2.05 specification */
>  /* XXX: beware that fcpsgn never checks for NaNs nor update FPSCR */
>  static void gen_fcpsgn(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
> +    TCGv_i64 t2;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    tcg_gen_deposit_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpr[rA(ctx->opcode=
)],
> -                        cpu_fpr[rB(ctx->opcode)], 0, 63);
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    t2 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rA(ctx->opcode));
> +    get_fpr(t1, rB(ctx->opcode));
> +    tcg_gen_deposit_i64(t2, t0, t1, 0, 63);
> +    set_fpr(rD(ctx->opcode), t2);
>      if (unlikely(Rc(ctx->opcode))) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
> +    tcg_temp_free_i64(t2);
>  }
> =20
>  static void gen_fmrgew(DisasContext *ctx)
>  {
>      TCGv_i64 b0;
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
>      b0 =3D tcg_temp_new_i64();
> -    tcg_gen_shri_i64(b0, cpu_fpr[rB(ctx->opcode)], 32);
> -    tcg_gen_deposit_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpr[rA(ctx->opcode=
)],
> -                        b0, 0, 32);
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    tcg_gen_shri_i64(b0, t0, 32);
> +    get_fpr(t0, rA(ctx->opcode));
> +    tcg_gen_deposit_i64(t1, t0, b0, 0, 32);
> +    set_fpr(rD(ctx->opcode), t1);
>      tcg_temp_free_i64(b0);
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  static void gen_fmrgow(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
> +    TCGv_i64 t1;
> +    TCGv_i64 t2;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> -    tcg_gen_deposit_i64(cpu_fpr[rD(ctx->opcode)],
> -                        cpu_fpr[rB(ctx->opcode)],
> -                        cpu_fpr[rA(ctx->opcode)],
> -                        32, 32);
> +    t0 =3D tcg_temp_new_i64();
> +    t1 =3D tcg_temp_new_i64();
> +    t2 =3D tcg_temp_new_i64();
> +    get_fpr(t0, rB(ctx->opcode));
> +    get_fpr(t1, rA(ctx->opcode));
> +    tcg_gen_deposit_i64(t2, t0, t1, 32, 32);
> +    set_fpr(rD(ctx->opcode), t2);
> +    tcg_temp_free_i64(t0);
> +    tcg_temp_free_i64(t1);
> +    tcg_temp_free_i64(t2);
>  }
> =20
>  /***                  Floating-Point status & ctrl register             =
   ***/
> @@ -458,15 +606,19 @@ static void gen_mcrfs(DisasContext *ctx)
>  /* mffs */
>  static void gen_mffs(DisasContext *ctx)
>  {
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
> +    t0 =3D tcg_temp_new_i64();
>      gen_reset_fpstatus();
> -    tcg_gen_extu_tl_i64(cpu_fpr[rD(ctx->opcode)], cpu_fpscr);
> +    tcg_gen_extu_tl_i64(t0, cpu_fpscr);
> +    set_fpr(rD(ctx->opcode), t0);
>      if (unlikely(Rc(ctx->opcode))) {
>          gen_set_cr1_from_fpscr(ctx);
>      }
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* mtfsb0 */
> @@ -522,6 +674,7 @@ static void gen_mtfsb1(DisasContext *ctx)
>  static void gen_mtfsf(DisasContext *ctx)
>  {
>      TCGv_i32 t0;
> +    TCGv_i64 t1;
>      int flm, l, w;
> =20
>      if (unlikely(!ctx->fpu_enabled)) {
> @@ -541,7 +694,9 @@ static void gen_mtfsf(DisasContext *ctx)
>      } else {
>          t0 =3D tcg_const_i32(flm << (w * 8));
>      }
> -    gen_helper_store_fpscr(cpu_env, cpu_fpr[rB(ctx->opcode)], t0);
> +    t1 =3D tcg_temp_new_i64();
> +    get_fpr(t1, rB(ctx->opcode));
> +    gen_helper_store_fpscr(cpu_env, t1, t0);
>      tcg_temp_free_i32(t0);
>      if (unlikely(Rc(ctx->opcode) !=3D 0)) {
>          tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);
> @@ -549,6 +704,7 @@ static void gen_mtfsf(DisasContext *ctx)
>      }
>      /* We can raise a differed exception */
>      gen_helper_float_check_status(cpu_env);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* mtfsfi */
> @@ -588,21 +744,26 @@ static void gen_mtfsfi(DisasContext *ctx)
>  static void glue(gen_, name)(DisasContext *ctx)                         =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_imm_index(ctx, EA, 0);                                     =
      \
> -    gen_qemu_##ldop(ctx, cpu_fpr[rD(ctx->opcode)], EA);                 =
      \
> +    gen_qemu_##ldop(ctx, t0, EA);                                       =
      \
> +    set_fpr(rD(ctx->opcode), t0);                                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_LDUF(name, ldop, opc, type)                                 =
      \
>  static void glue(gen_, name##u)(DisasContext *ctx)                      =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
> @@ -613,20 +774,25 @@ static void glue(gen_, name##u)(DisasContext *ctx)
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_imm_index(ctx, EA, 0);                                     =
      \
> -    gen_qemu_##ldop(ctx, cpu_fpr[rD(ctx->opcode)], EA);                 =
      \
> +    gen_qemu_##ldop(ctx, t0, EA);                                       =
      \
> +    set_fpr(rD(ctx->opcode), t0);                                       =
      \
>      tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_LDUXF(name, ldop, opc, type)                                =
      \
>  static void glue(gen_, name##ux)(DisasContext *ctx)                     =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      if (unlikely(rA(ctx->opcode) =3D=3D 0)) {                           =
          \
>          gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);             =
      \
>          return;                                                         =
      \
> @@ -634,24 +800,30 @@ static void glue(gen_, name##ux)(DisasContext *ctx)
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
>      gen_addr_reg_index(ctx, EA);                                        =
      \
> -    gen_qemu_##ldop(ctx, cpu_fpr[rD(ctx->opcode)], EA);                 =
      \
> +    gen_qemu_##ldop(ctx, t0, EA);                                       =
      \
> +    set_fpr(rD(ctx->opcode), t0);                                       =
      \
>      tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_LDXF(name, ldop, opc2, opc3, type)                          =
      \
>  static void glue(gen_, name##x)(DisasContext *ctx)                      =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_reg_index(ctx, EA);                                        =
      \
> -    gen_qemu_##ldop(ctx, cpu_fpr[rD(ctx->opcode)], EA);                 =
      \
> +    gen_qemu_##ldop(ctx, t0, EA);                                       =
      \
> +    set_fpr(rD(ctx->opcode), t0);                                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_LDFS(name, ldop, op, type)                                  =
      \
> @@ -677,6 +849,7 @@ GEN_LDFS(lfs, ld32fs, 0x10, PPC_FLOAT);
>  static void gen_lfdepx(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      CHK_SV;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
> @@ -684,16 +857,19 @@ static void gen_lfdepx(DisasContext *ctx)
>      }
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
> +    t0 =3D tcg_temp_new_i64();
>      gen_addr_reg_index(ctx, EA);
> -    tcg_gen_qemu_ld_i64(cpu_fpr[rD(ctx->opcode)], EA, PPC_TLB_EPID_LOAD,
> -        DEF_MEMOP(MO_Q));
> +    tcg_gen_qemu_ld_i64(t0, EA, PPC_TLB_EPID_LOAD, DEF_MEMOP(MO_Q));
> +    set_fpr(rD(ctx->opcode), t0);
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* lfdp */
>  static void gen_lfdp(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
> @@ -701,24 +877,31 @@ static void gen_lfdp(DisasContext *ctx)
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
>      gen_addr_imm_index(ctx, EA, 0);
> +    t0 =3D tcg_temp_new_i64();
>      /* We only need to swap high and low halves. gen_qemu_ld64_i64 does
>         necessary 64-bit byteswap already. */
>      if (unlikely(ctx->le_mode)) {
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode) + 1, t0);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode), t0);
>      } else {
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode), t0);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode) + 1, t0);
>      }
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* lfdpx */
>  static void gen_lfdpx(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
> @@ -726,18 +909,24 @@ static void gen_lfdpx(DisasContext *ctx)
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
>      gen_addr_reg_index(ctx, EA);
> +    t0 =3D tcg_temp_new_i64();
>      /* We only need to swap high and low halves. gen_qemu_ld64_i64 does
>         necessary 64-bit byteswap already. */
>      if (unlikely(ctx->le_mode)) {
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode) + 1, t0);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode), t0);
>      } else {
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode), t0);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_ld64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        gen_qemu_ld64_i64(ctx, t0, EA);
> +        set_fpr(rD(ctx->opcode) + 1, t0);
>      }
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* lfiwax */
> @@ -745,6 +934,7 @@ static void gen_lfiwax(DisasContext *ctx)
>  {
>      TCGv EA;
>      TCGv t0;
> +    TCGv_i64 t1;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
> @@ -752,47 +942,59 @@ static void gen_lfiwax(DisasContext *ctx)
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
>      t0 =3D tcg_temp_new();
> +    t1 =3D tcg_temp_new_i64();
>      gen_addr_reg_index(ctx, EA);
>      gen_qemu_ld32s(ctx, t0, EA);
> -    tcg_gen_ext_tl_i64(cpu_fpr[rD(ctx->opcode)], t0);
> +    tcg_gen_ext_tl_i64(t1, t0);
> +    set_fpr(rD(ctx->opcode), t1);
>      tcg_temp_free(EA);
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* lfiwzx */
>  static void gen_lfiwzx(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
> +    t0 =3D tcg_temp_new_i64();
>      gen_addr_reg_index(ctx, EA);
> -    gen_qemu_ld32u_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +    gen_qemu_ld32u_i64(ctx, t0, EA);
> +    set_fpr(rD(ctx->opcode), t0);
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
>  /***                         Floating-point store                       =
   ***/
>  #define GEN_STF(name, stop, opc, type)                                  =
      \
>  static void glue(gen_, name)(DisasContext *ctx)                         =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_imm_index(ctx, EA, 0);                                     =
      \
> -    gen_qemu_##stop(ctx, cpu_fpr[rS(ctx->opcode)], EA);                 =
      \
> +    get_fpr(t0, rS(ctx->opcode));                                       =
      \
> +    gen_qemu_##stop(ctx, t0, EA);                                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_STUF(name, stop, opc, type)                                 =
      \
>  static void glue(gen_, name##u)(DisasContext *ctx)                      =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
> @@ -803,16 +1005,20 @@ static void glue(gen_, name##u)(DisasContext *ctx)
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_imm_index(ctx, EA, 0);                                     =
      \
> -    gen_qemu_##stop(ctx, cpu_fpr[rS(ctx->opcode)], EA);                 =
      \
> +    get_fpr(t0, rS(ctx->opcode));                                       =
      \
> +    gen_qemu_##stop(ctx, t0, EA);                                       =
      \
>      tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_STUXF(name, stop, opc, type)                                =
      \
>  static void glue(gen_, name##ux)(DisasContext *ctx)                     =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
> @@ -823,25 +1029,32 @@ static void glue(gen_, name##ux)(DisasContext *ctx)
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_reg_index(ctx, EA);                                        =
      \
> -    gen_qemu_##stop(ctx, cpu_fpr[rS(ctx->opcode)], EA);                 =
      \
> +    get_fpr(t0, rS(ctx->opcode));                                       =
      \
> +    gen_qemu_##stop(ctx, t0, EA);                                       =
      \
>      tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], EA);                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_STXF(name, stop, opc2, opc3, type)                          =
      \
>  static void glue(gen_, name##x)(DisasContext *ctx)                      =
              \
>  {                                                                       =
      \
>      TCGv EA;                                                            =
      \
> +    TCGv_i64 t0;                                                        =
      \
>      if (unlikely(!ctx->fpu_enabled)) {                                  =
      \
>          gen_exception(ctx, POWERPC_EXCP_FPU);                           =
      \
>          return;                                                         =
      \
>      }                                                                   =
      \
>      gen_set_access_type(ctx, ACCESS_FLOAT);                             =
      \
>      EA =3D tcg_temp_new();                                              =
        \
> +    t0 =3D tcg_temp_new_i64();                                          =
        \
>      gen_addr_reg_index(ctx, EA);                                        =
      \
> -    gen_qemu_##stop(ctx, cpu_fpr[rS(ctx->opcode)], EA);                 =
      \
> +    get_fpr(t0, rS(ctx->opcode));                                       =
      \
> +    gen_qemu_##stop(ctx, t0, EA);                                       =
      \
>      tcg_temp_free(EA);                                                  =
      \
> +    tcg_temp_free_i64(t0);                                              =
      \
>  }
> =20
>  #define GEN_STFS(name, stop, op, type)                                  =
      \
> @@ -867,6 +1080,7 @@ GEN_STFS(stfs, st32fs, 0x14, PPC_FLOAT);
>  static void gen_stfdepx(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      CHK_SV;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
> @@ -874,60 +1088,76 @@ static void gen_stfdepx(DisasContext *ctx)
>      }
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
> +    t0 =3D tcg_temp_new_i64();
>      gen_addr_reg_index(ctx, EA);
> -    tcg_gen_qemu_st_i64(cpu_fpr[rD(ctx->opcode)], EA, PPC_TLB_EPID_STORE,
> -                       DEF_MEMOP(MO_Q));
> +    get_fpr(t0, rD(ctx->opcode));
> +    tcg_gen_qemu_st_i64(t0, EA, PPC_TLB_EPID_STORE, DEF_MEMOP(MO_Q));
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* stfdp */
>  static void gen_stfdp(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
> +    t0 =3D tcg_temp_new_i64();
>      gen_addr_imm_index(ctx, EA, 0);
>      /* We only need to swap high and low halves. gen_qemu_st64_i64 does
>         necessary 64-bit byteswap already. */
>      if (unlikely(ctx->le_mode)) {
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        get_fpr(t0, rD(ctx->opcode) + 1);
> +        gen_qemu_st64_i64(ctx, t0, EA);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        get_fpr(t0, rD(ctx->opcode));
> +        gen_qemu_st64_i64(ctx, t0, EA);
>      } else {
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        get_fpr(t0, rD(ctx->opcode));
> +        gen_qemu_st64_i64(ctx, t0, EA);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        get_fpr(t0, rD(ctx->opcode) + 1);
> +        gen_qemu_st64_i64(ctx, t0, EA);
>      }
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* stfdpx */
>  static void gen_stfdpx(DisasContext *ctx)
>  {
>      TCGv EA;
> +    TCGv_i64 t0;
>      if (unlikely(!ctx->fpu_enabled)) {
>          gen_exception(ctx, POWERPC_EXCP_FPU);
>          return;
>      }
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      EA =3D tcg_temp_new();
> +    t0 =3D tcg_temp_new_i64();
>      gen_addr_reg_index(ctx, EA);
>      /* We only need to swap high and low halves. gen_qemu_st64_i64 does
>         necessary 64-bit byteswap already. */
>      if (unlikely(ctx->le_mode)) {
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        get_fpr(t0, rD(ctx->opcode) + 1);
> +        gen_qemu_st64_i64(ctx, t0, EA);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        get_fpr(t0, rD(ctx->opcode));
> +        gen_qemu_st64_i64(ctx, t0, EA);
>      } else {
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode)], EA);
> +        get_fpr(t0, rD(ctx->opcode));
> +        gen_qemu_st64_i64(ctx, t0, EA);
>          tcg_gen_addi_tl(EA, EA, 8);
> -        gen_qemu_st64_i64(ctx, cpu_fpr[rD(ctx->opcode) + 1], EA);
> +        get_fpr(t0, rD(ctx->opcode) + 1);
> +        gen_qemu_st64_i64(ctx, t0, EA);
>      }
>      tcg_temp_free(EA);
> +    tcg_temp_free_i64(t0);
>  }
> =20
>  /* Optional: */
> @@ -949,13 +1179,18 @@ static void gen_lfq(DisasContext *ctx)
>  {
>      int rd =3D rD(ctx->opcode);
>      TCGv t0;
> +    TCGv_i64 t1;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      t0 =3D tcg_temp_new();
> +    t1 =3D tcg_temp_new_i64();
>      gen_addr_imm_index(ctx, t0, 0);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[rd], t0);
> +    gen_qemu_ld64_i64(ctx, t1, t0);
> +    set_fpr(rd, t1);
>      gen_addr_add(ctx, t0, t0, 8);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[(rd + 1) % 32], t0);
> +    gen_qemu_ld64_i64(ctx, t1, t0);
> +    set_fpr((rd + 1) % 32, t1);
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* lfqu */
> @@ -964,17 +1199,22 @@ static void gen_lfqu(DisasContext *ctx)
>      int ra =3D rA(ctx->opcode);
>      int rd =3D rD(ctx->opcode);
>      TCGv t0, t1;
> +    TCGv_i64 t2;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      t0 =3D tcg_temp_new();
>      t1 =3D tcg_temp_new();
> +    t2 =3D tcg_temp_new_i64();
>      gen_addr_imm_index(ctx, t0, 0);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[rd], t0);
> +    gen_qemu_ld64_i64(ctx, t2, t0);
> +    set_fpr(rd, t2);
>      gen_addr_add(ctx, t1, t0, 8);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[(rd + 1) % 32], t1);
> +    gen_qemu_ld64_i64(ctx, t2, t1);
> +    set_fpr((rd + 1) % 32, t2);
>      if (ra !=3D 0)
>          tcg_gen_mov_tl(cpu_gpr[ra], t0);
>      tcg_temp_free(t0);
>      tcg_temp_free(t1);
> +    tcg_temp_free_i64(t2);
>  }
> =20
>  /* lfqux */
> @@ -984,16 +1224,21 @@ static void gen_lfqux(DisasContext *ctx)
>      int rd =3D rD(ctx->opcode);
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      TCGv t0, t1;
> +    TCGv_i64 t2;
> +    t2 =3D tcg_temp_new_i64();
>      t0 =3D tcg_temp_new();
>      gen_addr_reg_index(ctx, t0);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[rd], t0);
> +    gen_qemu_ld64_i64(ctx, t2, t0);
> +    set_fpr(rd, t2);
>      t1 =3D tcg_temp_new();
>      gen_addr_add(ctx, t1, t0, 8);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[(rd + 1) % 32], t1);
> +    gen_qemu_ld64_i64(ctx, t2, t1);
> +    set_fpr((rd + 1) % 32, t2);
>      tcg_temp_free(t1);
>      if (ra !=3D 0)
>          tcg_gen_mov_tl(cpu_gpr[ra], t0);
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t2);
>  }
> =20
>  /* lfqx */
> @@ -1001,13 +1246,18 @@ static void gen_lfqx(DisasContext *ctx)
>  {
>      int rd =3D rD(ctx->opcode);
>      TCGv t0;
> +    TCGv_i64 t1;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      t0 =3D tcg_temp_new();
> +    t1 =3D tcg_temp_new_i64();
>      gen_addr_reg_index(ctx, t0);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[rd], t0);
> +    gen_qemu_ld64_i64(ctx, t1, t0);
> +    set_fpr(rd, t1);
>      gen_addr_add(ctx, t0, t0, 8);
> -    gen_qemu_ld64_i64(ctx, cpu_fpr[(rd + 1) % 32], t0);
> +    gen_qemu_ld64_i64(ctx, t1, t0);
> +    set_fpr((rd + 1) % 32, t1);
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* stfq */
> @@ -1015,13 +1265,18 @@ static void gen_stfq(DisasContext *ctx)
>  {
>      int rd =3D rD(ctx->opcode);
>      TCGv t0;
> +    TCGv_i64 t1;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
>      t0 =3D tcg_temp_new();
> +    t1 =3D tcg_temp_new_i64();
>      gen_addr_imm_index(ctx, t0, 0);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[rd], t0);
> +    get_fpr(t1, rd);
> +    gen_qemu_st64_i64(ctx, t1, t0);
>      gen_addr_add(ctx, t0, t0, 8);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[(rd + 1) % 32], t0);
> +    get_fpr(t1, (rd + 1) % 32);
> +    gen_qemu_st64_i64(ctx, t1, t0);
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  /* stfqu */
> @@ -1030,17 +1285,23 @@ static void gen_stfqu(DisasContext *ctx)
>      int ra =3D rA(ctx->opcode);
>      int rd =3D rD(ctx->opcode);
>      TCGv t0, t1;
> +    TCGv_i64 t2;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
> +    t2 =3D tcg_temp_new_i64();
>      t0 =3D tcg_temp_new();
>      gen_addr_imm_index(ctx, t0, 0);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[rd], t0);
> +    get_fpr(t2, rd);
> +    gen_qemu_st64_i64(ctx, t2, t0);
>      t1 =3D tcg_temp_new();
>      gen_addr_add(ctx, t1, t0, 8);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[(rd + 1) % 32], t1);
> +    get_fpr(t2, (rd + 1) % 32);
> +    gen_qemu_st64_i64(ctx, t2, t1);
>      tcg_temp_free(t1);
> -    if (ra !=3D 0)
> +    if (ra !=3D 0) {
>          tcg_gen_mov_tl(cpu_gpr[ra], t0);
> +    }
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t2);
>  }
> =20
>  /* stfqux */
> @@ -1049,17 +1310,23 @@ static void gen_stfqux(DisasContext *ctx)
>      int ra =3D rA(ctx->opcode);
>      int rd =3D rD(ctx->opcode);
>      TCGv t0, t1;
> +    TCGv_i64 t2;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
> +    t2 =3D tcg_temp_new_i64();
>      t0 =3D tcg_temp_new();
>      gen_addr_reg_index(ctx, t0);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[rd], t0);
> +    get_fpr(t2, rd);
> +    gen_qemu_st64_i64(ctx, t2, t0);
>      t1 =3D tcg_temp_new();
>      gen_addr_add(ctx, t1, t0, 8);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[(rd + 1) % 32], t1);
> +    get_fpr(t2, (rd + 1) % 32);
> +    gen_qemu_st64_i64(ctx, t2, t1);
>      tcg_temp_free(t1);
> -    if (ra !=3D 0)
> +    if (ra !=3D 0) {
>          tcg_gen_mov_tl(cpu_gpr[ra], t0);
> +    }
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t2);
>  }
> =20
>  /* stfqx */
> @@ -1067,13 +1334,18 @@ static void gen_stfqx(DisasContext *ctx)
>  {
>      int rd =3D rD(ctx->opcode);
>      TCGv t0;
> +    TCGv_i64 t1;
>      gen_set_access_type(ctx, ACCESS_FLOAT);
> +    t1 =3D tcg_temp_new_i64();
>      t0 =3D tcg_temp_new();
>      gen_addr_reg_index(ctx, t0);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[rd], t0);
> +    get_fpr(t1, rd);
> +    gen_qemu_st64_i64(ctx, t1, t0);
>      gen_addr_add(ctx, t0, t0, 8);
> -    gen_qemu_st64_i64(ctx, cpu_fpr[(rd + 1) % 32], t0);
> +    get_fpr(t1, (rd + 1) % 32);
> +    gen_qemu_st64_i64(ctx, t1, t0);
>      tcg_temp_free(t0);
> +    tcg_temp_free_i64(t1);
>  }
> =20
>  #undef _GEN_FLOAT_ACB

--=20
David Gibson			| I'll have my music baroque, and my code
david AT gibson.dropbear.id.au	| minimalist, thank you.  NOT _the_ _other_
				| _way_ _around_!
http://www.ozlabs.org/~dgibson

--pwWdILMQNxDD/Cps
Content-Type: application/pgp-signature; name="signature.asc"

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEdfRlhq5hpmzETofcbDjKyiDZs5IFAlwN9uUACgkQbDjKyiDZ
s5LEtBAAyVDU40oX12NeKWV5L+rKNkRGuEuWBX72ytTgxIZrFhzxJEOFbXZdWmfg
IH8JXAyhQE6tNQaaIUY+gDVBZQevn31+87bunfOvH2fBLxE9Wq7JM7Jee9FO+5UZ
A95+J0u3Ucap2yrFRAcRaRedAm34rMabKh2rMhXdfGWBnSsQow/isegJvrp7bpiS
6qi7nYje2rzgqGYtbjm9uZnhnD4IE3IfedjiJzDxbUvbgfGeXQNr1xTl2yU8vi+o
E+HUPNUG+EQG5eGzPGyIoCOotLCxAF1p9VKPpG6gaYLGfZR0QQWhBwbTR4FnbsDc
xAN9gamMGyR+WOv188tyI1tWk2or7ESNp9uUFYUiDNUpAR7uFP2XjHmXxC4U0dk1
K6CH7JKFd3rp4nNQTx/5uND1zsGnz2OpOlCrW1NJPtoeF4dOh6i/KAkXuXJxpeh/
PGniVXBm8gGHTYorWxQJjIlj4AEzEXqjW8y28TjscHrl1TctDSycY3fYv2MB9ATs
GT31QlgaHIAi9tetZIuZCnqdR3cnqU/oAGWjfHYzjl3gAne0DUs2Eu7YYLctybzH
gcOxiFTTY6AW8CwRD7gW5w2OiMH5BcgtCmqDpRQddydHxM4eaRbn8GGtYf1//ZgR
rAfKHn9Nt2KUe+D+wgRvSm6R+LwV1AISz2UbCssaMhYEVTtsY+o=
=NLDq
-----END PGP SIGNATURE-----

--pwWdILMQNxDD/Cps--

