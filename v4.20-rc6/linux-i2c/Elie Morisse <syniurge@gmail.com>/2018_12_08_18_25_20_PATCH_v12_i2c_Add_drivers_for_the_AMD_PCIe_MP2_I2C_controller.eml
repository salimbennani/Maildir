Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 09 Dec 2018 18:56:50 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 08A4A5803DC;
	Sat,  8 Dec 2018 10:25:38 -0800 (PST)
Received: from fmsmga104.fm.intel.com ([10.1.193.100])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 08 Dec 2018 10:25:37 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AMexdeByqeeSnwxvXCy+O+j09IxM/srCxBDY+r6Qd?=
 =?us-ascii?q?0eweLPad9pjvdHbS+e9qxAeQG9mDu7Qc06L/iOPJYSQ4+5GPsXQPItRndiQuro?=
 =?us-ascii?q?EopTEmG9OPEkbhLfTnPGQQFcVGU0J5rTngaRAGUMnxaEfPrXKs8DUcBgvwNRZv?=
 =?us-ascii?q?JuTyB4Xek9m72/q99pHPYAhEniaxba9vJxiqsAvdsdUbj5F/Iagr0BvJpXVIe+?=
 =?us-ascii?q?VSxWx2IF+Yggjx6MSt8pN96ipco/0u+dJOXqX8ZKQ4UKdXDC86PGAv5c3krgfM?=
 =?us-ascii?q?QA2S7XYBSGoWkx5IAw/Y7BHmW5r6ryX3uvZh1CScIMb7Vq4/Vyi84Kh3SR/okC?=
 =?us-ascii?q?YHOCA/8GHLkcx7kaZXrAu8qxBj34LYZYeYP+d8cKzAZ9MXXWRPUMZPWSJcAY2z?=
 =?us-ascii?q?YJcAAPcPMuZDt4nwpUADrQeiCQS2GO/j1iVFimHw0KYn0+ohCwbG3Ak4EtwBtH?=
 =?us-ascii?q?TUrcv6P7oVX+Cy1qnIzC7Db+hI1jzg74XIaRAgofeNXbJta8rRxlcgGhjKjlWV?=
 =?us-ascii?q?s4PlPjeV2v4RvGic6uptTOSigHMppQF2pzig3MYsio/Ri4IW1F/E7yN5z5gxJd?=
 =?us-ascii?q?GiT057e9GkHINLtyGCNot2RMIiTH1zuCogzL0Jp4K7cDANyJUmwx7QceeIc5OS?=
 =?us-ascii?q?7hLkTuaRLjF1j29mdrKnnxu+71Ssx+nmWsWp3ltGsDBJnsTPu3wRzRDe68qKRu?=
 =?us-ascii?q?N+80u9wzqDyh7f5vtZLU07l6fXMZ4sz7o2m5EOq0rMBDX2l1/zjKKOdkUr5Oyo?=
 =?us-ascii?q?6+P/b7X4qZ+TKZV0hhv9MqswgMy/B/o3MgwUU2ic4+S826Xv/Uz/QLpUkv07ir?=
 =?us-ascii?q?fVvIzeKMgBu6K0DRFZ3pw+5xu8EzuqytUVkHsfIFJAYh2HjozpO1/UIPD/CPey?=
 =?us-ascii?q?m1CskDZtx/DbMbztG5bNIWbZkLfnY7l971dQyA09zNBZ+Z1UEKoMIOz8WkDvrt?=
 =?us-ascii?q?zUFBw5PBKuw+bhFtp90pkSWWWVAq+WKK/Sq0OH5vozI+mQY48YoDL9K/km5/Hw?=
 =?us-ascii?q?l3M4lkIdcLKt3ZsWbnC4A/tnL1+YYXrqntcOD2MKshAiQ+ztjV2ISSRTaGqqX6?=
 =?us-ascii?q?Ig+jE7D5qrDYfZSYCsnLyOxiC7EodWZmBbEF+MF3joep6AW/cNbiKSP8BgniYF?=
 =?us-ascii?q?VbinV48uyxWuuBXmxLpgK+re4jcYuo771Nhp++3Tkgk/9T5zD8uDyW2NTGZ0nm?=
 =?us-ascii?q?UORz8xx61/pU19ylGe0al3mfBYFNpT5+9XXQc+L5LT0+t6C9XqUALbYtiJUEqm?=
 =?us-ascii?q?QsmhATwpVN0x2N8OY0F+G9m4lBDMxSiqDqQRl7yKApw0763d02LwJ8Z713bJyq?=
 =?us-ascii?q?0hg0M6TctIMG2snrR/+BTLB47Vj0WZkL6ndacG0y7L7muDyWuOs1teUA5/SqjF?=
 =?us-ascii?q?WXEfZk3LrdX2/E/CTrmuCag5PQtF08KNNqxKatjxh1VcWPjjIMjeY362m2qoGB?=
 =?us-ascii?q?mH3K2MY5Twd2UdxirdDlMEnB4V/XqBMQg+BSKho2bFATxqFFLvZV7s8OZkpHO6?=
 =?us-ascii?q?SE800x+Fb0l727Wp/R4VgOSWS+kP0bIcpCchtzJ0EU6g0N3MFdqPuRBtfKVGbt?=
 =?us-ascii?q?M7+1dIy2TZuhd5PpyhKaBim1Effx52v0PoyxV4FIFAndI2o3MtyQp4MbiY309Z?=
 =?us-ascii?q?dzOEwZDwPaXaKnXz/BCqbK7WxlHe0daM9qcT8vg4rE/jvAWoFkok/HVqyN1V03?=
 =?us-ascii?q?qa5pXXAwseS5PxUkAr9xdko7HWeDUy54TR1Xd0K6m7rifC2841BOsi0huvZdNf?=
 =?us-ascii?q?P72LFQDsE8wWHdOhKPE3lFezaBIEP+dS9LAvMsOidvuG3rOrPel6kDKni2RH/J?=
 =?us-ascii?q?5y0kaW+yVgTe7I2o4Pw+uE0QufSzf8kFChv9j3mIBZfz0dAnCzyCnkBIFLYK1y?=
 =?us-ascii?q?cp0GCWOvI82x29V/iIThW39e9F6/GVwG3NWldgaVb1z4xQdQz1gYoWS7mSukyD?=
 =?us-ascii?q?x5iysprquD0yPU2eTtaR0HNnRNRGZ8l1fsIJG4gMwAU0iscgcmigGl5UH8x6VA?=
 =?us-ascii?q?oKR/Lm/TQVpHfiTsLmFiVLewuaSGY8JV9JwotiBXWvymYV+GUr79vwca0yT7Em?=
 =?us-ascii?q?pexTA3bTGrto/inxxnjmKQN3JzrHvfecFtyhbT/t3cRfhN3jUYQCl0kyXYBl+5?=
 =?us-ascii?q?P9Ox59Wbi4/DsvyiV2KmTpBTczPkzZmDtCu44m1mGwa/kOqwmt3kEAg61zH019?=
 =?us-ascii?q?9xWCXMrRb8ZJTr1qugPeJmeEloGEHz685gFo5ilYswgYka2WIGiZWN4XoHjWDz?=
 =?us-ascii?q?PM1b2K3ka3oBXzwLw9/T4AX+3E1jL3SJx5/2V3mHw8thYcW6bX0S2i4n889KD6?=
 =?us-ascii?q?KU5qRenSRpulq4sR7RYf9lkzce0/Qu6WQWg+EUuAU3yCWdDasfHU1ZPSzqihSJ?=
 =?us-ascii?q?4MqyrKRRZGazb7ew0FByksymDLGHugtcQmr2eo8+HS9s6cVyKFfM0Hzw6o7+Yt?=
 =?us-ascii?q?XRY8wctgaIkxjelehaM4w+luAFhSd8PWL9vHsly/M0jBB03JG6upSHJHtp/K6j?=
 =?us-ascii?q?HhFYMTj1bdsJ+j7xlaZegtqW34e3E5V9HTULWYHkTPOyHzIUqPTnLB2OEDwnp3?=
 =?us-ascii?q?efGLrfGxKf6Uh8o3LOFZCrK2+YJH0Dwdp+QxmdIVRVgBoIUzUigp45CgeqydT6?=
 =?us-ascii?q?f0hj4TAR4kP4pgFIyuJ1LBT/VmbfpAG1ajY7UpSfLRxW7h1c6EfRK8CR8uVzHy?=
 =?us-ascii?q?RA9J27sAONMnCbZxhPDWwRWEyLHVXjMae15dXa7+iUHOm+L+bNYbWTr+xRTeyI?=
 =?us-ascii?q?yImr0otn+TaMK8qOMmNjD/09xkpMQ3R5F97FlDUITiwdjzjNYNKDpBeg5i13qd?=
 =?us-ascii?q?iy8fTsWALy/IuPFqFdMdN19xCthqeDMeGQiT19KTZZ0JMM2HDJxKIe3F4UlyFh?=
 =?us-ascii?q?aT2tHa4cui7KSaLagrVXAAIDayNvKMtI6Lox3glTNs7aidP11b94guQ2C1dfUl?=
 =?us-ascii?q?zhld+mZdYXI2GmL17HAEeLNLKbJTzE2c33YKW8SaFOg+VQrRG/pTGbE0r7NDSZ?=
 =?us-ascii?q?izbpTwyvMf1LjCyDJhNepZqycgxzBmnjVt7mbhy7PcRzjT03x700m3zLOXQdMT?=
 =?us-ascii?q?h6b0NCsLmQ4TlEjfV4HmxL9mBlIvWcmyaF8+nYLY4bsedqAiRxje5V/G42xKdV?=
 =?us-ascii?q?7C5aQvx4gy/Srt9oo1G7neiD0DtnUBxSqjlVgIKHp1ltOaLc9pNYQ3bL4AoN7X?=
 =?us-ascii?q?mMCxQNv9ZkCsfgu6ZVytjOkqL8MDZD89LO8ssaCMjZM8aHMHsnMRr0Fz/YFgoF?=
 =?us-ascii?q?TTi3NW7Bg0xRiu2d9nqQrstylp+5nJsIV68eVQY+Pu0VB14jH9EYJppzGDQ+nv?=
 =?us-ascii?q?rTs8kM62C3qVHqTcNV9sTYTfu6HfXibTqDgLBBfF0EzOW8ZYQeMoLy0ldKaVRg?=
 =?us-ascii?q?monOXU3KUpQFhCBhZwtxqkxO7Xx1TmQ111jsLDit6X87HPu42BUxj082WuQ8/T?=
 =?us-ascii?q?Kp+EoxKlPQ4hB1k2E4nNmjijeUNHbqJaG8UIxOTTH1sUcxGpr+T0B+agj21Uhl?=
 =?us-ascii?q?MirUArFclb1tcUh1hwLG/5hCA/hRSetDehBD6+uQYqAF1VVR4gCg305c/uaNXY?=
 =?us-ascii?q?Bzkgo3a5Ghh31F0gNnKtUyIPqDd+Jy0lFMi/fW7WeT3ecrzVpbfh5V/Q=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAAAQDAxch0O0hNFcCBsBAQEBAwEBA?=
 =?us-ascii?q?QcDAQEBgVEGAQEBCwGBWoEDDIECJ4wTX4swUAEBBoFJaIgkhSGJEBSBYw4BARg?=
 =?us-ascii?q?LCAGEQIMdIjQJDQEDAQEBAQEBAgETAQEBCgsJCCkjDII2JAGCZQQCFwEMEwYBG?=
 =?us-ascii?q?x4DAgkCBSYlAwwFDQIFDAEFASIBCQIHBYJRSwGBaAEDCA0EAQqZNzyMCRYFARe?=
 =?us-ascii?q?CdwWBMQELAYJ5ChknDV2BNwIGEowPF3iBB4EQAYJdB4MFRwOBJBcDCkSDCYImA?=
 =?us-ascii?q?okVGgYBAzGFU4FOjzwuCYcIhihwgyQjCgKBUE2HPTaHIYkihHOBDolmBgIJBw8?=
 =?us-ascii?q?hgSWCDjMaCBsVO4JsCYISCQMXg0qEWSAbhVkmMgGBBAEBBwEZiVKCPgEB?=
X-IPAS-Result: =?us-ascii?q?A0AEAAAQDAxch0O0hNFcCBsBAQEBAwEBAQcDAQEBgVEGAQE?=
 =?us-ascii?q?BCwGBWoEDDIECJ4wTX4swUAEBBoFJaIgkhSGJEBSBYw4BARgLCAGEQIMdIjQJD?=
 =?us-ascii?q?QEDAQEBAQEBAgETAQEBCgsJCCkjDII2JAGCZQQCFwEMEwYBGx4DAgkCBSYlAww?=
 =?us-ascii?q?FDQIFDAEFASIBCQIHBYJRSwGBaAEDCA0EAQqZNzyMCRYFAReCdwWBMQELAYJ5C?=
 =?us-ascii?q?hknDV2BNwIGEowPF3iBB4EQAYJdB4MFRwOBJBcDCkSDCYImAokVGgYBAzGFU4F?=
 =?us-ascii?q?OjzwuCYcIhihwgyQjCgKBUE2HPTaHIYkihHOBDolmBgIJBw8hgSWCDjMaCBsVO?=
 =?us-ascii?q?4JsCYISCQMXg0qEWSAbhVkmMgGBBAEBBwEZiVKCPgEB?=
X-IronPort-AV: E=Sophos;i="5.56,331,1539673200"; 
   d="scan'208";a="54399629"
X-Amp-Result: UNKNOWN
X-Amp-Original-Verdict: FILE UNKNOWN
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 08 Dec 2018 10:25:34 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726251AbeLHSZc (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sat, 8 Dec 2018 13:25:32 -0500
Received: from mail-wr1-f66.google.com ([209.85.221.66]:46389 "EHLO
        mail-wr1-f66.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726142AbeLHSZb (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sat, 8 Dec 2018 13:25:31 -0500
Received: by mail-wr1-f66.google.com with SMTP id l9so6637064wrt.13;
        Sat, 08 Dec 2018 10:25:27 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=date:from:to:subject:message-id:mime-version:content-disposition
         :user-agent;
        bh=wZRraFORSa9LzdFQT6mYXkkJPXGBxGKdUlB1mlZb+3Q=;
        b=N2ClxO7vRyBuoHiHT9j1ctH60xbZoXArb3Ly3jMTLdrXINLyyp+LD3B//xqvXsmzPw
         qJ7ECIVFIITbL1dcmjh5SIANEEdN58j4DqPWqGmFGnB30DXRWBTbuBNoIPXC6mcv2N0O
         A3CQGQhVY8RQRB9f24f5Aff2/gMUASfVXKJGoibd6+DSXMrQDKjb3S7pO3ABDVYpFomM
         6kjxJ4SUMW/owTRE0ENoYGbY4RgspWwSlu3veh9OZ/OyT9Bi+L0Tbo83koe6kOC9nFNm
         mdTYiUzzqABQmdmrGeg++Hx7uB6E5/LxcJ0J8ZRqrxGeJDqIlHHseRuFKTOOy3pxEh24
         itzg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:date:from:to:subject:message-id:mime-version
         :content-disposition:user-agent;
        bh=wZRraFORSa9LzdFQT6mYXkkJPXGBxGKdUlB1mlZb+3Q=;
        b=qVl6rlNl9SVc91VDIFLCG3t1rOTfaD/y5ZDiygaI9SsYTMltxPa27xnhFTp+dmaZal
         y2NZ9/pYqRsaRQGEovBdaSQIffKgs99gcSU0EdZy7deOmFPfGc+ETv3CvmzoRYBoXu9f
         m48HLR2TOX4AuH8u6VcFcvaUAQs8d0UsjH/Uyrn4MMfoInQHduBsxyd2bm39KLf1Hh+x
         lj+jl33+5+RVmNdaCsRnvvez7r3393pGnQ1S+ZfFzBeH9BCcqJk0En6gcIgGbeVzFh6/
         sOrX9ujgS9pwhpcvZnBgkOA/xLIAUnL49OjkhVaWskxJaCrv/TK30VO+l9AXPMWt3ZWt
         N30g==
X-Gm-Message-State: AA+aEWaEH2mx0SKlPbd4YpLtU/RzD7vVerE0riFSmK2E/Uunp7CPq9C1
        kTWQwwc+EZOZOqM39Tg6WC4HhreEVdw=
X-Google-Smtp-Source: AFSGD/UdNRPb3dkbsYXnd7w73yPVGVin0n6IsxVvFeYuSesWHiBlWKQtJhiufv2wugouriWPsA5f6g==
X-Received: by 2002:adf:84e4:: with SMTP id 91mr5109448wrg.237.1544293525449;
        Sat, 08 Dec 2018 10:25:25 -0800 (PST)
Received: from syn-yoga530 (acayenne-651-1-10-59.w80-12.abo.wanadoo.fr. [80.12.147.59])
        by smtp.gmail.com with ESMTPSA id j8sm9620836wrt.40.2018.12.08.10.25.23
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Sat, 08 Dec 2018 10:25:24 -0800 (PST)
Date: Sat, 8 Dec 2018 15:25:20 -0300
From: Elie Morisse <syniurge@gmail.com>
To: linux-i2c@vger.kernel.org, Wolfram Sang <wsa@the-dreams.de>,
        helgaas@kernel.org, Nehal-bakulchandra.Shah@amd.com,
        Shyam-sundar.S-k@amd.com, sandeep.singh@amd.com,
        linux-kernel@vger.kernel.org
Subject: [PATCH v12] i2c: Add drivers for the AMD PCIe MP2 I2C controller
Message-ID: <20181208182520.GA5878@syn-yoga530>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

MP2 controllers have two separate busses, so may accommodate up to two I2C
adapters. Those adapters are listed in the ACPI namespace with the
"AMDI0011" HID, and probed by a platform driver.

Communication with the MP2 takes place through iomapped registers, or
through DMA for more than 32 bytes transfers.

This is major rework of the patch submitted by Nehal-bakulchandra Shah from
AMD (https://patchwork.kernel.org/patch/10597369/).

Most of the event handling of v3 was rewritten to make it work with more
than one bus (e.g on Ryzen-based Lenovo Yoga 530), and this version
contains many other improvements.

Signed-off-by: Elie Morisse <syniurge@gmail.com>
---
Changes since v1 (https://www.spinics.net/lists/linux-i2c/msg34650.html):
-> Add fix for IOMMU
-> Add depedency of ACPI
-> Add locks to avoid the crash

Changes since v2 (https://patchwork.ozlabs.org/patch/961270/):

-> fix for review comments
-> fix for more than 32 bytes write issue

Changes since v3 (https://patchwork.kernel.org/patch/10597369/) by Elie M.:

-> support more than one bus/adapter
-> support more than one slave per bus
-> use the bus speed specified by the slaves declared in the DSDT instead of
   assuming speed == 400kbits/s
-> instead of kzalloc'ing a buffer for every less than 32 bytes reads, simply
   use i2c_msg.buf
-> fix buffer overreads/overflows when (<=32 bytes) message lengths aren't a
   multiple of 4 by using memcpy_fromio and memcpy_toio
-> use streaming DMA mappings instead of allocating a coherent DMA buffer for
   every >32 bytes read/write
-> properly check for timeouts during i2c_amd_xfer and increase it from 50
   jiffies to 250 msecs (which is more in line with other drivers)
-> complete amd_i2c_dev.msg even if the device doesn't return a xxx_success
   event, instead of stalling i2c_amd_xfer
-> removed the spinlock and mdelay during i2c_amd_pci_configure, I didn't see
   the point since it's already waiting for a i2c_busenable_complete event
-> add an adapter-specific mutex lock for i2c_amd_xfer, since we don't want
   parallel calls writing to AMD_C2P_MSG0 (or AMD_C2P_MSG1)
-> add a global mutex lock for registers AMD_C2P_MSG2 to AMD_C2P_MSG9,  which
   are shared across the two busses/adapters
-> add MODULE_DEVICE_TABLE to automatically load i2c-amd-platdrv if the DSDT
   enumerates devices with the "AMDI0011" HID
-> set maximum length of reads/writes to 4095 (event's length field is 12 bits)
-> basic PM support
-> style corrections to match the kernel code style, and tried to reduce code
   duplication whenever possible

Changes since v4 by Elie M.:

-> fix missing typecast warning
-> removed the duplicated entry in Kconfig

Changes since v5 by Elie M.:

-> move DMA mapping from the platform driver to the PCI driver
-> attempt to find the platform device's PCI parent through the _DEP ACPI method
   (if not found take the first MP2 device registred in the i2c-amd-pci-mp2
   driver, like before)
-> do not assume anymore that the PCI device is owned by the i2c-amd-pci-mp2
   driver
-> address other review comments by Bjorn Helgaas (meant for v3)

Changes since v6 by Elie M.:

-> remove unnecessary memcpy from the DMA buffer during i2c_amd_read_completion

Changes since v7 by Elie M.:

-> merge the two modules into one named i2c-amd-mp2, delete now useless exports
-> unlock the C2P mutex if i2c_amd_xfer_msg timeouts, to prevent stalling the
   MP2 controller if a slave doesn't respond to a read or write request
-> unmap the DMA buffer before read/write_complete
-> fix bus_disable commands handling (no more errors during module exit)
-> prefer managed versions of pci_ and dev_ functions whenever possible
-> increase adapter retries from 0 to 3
-> reduce code duplication in debugfs functions
-> address other review points by Bjorn Helgaas (except regarding the _DEP
   hint)

Changes since v8 by Elie M.:

-> remove mostly redundant amd_i2c_rw_config, refer to i2c_msg whenever
possible
-> use i2c_get_dma_safe_msg_buf and i2c_put_dma_safe_msg_buf
-> defer probe() by the platform driver if no MP2 device has been probed
yet by the PCI driver (which should address Bjorn Helgaas' concern while
preserving the platform driver)
-> if the interrupt following a command doesn't get handled after 250ms,
zero AMD_P2C_MSG_INTEN to prevent the MP2 from stalling for a few more
seconds
-> include AMD_P2C_MSG3 and fix typo in debugfs output
-> cosmetic fixes, code reduction, and better comments
-> add Nehal Shah and Shyam Sundar S K from AMD to the list of maintainers

Changes since v9 by Elie M.:

-> remove the xfer_lock mutex which was redundant with i2c_adapter.bus_lock
-> platform device remove() fixes (protection against the very unlikely
case that both the PCI and platform devices get detached manually and
simultaneously)
-> fix manually unbinding the PCI device and then rebinding, there was an
interrupt that wouldn't get serviced and thus the line got disabled
-> look for the MP2 device corresponding to an AMDI0011 ACPI device in
every device enumerated by _DEP, not just the first one
-> set i2c_adapter.nr to pdev->id and call i2c_add_numbered_adapter()
-> add Documentation/i2c/busses/ entry
-> minor enhancements

Changes since v10 by Elie M.:

-> runtime PM support
-> synchronisation fixes for <=32 bytes reads/writes through C2P registers,
no more timeouts or "irq: nobody cared" errors on Lenovo Ideapad 530s
-> remove the isr spinlock, not needed since isr aren't re-entrant
-> remove the delayed_work field, make the isr complete .cmd_complete
directly
-> xfer now returns -EIO if the MP2 response isn't the expected one
-> check that the adapter still exists at the beginning of xfer
-> less code duplication in amd_mp2_read/write
-> better names (bus_xnable => bus_enable_set, _msg => _cmd) and other
minor enhancements

Changes since v11 by Elie M.:

-> remove the ACPI _DEP hint, Nehal from AMD said that there's no plan to
have more than one MP2 device per system and this wasn't _DEP's purpose
-> use device links between the two drivers to simplify the .remove logic
-> do not hardcode the i2c adapter timeout
-> code reduction and comment fixes

 Documentation/i2c/busses/i2c-amd-mp2  |  24 +
 MAINTAINERS                           |   8 +
 drivers/i2c/busses/Kconfig            |  10 +
 drivers/i2c/busses/Makefile           |   2 +
 drivers/i2c/busses/i2c-amd-mp2-pci.c  | 694 ++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-amd-mp2-plat.c | 342 +++++++++++++
 drivers/i2c/busses/i2c-amd-mp2.h      | 228 +++++++++
 7 files changed, 1308 insertions(+)
 create mode 100644 Documentation/i2c/busses/i2c-amd-mp2
 create mode 100644 drivers/i2c/busses/i2c-amd-mp2-pci.c
 create mode 100644 drivers/i2c/busses/i2c-amd-mp2-plat.c
 create mode 100644 drivers/i2c/busses/i2c-amd-mp2.h

diff --git a/Documentation/i2c/busses/i2c-amd-mp2 b/Documentation/i2c/busses/i2c-amd-mp2
new file mode 100644
index 000000000000..4b3d4b804413
--- /dev/null
+++ b/Documentation/i2c/busses/i2c-amd-mp2
@@ -0,0 +1,24 @@
+Kernel driver i2c-amd-mp2
+
+Supported adapters:
+  * AMD MP2 PCIe interface
+
+Datasheet: not publicly available.
+
+Authors:
+	Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+	Nehal Shah <nehal-bakulchandra.shah@amd.com>
+	Elie Morisse <syniurge@gmail.com>
+
+Description
+-----------
+
+The MP2 is an ARM processor programmed as an I2C controller and communicating
+with the x86 host through PCI.
+
+If you see something like this:
+
+03:00.7 Non-VGA unclassified device: Advanced Micro Devices, Inc. [AMD] Device
+									15e6
+
+in your 'lspci -v', then this driver is for your device.
diff --git a/MAINTAINERS b/MAINTAINERS
index 6ac000cc006d..99382f213b1c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -791,6 +791,14 @@ F:	drivers/gpu/drm/amd/include/vi_structs.h
 F:	drivers/gpu/drm/amd/include/v9_structs.h
 F:	include/uapi/linux/kfd_ioctl.h
 
+AMD MP2 I2C DRIVER
+M:	Elie Morisse <syniurge@gmail.com>
+M:	Nehal Shah <nehal-bakulchandra.shah@amd.com>
+M:	Shyam Sundar S K <shyam-sundar.s-k@amd.com>
+L:	linux-i2c@vger.kernel.org
+S:	Maintained
+F:	drivers/i2c/busses/i2c-amd-mp2*
+
 AMD POWERPLAY
 M:	Rex Zhu <rex.zhu@amd.com>
 M:	Evan Quan <evan.quan@amd.com>
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 451d4ae50e66..70819245919e 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -77,6 +77,16 @@ config I2C_AMD8111
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-amd8111.
 
+config I2C_AMD_MP2_PCI
+	tristate "AMD MP2 PCIe I2C adapter"
+	depends on PCI && ACPI
+	help
+	  If you say yes to this option, support will be included for the AMD
+	  MP2 PCIe I2C adapter.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-amd-mp2.
+
 config I2C_HIX5HD2
 	tristate "Hix5hd2 high-speed I2C driver"
 	depends on ARCH_HISI || ARCH_HIX5HD2 || COMPILE_TEST
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 18b26af82b1c..b036ffab0165 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -32,6 +32,8 @@ obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 
 # Embedded system I2C/SMBus host controller drivers
 obj-$(CONFIG_I2C_ALTERA)	+= i2c-altera.o
+obj-$(CONFIG_I2C_AMD_MP2_PCI)	+= i2c-amd-mp2.o
+i2c-amd-mp2-objs := i2c-amd-mp2-pci.o i2c-amd-mp2-plat.o
 obj-$(CONFIG_I2C_ASPEED)	+= i2c-aspeed.o
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
diff --git a/drivers/i2c/busses/i2c-amd-mp2-pci.c b/drivers/i2c/busses/i2c-amd-mp2-pci.c
new file mode 100644
index 000000000000..a41800e1971f
--- /dev/null
+++ b/drivers/i2c/busses/i2c-amd-mp2-pci.c
@@ -0,0 +1,694 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/*
+ * AMD MP2 PCIe communication driver
+ *
+ * Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+ *          Elie Morisse <syniurge@gmail.com>
+ */
+
+#include <linux/debugfs.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+
+#include "i2c-amd-mp2.h"
+
+#define DRIVER_NAME	"i2c_amd_mp2"
+#define DRIVER_DESC	"AMD(R) PCI-E MP2 I2C Controller Driver"
+#define DRIVER_VER	"1.0"
+
+static inline void write64(u64 val, void __iomem *mmio)
+{
+	writel(val, mmio);
+	writel(val >> 32, mmio + sizeof(u32));
+}
+
+static inline u64 read64(void __iomem *mmio)
+{
+	u64 low, high;
+
+	low = readl(mmio);
+	high = readl(mmio + sizeof(u32));
+	return low | (high << 32);
+}
+
+static void amd_mp2_c2p_mutex_lock(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	/* there is only one data mailbox for two i2c adapters */
+	mutex_lock(&privdata->c2p_lock);
+	privdata->c2p_lock_busid = i2c_common->bus_id;
+}
+
+static void amd_mp2_c2p_mutex_unlock(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	if (unlikely(privdata->c2p_lock_busid != i2c_common->bus_id)) {
+		dev_warn(ndev_dev(privdata),
+			 "bus %d attempting to unlock C2P locked by bus %d\n",
+			 i2c_common->bus_id, privdata->c2p_lock_busid);
+		return;
+	}
+
+	mutex_unlock(&privdata->c2p_lock);
+}
+
+static int amd_mp2_cmd(struct amd_i2c_common *i2c_common,
+		       union i2c_cmd_base i2c_cmd_base)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	void __iomem *reg;
+
+	i2c_common->reqcmd = i2c_cmd_base.s.i2c_cmd;
+
+	reg = privdata->mmio + ((i2c_cmd_base.s.bus_id == 1) ?
+				AMD_C2P_MSG1 : AMD_C2P_MSG0);
+	writel(i2c_cmd_base.ul, reg);
+
+	return 0;
+}
+
+int amd_mp2_bus_enable_set(struct amd_i2c_common *i2c_common, bool enable)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	union i2c_cmd_base i2c_cmd_base;
+
+	dev_dbg(ndev_dev(privdata), "%s id: %d\n", __func__,
+		i2c_common->bus_id);
+
+	i2c_cmd_base.ul = 0;
+	i2c_cmd_base.s.i2c_cmd = enable ? i2c_enable : i2c_disable;
+	i2c_cmd_base.s.bus_id = i2c_common->bus_id;
+	i2c_cmd_base.s.i2c_speed = i2c_common->i2c_speed;
+
+	amd_mp2_c2p_mutex_lock(i2c_common);
+
+	return amd_mp2_cmd(i2c_common, i2c_cmd_base);
+}
+
+static void amd_mp2_cmd_rw_fill(struct amd_i2c_common *i2c_common,
+				union i2c_cmd_base *i2c_cmd_base,
+				enum i2c_cmd reqcmd)
+{
+	i2c_cmd_base->s.i2c_cmd = reqcmd;
+	i2c_cmd_base->s.bus_id = i2c_common->bus_id;
+	i2c_cmd_base->s.i2c_speed = i2c_common->i2c_speed;
+	i2c_cmd_base->s.slave_addr = i2c_common->msg->addr;
+	i2c_cmd_base->s.length = i2c_common->msg->len;
+}
+
+static int amd_mp2_dma_map(struct amd_mp2_dev *privdata,
+			   struct amd_i2c_common *i2c_common)
+{
+	enum dma_data_direction dma_direction =
+			i2c_common->msg->flags & I2C_M_RD ?
+			DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	i2c_common->dma_buf = i2c_get_dma_safe_msg_buf(i2c_common->msg, 0);
+	i2c_common->dma_addr = dma_map_single(&privdata->pci_dev->dev,
+					      i2c_common->dma_buf,
+					      i2c_common->msg->len,
+					      dma_direction);
+
+	if (dma_mapping_error(&privdata->pci_dev->dev,
+			      i2c_common->dma_addr)) {
+		dev_err(ndev_dev(privdata),
+			"Error while mapping dma buffer %p\n",
+			i2c_common->dma_buf);
+		return -EIO;
+	}
+
+	dev_dbg(ndev_dev(privdata), "%s dma_addr: %llx size: %u dir: %s\n",
+		__func__, i2c_common->dma_addr, i2c_common->msg->len,
+		dma_direction == DMA_FROM_DEVICE ? "from" : "to");
+
+	return 0;
+}
+
+static void amd_mp2_dma_unmap(struct amd_mp2_dev *privdata,
+			      struct amd_i2c_common *i2c_common)
+{
+	enum dma_data_direction dma_direction =
+			i2c_common->msg->flags & I2C_M_RD ?
+			DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	dma_unmap_single(&privdata->pci_dev->dev,
+			 i2c_common->dma_addr,
+			 i2c_common->msg->len,
+			 dma_direction);
+
+	i2c_put_dma_safe_msg_buf(i2c_common->dma_buf, i2c_common->msg, true);
+}
+
+static int amd_mp2_rw(struct amd_i2c_common *i2c_common, enum i2c_cmd reqcmd)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	union i2c_cmd_base i2c_cmd_base;
+
+	amd_mp2_cmd_rw_fill(i2c_common, &i2c_cmd_base, reqcmd);
+	amd_mp2_c2p_mutex_lock(i2c_common);
+
+	if (i2c_common->msg->len <= 32) {
+		i2c_cmd_base.s.mem_type = use_c2pmsg;
+		if (reqcmd == i2c_write)
+			memcpy_toio(privdata->mmio + AMD_C2P_MSG2,
+				    i2c_common->msg->buf,
+				    i2c_common->msg->len);
+	} else {
+		i2c_cmd_base.s.mem_type = use_dram;
+		if (amd_mp2_dma_map(privdata, i2c_common))
+			return -EIO;
+		write64((u64)i2c_common->dma_addr,
+			privdata->mmio + AMD_C2P_MSG2);
+	}
+
+	return amd_mp2_cmd(i2c_common, i2c_cmd_base);
+}
+
+int amd_mp2_read(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	dev_dbg(ndev_dev(privdata), "%s addr: %x id: %d\n", __func__,
+		i2c_common->msg->addr, i2c_common->bus_id);
+
+	return amd_mp2_rw(i2c_common, i2c_read);
+}
+
+int amd_mp2_write(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	dev_dbg(ndev_dev(privdata), "%s addr: %x id: %d\n", __func__,
+		i2c_common->msg->addr, i2c_common->bus_id);
+
+	return amd_mp2_rw(i2c_common, i2c_write);
+}
+
+static void amd_mp2_pci_check_rw_event(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	int len = i2c_common->eventval.r.length;
+	u32 slave_addr = i2c_common->eventval.r.slave_addr;
+	bool err = false;
+
+	if (unlikely(len != i2c_common->msg->len)) {
+		dev_err(ndev_dev(privdata),
+			"length %d in event doesn't match buffer length %d!\n",
+			len, i2c_common->msg->len);
+		err = true;
+	}
+
+	if (unlikely(slave_addr != i2c_common->msg->addr)) {
+		dev_err(ndev_dev(privdata),
+			"unexpected slave address %x (expected: %x)!\n",
+			slave_addr, i2c_common->msg->addr);
+		err = true;
+	}
+
+	if (!err)
+		i2c_common->cmd_success = true;
+}
+
+static void __amd_mp2_process_event(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	enum status_type sts = i2c_common->eventval.r.status;
+	enum response_type res = i2c_common->eventval.r.response;
+	int len = i2c_common->eventval.r.length;
+
+	if ((i2c_common->reqcmd == i2c_read ||
+	     i2c_common->reqcmd == i2c_write) &&
+	    i2c_common->msg->len > 32)
+		amd_mp2_dma_unmap(privdata, i2c_common);
+
+	if (res != command_success) {
+		if (res == command_failed)
+			dev_err(ndev_dev(privdata), "i2c command failed!\n");
+		else
+			dev_err(ndev_dev(privdata), "invalid response to i2c command!\n");
+		return;
+	}
+
+	switch (i2c_common->reqcmd) {
+	case i2c_read:
+		if (sts == i2c_readcomplete_event) {
+			amd_mp2_pci_check_rw_event(i2c_common);
+			if (len <= 32)
+				memcpy_fromio(i2c_common->msg->buf,
+					      privdata->mmio + AMD_C2P_MSG2,
+					      i2c_common->msg->len);
+		} else if (sts == i2c_readfail_event) {
+			dev_err(ndev_dev(privdata), "i2c read failed!\n");
+		} else {
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after read (%d)!\n", sts);
+		}
+		break;
+	case i2c_write:
+		if (sts == i2c_writecomplete_event)
+			amd_mp2_pci_check_rw_event(i2c_common);
+		else if (sts == i2c_writefail_event)
+			dev_err(ndev_dev(privdata), "i2c write failed!\n");
+		else
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after write (%d)!\n", sts);
+		break;
+	case i2c_enable:
+		if (sts == i2c_busenable_failed)
+			dev_err(ndev_dev(privdata), "i2c bus enable failed!\n");
+		else if (sts != i2c_busenable_complete)
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after bus enable (%d)!\n",
+				sts);
+		else
+			i2c_common->cmd_success = true;
+		break;
+	case i2c_disable:
+		if (sts == i2c_busdisable_failed)
+			dev_err(ndev_dev(privdata), "i2c bus disable failed!\n");
+		else if (sts != i2c_busdisable_complete)
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after bus disable (%d)!\n",
+				sts);
+		else
+			i2c_common->cmd_success = true;
+		break;
+	default:
+		break;
+	}
+}
+
+void amd_mp2_process_event(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	if (unlikely(i2c_common->reqcmd == i2c_none)) {
+		dev_warn(ndev_dev(privdata),
+			 "received msg but no cmd was sent (bus = %d)!\n",
+			 i2c_common->bus_id);
+		return;
+	}
+
+	__amd_mp2_process_event(i2c_common);
+
+	i2c_common->reqcmd = i2c_none;
+	amd_mp2_c2p_mutex_unlock(i2c_common);
+}
+
+static irqreturn_t amd_mp2_irq_isr(int irq, void *dev)
+{
+	struct amd_mp2_dev *privdata = dev;
+	struct amd_i2c_common *i2c_common;
+	u32 val;
+	unsigned int bus_id;
+	void __iomem *reg;
+	enum irqreturn ret = IRQ_NONE;
+
+	for (bus_id = 0; bus_id < 2; bus_id++) {
+		i2c_common = privdata->busses[bus_id];
+		if (!i2c_common)
+			continue;
+
+		reg = privdata->mmio + ((bus_id == 0) ?
+					AMD_P2C_MSG1 : AMD_P2C_MSG2);
+		val = readl(reg);
+		if (val != 0) {
+			writel(0, reg);
+			writel(0, privdata->mmio + AMD_P2C_MSG_INTEN);
+			i2c_common->eventval.ul = val;
+			i2c_amd_cmd_completion(i2c_common);
+
+			ret = IRQ_HANDLED;
+		}
+	}
+
+	if (ret != IRQ_HANDLED) {
+		val = readl(privdata->mmio + AMD_P2C_MSG_INTEN);
+		if (unlikely(val != 0)) {
+			writel(0, privdata->mmio + AMD_P2C_MSG_INTEN);
+			dev_warn(ndev_dev(privdata),
+				 "received irq without message\n");
+			ret = IRQ_HANDLED;
+		}
+	}
+
+	return ret;
+}
+
+void amd_mp2_rw_timeout(struct amd_i2c_common *i2c_common)
+{
+	i2c_common->reqcmd = i2c_none;
+	amd_mp2_c2p_mutex_unlock(i2c_common);
+}
+
+int amd_mp2_register_cb(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	if (i2c_common->bus_id > 1)
+		return -EINVAL;
+
+	if (privdata->busses[i2c_common->bus_id]) {
+		dev_err(ndev_dev(privdata),
+			"Bus %d already taken!\n", i2c_common->bus_id);
+		return -EINVAL;
+	}
+
+	privdata->busses[i2c_common->bus_id] = i2c_common;
+
+	return 0;
+}
+
+int amd_mp2_unregister_cb(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	privdata->busses[i2c_common->bus_id] = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static const struct file_operations amd_mp2_debugfs_info;
+static struct dentry *debugfs_root_dir;
+
+static ssize_t amd_mp2_debugfs_read(struct file *filp, char __user *ubuf,
+				    size_t count, loff_t *offp)
+{
+	struct amd_mp2_dev *privdata = filp->private_data;
+	void __iomem *mmio = privdata->mmio;
+	u8 *buf;
+	size_t buf_size = min_t(size_t, count, 0x800);
+	ssize_t ret, off = 0;
+	u32 v32;
+	int i;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	off += scnprintf(buf + off, buf_size - off,
+			 "MP2 Device Information:\n"
+			 "========================\n"
+			 "\tMP2 C2P Message Register Dump:\n\n");
+
+	for (i = 0; i < 10; i++) {
+		v32 = readl(privdata->mmio + AMD_C2P_MSG0 + i * 4);
+		off += scnprintf(buf + off, buf_size - off,
+				 "AMD_C2P_MSG%d -\t\t\t%#06x\n", i, v32);
+	}
+
+	off += scnprintf(buf + off, buf_size - off,
+			"\n\tMP2 P2C Message Register Dump:\n\n");
+
+	for (i = 0; i < 3; i++) {
+		v32 = readl(privdata->mmio + AMD_P2C_MSG1 + i * 4);
+		off += scnprintf(buf + off, buf_size - off,
+				 "AMD_P2C_MSG%d -\t\t\t%#06x\n", i + 1, v32);
+	}
+
+	v32 = readl(privdata->mmio + AMD_P2C_MSG_INTEN);
+	off += scnprintf(buf + off, buf_size - off,
+			"AMD_P2C_MSG_INTEN -\t\t%#06x\n", v32);
+
+	v32 = readl(privdata->mmio + AMD_P2C_MSG_INTSTS);
+	off += scnprintf(buf + off, buf_size - off,
+			"AMD_P2C_MSG_INTSTS -\t\t%#06x\n", v32);
+
+	ret = simple_read_from_buffer(ubuf, count, offp, buf, off);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations amd_mp2_debugfs_info = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = amd_mp2_debugfs_read,
+};
+
+static void amd_mp2_init_debugfs(struct amd_mp2_dev *privdata)
+{
+	if (!debugfs_root_dir)
+		return;
+
+	privdata->debugfs_dir = debugfs_create_dir(ndev_name(privdata),
+						   debugfs_root_dir);
+	if (!privdata->debugfs_dir) {
+		privdata->debugfs_info = NULL;
+	} else {
+		privdata->debugfs_info = debugfs_create_file
+			("info", 0400, privdata->debugfs_dir,
+			 privdata, &amd_mp2_debugfs_info);
+	}
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static void amd_mp2_clear_reg(struct amd_mp2_dev *privdata)
+{
+	int reg;
+
+	for (reg = AMD_C2P_MSG0; reg <= AMD_C2P_MSG9; reg += 4)
+		writel(0, privdata->mmio + reg);
+
+	for (reg = AMD_P2C_MSG1; reg <= AMD_P2C_MSG2; reg += 4)
+		writel(0, privdata->mmio + reg);
+}
+
+static int amd_mp2_pci_init(struct amd_mp2_dev *privdata,
+			    struct pci_dev *pci_dev)
+{
+	int rc;
+
+	pci_set_drvdata(pci_dev, privdata);
+
+	rc = pcim_enable_device(pci_dev);
+	if (rc) {
+		dev_err(ndev_dev(privdata), "Failed to enable MP2 PCI device\n");
+		goto err_pci_enable;
+	}
+
+	rc = pcim_iomap_regions(pci_dev, 1 << 2, pci_name(pci_dev));
+	if (rc) {
+		dev_err(ndev_dev(privdata), "I/O memory remapping failed\n");
+		goto err_pci_enable;
+	}
+	privdata->mmio = pcim_iomap_table(pci_dev)[2];
+
+	pci_set_master(pci_dev);
+
+	rc = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(64));
+	if (rc) {
+		rc = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));
+		if (rc)
+			goto err_dma_mask;
+	}
+
+	/* Set up intx irq */
+	writel(0, privdata->mmio + AMD_P2C_MSG_INTEN);
+	pci_intx(pci_dev, 1);
+	rc = devm_request_irq(&pci_dev->dev, pci_dev->irq, amd_mp2_irq_isr,
+			      IRQF_SHARED, dev_name(&pci_dev->dev), privdata);
+	if (rc)
+		dev_err(&pci_dev->dev, "Failure requesting irq %i: %d\n",
+			pci_dev->irq, rc);
+
+	return rc;
+
+err_dma_mask:
+	pci_clear_master(pci_dev);
+err_pci_enable:
+	pci_set_drvdata(pci_dev, NULL);
+	return rc;
+}
+
+static int amd_mp2_pci_probe(struct pci_dev *pci_dev,
+			     const struct pci_device_id *id)
+{
+	struct amd_mp2_dev *privdata;
+	int rc;
+	static bool first_probe = true;
+
+	if (first_probe) {
+		pr_info("%s: %s Version: %s\n", DRIVER_NAME,
+			DRIVER_DESC, DRIVER_VER);
+		first_probe = false;
+	}
+
+	dev_info(&pci_dev->dev, "MP2 device found [%04x:%04x] (rev %x)\n",
+		 pci_dev->vendor, pci_dev->device, pci_dev->revision);
+
+	privdata = devm_kzalloc(&pci_dev->dev, sizeof(*privdata), GFP_KERNEL);
+	if (!privdata)
+		return -ENOMEM;
+
+	rc = amd_mp2_pci_init(privdata, pci_dev);
+	if (rc)
+		return rc;
+
+	mutex_init(&privdata->c2p_lock);
+	privdata->pci_dev = pci_dev;
+
+	pm_runtime_set_autosuspend_delay(&pci_dev->dev, 1000);
+	pm_runtime_use_autosuspend(&pci_dev->dev);
+	pm_runtime_put_autosuspend(&pci_dev->dev);
+	pm_runtime_allow(&pci_dev->dev);
+
+	amd_mp2_init_debugfs(privdata);
+	dev_info(&pci_dev->dev, "MP2 device registered.\n");
+	return 0;
+}
+
+static bool amd_mp2_pci_is_probed(struct pci_dev *pci_dev)
+{
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+
+	if (!privdata)
+		return false;
+	return privdata->pci_dev != NULL;
+}
+
+static void amd_mp2_pci_remove(struct pci_dev *pci_dev)
+{
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+
+	pm_runtime_forbid(&pci_dev->dev);
+	pm_runtime_get_noresume(&pci_dev->dev);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(privdata->debugfs_dir);
+#endif /* CONFIG_DEBUG_FS */
+
+	pci_intx(pci_dev, 0);
+	pci_clear_master(pci_dev);
+
+	amd_mp2_clear_reg(privdata);
+}
+
+#ifdef CONFIG_PM
+static int amd_mp2_pci_suspend(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+	unsigned int bus_id;
+	int ret = 0;
+
+	for (bus_id = 0; bus_id < 2; bus_id++)
+		if (privdata->busses[bus_id])
+			i2c_amd_suspend(privdata->busses[bus_id]);
+
+	ret = pci_save_state(pci_dev);
+	if (ret) {
+		dev_err(ndev_dev(privdata),
+			"pci_save_state failed = %d\n", ret);
+		return ret;
+	}
+
+	pci_disable_device(pci_dev);
+	return ret;
+}
+
+static int amd_mp2_pci_resume(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+	unsigned int bus_id;
+	int ret = 0;
+
+	pci_restore_state(pci_dev);
+	ret = pci_enable_device(pci_dev);
+	if (ret < 0) {
+		dev_err(ndev_dev(privdata),
+			"pci_enable_device failed = %d\n", ret);
+		return ret;
+	}
+
+	for (bus_id = 0; bus_id < 2; bus_id++)
+		if (privdata->busses[bus_id]) {
+			ret = i2c_amd_resume(privdata->busses[bus_id]);
+			if (ret < 0)
+				return ret;
+		}
+
+	return ret;
+}
+
+static UNIVERSAL_DEV_PM_OPS(amd_mp2_pci_pm_ops, amd_mp2_pci_suspend,
+			    amd_mp2_pci_resume, NULL);
+#endif /* CONFIG_PM */
+
+static const struct pci_device_id amd_mp2_pci_tbl[] = {
+	{PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_MP2)},
+	{0}
+};
+MODULE_DEVICE_TABLE(pci, amd_mp2_pci_tbl);
+
+static struct pci_driver amd_mp2_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= amd_mp2_pci_tbl,
+	.probe		= amd_mp2_pci_probe,
+	.remove		= amd_mp2_pci_remove,
+#ifdef CONFIG_PM
+	.driver = {
+		.pm	= &amd_mp2_pci_pm_ops,
+	},
+#endif
+};
+
+static int amd_mp2_device_match(struct device *dev, void *data)
+{
+	return 1;
+}
+
+struct amd_mp2_dev *amd_mp2_find_device(void)
+{
+	struct device *dev;
+	struct pci_dev *pci_dev;
+
+	dev = driver_find_device(&amd_mp2_pci_driver.driver, NULL, NULL,
+				 amd_mp2_device_match);
+	if (!dev)
+		return NULL;
+
+	pci_dev = to_pci_dev(dev);
+	if (!amd_mp2_pci_is_probed(pci_dev))
+		return NULL;
+	return (struct amd_mp2_dev *)pci_get_drvdata(pci_dev);
+}
+
+static int __init amd_mp2_drv_init(void)
+{
+	int rc;
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_root_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+#endif /* CONFIG_DEBUG_FS */
+
+	rc = pci_register_driver(&amd_mp2_pci_driver);
+	if (rc)
+		return rc;
+	return i2c_amd_register_driver();
+}
+module_init(amd_mp2_drv_init);
+
+static void __exit amd_mp2_drv_exit(void)
+{
+	i2c_amd_unregister_driver();
+	pci_unregister_driver(&amd_mp2_pci_driver);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(debugfs_root_dir);
+#endif /* CONFIG_DEBUG_FS */
+}
+module_exit(amd_mp2_drv_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VER);
+MODULE_AUTHOR("Shyam Sundar S K <Shyam-sundar.S-k@amd.com>");
+MODULE_AUTHOR("Nehal Shah <nehal-bakulchandra.shah@amd.com>");
+MODULE_AUTHOR("Elie Morisse <syniurge@gmail.com>");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/i2c/busses/i2c-amd-mp2-plat.c b/drivers/i2c/busses/i2c-amd-mp2-plat.c
new file mode 100644
index 000000000000..acdd3e0a0cb1
--- /dev/null
+++ b/drivers/i2c/busses/i2c-amd-mp2-plat.c
@@ -0,0 +1,342 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/*
+ * AMD MP2 platform driver
+ *
+ * Setup the I2C adapters enumerated in the ACPI namespace.
+ * MP2 controllers have 2 separate busses, up to 2 I2C adapters may be listed.
+ *
+ * Authors: Nehal Bakulchandra Shah <Nehal-bakulchandra.shah@amd.com>
+ *          Elie Morisse <syniurge@gmail.com>
+ */
+
+#include <linux/acpi.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "i2c-amd-mp2.h"
+
+#define AMD_MP2_I2C_MAX_RW_LENGTH ((1 << 12) - 1)
+#define AMD_I2C_TIMEOUT (msecs_to_jiffies(250))
+
+/**
+ * struct amd_i2c_dev - MP2 bus/i2c adapter context
+ * @common: shared context with the MP2 PCI driver
+ * @pdev: platform driver node
+ * @adap: i2c adapter
+ * @cmd_complete: xfer completion object
+ */
+struct amd_i2c_dev {
+	struct amd_i2c_common common;
+	struct platform_device *pdev;
+	struct i2c_adapter adap;
+	struct completion cmd_complete;
+};
+
+#define amd_i2c_dev_common(__common) \
+	container_of(__common, struct amd_i2c_dev, common)
+
+void i2c_amd_cmd_completion(struct amd_i2c_common *i2c_common)
+{
+	struct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);
+	union i2c_event *event = &i2c_common->eventval;
+
+	if (event->r.status == i2c_readcomplete_event)
+		dev_dbg(&i2c_dev->pdev->dev, "%s readdata:%*ph\n",
+			__func__, event->r.length,
+			i2c_common->msg->buf);
+
+	complete(&i2c_dev->cmd_complete);
+}
+
+static const char *i2c_amd_cmd_name(enum i2c_cmd cmd)
+{
+	switch (cmd) {
+	case i2c_read:
+		return "i2c read";
+	case i2c_write:
+		return "i2c write";
+	case i2c_enable:
+		return "bus enable";
+	case i2c_disable:
+		return "bus disable";
+	case number_of_sensor_discovered:
+		return "'number of sensors discovered' cmd";
+	case is_mp2_active:
+		return "'is mp2 active' cmd";
+	default:
+		return "invalid cmd";
+	}
+}
+
+static void i2c_amd_start_cmd(struct amd_i2c_dev *i2c_dev)
+{
+	struct amd_i2c_common *i2c_common = &i2c_dev->common;
+
+	reinit_completion(&i2c_dev->cmd_complete);
+	i2c_common->cmd_success = false;
+}
+
+static int i2c_amd_check_cmd_completion(struct amd_i2c_dev *i2c_dev)
+{
+	struct amd_i2c_common *i2c_common = &i2c_dev->common;
+	unsigned long timeout;
+
+	timeout = wait_for_completion_timeout(&i2c_dev->cmd_complete,
+					      i2c_dev->adap.timeout);
+	if (timeout == 0) {
+		dev_err(&i2c_dev->pdev->dev, "%s timed out\n",
+			i2c_amd_cmd_name(i2c_common->reqcmd));
+		amd_mp2_rw_timeout(i2c_common);
+		return -ETIMEDOUT;
+	}
+
+	amd_mp2_process_event(i2c_common);
+
+	if (!i2c_common->cmd_success)
+		return -EIO;
+
+	return 0;
+}
+
+static int i2c_amd_enable_set(struct amd_i2c_dev *i2c_dev, bool enable)
+{
+	struct amd_i2c_common *i2c_common = &i2c_dev->common;
+
+	i2c_amd_start_cmd(i2c_dev);
+	amd_mp2_bus_enable_set(i2c_common, enable);
+
+	return i2c_amd_check_cmd_completion(i2c_dev);
+}
+
+static int i2c_amd_xfer_msg(struct amd_i2c_dev *i2c_dev, struct i2c_msg *pmsg)
+{
+	struct amd_i2c_common *i2c_common = &i2c_dev->common;
+
+	i2c_amd_start_cmd(i2c_dev);
+	i2c_common->msg = pmsg;
+
+	if (pmsg->flags & I2C_M_RD)
+		amd_mp2_read(i2c_common);
+	else
+		amd_mp2_write(i2c_common);
+
+	return i2c_amd_check_cmd_completion(i2c_dev);
+}
+
+static int i2c_amd_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	struct amd_i2c_dev *i2c_dev = i2c_get_adapdata(adap);
+	int i;
+	struct i2c_msg *pmsg;
+	int err;
+
+	/* the adapter might have been deleted while waiting for the bus lock */
+	if (unlikely(!i2c_dev->common.mp2_dev))
+		return -EINVAL;
+
+	amd_mp2_pm_runtime_get(i2c_dev->common.mp2_dev);
+
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		err = i2c_amd_xfer_msg(i2c_dev, pmsg);
+		if (err)
+			break;
+	}
+
+	amd_mp2_pm_runtime_put(i2c_dev->common.mp2_dev);
+	return err ? err : num;
+}
+
+static u32 i2c_amd_func(struct i2c_adapter *a)
+{
+	return I2C_FUNC_I2C;
+}
+
+static const struct i2c_algorithm i2c_amd_algorithm = {
+	.master_xfer = i2c_amd_xfer,
+	.functionality = i2c_amd_func,
+};
+
+#ifdef CONFIG_PM
+int i2c_amd_suspend(struct amd_i2c_common *i2c_common)
+{
+	struct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);
+
+	i2c_amd_enable_set(i2c_dev, false);
+	return 0;
+}
+
+int i2c_amd_resume(struct amd_i2c_common *i2c_common)
+{
+	struct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);
+
+	return i2c_amd_enable_set(i2c_dev, true);
+}
+#endif
+
+static enum speed_enum i2c_amd_get_bus_speed(struct platform_device *pdev)
+{
+	u32 acpi_speed;
+	int i;
+	static const u32 supported_speeds[] = {
+		0, 100000, 400000, 1000000, 1400000, 3400000
+	};
+
+	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
+	/* round down to the lowest standard speed */
+	for (i = 1; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (acpi_speed < supported_speeds[i])
+			break;
+	}
+	acpi_speed = supported_speeds[i - 1];
+
+	switch (acpi_speed) {
+	case 100000:
+		return speed100k;
+	case 400000:
+		return speed400k;
+	case 1000000:
+		return speed1000k;
+	case 1400000:
+		return speed1400k;
+	case 3400000:
+		return speed3400k;
+	default:
+		return speed400k;
+	}
+}
+
+static const struct i2c_adapter_quirks amd_i2c_dev_quirks = {
+	.max_read_len = AMD_MP2_I2C_MAX_RW_LENGTH,
+	.max_write_len = AMD_MP2_I2C_MAX_RW_LENGTH,
+};
+
+static int i2c_amd_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct amd_i2c_dev *i2c_dev;
+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
+	struct acpi_device *adev;
+	struct amd_mp2_dev *mp2_dev;
+	const char *uid;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return -ENODEV;
+
+	/* The ACPI namespace doesn't contain information about which MP2 PCI
+	 * device an AMDI0011 ACPI device is related to, so assume that there's
+	 * only one MP2 PCI device per system.
+	 */
+	mp2_dev = amd_mp2_find_device();
+	if (!mp2_dev)
+		/* The MP2 PCI device might get probed later */
+		return -EPROBE_DEFER;
+
+	i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
+	if (!i2c_dev)
+		return -ENOMEM;
+
+	i2c_dev->common.mp2_dev = mp2_dev;
+	i2c_dev->pdev = pdev;
+	platform_set_drvdata(pdev, i2c_dev);
+
+	uid = adev->pnp.unique_id;
+	if (!uid) {
+		dev_err(&pdev->dev, "missing UID/bus id!\n");
+		return -EINVAL;
+	} else if (strcmp(uid, "0") == 0) {
+		i2c_dev->common.bus_id = 0;
+	} else if (strcmp(uid, "1") == 0) {
+		i2c_dev->common.bus_id = 1;
+	} else {
+		dev_err(&pdev->dev, "incorrect UID/bus id \"%s\"!\n", uid);
+		return -EINVAL;
+	}
+	dev_dbg(&pdev->dev, "bus id is %u\n", i2c_dev->common.bus_id);
+
+	/* Register the adapter */
+	amd_mp2_pm_runtime_get(mp2_dev);
+
+	i2c_dev->common.reqcmd = i2c_none;
+	if (amd_mp2_register_cb(&i2c_dev->common))
+		return -EINVAL;
+	device_link_add(&i2c_dev->pdev->dev, &mp2_dev->pci_dev->dev,
+			DL_FLAG_AUTOREMOVE_CONSUMER);
+
+	i2c_dev->common.i2c_speed = i2c_amd_get_bus_speed(pdev);
+
+	/* Setup i2c adapter description */
+	i2c_dev->adap.owner = THIS_MODULE;
+	i2c_dev->adap.algo = &i2c_amd_algorithm;
+	i2c_dev->adap.quirks = &amd_i2c_dev_quirks;
+	i2c_dev->adap.dev.parent = &pdev->dev;
+	i2c_dev->adap.algo_data = i2c_dev;
+	i2c_dev->adap.nr = pdev->id;
+	i2c_dev->adap.timeout = AMD_I2C_TIMEOUT;
+	ACPI_COMPANION_SET(&i2c_dev->adap.dev, ACPI_COMPANION(&pdev->dev));
+	i2c_dev->adap.dev.of_node = pdev->dev.of_node;
+	snprintf(i2c_dev->adap.name, sizeof(i2c_dev->adap.name),
+		 "AMD MP2 i2c bus %u", i2c_dev->common.bus_id);
+	i2c_set_adapdata(&i2c_dev->adap, i2c_dev);
+
+	init_completion(&i2c_dev->cmd_complete);
+
+	/* Enable the bus */
+	if (i2c_amd_enable_set(i2c_dev, true))
+		dev_err(&pdev->dev, "initial bus enable failed\n");
+
+	/* Attach to the i2c layer */
+	ret = i2c_add_numbered_adapter(&i2c_dev->adap);
+
+	amd_mp2_pm_runtime_put(mp2_dev);
+
+	if (ret < 0)
+		dev_err(&pdev->dev, "i2c add adapter failed = %d\n", ret);
+
+	return ret;
+}
+
+static int i2c_amd_remove(struct platform_device *pdev)
+{
+	struct amd_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
+	struct amd_i2c_common *i2c_common = &i2c_dev->common;
+
+	i2c_lock_bus(&i2c_dev->adap, I2C_LOCK_ROOT_ADAPTER);
+
+	i2c_amd_enable_set(i2c_dev, false);
+	amd_mp2_unregister_cb(i2c_common);
+	i2c_common->mp2_dev = NULL;
+
+	i2c_unlock_bus(&i2c_dev->adap, I2C_LOCK_ROOT_ADAPTER);
+
+	i2c_del_adapter(&i2c_dev->adap);
+	return 0;
+}
+
+static const struct acpi_device_id i2c_amd_acpi_match[] = {
+	{ "AMDI0011" },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, i2c_amd_acpi_match);
+
+static struct platform_driver i2c_amd_plat_driver = {
+	.probe = i2c_amd_probe,
+	.remove = i2c_amd_remove,
+	.driver = {
+		.name = "i2c_amd_mp2",
+		.acpi_match_table = ACPI_PTR(i2c_amd_acpi_match),
+	},
+};
+
+int i2c_amd_register_driver(void)
+{
+	return platform_driver_register(&i2c_amd_plat_driver);
+}
+
+void i2c_amd_unregister_driver(void)
+{
+	platform_driver_unregister(&i2c_amd_plat_driver);
+}
diff --git a/drivers/i2c/busses/i2c-amd-mp2.h b/drivers/i2c/busses/i2c-amd-mp2.h
new file mode 100644
index 000000000000..189329e7fa4a
--- /dev/null
+++ b/drivers/i2c/busses/i2c-amd-mp2.h
@@ -0,0 +1,228 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/*
+ * AMD MP2 I2C adapter driver
+ *
+ * Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+ *          Elie Morisse <syniurge@gmail.com>
+ */
+
+#ifndef I2C_AMD_PCI_MP2_H
+#define I2C_AMD_PCI_MP2_H
+
+#include <linux/i2c.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+
+#define PCI_DEVICE_ID_AMD_MP2	0x15E6
+
+struct amd_i2c_common;
+struct amd_mp2_dev;
+
+enum {
+	/* MP2 C2P Message Registers */
+	AMD_C2P_MSG0 = 0x10500,			/* MP2 Message for I2C0 */
+	AMD_C2P_MSG1 = 0x10504,			/* MP2 Message for I2C1 */
+	AMD_C2P_MSG2 = 0x10508,			/* DRAM Address Lo / Data 0 */
+	AMD_C2P_MSG3 = 0x1050c,			/* DRAM Address HI / Data 1 */
+	AMD_C2P_MSG4 = 0x10510,			/* Data 2 */
+	AMD_C2P_MSG5 = 0x10514,			/* Data 3 */
+	AMD_C2P_MSG6 = 0x10518,			/* Data 4 */
+	AMD_C2P_MSG7 = 0x1051c,			/* Data 5 */
+	AMD_C2P_MSG8 = 0x10520,			/* Data 6 */
+	AMD_C2P_MSG9 = 0x10524,			/* Data 7 */
+
+	/* MP2 P2C Message Registers */
+	AMD_P2C_MSG0 = 0x10680,			/* Do not use */
+	AMD_P2C_MSG1 = 0x10684,			/* I2C0 interrupt register */
+	AMD_P2C_MSG2 = 0x10688,			/* I2C1 interrupt register */
+	AMD_P2C_MSG3 = 0x1068C,			/* MP2 debug info */
+	AMD_P2C_MSG_INTEN = 0x10690,		/* MP2 interrupt gen register */
+	AMD_P2C_MSG_INTSTS = 0x10694,		/* Interrupt status */
+};
+
+/* Command register data structures */
+
+#define i2c_none (-1)
+enum i2c_cmd {
+	i2c_read = 0,
+	i2c_write,
+	i2c_enable,
+	i2c_disable,
+	number_of_sensor_discovered,
+	is_mp2_active,
+	invalid_cmd = 0xF,
+};
+
+enum speed_enum {
+	speed100k = 0,
+	speed400k = 1,
+	speed1000k = 2,
+	speed1400k = 3,
+	speed3400k = 4
+};
+
+enum mem_type {
+	use_dram = 0,
+	use_c2pmsg = 1,
+};
+
+/**
+ * union i2c_cmd_base : bit access of C2P commands
+ * @i2c_cmd: bit 0..3 i2c R/W command
+ * @bus_id: bit 4..7 i2c bus index
+ * @slave_addr: bit 8..15 slave address
+ * @length: bit 16..27 read/write length
+ * @i2c_speed: bit 28..30 bus speed
+ * @mem_type: bit 31 0-DRAM; 1-C2P msg o/p
+ */
+union i2c_cmd_base {
+	u32 ul;
+	struct {
+		enum i2c_cmd i2c_cmd : 4;
+		u8 bus_id : 4;
+		u32 slave_addr : 8;
+		u32 length : 12;
+		enum speed_enum i2c_speed : 3;
+		enum mem_type mem_type : 1;
+	} s;
+};
+
+enum response_type {
+	invalid_response = 0,
+	command_success = 1,
+	command_failed = 2,
+};
+
+enum status_type {
+	i2c_readcomplete_event = 0,
+	i2c_readfail_event = 1,
+	i2c_writecomplete_event = 2,
+	i2c_writefail_event = 3,
+	i2c_busenable_complete = 4,
+	i2c_busenable_failed = 5,
+	i2c_busdisable_complete = 6,
+	i2c_busdisable_failed = 7,
+	invalid_data_length = 8,
+	invalid_slave_address = 9,
+	invalid_i2cbus_id = 10,
+	invalid_dram_addr = 11,
+	invalid_command = 12,
+	mp2_active = 13,
+	numberof_sensors_discovered_resp = 14,
+	i2c_bus_notinitialized
+};
+
+/**
+ * union i2c_event : bit access of P2C events
+ * @response: bit 0..1 i2c response type
+ * @status: bit 2..6 status_type
+ * @mem_type: bit 7 0-DRAM; 1-C2P msg o/p
+ * @bus_id: bit 8..11 i2c bus id
+ * @length: bit 12..23 message length
+ * @slave_addr: bit 24-31 slave address
+ */
+union i2c_event {
+	u32 ul;
+	struct {
+		enum response_type response : 2;
+		enum status_type status : 5;
+		enum mem_type mem_type : 1;
+		u8 bus_id : 4;
+		u32 length : 12;
+		u32 slave_addr : 8;
+	} r;
+};
+
+/**
+ * struct amd_i2c_common - per bus/i2c adapter context, shared
+ *	between the pci and the platform driver
+ * @eventval: MP2 event value set by the IRQ handler
+ * @mp2_dev: MP2 pci device this adapter is part of
+ * @msg: i2c message
+ * @reqcmd: requested i2c command type
+ * @cmd_success: set to true if the MP2 responded to a command with
+ *		 the expected status and response type
+ * @bus_id: bus index
+ * @i2c_speed: i2c bus speed determined by the slowest slave
+ * @dma_buf: if msg length > 32, holds the DMA buffer virtual address
+ * @dma_addr: if msg length > 32, holds the DMA buffer address
+ */
+struct amd_i2c_common {
+	union i2c_event eventval;
+	struct amd_mp2_dev *mp2_dev;
+	struct i2c_msg *msg;
+	enum i2c_cmd reqcmd;
+	u8 cmd_success;
+	u8 bus_id;
+	enum speed_enum i2c_speed;
+	u8 *dma_buf;
+	dma_addr_t dma_addr;
+};
+
+/**
+ * struct amd_mp2_dev - per PCI device context
+ * @pci_dev: PCI driver node
+ * @busses: MP2 devices may have up to two busses,
+ *	    each bus corresponding to an i2c adapter
+ * @mmio: iommapped registers
+ * @c2p_lock: controls access to the C2P mailbox shared between
+ *	      the two adapters
+ * @c2p_lock_busid: id of the adapter which locked c2p_lock
+ */
+struct amd_mp2_dev {
+	struct pci_dev *pci_dev;
+	struct amd_i2c_common *busses[2];
+	void __iomem *mmio;
+	struct mutex c2p_lock;
+	u8 c2p_lock_busid;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_dir;
+	struct dentry *debugfs_info;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+#define ndev_pdev(ndev) ((ndev)->pci_dev)
+#define ndev_name(ndev) pci_name(ndev_pdev(ndev))
+#define ndev_dev(ndev) (&ndev_pdev(ndev)->dev)
+#define work_amd_i2c_common(__work) \
+	container_of(__work, struct amd_i2c_common, work.work)
+
+/* PCIe communication driver */
+
+int amd_mp2_read(struct amd_i2c_common *i2c_common);
+int amd_mp2_write(struct amd_i2c_common *i2c_common);
+int amd_mp2_bus_enable_set(struct amd_i2c_common *i2c_common, bool enable);
+
+void amd_mp2_process_event(struct amd_i2c_common *i2c_common);
+
+void amd_mp2_rw_timeout(struct amd_i2c_common *i2c_common);
+
+int amd_mp2_register_cb(struct amd_i2c_common *i2c_common);
+int amd_mp2_unregister_cb(struct amd_i2c_common *i2c_common);
+
+struct amd_mp2_dev *amd_mp2_find_device(void);
+
+static inline void amd_mp2_pm_runtime_get(struct amd_mp2_dev *mp2_dev)
+{
+	pm_runtime_get_sync(&mp2_dev->pci_dev->dev);
+}
+
+static inline void amd_mp2_pm_runtime_put(struct amd_mp2_dev *mp2_dev)
+{
+	pm_runtime_mark_last_busy(&mp2_dev->pci_dev->dev);
+	pm_runtime_put_autosuspend(&mp2_dev->pci_dev->dev);
+}
+
+/* Platform driver */
+
+void i2c_amd_cmd_completion(struct amd_i2c_common *i2c_common);
+
+#ifdef CONFIG_PM
+int i2c_amd_suspend(struct amd_i2c_common *i2c_common);
+int i2c_amd_resume(struct amd_i2c_common *i2c_common);
+#endif /* CONFIG_PM */
+
+int i2c_amd_register_driver(void);
+void i2c_amd_unregister_driver(void);
+
+#endif
-- 
2.17.1

