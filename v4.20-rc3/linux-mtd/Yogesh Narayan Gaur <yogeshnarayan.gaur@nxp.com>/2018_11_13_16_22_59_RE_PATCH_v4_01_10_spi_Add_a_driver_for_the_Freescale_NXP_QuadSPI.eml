Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from pop3.zju.edu.cn (61.164.42.155:110) by
  likexu-MOBL1.ccr.corp.intel.com with POP3; 13 Nov 2018 15:22:03 -0000
Received: from icoremail.net (unknown [209.85.214.172])
	by mail-app2 (Coremail) with SMTP id by_KCgD3_48aiupb+pCEAQ--.6228S3;
	Tue, 13 Nov 2018 16:23:55 +0800 (CST)
Received: from mail-pl1-f172.google.com (unknown [209.85.214.172])
	by mx2.icoremail.net (Coremail) with SMTP id AQAAfwBXP0sYiupblP42AA--.4728S3;
	Tue, 13 Nov 2018 16:23:52 +0800 (CST)
Received: by mail-pl1-f172.google.com with SMTP id p16-v6so5626775plr.8
        for <xuliker@zju.edu.cn>; Tue, 13 Nov 2018 00:23:52 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:delivered-to:dkim-signature:from:to:cc:subject
         :thread-topic:thread-index:date:message-id:references:in-reply-to
         :accept-language:content-language:spamdiagnosticoutput
         :spamdiagnosticmetadata:content-transfer-encoding:mime-version
         :sender:precedence:list-id;
        bh=FkLtOpl49WSV3nHsjESKGmdLjfpGbmmrPRgGwGFzbyw=;
        b=ji7zjav4NjiC+TTvLnI1+ojUY05Bm8ZcOMa+xQyIfdPK6kXbyiqtkOBt+EvGxnW9le
         kD+1IOsglRT9xBiil78VzE1/ivNBxX7WZ33t5BEz9tg9lA/eCFECm4K2XhBdaGLiDVNp
         FVjk5ZV2H+4y0v3S6rTggyxUH6IFZxIg/IdCLtlUqMCr7Wd9rHay+rRWo8vg4FmQVNT3
         6W7/t7Dw8hfOZRw+PRVNmSjedeSDUCVfQGE20r0KdwYeH2oq0QV3UcP5HRd5rMZ4SPh2
         rNylL3gQJYSQ+SwGsQVQdPUx+GYjB45TenCf2xDYyfBZU4bj4wthF7cJq/VOgXNzW47P
         LW9Q==
X-Gm-Message-State: AGRZ1gIe1p6LCaYMZy5WzOTvwIx1Xn/d6G2ceUOrgw661QCOL/GXIgVk
	G6Eq5nOimwe1zRyF+GW+NMcu84GIgDa0RsGkydH35+LYR3n3h5K2Rg==
X-Received: by 2002:a17:902:6b4b:: with SMTP id g11-v6mr4117569plt.213.1542097431392;
        Tue, 13 Nov 2018 00:23:51 -0800 (PST)
X-Forwarded-To: xuliker@zju.edu.cn
X-Forwarded-For: liker.xu@gmail.com xuliker@zju.edu.cn
Delivered-To: liker.xu@gmail.com
Received: by 2002:a17:90a:c304:0:0:0:0 with SMTP id g4-v6csp4183298pjt;
        Tue, 13 Nov 2018 00:23:49 -0800 (PST)
X-Google-Smtp-Source: AJdET5forjDPMf+43RIFc4ya5vh2h8hh4ept2dXy2zN1z6ODzcMQ1QAXoq2SaatHLhT+haTJQKzo
X-Received: by 2002:a62:4bc2:: with SMTP id d63-v6mr4405557pfj.170.1542097429887;
        Tue, 13 Nov 2018 00:23:49 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1542097429; cv=none;
        d=google.com; s=arc-20160816;
        b=t9JQTf7QlPCxdXghTgsqu65JgyKYiX1TL7vwYXJRsMYV2rgA5LJJ7MaAouijPQCoJG
         +2cT++D3bgfZE5m3OSkj51vJk/c92BhuZYsUk9rXIEYizFWe2cb1MpxJQCZ3BBdMoE+k
         IECzojddr3qvUUkxYIB9nxh3FJxpyxsQXySpON660aLDf67H0Wmv3CV9vLqmfC6oCCb+
         tmV13Zx7V5/vF92Llt51jPWPuN2UJRb8E65o2bIkWTQ1h2A3AW6rPniJsHLLl83zcb6b
         TajKCiygtMFrE63+ZVzAblRaxIrBNNwCx+i5oz3HB9x0ix/lCm4a/2tj6B2Y51aqp29q
         1XPQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=list-id:precedence:sender:mime-version:content-transfer-encoding
         :spamdiagnosticmetadata:spamdiagnosticoutput:content-language
         :accept-language:in-reply-to:references:message-id:date:thread-index
         :thread-topic:subject:cc:to:from:dkim-signature;
        bh=FkLtOpl49WSV3nHsjESKGmdLjfpGbmmrPRgGwGFzbyw=;
        b=gnCzB57IO9LkCGhgqWvnu6I7W2HFs5fSOKd9Zb1oCu8wqQ/vh5bme3Toyc/+ydtLD5
         9V5bzt7ammCYQmfuA/RsxH/XaIQmfqC4ERBhHW/6DSRkXgsgKSyzrnkYSAGXwoP07Lj/
         vfCflMqUu8QhyNN/B4JQbLRMGY46v5FmdpU//teGD774R3Tg8kMKk/lvOq0DY3fdY0cA
         4/4jCoSkDA1mOADV34ssdt0sIcLYFhKMN3EZw6V3ARjz80n89KA+HSQslGs8yKXB3Qqa
         5KennsaKtZaSmbOmjhFNXITr7LfHKXNFP0wP2M3++uPYZF/B6iqde6hmdzzeddmxtOIJ
         91Qg==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=pass header.i=@nxp.com header.s=selector1 header.b=XNnY+ELf;
       spf=pass (google.com: best guess record for domain of linux-kernel-owner@vger.kernel.org designates 209.132.180.67 as permitted sender) smtp.mailfrom=linux-kernel-owner@vger.kernel.org;
       dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=nxp.com
Received: from vger.kernel.org (vger.kernel.org. [209.132.180.67])
        by mx.google.com with ESMTP id r24-v6si17189932pgv.380.2018.11.13.00.23.17;
        Tue, 13 Nov 2018 00:23:49 -0800 (PST)
Received-SPF: pass (google.com: best guess record for domain of linux-kernel-owner@vger.kernel.org designates 209.132.180.67 as permitted sender) client-ip=209.132.180.67;
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1731217AbeKMSUN (ORCPT <rfc822;revogelaar@gmail.com>
        + 99 others); Tue, 13 Nov 2018 13:20:13 -0500
Received: from mail-eopbgr60075.outbound.protection.outlook.com ([40.107.6.75]:63061
        "EHLO EUR04-DB3-obe.outbound.protection.outlook.com"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1730969AbeKMSUM (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 13 Nov 2018 13:20:12 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=nxp.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=FkLtOpl49WSV3nHsjESKGmdLjfpGbmmrPRgGwGFzbyw=;
 b=XNnY+ELfVgAwuKfUA1ctUijLl4QVqkGeQeWEUZumOdFwa5cziLpOY/I8mtl3geMSt7lK6Rj8vpOOwhIGAVIDo5RTQYMVjB/3ZQwQgzjP9ab4MFahwQSdGHpkFxOG7FdG93uQcCp5h+z0PtO+MlzjMtpqJE2Tc+M1EUQ7uC9nGkk=
Received: from VI1PR04MB5726.eurprd04.prod.outlook.com (20.178.127.24) by
 VI1PR04MB1102.eurprd04.prod.outlook.com (10.161.109.24) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1294.24; Tue, 13 Nov 2018 08:22:59 +0000
Received: from VI1PR04MB5726.eurprd04.prod.outlook.com
 ([fe80::297b:bb50:9b83:48e1]) by VI1PR04MB5726.eurprd04.prod.outlook.com
 ([fe80::297b:bb50:9b83:48e1%4]) with mapi id 15.20.1294.045; Tue, 13 Nov 2018
 08:22:59 +0000
From: Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>
To: Frieder Schrempf <frieder.schrempf@kontron.de>,
        "linux-mtd@lists.infradead.org" <linux-mtd@lists.infradead.org>,
        "boris.brezillon@bootlin.com" <boris.brezillon@bootlin.com>,
        "linux-spi@vger.kernel.org" <linux-spi@vger.kernel.org>
CC: "dwmw2@infradead.org" <dwmw2@infradead.org>,
        "computersforpeace@gmail.com" <computersforpeace@gmail.com>,
        "marek.vasut@gmail.com" <marek.vasut@gmail.com>,
        "richard@nod.at" <richard@nod.at>,
        "miquel.raynal@bootlin.com" <miquel.raynal@bootlin.com>,
        "broonie@kernel.org" <broonie@kernel.org>,
        David Wolfe <david.wolfe@nxp.com>,
        Fabio Estevam <fabio.estevam@nxp.com>,
        Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>,
        Han Xu <han.xu@nxp.com>,
        "shawnguo@kernel.org" <shawnguo@kernel.org>,
        Frieder Schrempf <frieder.schrempf@exceet.de>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: RE: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Topic: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Index: AQHUdqhUG2DxLc9MI0etfXbC+DhZ+aVNU0xQ
Date: Tue, 13 Nov 2018 08:22:59 +0000
Message-ID: <VI1PR04MB57269B88E1A064F6429D410999C20@VI1PR04MB5726.eurprd04.prod.outlook.com>
References: <1541601809-16950-1-git-send-email-frieder.schrempf@kontron.de>
 <1541601809-16950-2-git-send-email-frieder.schrempf@kontron.de>
In-Reply-To: <1541601809-16950-2-git-send-email-frieder.schrempf@kontron.de>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [14.142.187.166]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1;VI1PR04MB1102;6:Lm9Hkgbx72f5wGGwU79vwoXsvllEF89OZHbMCEf717woM9nrRetD+hoGB6I03ptcg3SQqVwLj3fevaix6YtZNJheilK7eqJHShrYx9NjNMKkha079p9i2iecpxmd024Dos/tlPY5tVIVyHrn536Egt1TjiJ1IRop5CTAUxGQe8e6Mq8aLPE/cn3rCpOP+uT9eJu1MdSAzOLDTBF5Nol0SdmlLDhtrCPECsgICQvLNrwbVMuYULHLRvnmSIdrL5bj3gNTr7DZeeTtKrg20ANpL0PiZ/v54suLLn+ra6gk8wlJ7ty8HLmIhMcm9v4YmqrfbfSEAW//otT66hYP1YFDlsBm5MuUuzOskSY+fWu+t0XK7NGz/U+OpT+7KQLb4hU7YJ/wuD/Z50fUiA7luWtCm3w2iRh00xM13+Iw1sjs8zlNVUtDRqCNXBlTVG100uycR0PgyRf/nN65JAu51KU32g==;5:wrdH5fH9uMxraGcs7TM8C4cjeiDieb+7mujY+8ZSHxRUMpU32V9FzvdvuM/+3//R7fbBc2ZHtsNz4OzsKOrs2dyUUcIbk+8lg8nLlxAGHngxCKnXMf7zuKSeW5CnOxNkAruNUyPM7CXBU2fLmSYZPszbJU8tVGHpBodby8yXs6Q=;7:WddhzPVpXIVqYYZTEBS93qG5j5UHC20gWYSne7nWqhYkBn+0o7A1QVKZ4p5r7BEU9LHQZWFUE0eNjI1/pQWKzBIcIMs5WRrK+7+ZzvUy+5qDyX5jMXbNaHwWudK8rI0Jyyc1DVxXeWxE/o1Cvjtmbw==
x-ms-exchange-antispam-srfa-diagnostics: SOS;
x-ms-office365-filtering-correlation-id: a0a3debb-5ada-47bb-cee1-08d649413911
x-ms-office365-filtering-ht: Tenant
x-microsoft-antispam: BCL:0;PCL:0;RULEID:(2390060)(7020095)(4652040)(8989299)(5600074)(711020)(4618075)(4534185)(7168020)(4627221)(201703031133081)(201702281549075)(8990200)(2017052603328)(7153060)(7193020);SRVR:VI1PR04MB1102;
x-ms-traffictypediagnostic: VI1PR04MB1102:
x-microsoft-antispam-prvs: <VI1PR04MB11025ECDBE186C360E45F2EF99C20@VI1PR04MB1102.eurprd04.prod.outlook.com>
x-exchange-antispam-report-test: UriScan:(258649278758335)(9452136761055)(85827821059158)(269456686620040)(185117386973197);
x-ms-exchange-senderadcheck: 1
x-exchange-antispam-report-cfa-test: BCL:0;PCL:0;RULEID:(8211001083)(6040522)(2401047)(5005006)(8121501046)(93006095)(93001095)(10201501046)(3002001)(3231382)(944501410)(52105112)(6055026)(148016)(149066)(150057)(6041310)(20161123558120)(20161123564045)(20161123560045)(20161123562045)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(201708071742011)(7699051)(76991095);SRVR:VI1PR04MB1102;BCL:0;PCL:0;RULEID:;SRVR:VI1PR04MB1102;
x-forefront-prvs: 085551F5A8
x-forefront-antispam-report: SFV:NSPM;SFS:(10009020)(136003)(366004)(396003)(346002)(39860400002)(376002)(13464003)(189003)(199004)(6436002)(55016002)(5660300001)(97736004)(7736002)(74316002)(2906002)(81156014)(81166006)(110136005)(54906003)(4744004)(68736007)(8676002)(316002)(25786009)(4326008)(71200400001)(2201001)(71190400001)(575784001)(53936002)(7416002)(9686003)(2501003)(78486014)(2900100001)(53946003)(6246003)(478600001)(86362001)(99286004)(33656002)(14444005)(8936002)(256004)(6506007)(14454004)(102836004)(55236004)(53546011)(66066001)(76176011)(7696005)(26005)(186003)(229853002)(105586002)(486006)(305945005)(106356001)(39060400002)(3846002)(6116002)(11346002)(446003)(476003)(569006);DIR:OUT;SFP:1101;SCL:1;SRVR:VI1PR04MB1102;H:VI1PR04MB5726.eurprd04.prod.outlook.com;FPR:;SPF:None;LANG:en;PTR:InfoNoRecords;MX:1;A:1;
received-spf: None (protection.outlook.com: nxp.com does not designate
 permitted sender hosts)
x-microsoft-antispam-message-info: /9iTKsRqi5RgYZflIMptaN03QomCX/MqJYhkU3DIqYFGYPT6g/HrZgw1IKZQFEHq88eJCWsOCmZbghkzRYHKB+fo8jj6nzX48sPeXu9zX0laXvd/RMUzd2fybBUJ8Llk0s8X7+Z0S0nr4V6jG/aKDPwC0AqEFLdX5rtJJE9wdj0x/MI9gTqHsdnjNNlDg9os90fGeH24Pw9YTc3hh6DyhAxiDEwjsYWe4hmV12fdzOdjyxzKlKF2CDbRZBsHc4TKO6Ddljtke3K+IU5VbmfSz0PEVv9pNbPjqeX592UkuG0OoVJCufIuLugq4O7U++50EdMi4fCzM/0z5hzVrIu8AzVDQjtdy7ycjK44Goqv2pk=
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-OriginatorOrg: nxp.com
X-MS-Exchange-CrossTenant-Network-Message-Id: a0a3debb-5ada-47bb-cee1-08d649413911
X-MS-Exchange-CrossTenant-originalarrivaltime: 13 Nov 2018 08:22:59.6852
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 686ea1d3-bc2b-4c6f-a92c-d99c5c301635
X-MS-Exchange-Transport-CrossTenantHeadersStamped: VI1PR04MB1102
Sender: liker.xu+caf_=xuliker=zju.edu.cn@gmail.com
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-CM-TRANSID: AQAAfwBXP0sYiupblP42AA--.4728S3
Authentication-Results: mail-app2; spf=pass smtp.mail=liker.xu+caf_=xu
	liker=zju.edu.cn@gmail.com;
X-Coremail-Antispam: 1UD129KBjvAXoWfXF17tr4xtrW8WF4UGFykZrb_yoW5AFWkGo
	Z3AF1xZw15tw1xArW8Grn7Xr9Igw18G398ArZ0yrZ5Gw12va4UKr4rWa17WF95W3W3Kr1f
	try7GrWrWay0yw17n29KB7ZKAUJUUUUU529EdanIXcx71UUUUj7v73VFW2AGmfu7jjvjm3
	AaLaJ3UjIYCTnIWjp_UUUYK7k0a2IF6w4kM7kC6x804xWl14x267AKxVWUJVW8JwAFIxvE
	14AKwVWUJVWUGwA2ocxC64kIII0Yj41l84x0c7CEw4AK67xGY2AK021l84ACjcxK6xIIjx
	v20xvE14v26F1j6w1UM28EF7xvwVC0I7IYx2IY6xkF7I0E14v26F4j6r4UJwA2z4x0Y4vE
	x4A2jsIE14v26rxl6s0DM28EF7xvwVC2z280aVCY1x0267AKxVW0oVCq3wAS0I0E0xvYzx
	vE52x082IY62kv0487Mc02F40EFcxC0VAKzVAqx4xG6I80ewAv7VC0I7IYx2IY67AKxVWU
	JVWUGwAv7VC2z280aVAFwI0_Gr0_Cr1lOx8S6xCaFVCjc4AY6r1j6r4UMx02cVCv0xWlc7
	CjxVAKzI0EY4vE52x082I5MxkFs20EY4vE44CYbxCE4x80FwCY02Avz4vEIxC_GFylc2Ij
	II80xcxEwVAKI48JMxvI42IY6xIIjxv20xvE14v26r1j6r1xMxvI42IY6xIIjxv20xvEc7
	CjxVAFwI0_Jr0_Gr1lcIIF0xvEx4A2jsIE14v26F4UJVW0owCYIxAIcVC2z280aVCY1x02
	67AKxVWxJr0_GcWl42xK82IYc2Ij64vIr41l42xK82IY64kExVAvwVAq07x20xyl4x8a6x
	804xWl4I8I3I0E4IkC6x0Yz7v_Jr0_Gr1lx2IqxVAqx4xG67AKxVWUJVWUGwC20s026x8G
	jcxK67AKxVWUGVWUWwC2zVAF1VAY17CE14v26r4a6rW5MIIYrxkI7VAKI48JMIIF0xvE42
	xK8VAvwI8IcIk0rVWrJr0_WFyUJbIYCTnIWIevJa73UjIFyTuYvjxUHiZcUUUUU

Hi,

> -----Original Message-----
> From: Frieder Schrempf [mailto:frieder.schrempf@kontron.de]
> Sent: Wednesday, November 7, 2018 8:13 PM
> To: linux-mtd@lists.infradead.org; boris.brezillon@bootlin.com; linux-
> spi@vger.kernel.org
> Cc: dwmw2@infradead.org; computersforpeace@gmail.com;
> marek.vasut@gmail.com; richard@nod.at; miquel.raynal@bootlin.com;
> broonie@kernel.org; David Wolfe <david.wolfe@nxp.com>; Fabio Estevam
> <fabio.estevam@nxp.com>; Prabhakar Kushwaha
> <prabhakar.kushwaha@nxp.com>; Yogesh Narayan Gaur
> <yogeshnarayan.gaur@nxp.com>; Han Xu <han.xu@nxp.com>;
> shawnguo@kernel.org; Frieder Schrempf <frieder.schrempf@exceet.de>; linux=
-
> kernel@vger.kernel.org
> Subject: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP QuadSPI
> controller
>=20
> From: Frieder Schrempf <frieder.schrempf@exceet.de>
>=20
> This driver is derived from the SPI NOR driver at mtd/spi-nor/fsl-quadspi=
.c. It
> uses the new SPI memory interface of the SPI framework to issue flash mem=
ory
> operations to up to four connected flash chips (2 buses with 2 CS each).
>=20
> The controller does not support generic SPI messages.
>=20
> Signed-off-by: Frieder Schrempf <frieder.schrempf@exceet.de>
> ---
>  drivers/spi/Kconfig        |  11 +
>  drivers/spi/Makefile       |   1 +
>  drivers/spi/spi-fsl-qspi.c | 948 +++++++++++++++++++++++++++++++++++++++=
+
>  3 files changed, 960 insertions(+)
>=20
> diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig index 7d3a5c9..52e=
2298
> 100644
> --- a/drivers/spi/Kconfig
> +++ b/drivers/spi/Kconfig
> @@ -259,6 +259,17 @@ config SPI_FSL_LPSPI
>  	help
>  	  This enables Freescale i.MX LPSPI controllers in master mode.
>=20
> +config SPI_FSL_QSPI
> +	tristate "Freescale QSPI controller"
> +	depends on ARCH_MXC || SOC_LS1021A || ARCH_LAYERSCAPE ||
> COMPILE_TEST
> +	depends on HAS_IOMEM
> +	help
> +	  This enables support for the Quad SPI controller in master mode.
> +	  Up to four flash chips can be connected on two buses with two
> +	  chipselects each.
> +	  This controller does not support generic SPI messages. It only
> +	  supports the high-level SPI memory interface.
> +
>  config SPI_GPIO
>  	tristate "GPIO-based bitbanging SPI Master"
>  	depends on GPIOLIB || COMPILE_TEST
> diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile index 3575205..8=
33b9e7
> 100644
> --- a/drivers/spi/Makefile
> +++ b/drivers/spi/Makefile
> @@ -44,6 +44,7 @@ obj-$(CONFIG_SPI_FSL_DSPI)		+=3D spi-fsl-
> dspi.o
>  obj-$(CONFIG_SPI_FSL_LIB)		+=3D spi-fsl-lib.o
>  obj-$(CONFIG_SPI_FSL_ESPI)		+=3D spi-fsl-espi.o
>  obj-$(CONFIG_SPI_FSL_LPSPI)		+=3D spi-fsl-lpspi.o
> +obj-$(CONFIG_SPI_FSL_QSPI)		+=3D spi-fsl-qspi.o
>  obj-$(CONFIG_SPI_FSL_SPI)		+=3D spi-fsl-spi.o
>  obj-$(CONFIG_SPI_GPIO)			+=3D spi-gpio.o
>  obj-$(CONFIG_SPI_IMG_SPFI)		+=3D spi-img-spfi.o
> diff --git a/drivers/spi/spi-fsl-qspi.c b/drivers/spi/spi-fsl-qspi.c new =
file mode
> 100644 index 0000000..a43cfe8
> --- /dev/null
> +++ b/drivers/spi/spi-fsl-qspi.c
> @@ -0,0 +1,948 @@
> +// SPDX-License-Identifier: GPL-2.0+
> +
> +/*
> + * Freescale QuadSPI driver.
> + *
> + * Copyright (C) 2013 Freescale Semiconductor, Inc.
> + * Copyright (C) 2018 Bootlin
> + * Copyright (C) 2018 exceet electronics GmbH
> + * Copyright (C) 2018 Kontron Electronics GmbH
> + *
> + * Transition to SPI MEM interface:
> + * Author:
> + *     Boris Brezillion <boris.brezillon@bootlin.com>
> + *     Frieder Schrempf <frieder.schrempf@kontron.de>
> + *     Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
> + *     Suresh Gupta <suresh.gupta@nxp.com>
> + *
> + * Based on the original fsl-quadspi.c spi-nor driver:
> + * Author: Freescale Semiconductor, Inc.
> + *
> + */
> +
> +#include <linux/bitops.h>
> +#include <linux/clk.h>
> +#include <linux/completion.h>
> +#include <linux/delay.h>
> +#include <linux/err.h>
> +#include <linux/errno.h>
> +#include <linux/interrupt.h>
> +#include <linux/io.h>
> +#include <linux/iopoll.h>
> +#include <linux/jiffies.h>
> +#include <linux/kernel.h>
> +#include <linux/module.h>
> +#include <linux/mutex.h>
> +#include <linux/of.h>
> +#include <linux/of_device.h>
> +#include <linux/platform_device.h>
> +#include <linux/pm_qos.h>
> +#include <linux/sizes.h>
> +
> +#include <linux/spi/spi.h>
> +#include <linux/spi/spi-mem.h>
> +
> +/*
> + * The driver only uses one single LUT entry, that is updated on
> + * each call of exec_op(). Index 0 is preset at boot with a basic
> + * read operation, so let's use the last entry (15).
> + */
> +#define	SEQID_LUT			15
> +
> +/* Registers used by the driver */
> +#define QUADSPI_MCR			0x00
> +#define QUADSPI_MCR_RESERVED_MASK	GENMASK(19, 16)
> +#define QUADSPI_MCR_MDIS_MASK		BIT(14)
> +#define QUADSPI_MCR_CLR_TXF_MASK	BIT(11)
> +#define QUADSPI_MCR_CLR_RXF_MASK	BIT(10)
> +#define QUADSPI_MCR_DDR_EN_MASK		BIT(7)
> +#define QUADSPI_MCR_END_CFG_MASK	GENMASK(3, 2)
> +#define QUADSPI_MCR_SWRSTHD_MASK	BIT(1)
> +#define QUADSPI_MCR_SWRSTSD_MASK	BIT(0)
> +
> +#define QUADSPI_IPCR			0x08
> +#define QUADSPI_IPCR_SEQID(x)		((x) << 24)
> +
> +#define QUADSPI_BUF3CR			0x1c
> +#define QUADSPI_BUF3CR_ALLMST_MASK	BIT(31)
> +#define QUADSPI_BUF3CR_ADATSZ(x)	((x) << 8)
> +#define QUADSPI_BUF3CR_ADATSZ_MASK	GENMASK(15, 8)
> +
> +#define QUADSPI_BFGENCR			0x20
> +#define QUADSPI_BFGENCR_SEQID(x)	((x) << 12)
> +
> +#define QUADSPI_BUF0IND			0x30
> +#define QUADSPI_BUF1IND			0x34
> +#define QUADSPI_BUF2IND			0x38
> +#define QUADSPI_SFAR			0x100
> +
> +#define QUADSPI_SMPR			0x108
> +#define QUADSPI_SMPR_DDRSMP_MASK	GENMASK(18, 16)
> +#define QUADSPI_SMPR_FSDLY_MASK		BIT(6)
> +#define QUADSPI_SMPR_FSPHS_MASK		BIT(5)
> +#define QUADSPI_SMPR_HSENA_MASK		BIT(0)
> +
> +#define QUADSPI_RBCT			0x110
> +#define QUADSPI_RBCT_WMRK_MASK		GENMASK(4, 0)
> +#define QUADSPI_RBCT_RXBRD_USEIPS	BIT(8)
> +
> +#define QUADSPI_TBDR			0x154
> +
> +#define QUADSPI_SR			0x15c
> +#define QUADSPI_SR_IP_ACC_MASK		BIT(1)
> +#define QUADSPI_SR_AHB_ACC_MASK		BIT(2)
> +
> +#define QUADSPI_FR			0x160
> +#define QUADSPI_FR_TFF_MASK		BIT(0)
> +
> +#define QUADSPI_SPTRCLR			0x16c
> +#define QUADSPI_SPTRCLR_IPPTRC		BIT(8)
> +#define QUADSPI_SPTRCLR_BFPTRC		BIT(0)
> +
> +#define QUADSPI_SFA1AD			0x180
> +#define QUADSPI_SFA2AD			0x184
> +#define QUADSPI_SFB1AD			0x188
> +#define QUADSPI_SFB2AD			0x18c
> +#define QUADSPI_RBDR(x)			(0x200 + ((x) * 4))
> +
> +#define QUADSPI_LUTKEY			0x300
> +#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
> +
> +#define QUADSPI_LCKCR			0x304
> +#define QUADSPI_LCKER_LOCK		BIT(0)
> +#define QUADSPI_LCKER_UNLOCK		BIT(1)
> +
> +#define QUADSPI_RSER			0x164
> +#define QUADSPI_RSER_TFIE		BIT(0)
> +
> +#define QUADSPI_LUT_BASE		0x310
> +#define QUADSPI_LUT_OFFSET		(SEQID_LUT * 4 * 4)
> +#define QUADSPI_LUT_REG(idx) \
> +	(QUADSPI_LUT_BASE + QUADSPI_LUT_OFFSET + (idx) * 4)
> +
> +/* Instruction set for the LUT register */
> +#define LUT_STOP		0
> +#define LUT_CMD			1
> +#define LUT_ADDR		2
> +#define LUT_DUMMY		3
> +#define LUT_MODE		4
> +#define LUT_MODE2		5
> +#define LUT_MODE4		6
> +#define LUT_FSL_READ		7
> +#define LUT_FSL_WRITE		8
> +#define LUT_JMP_ON_CS		9
> +#define LUT_ADDR_DDR		10
> +#define LUT_MODE_DDR		11
> +#define LUT_MODE2_DDR		12
> +#define LUT_MODE4_DDR		13
> +#define LUT_FSL_READ_DDR	14
> +#define LUT_FSL_WRITE_DDR	15
> +#define LUT_DATA_LEARN		16
> +
> +/*
> + * The PAD definitions for LUT register.
> + *
> + * The pad stands for the number of IO lines [0:3].
> + * For example, the quad read needs four IO lines,
> + * so you should use LUT_PAD(4).
> + */
> +#define LUT_PAD(x) (fls(x) - 1)
> +
> +/*
> + * Macro for constructing the LUT entries with the following
> + * register layout:
> + *
> + *  ---------------------------------------------------
> + *  | INSTR1 | PAD1 | OPRND1 | INSTR0 | PAD0 | OPRND0 |
> + *  ---------------------------------------------------
> + */
> +#define LUT_DEF(idx, ins, pad, opr)					\
> +	((((ins) << 10) | ((pad) << 8) | (opr)) << (((idx) % 2) * 16))
> +
> +/* Controller needs driver to swap endianness */
> +#define QUADSPI_QUIRK_SWAP_ENDIAN	BIT(0)
> +
> +/* Controller needs 4x internal clock */
> +#define QUADSPI_QUIRK_4X_INT_CLK	BIT(1)
> +
> +/*
> + * TKT253890, the controller needs the driver to fill the txfifo with
> + * 16 bytes at least to trigger a data transfer, even though the extra
> + * data won't be transferred.
> + */
> +#define QUADSPI_QUIRK_TKT253890		BIT(2)
> +
> +/* TKT245618, the controller cannot wake up from wait mode */
> +#define QUADSPI_QUIRK_TKT245618		BIT(3)
> +
> +enum fsl_qspi_devtype {
> +	FSL_QUADSPI_VYBRID,
> +	FSL_QUADSPI_IMX6SX,
> +	FSL_QUADSPI_IMX7D,
> +	FSL_QUADSPI_IMX6UL,
> +	FSL_QUADSPI_LS1021A,
> +	FSL_QUADSPI_LS2080A,
> +};
> +
We can go away with this enum

> +struct fsl_qspi_devtype_data {
> +	enum fsl_qspi_devtype devtype;
> +	unsigned int rxfifo;
> +	unsigned int txfifo;
> +	unsigned int ahb_buf_size;
> +	unsigned int quirks;
> +	bool little_endian;
> +};
> +
> +static const struct fsl_qspi_devtype_data vybrid_data =3D {
> +	.devtype =3D FSL_QUADSPI_VYBRID,
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_SWAP_ENDIAN,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx6sx_data =3D {
> +	.devtype =3D FSL_QUADSPI_IMX6SX,
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_4X_INT_CLK | QUADSPI_QUIRK_TKT245618,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx7d_data =3D {
> +	.devtype =3D FSL_QUADSPI_IMX7D,
> +	.rxfifo =3D SZ_512,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data imx6ul_data =3D {
> +	.devtype =3D FSL_QUADSPI_IMX6UL,
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_512,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK,
> +	.little_endian =3D true,
> +};
> +
> +static const struct fsl_qspi_devtype_data ls1021a_data =3D {
> +	.devtype =3D FSL_QUADSPI_LS1021A,
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D 0,
> +	.little_endian =3D false,
> +};
> +
> +static const struct fsl_qspi_devtype_data ls2080a_data =3D {
> +	.devtype =3D FSL_QUADSPI_LS2080A,
> +	.rxfifo =3D SZ_128,
> +	.txfifo =3D SZ_64,
> +	.ahb_buf_size =3D SZ_1K,
> +	.quirks =3D QUADSPI_QUIRK_TKT253890,
> +	.little_endian =3D true,
> +};
> +
> +struct fsl_qspi {
> +	void __iomem *iobase;
> +	void __iomem *ahb_addr;
> +	u32 memmap_phy;
> +	struct clk *clk, *clk_en;
> +	struct device *dev;
> +	struct completion c;
> +	const struct fsl_qspi_devtype_data *devtype_data;
> +	struct mutex lock;
> +	struct pm_qos_request pm_qos_req;
> +	int selected;
> +	u8 seq;
> +	void (*write)(u32 val, void __iomem *addr);
> +	u32 (*read)(void __iomem *addr);
> +};
> +
> +static inline int needs_swap_endian(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_SWAP_ENDIAN; }
> +
> +static inline int needs_4x_clock(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_4X_INT_CLK; }
> +
> +static inline int needs_fill_txfifo(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT253890; }
> +
> +static inline int needs_wakeup_wait_mode(struct fsl_qspi *q) {
> +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT245618; }
> +
> +/*
> + * An IC bug makes it necessary to rearrange the 32-bit data.
> + * Later chips, such as IMX6SLX, have fixed this bug.
> + */
> +static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a) {
> +	return needs_swap_endian(q) ? __swab32(a) : a; }
> +
> +/*
> + * R/W functions for big- or little-endian registers:
> + * The QSPI controller's endianness is independent of
> + * the CPU core's endianness. So far, although the CPU
> + * core is little-endian the QSPI controller can use
> + * big-endian or little-endian.
> + */
> +static void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem
> +*addr) {
> +	if (q->devtype_data->little_endian)
> +		iowrite32(val, addr);
> +	else
> +		iowrite32be(val, addr);
> +}
> +
> +static u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr) {
> +	if (q->devtype_data->little_endian)
> +		return ioread32(addr);
> +
> +	return ioread32be(addr);
> +}
> +
> +static irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id) {
> +	struct fsl_qspi *q =3D dev_id;
> +	u32 reg;
> +
> +	/* clear interrupt */
> +	reg =3D qspi_readl(q, q->iobase + QUADSPI_FR);
> +	qspi_writel(q, reg, q->iobase + QUADSPI_FR);
> +
> +	if (reg & QUADSPI_FR_TFF_MASK)
> +		complete(&q->c);
> +
> +	dev_dbg(q->dev, "QUADSPI_FR : 0x%.8x:0x%.8x\n", 0, reg);
> +	return IRQ_HANDLED;
> +}
> +
> +static int fsl_qspi_check_buswidth(struct fsl_qspi *q, u8 width) {
> +	switch (width) {
> +	case 1:
> +	case 2:
> +	case 4:
> +		return 0;
> +	}
> +
> +	return -ENOTSUPP;
> +}
> +
> +static bool fsl_qspi_supports_op(struct spi_mem *mem,
> +				 const struct spi_mem_op *op)
> +{
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	int ret;
> +
> +	ret =3D fsl_qspi_check_buswidth(q, op->cmd.buswidth);
> +
> +	if (op->addr.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->addr.buswidth);
> +
> +	if (op->dummy.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->dummy.buswidth);
> +
> +	if (op->data.nbytes)
> +		ret |=3D fsl_qspi_check_buswidth(q, op->data.buswidth);
> +
> +	if (ret)
> +		return false;
> +
> +	/*
> +	 * The number of instructions needed for the op, needs
> +	 * to fit into a single LUT entry.
> +	 */
> +	if (op->addr.nbytes +
> +	   (op->dummy.nbytes ? 1:0) +
> +	   (op->data.nbytes ? 1:0) > 6)
> +		return false;
> +
> +	/* Max 64 dummy clock cycles supported */
> +	if (op->dummy.nbytes &&
> +	    (op->dummy.nbytes * 8 / op->dummy.buswidth > 64))
> +		return false;
> +
> +	/* Max data length, check controller limits and alignment */
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_IN &&
> +	    (op->data.nbytes > q->devtype_data->ahb_buf_size ||
> +	     (op->data.nbytes > q->devtype_data->rxfifo - 4 &&
> +	      !IS_ALIGNED(op->data.nbytes, 8))))
> +		return false;
> +
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT &&
> +	    op->data.nbytes > q->devtype_data->txfifo)
> +		return false;
> +
> +	return true;
> +}
> +
> +static void fsl_qspi_prepare_lut(struct fsl_qspi *q,
> +				 const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	u32 lutval[4] =3D {};
> +	int lutidx =3D 1, i;
> +
> +	lutval[0] |=3D LUT_DEF(0, LUT_CMD, LUT_PAD(op->cmd.buswidth),
> +			     op->cmd.opcode);
> +
> +	/*
> +	 * For some unknown reason, using LUT_ADDR doesn't work in some
> +	 * cases (at least with only one byte long addresses), so
> +	 * let's use LUT_MODE to write the address bytes one by one
> +	 */
> +	for (i =3D 0; i < op->addr.nbytes; i++) {
> +		u8 addrbyte =3D op->addr.val >> (8 * (op->addr.nbytes - i - 1));
> +
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_MODE,
> +					      LUT_PAD(op->addr.buswidth),
> +					      addrbyte);
> +		lutidx++;
> +	}
> +
> +	if (op->dummy.nbytes) {
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_DUMMY,
> +					      LUT_PAD(op->dummy.buswidth),
> +					      op->dummy.nbytes * 8 /
> +					      op->dummy.buswidth);
> +		lutidx++;
> +	}
> +
> +	if (op->data.nbytes) {
> +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx,
> +					      op->data.dir =3D=3D
> SPI_MEM_DATA_IN ?
> +					      LUT_FSL_READ : LUT_FSL_WRITE,
> +					      LUT_PAD(op->data.buswidth),
> +					      0);
> +		lutidx++;
> +	}
> +
> +	lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_STOP, 0, 0);
> +
> +	/* unlock LUT */
> +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
> +	qspi_writel(q, QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);
> +
> +	/* fill LUT */
> +	for (i =3D 0; i < ARRAY_SIZE(lutval); i++)
> +		qspi_writel(q, lutval[i], base + QUADSPI_LUT_REG(i));
> +
> +	/* lock LUT */
> +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
> +	qspi_writel(q, QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR); }
> +
> +static int fsl_qspi_clk_prep_enable(struct fsl_qspi *q) {
> +	int ret;
> +
> +	ret =3D clk_prepare_enable(q->clk_en);
> +	if (ret)
> +		return ret;
> +
> +	ret =3D clk_prepare_enable(q->clk);
> +	if (ret) {
> +		clk_disable_unprepare(q->clk_en);
> +		return ret;
> +	}
> +
> +	if (needs_wakeup_wait_mode(q))
> +		pm_qos_add_request(&q->pm_qos_req,
> PM_QOS_CPU_DMA_LATENCY, 0);
> +
> +	return 0;
> +}
> +
> +static void fsl_qspi_clk_disable_unprep(struct fsl_qspi *q) {
> +	if (needs_wakeup_wait_mode(q))
> +		pm_qos_remove_request(&q->pm_qos_req);
> +
> +	clk_disable_unprepare(q->clk);
> +	clk_disable_unprepare(q->clk_en);
> +}
> +
> +static void fsl_qspi_select_mem(struct fsl_qspi *q, struct spi_device
> +*spi) {
> +	unsigned long rate =3D spi->max_speed_hz;
> +	int ret, i;
> +	u32 map_addr;
> +
> +	if (q->selected =3D=3D spi->chip_select)
> +		return;
> +
> +	/*
> +	 * In HW there can be a maximum of four chips on two buses with
> +	 * two chip selects on each bus. We use four chip selects in SW
> +	 * to differentiate between the four chips.
> +	 * We use the SFA1AD, SFA2AD, SFB1AD, SFB2AD registers to select
> +	 * the chip we want to access.
> +	 */
> +	for (i =3D 0; i < 4; i++) {
> +		if (i < spi->chip_select)
> +			map_addr =3D q->memmap_phy;
> +		else
> +			map_addr =3D q->memmap_phy +
> +				   2 * q->devtype_data->ahb_buf_size;
> +
> +		qspi_writel(q, map_addr, q->iobase + QUADSPI_SFA1AD + (i *
> 4));
> +	}
> +
> +	if (needs_4x_clock(q))
> +		rate *=3D 4;
> +
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	ret =3D clk_set_rate(q->clk, rate);
> +	if (ret)
> +		return;
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret)
> +		return;
> +
> +	q->selected =3D spi->chip_select;
> +}
> +
> +static void fsl_qspi_read_ahb(struct fsl_qspi *q, const struct
> +spi_mem_op *op) {
> +	/*
> +	 * We want to avoid needing to invalidate the cache by issueing
> +	 * a reset to the AHB and Serial Flash domain, as this needs
> +	 * time. So we change the address on each read to trigger an
> +	 * actual read operation on the flash. The actual address for
> +	 * the flash memory is set by programming the LUT.
> +	 */
As discussed previously, please go away with this hack and use AHB bus inva=
lidation method with smaller timeout value.

I would start doing validation of this patch series from next version onwar=
d. As you have mentioned in other mail discussion about issue in the break =
condition for function  fsl_qspi_readl_poll_tout().

--
Regards
Yogesh Gaur

> +	memcpy_fromio(op->data.buf.in,
> +		      q->ahb_addr +
> +		      (((q->seq & (1 << q->selected)) =3D=3D 0 ? 0:1) *
> +		       q->devtype_data->ahb_buf_size),
> +		      op->data.nbytes);
> +
> +	q->seq ^=3D 1 << q->selected;
> +}
> +
> +static void fsl_qspi_fill_txfifo(struct fsl_qspi *q,
> +				 const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	int i;
> +	u32 val;
> +
> +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> +		memcpy(&val, op->data.buf.out + i, 4);
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		qspi_writel(q, val, base + QUADSPI_TBDR);
> +	}
> +
> +	if (i < op->data.nbytes) {
> +		memcpy(&val, op->data.buf.out + i, op->data.nbytes - i);
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		qspi_writel(q, val, base + QUADSPI_TBDR);
> +	}
> +
> +	if (needs_fill_txfifo(q)) {
> +		for (i =3D op->data.nbytes; i < 16; i +=3D 4)
> +			qspi_writel(q, 0, base + QUADSPI_TBDR);
> +	}
> +}
> +
> +static void fsl_qspi_read_rxfifo(struct fsl_qspi *q,
> +			  const struct spi_mem_op *op)
> +{
> +	void __iomem *base =3D q->iobase;
> +	int i;
> +	u8 *buf =3D op->data.buf.in;
> +	u32 val;
> +
> +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		memcpy(buf + i, &val, 4);
> +	}
> +
> +	if (i < op->data.nbytes) {
> +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> +		val =3D fsl_qspi_endian_xchg(q, val);
> +		memcpy(buf + i, &val, op->data.nbytes - i);
> +	}
> +}
> +
> +static int fsl_qspi_do_op(struct fsl_qspi *q, const struct spi_mem_op
> +*op) {
> +	void __iomem *base =3D q->iobase;
> +	int err =3D 0;
> +
> +	init_completion(&q->c);
> +
> +	/*
> +	 * Always start the sequence at the same index since we update
> +	 * the LUT at each exec_op() call. And also specify the DATA
> +	 * length, since it's has not been specified in the LUT.
> +	 */
> +	qspi_writel(q, op->data.nbytes | QUADSPI_IPCR_SEQID(SEQID_LUT),
> +		    base + QUADSPI_IPCR);
> +
> +	/* Wait for the interrupt. */
> +	if (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000)))
> +		err =3D -ETIMEDOUT;
> +
> +	if (!err && op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_IN)
> +		fsl_qspi_read_rxfifo(q, op);
> +
> +	return err;
> +}
> +
> +static int fsl_qspi_readl_poll_tout(struct fsl_qspi *q, void __iomem *ba=
se,
> +				    u32 mask, u32 delay_us, u32 timeout_us) {
> +	u32 reg;
> +
> +	if (!q->devtype_data->little_endian)
> +		mask =3D (u32)cpu_to_be32(mask);
> +
> +	return readl_poll_timeout(base, reg, (reg & mask), delay_us,
> +				  timeout_us);
> +}
> +
> +static int fsl_qspi_exec_op(struct spi_mem *mem, const struct
> +spi_mem_op *op) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	void __iomem *base =3D q->iobase;
> +	int err =3D 0;
> +
> +	mutex_lock(&q->lock);
> +
> +	fsl_qspi_readl_poll_tout(q, base + QUADSPI_SR,
> (QUADSPI_SR_IP_ACC_MASK |
> +				 QUADSPI_SR_AHB_ACC_MASK), 10, 1000);
> +
> +	fsl_qspi_select_mem(q, mem->spi);
> +
> +	qspi_writel(q, q->memmap_phy, base + QUADSPI_SFAR);
> +
> +	qspi_writel(q, qspi_readl(q, base + QUADSPI_MCR) |
> +		    QUADSPI_MCR_CLR_RXF_MASK |
> QUADSPI_MCR_CLR_TXF_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	qspi_writel(q, QUADSPI_SPTRCLR_BFPTRC | QUADSPI_SPTRCLR_IPPTRC,
> +		    base + QUADSPI_SPTRCLR);
> +
> +	fsl_qspi_prepare_lut(q, op);
> +
> +	/*
> +	 * If we have large chunks of data, we read them through the AHB bus
> +	 * by accessing the mapped memory. In all other cases we use
> +	 * IP commands to access the flash.
> +	 */
> +	if (op->data.nbytes > (q->devtype_data->rxfifo - 4) &&
> +	    op->data.dir =3D=3D SPI_MEM_DATA_IN) {
> +		fsl_qspi_read_ahb(q, op);
> +	} else {
> +		qspi_writel(q, QUADSPI_RBCT_WMRK_MASK |
> +			    QUADSPI_RBCT_RXBRD_USEIPS, base +
> QUADSPI_RBCT);
> +
> +		if (op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_OUT)
> +			fsl_qspi_fill_txfifo(q, op);
> +
> +		err =3D fsl_qspi_do_op(q, op);
> +	}
> +
> +	mutex_unlock(&q->lock);
> +
> +	return err;
> +}
> +
> +static int fsl_qspi_adjust_op_size(struct spi_mem *mem, struct
> +spi_mem_op *op) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +
> +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT) {
> +		if (op->data.nbytes > q->devtype_data->txfifo)
> +			op->data.nbytes =3D q->devtype_data->txfifo;
> +	} else {
> +		if (op->data.nbytes > q->devtype_data->ahb_buf_size)
> +			op->data.nbytes =3D q->devtype_data->ahb_buf_size;
> +		else if (op->data.nbytes > (q->devtype_data->rxfifo - 4))
> +			op->data.nbytes =3D ALIGN_DOWN(op->data.nbytes, 8);
> +	}
> +
> +	return 0;
> +}
> +
> +static int fsl_qspi_default_setup(struct fsl_qspi *q) {
> +	void __iomem *base =3D q->iobase;
> +	u32 reg;
> +	int ret;
> +
> +	/* disable and unprepare clock to avoid glitch pass to controller */
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	/* the default frequency, we will change it later if necessary. */
> +	ret =3D clk_set_rate(q->clk, 66000000);
> +	if (ret)
> +		return ret;
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret)
> +		return ret;
> +
> +	/* Reset the module */
> +	qspi_writel(q, QUADSPI_MCR_SWRSTSD_MASK |
> QUADSPI_MCR_SWRSTHD_MASK,
> +		    base + QUADSPI_MCR);
> +	udelay(1);
> +
> +	/* Disable the module */
> +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK |
> QUADSPI_MCR_RESERVED_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	reg =3D qspi_readl(q, base + QUADSPI_SMPR);
> +	qspi_writel(q, reg & ~(QUADSPI_SMPR_FSDLY_MASK
> +			| QUADSPI_SMPR_FSPHS_MASK
> +			| QUADSPI_SMPR_HSENA_MASK
> +			| QUADSPI_SMPR_DDRSMP_MASK), base +
> QUADSPI_SMPR);
> +
> +	/* We only use the buffer3 for AHB read */
> +	qspi_writel(q, 0, base + QUADSPI_BUF0IND);
> +	qspi_writel(q, 0, base + QUADSPI_BUF1IND);
> +	qspi_writel(q, 0, base + QUADSPI_BUF2IND);
> +
> +	qspi_writel(q, QUADSPI_BFGENCR_SEQID(SEQID_LUT),
> +		    q->iobase + QUADSPI_BFGENCR);
> +	qspi_writel(q, QUADSPI_RBCT_WMRK_MASK, base + QUADSPI_RBCT);
> +	qspi_writel(q, QUADSPI_BUF3CR_ALLMST_MASK |
> +		    QUADSPI_BUF3CR_ADATSZ(q->devtype_data->ahb_buf_size /
> 8),
> +		    base + QUADSPI_BUF3CR);
> +
> +	q->selected =3D -1;
> +	q->seq =3D 0;
> +
> +	/* Enable the module */
> +	qspi_writel(q, QUADSPI_MCR_RESERVED_MASK |
> QUADSPI_MCR_END_CFG_MASK,
> +		    base + QUADSPI_MCR);
> +
> +	/* clear all interrupt status */
> +	qspi_writel(q, 0xffffffff, q->iobase + QUADSPI_FR);
> +
> +	/* enable the interrupt */
> +	qspi_writel(q, QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);
> +
> +	return 0;
> +}
> +
> +static const char *fsl_qspi_get_name(struct spi_mem *mem) {
> +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> +	struct device *dev =3D &mem->spi->dev;
> +	const char *name;
> +
> +	/*
> +	 * In order to keep mtdparts compatible with the old MTD driver at
> +	 * mtd/spi-nor/fsl-quadspi.c, we set a custom name derived from the
> +	 * platform_device of the controller.
> +	 */
> +	if (of_get_available_child_count(q->dev->of_node) =3D=3D 1)
> +		return dev_name(q->dev);
> +
> +	name =3D devm_kasprintf(dev, GFP_KERNEL,
> +			      "%s-%d", dev_name(q->dev),
> +			      mem->spi->chip_select);
> +
> +	if (!name) {
> +		dev_err(dev, "failed to get memory for custom flash name\n");
> +		return ERR_PTR(-ENOMEM);
> +	}
> +
> +	return name;
> +}
> +
> +static const struct spi_controller_mem_ops fsl_qspi_mem_ops =3D {
> +	.adjust_op_size =3D fsl_qspi_adjust_op_size,
> +	.supports_op =3D fsl_qspi_supports_op,
> +	.exec_op =3D fsl_qspi_exec_op,
> +	.get_name =3D fsl_qspi_get_name,
> +};
> +
> +static int fsl_qspi_probe(struct platform_device *pdev) {
> +	struct spi_controller *ctlr;
> +	struct device *dev =3D &pdev->dev;
> +	struct device_node *np =3D dev->of_node;
> +	struct resource *res;
> +	struct fsl_qspi *q;
> +	int ret;
> +
> +	ctlr =3D spi_alloc_master(&pdev->dev, sizeof(*q));
> +	if (!ctlr)
> +		return -ENOMEM;
> +
> +	ctlr->mode_bits =3D SPI_RX_DUAL | SPI_RX_QUAD |
> +			  SPI_TX_DUAL | SPI_TX_QUAD;
> +
> +	q =3D spi_controller_get_devdata(ctlr);
> +	q->dev =3D dev;
> +	q->devtype_data =3D of_device_get_match_data(dev);
> +	if (!q->devtype_data) {
> +		ret =3D -ENODEV;
> +		goto err_put_ctrl;
> +	}
> +
> +	platform_set_drvdata(pdev, q);
> +
> +	/* find the resources */
> +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> "QuadSPI");
> +	q->iobase =3D devm_ioremap_resource(dev, res);
> +	if (IS_ERR(q->iobase)) {
> +		ret =3D PTR_ERR(q->iobase);
> +		goto err_put_ctrl;
> +	}
> +
> +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> +					"QuadSPI-memory");
> +	q->ahb_addr =3D devm_ioremap_resource(dev, res);
> +	if (IS_ERR(q->ahb_addr)) {
> +		ret =3D PTR_ERR(q->ahb_addr);
> +		goto err_put_ctrl;
> +	}
> +
> +	q->memmap_phy =3D res->start;
> +
> +	/* find the clocks */
> +	q->clk_en =3D devm_clk_get(dev, "qspi_en");
> +	if (IS_ERR(q->clk_en)) {
> +		ret =3D PTR_ERR(q->clk_en);
> +		goto err_put_ctrl;
> +	}
> +
> +	q->clk =3D devm_clk_get(dev, "qspi");
> +	if (IS_ERR(q->clk)) {
> +		ret =3D PTR_ERR(q->clk);
> +		goto err_put_ctrl;
> +	}
> +
> +	ret =3D fsl_qspi_clk_prep_enable(q);
> +	if (ret) {
> +		dev_err(dev, "can not enable the clock\n");
> +		goto err_put_ctrl;
> +	}
> +
> +	/* find the irq */
> +	ret =3D platform_get_irq(pdev, 0);
> +	if (ret < 0) {
> +		dev_err(dev, "failed to get the irq: %d\n", ret);
> +		goto err_disable_clk;
> +	}
> +
> +	ret =3D devm_request_irq(dev, ret,
> +			fsl_qspi_irq_handler, 0, pdev->name, q);
> +	if (ret) {
> +		dev_err(dev, "failed to request irq: %d\n", ret);
> +		goto err_disable_clk;
> +	}
> +
> +	mutex_init(&q->lock);
> +
> +	ctlr->bus_num =3D -1;
> +	ctlr->num_chipselect =3D 4;
> +	ctlr->mem_ops =3D &fsl_qspi_mem_ops;
> +
> +	fsl_qspi_default_setup(q);
> +
> +	ctlr->dev.of_node =3D np;
> +
> +	ret =3D spi_register_controller(ctlr);
> +	if (ret)
> +		goto err_destroy_mutex;
> +
> +	return 0;
> +
> +err_destroy_mutex:
> +	mutex_destroy(&q->lock);
> +
> +err_disable_clk:
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +err_put_ctrl:
> +	spi_controller_put(ctlr);
> +
> +	dev_err(dev, "Freescale QuadSPI probe failed\n");
> +	return ret;
> +}
> +
> +static int fsl_qspi_remove(struct platform_device *pdev) {
> +	struct fsl_qspi *q =3D platform_get_drvdata(pdev);
> +
> +	/* disable the hardware */
> +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK, q->iobase + QUADSPI_MCR);
> +	qspi_writel(q, 0x0, q->iobase + QUADSPI_RSER);
> +
> +	fsl_qspi_clk_disable_unprep(q);
> +
> +	mutex_destroy(&q->lock);
> +
> +	return 0;
> +}
> +
> +static int fsl_qspi_suspend(struct device *dev) {
> +	return 0;
> +}
> +
> +static int fsl_qspi_resume(struct device *dev) {
> +	struct fsl_qspi *q =3D dev_get_drvdata(dev);
> +
> +	fsl_qspi_default_setup(q);
> +
> +	return 0;
> +}
> +
> +static const struct of_device_id fsl_qspi_dt_ids[] =3D {
> +	{ .compatible =3D "fsl,vf610-qspi", .data =3D &vybrid_data, },
> +	{ .compatible =3D "fsl,imx6sx-qspi", .data =3D &imx6sx_data, },
> +	{ .compatible =3D "fsl,imx7d-qspi", .data =3D &imx7d_data, },
> +	{ .compatible =3D "fsl,imx6ul-qspi", .data =3D &imx6ul_data, },
> +	{ .compatible =3D "fsl,ls1021a-qspi", .data =3D &ls1021a_data, },
> +	{ .compatible =3D "fsl,ls2080a-qspi", .data =3D &ls2080a_data, },
> +	{ /* sentinel */ }
> +};
> +MODULE_DEVICE_TABLE(of, fsl_qspi_dt_ids);
> +
> +static const struct dev_pm_ops fsl_qspi_pm_ops =3D {
> +	.suspend	=3D fsl_qspi_suspend,
> +	.resume		=3D fsl_qspi_resume,
> +};
> +
> +static struct platform_driver fsl_qspi_driver =3D {
> +	.driver =3D {
> +		.name	=3D "fsl-quadspi",
> +		.of_match_table =3D fsl_qspi_dt_ids,
> +		.pm =3D   &fsl_qspi_pm_ops,
> +	},
> +	.probe          =3D fsl_qspi_probe,
> +	.remove		=3D fsl_qspi_remove,
> +};
> +module_platform_driver(fsl_qspi_driver);
> +
> +MODULE_DESCRIPTION("Freescale QuadSPI Controller Driver");
> +MODULE_AUTHOR("Freescale Semiconductor Inc."); MODULE_AUTHOR("Boris
> +Brezillion <boris.brezillon@bootlin.com>"); MODULE_AUTHOR("Frieder
> +Schrempf <frieder.schrempf@kontron.de>"); MODULE_AUTHOR("Yogesh Gaur
> +<yogeshnarayan.gaur@nxp.com>"); MODULE_AUTHOR("Suresh Gupta
> +<suresh.gupta@nxp.com>"); MODULE_LICENSE("GPL v2");
> --
> 2.7.4
