Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from pop3.zju.edu.cn (61.164.42.155:110) by
  likexu-MOBL1.ccr.corp.intel.com with POP3; 13 Nov 2018 15:22:08 -0000
Received: from icoremail.net (unknown [209.85.210.172])
	by mail-app2 (Coremail) with SMTP id by_KCgD3_yfki+pbIJ6EAQ--.40127S3;
	Tue, 13 Nov 2018 16:31:33 +0800 (CST)
Received: from mail-pf1-f172.google.com (unknown [209.85.210.172])
	by mx2.icoremail.net (Coremail) with SMTP id AQAAfwA3FEDhi+pbEgc3AA--.4095S3;
	Tue, 13 Nov 2018 16:31:29 +0800 (CST)
Received: by mail-pf1-f172.google.com with SMTP id y18-v6so5686184pfn.1
        for <xuliker@zju.edu.cn>; Tue, 13 Nov 2018 00:31:29 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:delivered-to:dkim-signature:from:to:cc:subject
         :thread-topic:thread-index:date:message-id:references:in-reply-to
         :accept-language:content-language:spamdiagnosticoutput
         :spamdiagnosticmetadata:content-transfer-encoding:mime-version
         :sender:precedence:list-id;
        bh=3067p485VsECMWo7y6M+Y8bNw58IcgOs0OUFQtc16jw=;
        b=g1RlYg5K/Q9J/VVgMwDvL2WaAwx6XWrh2Y0tVSgU9vNUjMDdJBv4YG64XA3j5lvYGz
         XJTKJB8Q5+YUqUq8bSadbp1hFSkarqhLgB639mfQvIcOODb1Xd08IR3n9rsW+4MuT1Il
         n9rvKpwAOynElWF3ego4vYfD8zodL1kyNHEJhzFItGX3lt4Izs09Otx8oKRK+kpoSzCG
         tVD1vSdXJi5pOerkTcz265ee9kr6K/nJBOnj+KwjbOJBMgDG9/CrFJg1U0E7hPX8OA9a
         kRH8eqTs5iGM/cajgDYPbsLp9FeDdvPJVnm6V8/iRVT23mev0i6gkG70raCnhC+DDaWf
         g1TQ==
X-Gm-Message-State: AGRZ1gKquXUsPsrB9NoC9gD0lg8IzmLnBEajnV58gt2ojxclZVvrD3Dc
	Vo456ESp60P1Z2UmOQwNRerk5VO4524oTgxSQA/lKykGhc/PFyVLsQ==
X-Received: by 2002:a65:64d5:: with SMTP id t21-v6mr3991557pgv.428.1542097889089;
        Tue, 13 Nov 2018 00:31:29 -0800 (PST)
X-Forwarded-To: xuliker@zju.edu.cn
X-Forwarded-For: liker.xu@gmail.com xuliker@zju.edu.cn
Delivered-To: liker.xu@gmail.com
Received: by 2002:a17:90a:c304:0:0:0:0 with SMTP id g4-v6csp4189284pjt;
        Tue, 13 Nov 2018 00:31:27 -0800 (PST)
X-Google-Smtp-Source: AJdET5ciu215BsxBV+UydihjaDUM95ViuoSgDQzcOgcndT0QOWepVqz7DttoRCSy62LOgqs4CX/o
X-Received: by 2002:a63:920a:: with SMTP id o10mr3774983pgd.141.1542097887763;
        Tue, 13 Nov 2018 00:31:27 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1542097887; cv=none;
        d=google.com; s=arc-20160816;
        b=BRkjMTktKKefS/dwEwD/Cjv4GfbyMcbgUw9owdFuMyDqH37gpy35GzVNIDY9iEwEwe
         Bilpm1kSgR3QM7YNWE5WXjbYvlvvAv0Wbguq58kA13JahO+7yGdmAdGxhQguzGUDb1R6
         IL8ez6SMI1EX95AZXL5+MOMISFR5Jt6xbRAFs/lfNf8BM112BjihNqhHDFiIe3qXWmv7
         cD3CK/LPafD1IWFPLkKBrwczSWtW6RSXsWnzAzFiQkNaAif7fVP7BsAKsFUYMXysBtKL
         XcDmQh1XdBudKRI/0La4WrbeCBN3BTLZFynVnJqNMq07epZqOU/xlmByvmcRy0MsawFV
         CQFQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=list-id:precedence:sender:mime-version:content-transfer-encoding
         :spamdiagnosticmetadata:spamdiagnosticoutput:content-language
         :accept-language:in-reply-to:references:message-id:date:thread-index
         :thread-topic:subject:cc:to:from:dkim-signature;
        bh=3067p485VsECMWo7y6M+Y8bNw58IcgOs0OUFQtc16jw=;
        b=lZO3Ay76WSI2xv/ObqTDpagZfnkPt1l9TwDK8oiHAxXHaSHotnW376J89QNNlYfL3F
         tL97ARygzr7kAWCm9u48ASI5ktzxWIr/ynIGpNBEa7Qv3TbJWan5VPfVT3njQvWKN/w8
         oV/6g3Zay+nOpGueryV+XvTLIrcYTMVaUqcB2fTLq0Nqh6+xQRhLW4ioZKVage80RqDs
         pxtLiNBhuVicaOCLl0A2H3RUPcWsafYYhE2VZ//5deOHBDbrRSUalh+sQEw9x3rWgbpL
         lbxSxdiJGmopdcHV+bQwi4RA9OT+MKOdXajYMeTb2ppVe+UG/iFupVGojOUpO17FcAE/
         uurw==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=pass header.i=@nxp.com header.s=selector1 header.b=G+FQgbFh;
       spf=pass (google.com: best guess record for domain of linux-kernel-owner@vger.kernel.org designates 209.132.180.67 as permitted sender) smtp.mailfrom=linux-kernel-owner@vger.kernel.org;
       dmarc=pass (p=NONE sp=NONE dis=NONE) header.from=nxp.com
Received: from vger.kernel.org (vger.kernel.org. [209.132.180.67])
        by mx.google.com with ESMTP id 33-v6si22577357plk.407.2018.11.13.00.31.12;
        Tue, 13 Nov 2018 00:31:27 -0800 (PST)
Received-SPF: pass (google.com: best guess record for domain of linux-kernel-owner@vger.kernel.org designates 209.132.180.67 as permitted sender) client-ip=209.132.180.67;
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1731372AbeKMS2F (ORCPT <rfc822;revogelaar@gmail.com>
        + 99 others); Tue, 13 Nov 2018 13:28:05 -0500
Received: from mail-eopbgr00062.outbound.protection.outlook.com ([40.107.0.62]:43482
        "EHLO EUR02-AM5-obe.outbound.protection.outlook.com"
        rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
        id S1731116AbeKMS2F (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 13 Nov 2018 13:28:05 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=nxp.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=3067p485VsECMWo7y6M+Y8bNw58IcgOs0OUFQtc16jw=;
 b=G+FQgbFhjz1gMKwJuHzl9JlMjDEymaW9dNULeC7AvHJ1+CfCfV8KpI3bhx1LEIJ9KV9g4G+KXVWC2Fxr4oGG0YquigI25+r0bA3IPyV0D4cJsSiYH23Tbw1m37qOsoP/ThdK9nH9yZkZtUkmwQLFuB3LWBKx70BuQRgSobYcWL4=
Received: from VI1PR04MB5726.eurprd04.prod.outlook.com (20.178.127.24) by
 VI1PR04MB5200.eurprd04.prod.outlook.com (20.177.51.161) with Microsoft SMTP
 Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.1294.27; Tue, 13 Nov 2018 08:30:49 +0000
Received: from VI1PR04MB5726.eurprd04.prod.outlook.com
 ([fe80::297b:bb50:9b83:48e1]) by VI1PR04MB5726.eurprd04.prod.outlook.com
 ([fe80::297b:bb50:9b83:48e1%4]) with mapi id 15.20.1294.045; Tue, 13 Nov 2018
 08:30:49 +0000
From: Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>
To: Frieder Schrempf <frieder.schrempf@kontron.de>,
        "linux-mtd@lists.infradead.org" <linux-mtd@lists.infradead.org>,
        "boris.brezillon@bootlin.com" <boris.brezillon@bootlin.com>,
        "linux-spi@vger.kernel.org" <linux-spi@vger.kernel.org>
CC: "dwmw2@infradead.org" <dwmw2@infradead.org>,
        "computersforpeace@gmail.com" <computersforpeace@gmail.com>,
        "marek.vasut@gmail.com" <marek.vasut@gmail.com>,
        "richard@nod.at" <richard@nod.at>,
        "miquel.raynal@bootlin.com" <miquel.raynal@bootlin.com>,
        "broonie@kernel.org" <broonie@kernel.org>,
        David Wolfe <david.wolfe@nxp.com>,
        Fabio Estevam <fabio.estevam@nxp.com>,
        Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>,
        Han Xu <han.xu@nxp.com>,
        "shawnguo@kernel.org" <shawnguo@kernel.org>,
        Frieder Schrempf <frieder.schrempf@exceet.de>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: RE: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Topic: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP QuadSPI
 controller
Thread-Index: AQHUdqhUG2DxLc9MI0etfXbC+DhZ+aVNU0xQgAAVg6A=
Date: Tue, 13 Nov 2018 08:30:49 +0000
Message-ID: <VI1PR04MB5726F32728ACA963FD28E87999C20@VI1PR04MB5726.eurprd04.prod.outlook.com>
References: <1541601809-16950-1-git-send-email-frieder.schrempf@kontron.de>
 <1541601809-16950-2-git-send-email-frieder.schrempf@kontron.de>
 <VI1PR04MB57269B88E1A064F6429D410999C20@VI1PR04MB5726.eurprd04.prod.outlook.com>
In-Reply-To: <VI1PR04MB57269B88E1A064F6429D410999C20@VI1PR04MB5726.eurprd04.prod.outlook.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [14.142.187.166]
x-ms-publictraffictype: Email
x-microsoft-exchange-diagnostics: 1;VI1PR04MB5200;6:znGbv8oGaG6NL8M7AThmGqoBY62SkAqCavNH2M6oT0VIBi0T54JYKNA7h4ar59JVkFEd0m3mGfp8epj0qhNp5kquDUuCl69Y6+tCcHS8ehnIrKo0o7FbVVTpPgdOTkJ0KLskn223CYYkH4kMjm7gugIjw0oYNMTr2aflE0lWbMg46rJYycR57d8+cS/8YkIt42hpMO3+3ChRx9lUUmEEfYuYnPlhFBeVAVJxEOzJuW5yRqwBE8oHYJVefSvWeE6Q0JS2QmjHP65xnF518M38aLAFXFwueuSvWXo1BNFPSz9jgiayouGroP5VBJKl3gkpCjBitVnXk6aP4qE+9EOvrhNj8jGjFETQ/WpbOLOnLS5Cgsz6ne+v/okir5/fGKucMxvSA37A0aYFeLu4fNbyGddr3Hl7c+A4Ow34UD3fHUVsphe5U1Ge+tn2GwK2yhi2SMX77wdM7AAXJXpmMdjUSA==;5:fvFQLPmpJFbT7NbzAwJZqgJqC3HtyvFQCW7zxUUn7RMijnpBaH5cZs6FVyViXzIp+XMXBXVqe6Ls/ax+qlqLStXurEMm839yRpJA9UstT0Q1giwIA9qX4crrNlBRwoBQAzAlAtsbdtIfBfqeSUugKKmx9urMzn+VgTEOMnJTG7I=;7:qinyOQYdLI46GxofAKv4yBPo8de3uKVIGJyMQy5P16T899y2Pf97Sw3Q3eC/mNxbS7t7vHMY+ohP+8iX+7GGaRdwCcE+APQzv1V0dscyUfTwdh2tZT2YNoqqaRUc9JXX5cFPPuRY6Zz3ZXwBXe8T+w==
x-ms-exchange-antispam-srfa-diagnostics: SOS;
x-ms-office365-filtering-correlation-id: 95347ae8-4bf2-4116-6eb4-08d649425116
x-ms-office365-filtering-ht: Tenant
x-microsoft-antispam: BCL:0;PCL:0;RULEID:(2390060)(7020095)(4652040)(8989299)(4534185)(7168020)(4627221)(201703031133081)(201702281549075)(8990200)(5600074)(711020)(4618075)(2017052603328)(7153060)(7193020);SRVR:VI1PR04MB5200;
x-ms-traffictypediagnostic: VI1PR04MB5200:
x-microsoft-antispam-prvs: <VI1PR04MB5200B611F026EB4DC22D9F1599C20@VI1PR04MB5200.eurprd04.prod.outlook.com>
x-exchange-antispam-report-test: UriScan:(258649278758335)(9452136761055)(85827821059158)(269456686620040)(185117386973197);
x-ms-exchange-senderadcheck: 1
x-exchange-antispam-report-cfa-test: BCL:0;PCL:0;RULEID:(8211001083)(6040522)(2401047)(8121501046)(5005006)(3002001)(10201501046)(3231406)(944501410)(52105112)(93006095)(93001095)(6055026)(148016)(149066)(150057)(6041310)(20161123564045)(20161123560045)(20161123558120)(201703131423095)(201702281528075)(20161123555045)(201703061421075)(201703061406153)(20161123562045)(201708071742011)(7699051)(76991095);SRVR:VI1PR04MB5200;BCL:0;PCL:0;RULEID:;SRVR:VI1PR04MB5200;
x-forefront-prvs: 085551F5A8
x-forefront-antispam-report: SFV:NSPM;SFS:(10009020)(366004)(136003)(376002)(396003)(39860400002)(346002)(199004)(189003)(13464003)(2900100001)(2501003)(316002)(14454004)(478600001)(2940100002)(33656002)(106356001)(25786009)(229853002)(105586002)(86362001)(575784001)(97736004)(4326008)(2201001)(93156006)(81166006)(81156014)(8676002)(71190400001)(71200400001)(8936002)(6436002)(5660300001)(186003)(476003)(66066001)(305945005)(4744004)(53546011)(14444005)(53946003)(68736007)(256004)(74316002)(7736002)(55236004)(53936002)(102836004)(26005)(6246003)(39060400002)(55016002)(7696005)(99286004)(7416002)(9686003)(6506007)(76176011)(486006)(2906002)(446003)(78486014)(11346002)(54906003)(110136005)(3846002)(6116002)(579004)(559001)(569006);DIR:OUT;SFP:1101;SCL:1;SRVR:VI1PR04MB5200;H:VI1PR04MB5726.eurprd04.prod.outlook.com;FPR:;SPF:None;LANG:en;PTR:InfoNoRecords;A:1;MX:1;
received-spf: None (protection.outlook.com: nxp.com does not designate
 permitted sender hosts)
x-microsoft-antispam-message-info: Obmt9h2WRQF8oXvsFG93tP8iWJY7s54F3fvu1Mw0r2r4rdv6iBE3WF22o+f9kNx7TmdLCLgGRSnCnJOtNNmNacNBITpiyqIsbCsatumSVayK+GyzpAIWeA9PHyLJtwNnVrozmcLjByruJQ3zvxUz2cCWb6JXNBVPoQoQWfy0KYzdqNuI10Z81N/PD6MpPjH6jSRnpqyxUf3nZL3yYMYFETvkL3EB2obf0Rht7IlIexH1Ie3H+pGwnjL5bbWtalV2ZtsFbTTfkxAhiGT/4H+92d7fSF7ZJXTo6g5xRYohBtDPmORvL64MDXbI73Yzfl7rNW4SU1dV4AROO3Nv7Ym52ufFvp1cZtyGELEAS3qB+j4=
spamdiagnosticoutput: 1:99
spamdiagnosticmetadata: NSPM
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-OriginatorOrg: nxp.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 95347ae8-4bf2-4116-6eb4-08d649425116
X-MS-Exchange-CrossTenant-originalarrivaltime: 13 Nov 2018 08:30:49.5496
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 686ea1d3-bc2b-4c6f-a92c-d99c5c301635
X-MS-Exchange-Transport-CrossTenantHeadersStamped: VI1PR04MB5200
Sender: liker.xu+caf_=xuliker=zju.edu.cn@gmail.com
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-CM-TRANSID: AQAAfwA3FEDhi+pbEgc3AA--.4095S3
Authentication-Results: mail-app2; spf=pass smtp.mail=liker.xu+caf_=xu
	liker=zju.edu.cn@gmail.com;
X-Coremail-Antispam: 1UD129KBjvAXoWftrWDtF1xtFyUZrWfKryDKFg_yoW5ZF43Zo
	ZxAr1Ivw13tr1UAr48G3s2qryYk348W3yYyanYy3s3G3W2va4UKr4rWa17WFWrWFy3Kr1x
	JF17Gry5uFW0yw13n29KB7ZKAUJUUUUU529EdanIXcx71UUUUj7v73VFW2AGmfu7jjvjm3
	AaLaJ3UjIYCTnIWjp_UUUYu7k0a2IF6w4kM7kC6x804xWl14x267AKxVWUJVW8JwAFIxvE
	14AKwVWUJVWUGwA2ocxC64kIII0Yj41l84x0c7CEw4AK67xGY2AK021l84ACjcxK6xIIjx
	v20xvE14v26w1j6s0DM28EF7xvwVC0I7IYx2IY6xkF7I0E14v26F4j6r4UJwA2z4x0Y4vE
	x4A2jsIE14v26rxl6s0DM28EF7xvwVC2z280aVCY1x0267AKxVW0oVCq3wAS0I0E0xvYzx
	vE52x082IY62kv0487Mc02F40EFcxC0VAKzVAqx4xG6I80ewAv7VC0I7IYx2IY67AKxVWU
	XVWUAwAv7VC2z280aVAFwI0_Gr0_Cr1lOx8S6xCaFVCjc4AY6r1j6r4UMx02cVCv0xWlc7
	CjxVAKzI0EY4vE52x082I5MxkFs20EY4vE44CYbxCE4x80FwCY02Avz4vEIxC_GFylc2Ij
	II80xcxEwVAKI48JMxvI42IY6xIIjxv20xvE14v26r4j6ryUMxvI42IY6xIIjxv20xvEc7
	CjxVAFwI0_Gr0_Cr1lcIIF0xvEx4A2jsIE14v26F4UJVW0owCYIxAIcVC2z280aVCY1x02
	67AKxVWxJr0_GcWl42xK82IYc2Ij64vIr41l42xK82IY64kExVAvwVAq07x20xyl4x8a6x
	804xWl4I8I3I0E4IkC6x0Yz7v_Jr0_Gr1lx2IqxVAqx4xG67AKxVWUJVWUGwC20s026x8G
	jcxK67AKxVWUGVWUWwC2zVAF1VAY17CE14v26r4a6rW5MIIYrxkI7VAKI48JMIIF0xvE42
	xK8VAvwI8IcIk0rVW3JVWrJrUvcSsGvfC2KfnxnUUI43ZEXa7IUO_KsUUUUUU==

Hi,

> -----Original Message-----
> From: Yogesh Narayan Gaur
> Sent: Tuesday, November 13, 2018 1:53 PM
> To: 'Frieder Schrempf' <frieder.schrempf@kontron.de>; linux-
> mtd@lists.infradead.org; boris.brezillon@bootlin.com; linux-
> spi@vger.kernel.org
> Cc: dwmw2@infradead.org; computersforpeace@gmail.com;
> marek.vasut@gmail.com; richard@nod.at; miquel.raynal@bootlin.com;
> broonie@kernel.org; David Wolfe <david.wolfe@nxp.com>; Fabio Estevam
> <fabio.estevam@nxp.com>; Prabhakar Kushwaha
> <prabhakar.kushwaha@nxp.com>; Han Xu <han.xu@nxp.com>;
> shawnguo@kernel.org; Frieder Schrempf <frieder.schrempf@exceet.de>; linux=
-
> kernel@vger.kernel.org
> Subject: RE: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP Qua=
dSPI
> controller
>=20
> Hi,
>=20
> > -----Original Message-----
> > From: Frieder Schrempf [mailto:frieder.schrempf@kontron.de]
> > Sent: Wednesday, November 7, 2018 8:13 PM
> > To: linux-mtd@lists.infradead.org; boris.brezillon@bootlin.com; linux-
> > spi@vger.kernel.org
> > Cc: dwmw2@infradead.org; computersforpeace@gmail.com;
> > marek.vasut@gmail.com; richard@nod.at; miquel.raynal@bootlin.com;
> > broonie@kernel.org; David Wolfe <david.wolfe@nxp.com>; Fabio Estevam
> > <fabio.estevam@nxp.com>; Prabhakar Kushwaha
> > <prabhakar.kushwaha@nxp.com>; Yogesh Narayan Gaur
> > <yogeshnarayan.gaur@nxp.com>; Han Xu <han.xu@nxp.com>;
> > shawnguo@kernel.org; Frieder Schrempf <frieder.schrempf@exceet.de>;
> > linux- kernel@vger.kernel.org
> > Subject: [PATCH v4 01/10] spi: Add a driver for the Freescale/NXP
> > QuadSPI controller
> >
> > From: Frieder Schrempf <frieder.schrempf@exceet.de>
> >
> > This driver is derived from the SPI NOR driver at
> > mtd/spi-nor/fsl-quadspi.c. It uses the new SPI memory interface of the
> > SPI framework to issue flash memory operations to up to four connected =
flash
> chips (2 buses with 2 CS each).
> >
> > The controller does not support generic SPI messages.
> >
> > Signed-off-by: Frieder Schrempf <frieder.schrempf@exceet.de>
> > ---
> >  drivers/spi/Kconfig        |  11 +
> >  drivers/spi/Makefile       |   1 +
> >  drivers/spi/spi-fsl-qspi.c | 948
> > ++++++++++++++++++++++++++++++++++++++++
> >  3 files changed, 960 insertions(+)
> >
> > diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig index
> > 7d3a5c9..52e2298
> > 100644
> > --- a/drivers/spi/Kconfig
> > +++ b/drivers/spi/Kconfig
> > @@ -259,6 +259,17 @@ config SPI_FSL_LPSPI
> >  	help
> >  	  This enables Freescale i.MX LPSPI controllers in master mode.
> >
> > +config SPI_FSL_QSPI
> > +	tristate "Freescale QSPI controller"
> > +	depends on ARCH_MXC || SOC_LS1021A || ARCH_LAYERSCAPE ||
> > COMPILE_TEST
> > +	depends on HAS_IOMEM
> > +	help
> > +	  This enables support for the Quad SPI controller in master mode.
> > +	  Up to four flash chips can be connected on two buses with two
> > +	  chipselects each.
> > +	  This controller does not support generic SPI messages. It only
> > +	  supports the high-level SPI memory interface.
> > +
> >  config SPI_GPIO
> >  	tristate "GPIO-based bitbanging SPI Master"
> >  	depends on GPIOLIB || COMPILE_TEST
> > diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile index
> > 3575205..833b9e7
> > 100644
> > --- a/drivers/spi/Makefile
> > +++ b/drivers/spi/Makefile
> > @@ -44,6 +44,7 @@ obj-$(CONFIG_SPI_FSL_DSPI)		+=3D spi-fsl-
> > dspi.o
> >  obj-$(CONFIG_SPI_FSL_LIB)		+=3D spi-fsl-lib.o
> >  obj-$(CONFIG_SPI_FSL_ESPI)		+=3D spi-fsl-espi.o
> >  obj-$(CONFIG_SPI_FSL_LPSPI)		+=3D spi-fsl-lpspi.o
> > +obj-$(CONFIG_SPI_FSL_QSPI)		+=3D spi-fsl-qspi.o
> >  obj-$(CONFIG_SPI_FSL_SPI)		+=3D spi-fsl-spi.o
> >  obj-$(CONFIG_SPI_GPIO)			+=3D spi-gpio.o
> >  obj-$(CONFIG_SPI_IMG_SPFI)		+=3D spi-img-spfi.o
> > diff --git a/drivers/spi/spi-fsl-qspi.c b/drivers/spi/spi-fsl-qspi.c
> > new file mode
> > 100644 index 0000000..a43cfe8
> > --- /dev/null
> > +++ b/drivers/spi/spi-fsl-qspi.c
> > @@ -0,0 +1,948 @@
> > +// SPDX-License-Identifier: GPL-2.0+
> > +
> > +/*
> > + * Freescale QuadSPI driver.
> > + *
> > + * Copyright (C) 2013 Freescale Semiconductor, Inc.
> > + * Copyright (C) 2018 Bootlin
> > + * Copyright (C) 2018 exceet electronics GmbH
> > + * Copyright (C) 2018 Kontron Electronics GmbH
> > + *
> > + * Transition to SPI MEM interface:
> > + * Author:
> > + *     Boris Brezillion <boris.brezillon@bootlin.com>
> > + *     Frieder Schrempf <frieder.schrempf@kontron.de>
> > + *     Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
> > + *     Suresh Gupta <suresh.gupta@nxp.com>
> > + *
> > + * Based on the original fsl-quadspi.c spi-nor driver:
> > + * Author: Freescale Semiconductor, Inc.
> > + *
> > + */
> > +
> > +#include <linux/bitops.h>
> > +#include <linux/clk.h>
> > +#include <linux/completion.h>
> > +#include <linux/delay.h>
> > +#include <linux/err.h>
> > +#include <linux/errno.h>
> > +#include <linux/interrupt.h>
> > +#include <linux/io.h>
> > +#include <linux/iopoll.h>
> > +#include <linux/jiffies.h>
> > +#include <linux/kernel.h>
> > +#include <linux/module.h>
> > +#include <linux/mutex.h>
> > +#include <linux/of.h>
> > +#include <linux/of_device.h>
> > +#include <linux/platform_device.h>
> > +#include <linux/pm_qos.h>
> > +#include <linux/sizes.h>
> > +
> > +#include <linux/spi/spi.h>
> > +#include <linux/spi/spi-mem.h>
> > +
> > +/*
> > + * The driver only uses one single LUT entry, that is updated on
> > + * each call of exec_op(). Index 0 is preset at boot with a basic
> > + * read operation, so let's use the last entry (15).
> > + */
> > +#define	SEQID_LUT			15
> > +
> > +/* Registers used by the driver */
> > +#define QUADSPI_MCR			0x00
> > +#define QUADSPI_MCR_RESERVED_MASK	GENMASK(19, 16)
> > +#define QUADSPI_MCR_MDIS_MASK		BIT(14)
> > +#define QUADSPI_MCR_CLR_TXF_MASK	BIT(11)
> > +#define QUADSPI_MCR_CLR_RXF_MASK	BIT(10)
> > +#define QUADSPI_MCR_DDR_EN_MASK		BIT(7)
> > +#define QUADSPI_MCR_END_CFG_MASK	GENMASK(3, 2)
> > +#define QUADSPI_MCR_SWRSTHD_MASK	BIT(1)
> > +#define QUADSPI_MCR_SWRSTSD_MASK	BIT(0)
> > +
> > +#define QUADSPI_IPCR			0x08
> > +#define QUADSPI_IPCR_SEQID(x)		((x) << 24)
> > +
> > +#define QUADSPI_BUF3CR			0x1c
> > +#define QUADSPI_BUF3CR_ALLMST_MASK	BIT(31)
> > +#define QUADSPI_BUF3CR_ADATSZ(x)	((x) << 8)
> > +#define QUADSPI_BUF3CR_ADATSZ_MASK	GENMASK(15, 8)
> > +
> > +#define QUADSPI_BFGENCR			0x20
> > +#define QUADSPI_BFGENCR_SEQID(x)	((x) << 12)
> > +
> > +#define QUADSPI_BUF0IND			0x30
> > +#define QUADSPI_BUF1IND			0x34
> > +#define QUADSPI_BUF2IND			0x38
> > +#define QUADSPI_SFAR			0x100
> > +
> > +#define QUADSPI_SMPR			0x108
> > +#define QUADSPI_SMPR_DDRSMP_MASK	GENMASK(18, 16)
> > +#define QUADSPI_SMPR_FSDLY_MASK		BIT(6)
> > +#define QUADSPI_SMPR_FSPHS_MASK		BIT(5)
> > +#define QUADSPI_SMPR_HSENA_MASK		BIT(0)
> > +
> > +#define QUADSPI_RBCT			0x110
> > +#define QUADSPI_RBCT_WMRK_MASK		GENMASK(4, 0)
> > +#define QUADSPI_RBCT_RXBRD_USEIPS	BIT(8)
> > +
> > +#define QUADSPI_TBDR			0x154
> > +
> > +#define QUADSPI_SR			0x15c
> > +#define QUADSPI_SR_IP_ACC_MASK		BIT(1)
> > +#define QUADSPI_SR_AHB_ACC_MASK		BIT(2)
> > +
> > +#define QUADSPI_FR			0x160
> > +#define QUADSPI_FR_TFF_MASK		BIT(0)
> > +
> > +#define QUADSPI_SPTRCLR			0x16c
> > +#define QUADSPI_SPTRCLR_IPPTRC		BIT(8)
> > +#define QUADSPI_SPTRCLR_BFPTRC		BIT(0)
> > +
> > +#define QUADSPI_SFA1AD			0x180
> > +#define QUADSPI_SFA2AD			0x184
> > +#define QUADSPI_SFB1AD			0x188
> > +#define QUADSPI_SFB2AD			0x18c
> > +#define QUADSPI_RBDR(x)			(0x200 + ((x) * 4))
> > +
> > +#define QUADSPI_LUTKEY			0x300
> > +#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
> > +
> > +#define QUADSPI_LCKCR			0x304
> > +#define QUADSPI_LCKER_LOCK		BIT(0)
> > +#define QUADSPI_LCKER_UNLOCK		BIT(1)
> > +
> > +#define QUADSPI_RSER			0x164
> > +#define QUADSPI_RSER_TFIE		BIT(0)
> > +
> > +#define QUADSPI_LUT_BASE		0x310
> > +#define QUADSPI_LUT_OFFSET		(SEQID_LUT * 4 * 4)
> > +#define QUADSPI_LUT_REG(idx) \
> > +	(QUADSPI_LUT_BASE + QUADSPI_LUT_OFFSET + (idx) * 4)
> > +
> > +/* Instruction set for the LUT register */
> > +#define LUT_STOP		0
> > +#define LUT_CMD			1
> > +#define LUT_ADDR		2
> > +#define LUT_DUMMY		3
> > +#define LUT_MODE		4
> > +#define LUT_MODE2		5
> > +#define LUT_MODE4		6
> > +#define LUT_FSL_READ		7
> > +#define LUT_FSL_WRITE		8
> > +#define LUT_JMP_ON_CS		9
> > +#define LUT_ADDR_DDR		10
> > +#define LUT_MODE_DDR		11
> > +#define LUT_MODE2_DDR		12
> > +#define LUT_MODE4_DDR		13
> > +#define LUT_FSL_READ_DDR	14
> > +#define LUT_FSL_WRITE_DDR	15
> > +#define LUT_DATA_LEARN		16
> > +
> > +/*
> > + * The PAD definitions for LUT register.
> > + *
> > + * The pad stands for the number of IO lines [0:3].
> > + * For example, the quad read needs four IO lines,
> > + * so you should use LUT_PAD(4).
> > + */
> > +#define LUT_PAD(x) (fls(x) - 1)
> > +
> > +/*
> > + * Macro for constructing the LUT entries with the following
> > + * register layout:
> > + *
> > + *  ---------------------------------------------------
> > + *  | INSTR1 | PAD1 | OPRND1 | INSTR0 | PAD0 | OPRND0 |
> > + *  ---------------------------------------------------
> > + */
> > +#define LUT_DEF(idx, ins, pad, opr)					\
> > +	((((ins) << 10) | ((pad) << 8) | (opr)) << (((idx) % 2) * 16))
> > +
> > +/* Controller needs driver to swap endianness */
> > +#define QUADSPI_QUIRK_SWAP_ENDIAN	BIT(0)
> > +
> > +/* Controller needs 4x internal clock */
> > +#define QUADSPI_QUIRK_4X_INT_CLK	BIT(1)
> > +
> > +/*
> > + * TKT253890, the controller needs the driver to fill the txfifo with
> > + * 16 bytes at least to trigger a data transfer, even though the
> > +extra
> > + * data won't be transferred.
> > + */
> > +#define QUADSPI_QUIRK_TKT253890		BIT(2)
> > +
> > +/* TKT245618, the controller cannot wake up from wait mode */
> > +#define QUADSPI_QUIRK_TKT245618		BIT(3)
> > +
> > +enum fsl_qspi_devtype {
> > +	FSL_QUADSPI_VYBRID,
> > +	FSL_QUADSPI_IMX6SX,
> > +	FSL_QUADSPI_IMX7D,
> > +	FSL_QUADSPI_IMX6UL,
> > +	FSL_QUADSPI_LS1021A,
> > +	FSL_QUADSPI_LS2080A,
> > +};
> > +
> We can go away with this enum
>=20
> > +struct fsl_qspi_devtype_data {
> > +	enum fsl_qspi_devtype devtype;
> > +	unsigned int rxfifo;
> > +	unsigned int txfifo;
> > +	unsigned int ahb_buf_size;
> > +	unsigned int quirks;
> > +	bool little_endian;
> > +};
> > +
> > +static const struct fsl_qspi_devtype_data vybrid_data =3D {
> > +	.devtype =3D FSL_QUADSPI_VYBRID,
> > +	.rxfifo =3D SZ_128,
> > +	.txfifo =3D SZ_64,
> > +	.ahb_buf_size =3D SZ_1K,
> > +	.quirks =3D QUADSPI_QUIRK_SWAP_ENDIAN,
> > +	.little_endian =3D true,
> > +};
> > +
> > +static const struct fsl_qspi_devtype_data imx6sx_data =3D {
> > +	.devtype =3D FSL_QUADSPI_IMX6SX,
> > +	.rxfifo =3D SZ_128,
> > +	.txfifo =3D SZ_512,
> > +	.ahb_buf_size =3D SZ_1K,
> > +	.quirks =3D QUADSPI_QUIRK_4X_INT_CLK | QUADSPI_QUIRK_TKT245618,
> > +	.little_endian =3D true,
> > +};
> > +
> > +static const struct fsl_qspi_devtype_data imx7d_data =3D {
> > +	.devtype =3D FSL_QUADSPI_IMX7D,
> > +	.rxfifo =3D SZ_512,
> > +	.txfifo =3D SZ_512,
> > +	.ahb_buf_size =3D SZ_1K,
> > +	.quirks =3D QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK,
> > +	.little_endian =3D true,
> > +};
> > +
> > +static const struct fsl_qspi_devtype_data imx6ul_data =3D {
> > +	.devtype =3D FSL_QUADSPI_IMX6UL,
> > +	.rxfifo =3D SZ_128,
> > +	.txfifo =3D SZ_512,
> > +	.ahb_buf_size =3D SZ_1K,
> > +	.quirks =3D QUADSPI_QUIRK_TKT253890 | QUADSPI_QUIRK_4X_INT_CLK,
> > +	.little_endian =3D true,
> > +};
> > +
> > +static const struct fsl_qspi_devtype_data ls1021a_data =3D {
> > +	.devtype =3D FSL_QUADSPI_LS1021A,
> > +	.rxfifo =3D SZ_128,
> > +	.txfifo =3D SZ_64,
> > +	.ahb_buf_size =3D SZ_1K,
> > +	.quirks =3D 0,
> > +	.little_endian =3D false,
> > +};
> > +
> > +static const struct fsl_qspi_devtype_data ls2080a_data =3D {
> > +	.devtype =3D FSL_QUADSPI_LS2080A,
> > +	.rxfifo =3D SZ_128,
> > +	.txfifo =3D SZ_64,
> > +	.ahb_buf_size =3D SZ_1K,
> > +	.quirks =3D QUADSPI_QUIRK_TKT253890,
> > +	.little_endian =3D true,
> > +};
> > +
> > +struct fsl_qspi {
> > +	void __iomem *iobase;
> > +	void __iomem *ahb_addr;
> > +	u32 memmap_phy;
> > +	struct clk *clk, *clk_en;
> > +	struct device *dev;
> > +	struct completion c;
> > +	const struct fsl_qspi_devtype_data *devtype_data;
> > +	struct mutex lock;
> > +	struct pm_qos_request pm_qos_req;
> > +	int selected;
> > +	u8 seq;
> > +	void (*write)(u32 val, void __iomem *addr);
> > +	u32 (*read)(void __iomem *addr);

We can go away with these read and write function pointer.

--
Regards
Yogesh Gaur
> > +};
> > +
> > +static inline int needs_swap_endian(struct fsl_qspi *q) {
> > +	return q->devtype_data->quirks & QUADSPI_QUIRK_SWAP_ENDIAN; }
> > +
> > +static inline int needs_4x_clock(struct fsl_qspi *q) {
> > +	return q->devtype_data->quirks & QUADSPI_QUIRK_4X_INT_CLK; }
> > +
> > +static inline int needs_fill_txfifo(struct fsl_qspi *q) {
> > +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT253890; }
> > +
> > +static inline int needs_wakeup_wait_mode(struct fsl_qspi *q) {
> > +	return q->devtype_data->quirks & QUADSPI_QUIRK_TKT245618; }
> > +
> > +/*
> > + * An IC bug makes it necessary to rearrange the 32-bit data.
> > + * Later chips, such as IMX6SLX, have fixed this bug.
> > + */
> > +static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a) {
> > +	return needs_swap_endian(q) ? __swab32(a) : a; }
> > +
> > +/*
> > + * R/W functions for big- or little-endian registers:
> > + * The QSPI controller's endianness is independent of
> > + * the CPU core's endianness. So far, although the CPU
> > + * core is little-endian the QSPI controller can use
> > + * big-endian or little-endian.
> > + */
> > +static void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem
> > +*addr) {
> > +	if (q->devtype_data->little_endian)
> > +		iowrite32(val, addr);
> > +	else
> > +		iowrite32be(val, addr);
> > +}
> > +
> > +static u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr) {
> > +	if (q->devtype_data->little_endian)
> > +		return ioread32(addr);
> > +
> > +	return ioread32be(addr);
> > +}
> > +
> > +static irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id) {
> > +	struct fsl_qspi *q =3D dev_id;
> > +	u32 reg;
> > +
> > +	/* clear interrupt */
> > +	reg =3D qspi_readl(q, q->iobase + QUADSPI_FR);
> > +	qspi_writel(q, reg, q->iobase + QUADSPI_FR);
> > +
> > +	if (reg & QUADSPI_FR_TFF_MASK)
> > +		complete(&q->c);
> > +
> > +	dev_dbg(q->dev, "QUADSPI_FR : 0x%.8x:0x%.8x\n", 0, reg);
> > +	return IRQ_HANDLED;
> > +}
> > +
> > +static int fsl_qspi_check_buswidth(struct fsl_qspi *q, u8 width) {
> > +	switch (width) {
> > +	case 1:
> > +	case 2:
> > +	case 4:
> > +		return 0;
> > +	}
> > +
> > +	return -ENOTSUPP;
> > +}
> > +
> > +static bool fsl_qspi_supports_op(struct spi_mem *mem,
> > +				 const struct spi_mem_op *op)
> > +{
> > +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> > +	int ret;
> > +
> > +	ret =3D fsl_qspi_check_buswidth(q, op->cmd.buswidth);
> > +
> > +	if (op->addr.nbytes)
> > +		ret |=3D fsl_qspi_check_buswidth(q, op->addr.buswidth);
> > +
> > +	if (op->dummy.nbytes)
> > +		ret |=3D fsl_qspi_check_buswidth(q, op->dummy.buswidth);
> > +
> > +	if (op->data.nbytes)
> > +		ret |=3D fsl_qspi_check_buswidth(q, op->data.buswidth);
> > +
> > +	if (ret)
> > +		return false;
> > +
> > +	/*
> > +	 * The number of instructions needed for the op, needs
> > +	 * to fit into a single LUT entry.
> > +	 */
> > +	if (op->addr.nbytes +
> > +	   (op->dummy.nbytes ? 1:0) +
> > +	   (op->data.nbytes ? 1:0) > 6)
> > +		return false;
> > +
> > +	/* Max 64 dummy clock cycles supported */
> > +	if (op->dummy.nbytes &&
> > +	    (op->dummy.nbytes * 8 / op->dummy.buswidth > 64))
> > +		return false;
> > +
> > +	/* Max data length, check controller limits and alignment */
> > +	if (op->data.dir =3D=3D SPI_MEM_DATA_IN &&
> > +	    (op->data.nbytes > q->devtype_data->ahb_buf_size ||
> > +	     (op->data.nbytes > q->devtype_data->rxfifo - 4 &&
> > +	      !IS_ALIGNED(op->data.nbytes, 8))))
> > +		return false;
> > +
> > +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT &&
> > +	    op->data.nbytes > q->devtype_data->txfifo)
> > +		return false;
> > +
> > +	return true;
> > +}
> > +
> > +static void fsl_qspi_prepare_lut(struct fsl_qspi *q,
> > +				 const struct spi_mem_op *op)
> > +{
> > +	void __iomem *base =3D q->iobase;
> > +	u32 lutval[4] =3D {};
> > +	int lutidx =3D 1, i;
> > +
> > +	lutval[0] |=3D LUT_DEF(0, LUT_CMD, LUT_PAD(op->cmd.buswidth),
> > +			     op->cmd.opcode);
> > +
> > +	/*
> > +	 * For some unknown reason, using LUT_ADDR doesn't work in some
> > +	 * cases (at least with only one byte long addresses), so
> > +	 * let's use LUT_MODE to write the address bytes one by one
> > +	 */
> > +	for (i =3D 0; i < op->addr.nbytes; i++) {
> > +		u8 addrbyte =3D op->addr.val >> (8 * (op->addr.nbytes - i - 1));
> > +
> > +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_MODE,
> > +					      LUT_PAD(op->addr.buswidth),
> > +					      addrbyte);
> > +		lutidx++;
> > +	}
> > +
> > +	if (op->dummy.nbytes) {
> > +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_DUMMY,
> > +					      LUT_PAD(op->dummy.buswidth),
> > +					      op->dummy.nbytes * 8 /
> > +					      op->dummy.buswidth);
> > +		lutidx++;
> > +	}
> > +
> > +	if (op->data.nbytes) {
> > +		lutval[lutidx / 2] |=3D LUT_DEF(lutidx,
> > +					      op->data.dir =3D=3D
> > SPI_MEM_DATA_IN ?
> > +					      LUT_FSL_READ : LUT_FSL_WRITE,
> > +					      LUT_PAD(op->data.buswidth),
> > +					      0);
> > +		lutidx++;
> > +	}
> > +
> > +	lutval[lutidx / 2] |=3D LUT_DEF(lutidx, LUT_STOP, 0, 0);
> > +
> > +	/* unlock LUT */
> > +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
> > +	qspi_writel(q, QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);
> > +
> > +	/* fill LUT */
> > +	for (i =3D 0; i < ARRAY_SIZE(lutval); i++)
> > +		qspi_writel(q, lutval[i], base + QUADSPI_LUT_REG(i));
> > +
> > +	/* lock LUT */
> > +	qspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
> > +	qspi_writel(q, QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR); }
> > +
> > +static int fsl_qspi_clk_prep_enable(struct fsl_qspi *q) {
> > +	int ret;
> > +
> > +	ret =3D clk_prepare_enable(q->clk_en);
> > +	if (ret)
> > +		return ret;
> > +
> > +	ret =3D clk_prepare_enable(q->clk);
> > +	if (ret) {
> > +		clk_disable_unprepare(q->clk_en);
> > +		return ret;
> > +	}
> > +
> > +	if (needs_wakeup_wait_mode(q))
> > +		pm_qos_add_request(&q->pm_qos_req,
> > PM_QOS_CPU_DMA_LATENCY, 0);
> > +
> > +	return 0;
> > +}
> > +
> > +static void fsl_qspi_clk_disable_unprep(struct fsl_qspi *q) {
> > +	if (needs_wakeup_wait_mode(q))
> > +		pm_qos_remove_request(&q->pm_qos_req);
> > +
> > +	clk_disable_unprepare(q->clk);
> > +	clk_disable_unprepare(q->clk_en);
> > +}
> > +
> > +static void fsl_qspi_select_mem(struct fsl_qspi *q, struct spi_device
> > +*spi) {
> > +	unsigned long rate =3D spi->max_speed_hz;
> > +	int ret, i;
> > +	u32 map_addr;
> > +
> > +	if (q->selected =3D=3D spi->chip_select)
> > +		return;
> > +
> > +	/*
> > +	 * In HW there can be a maximum of four chips on two buses with
> > +	 * two chip selects on each bus. We use four chip selects in SW
> > +	 * to differentiate between the four chips.
> > +	 * We use the SFA1AD, SFA2AD, SFB1AD, SFB2AD registers to select
> > +	 * the chip we want to access.
> > +	 */
> > +	for (i =3D 0; i < 4; i++) {
> > +		if (i < spi->chip_select)
> > +			map_addr =3D q->memmap_phy;
> > +		else
> > +			map_addr =3D q->memmap_phy +
> > +				   2 * q->devtype_data->ahb_buf_size;
> > +
> > +		qspi_writel(q, map_addr, q->iobase + QUADSPI_SFA1AD + (i *
> > 4));
> > +	}
> > +
> > +	if (needs_4x_clock(q))
> > +		rate *=3D 4;
> > +
> > +	fsl_qspi_clk_disable_unprep(q);
> > +
> > +	ret =3D clk_set_rate(q->clk, rate);
> > +	if (ret)
> > +		return;
> > +
> > +	ret =3D fsl_qspi_clk_prep_enable(q);
> > +	if (ret)
> > +		return;
> > +
> > +	q->selected =3D spi->chip_select;
> > +}
> > +
> > +static void fsl_qspi_read_ahb(struct fsl_qspi *q, const struct
> > +spi_mem_op *op) {
> > +	/*
> > +	 * We want to avoid needing to invalidate the cache by issueing
> > +	 * a reset to the AHB and Serial Flash domain, as this needs
> > +	 * time. So we change the address on each read to trigger an
> > +	 * actual read operation on the flash. The actual address for
> > +	 * the flash memory is set by programming the LUT.
> > +	 */
> As discussed previously, please go away with this hack and use AHB bus
> invalidation method with smaller timeout value.
>=20
> I would start doing validation of this patch series from next version onw=
ard. As
> you have mentioned in other mail discussion about issue in the break cond=
ition
> for function  fsl_qspi_readl_poll_tout().
>=20
> --
> Regards
> Yogesh Gaur
>=20
> > +	memcpy_fromio(op->data.buf.in,
> > +		      q->ahb_addr +
> > +		      (((q->seq & (1 << q->selected)) =3D=3D 0 ? 0:1) *
> > +		       q->devtype_data->ahb_buf_size),
> > +		      op->data.nbytes);
> > +
> > +	q->seq ^=3D 1 << q->selected;
> > +}
> > +
> > +static void fsl_qspi_fill_txfifo(struct fsl_qspi *q,
> > +				 const struct spi_mem_op *op)
> > +{
> > +	void __iomem *base =3D q->iobase;
> > +	int i;
> > +	u32 val;
> > +
> > +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> > +		memcpy(&val, op->data.buf.out + i, 4);
> > +		val =3D fsl_qspi_endian_xchg(q, val);
> > +		qspi_writel(q, val, base + QUADSPI_TBDR);
> > +	}
> > +
> > +	if (i < op->data.nbytes) {
> > +		memcpy(&val, op->data.buf.out + i, op->data.nbytes - i);
> > +		val =3D fsl_qspi_endian_xchg(q, val);
> > +		qspi_writel(q, val, base + QUADSPI_TBDR);
> > +	}
> > +
> > +	if (needs_fill_txfifo(q)) {
> > +		for (i =3D op->data.nbytes; i < 16; i +=3D 4)
> > +			qspi_writel(q, 0, base + QUADSPI_TBDR);
> > +	}
> > +}
> > +
> > +static void fsl_qspi_read_rxfifo(struct fsl_qspi *q,
> > +			  const struct spi_mem_op *op)
> > +{
> > +	void __iomem *base =3D q->iobase;
> > +	int i;
> > +	u8 *buf =3D op->data.buf.in;
> > +	u32 val;
> > +
> > +	for (i =3D 0; i < ALIGN_DOWN(op->data.nbytes, 4); i +=3D 4) {
> > +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> > +		val =3D fsl_qspi_endian_xchg(q, val);
> > +		memcpy(buf + i, &val, 4);
> > +	}
> > +
> > +	if (i < op->data.nbytes) {
> > +		val =3D qspi_readl(q, base + QUADSPI_RBDR(i / 4));
> > +		val =3D fsl_qspi_endian_xchg(q, val);
> > +		memcpy(buf + i, &val, op->data.nbytes - i);
> > +	}
> > +}
> > +
> > +static int fsl_qspi_do_op(struct fsl_qspi *q, const struct spi_mem_op
> > +*op) {
> > +	void __iomem *base =3D q->iobase;
> > +	int err =3D 0;
> > +
> > +	init_completion(&q->c);
> > +
> > +	/*
> > +	 * Always start the sequence at the same index since we update
> > +	 * the LUT at each exec_op() call. And also specify the DATA
> > +	 * length, since it's has not been specified in the LUT.
> > +	 */
> > +	qspi_writel(q, op->data.nbytes | QUADSPI_IPCR_SEQID(SEQID_LUT),
> > +		    base + QUADSPI_IPCR);
> > +
> > +	/* Wait for the interrupt. */
> > +	if (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000)))
> > +		err =3D -ETIMEDOUT;
> > +
> > +	if (!err && op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_IN)
> > +		fsl_qspi_read_rxfifo(q, op);
> > +
> > +	return err;
> > +}
> > +
> > +static int fsl_qspi_readl_poll_tout(struct fsl_qspi *q, void __iomem *=
base,
> > +				    u32 mask, u32 delay_us, u32 timeout_us) {
> > +	u32 reg;
> > +
> > +	if (!q->devtype_data->little_endian)
> > +		mask =3D (u32)cpu_to_be32(mask);
> > +
> > +	return readl_poll_timeout(base, reg, (reg & mask), delay_us,
> > +				  timeout_us);
> > +}
> > +
> > +static int fsl_qspi_exec_op(struct spi_mem *mem, const struct
> > +spi_mem_op *op) {
> > +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> > +	void __iomem *base =3D q->iobase;
> > +	int err =3D 0;
> > +
> > +	mutex_lock(&q->lock);
> > +
> > +	fsl_qspi_readl_poll_tout(q, base + QUADSPI_SR,
> > (QUADSPI_SR_IP_ACC_MASK |
> > +				 QUADSPI_SR_AHB_ACC_MASK), 10, 1000);
> > +
> > +	fsl_qspi_select_mem(q, mem->spi);
> > +
> > +	qspi_writel(q, q->memmap_phy, base + QUADSPI_SFAR);
> > +
> > +	qspi_writel(q, qspi_readl(q, base + QUADSPI_MCR) |
> > +		    QUADSPI_MCR_CLR_RXF_MASK |
> > QUADSPI_MCR_CLR_TXF_MASK,
> > +		    base + QUADSPI_MCR);
> > +
> > +	qspi_writel(q, QUADSPI_SPTRCLR_BFPTRC | QUADSPI_SPTRCLR_IPPTRC,
> > +		    base + QUADSPI_SPTRCLR);
> > +
> > +	fsl_qspi_prepare_lut(q, op);
> > +
> > +	/*
> > +	 * If we have large chunks of data, we read them through the AHB bus
> > +	 * by accessing the mapped memory. In all other cases we use
> > +	 * IP commands to access the flash.
> > +	 */
> > +	if (op->data.nbytes > (q->devtype_data->rxfifo - 4) &&
> > +	    op->data.dir =3D=3D SPI_MEM_DATA_IN) {
> > +		fsl_qspi_read_ahb(q, op);
> > +	} else {
> > +		qspi_writel(q, QUADSPI_RBCT_WMRK_MASK |
> > +			    QUADSPI_RBCT_RXBRD_USEIPS, base +
> > QUADSPI_RBCT);
> > +
> > +		if (op->data.nbytes && op->data.dir =3D=3D SPI_MEM_DATA_OUT)
> > +			fsl_qspi_fill_txfifo(q, op);
> > +
> > +		err =3D fsl_qspi_do_op(q, op);
> > +	}
> > +
> > +	mutex_unlock(&q->lock);
> > +
> > +	return err;
> > +}
> > +
> > +static int fsl_qspi_adjust_op_size(struct spi_mem *mem, struct
> > +spi_mem_op *op) {
> > +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> > +
> > +	if (op->data.dir =3D=3D SPI_MEM_DATA_OUT) {
> > +		if (op->data.nbytes > q->devtype_data->txfifo)
> > +			op->data.nbytes =3D q->devtype_data->txfifo;
> > +	} else {
> > +		if (op->data.nbytes > q->devtype_data->ahb_buf_size)
> > +			op->data.nbytes =3D q->devtype_data->ahb_buf_size;
> > +		else if (op->data.nbytes > (q->devtype_data->rxfifo - 4))
> > +			op->data.nbytes =3D ALIGN_DOWN(op->data.nbytes, 8);
> > +	}
> > +
> > +	return 0;
> > +}
> > +
> > +static int fsl_qspi_default_setup(struct fsl_qspi *q) {
> > +	void __iomem *base =3D q->iobase;
> > +	u32 reg;
> > +	int ret;
> > +
> > +	/* disable and unprepare clock to avoid glitch pass to controller */
> > +	fsl_qspi_clk_disable_unprep(q);
> > +
> > +	/* the default frequency, we will change it later if necessary. */
> > +	ret =3D clk_set_rate(q->clk, 66000000);
> > +	if (ret)
> > +		return ret;
> > +
> > +	ret =3D fsl_qspi_clk_prep_enable(q);
> > +	if (ret)
> > +		return ret;
> > +
> > +	/* Reset the module */
> > +	qspi_writel(q, QUADSPI_MCR_SWRSTSD_MASK |
> > QUADSPI_MCR_SWRSTHD_MASK,
> > +		    base + QUADSPI_MCR);
> > +	udelay(1);
> > +
> > +	/* Disable the module */
> > +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK |
> > QUADSPI_MCR_RESERVED_MASK,
> > +		    base + QUADSPI_MCR);
> > +
> > +	reg =3D qspi_readl(q, base + QUADSPI_SMPR);
> > +	qspi_writel(q, reg & ~(QUADSPI_SMPR_FSDLY_MASK
> > +			| QUADSPI_SMPR_FSPHS_MASK
> > +			| QUADSPI_SMPR_HSENA_MASK
> > +			| QUADSPI_SMPR_DDRSMP_MASK), base +
> > QUADSPI_SMPR);
> > +
> > +	/* We only use the buffer3 for AHB read */
> > +	qspi_writel(q, 0, base + QUADSPI_BUF0IND);
> > +	qspi_writel(q, 0, base + QUADSPI_BUF1IND);
> > +	qspi_writel(q, 0, base + QUADSPI_BUF2IND);
> > +
> > +	qspi_writel(q, QUADSPI_BFGENCR_SEQID(SEQID_LUT),
> > +		    q->iobase + QUADSPI_BFGENCR);
> > +	qspi_writel(q, QUADSPI_RBCT_WMRK_MASK, base + QUADSPI_RBCT);
> > +	qspi_writel(q, QUADSPI_BUF3CR_ALLMST_MASK |
> > +		    QUADSPI_BUF3CR_ADATSZ(q->devtype_data->ahb_buf_size /
> > 8),
> > +		    base + QUADSPI_BUF3CR);
> > +
> > +	q->selected =3D -1;
> > +	q->seq =3D 0;
> > +
> > +	/* Enable the module */
> > +	qspi_writel(q, QUADSPI_MCR_RESERVED_MASK |
> > QUADSPI_MCR_END_CFG_MASK,
> > +		    base + QUADSPI_MCR);
> > +
> > +	/* clear all interrupt status */
> > +	qspi_writel(q, 0xffffffff, q->iobase + QUADSPI_FR);
> > +
> > +	/* enable the interrupt */
> > +	qspi_writel(q, QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);
> > +
> > +	return 0;
> > +}
> > +
> > +static const char *fsl_qspi_get_name(struct spi_mem *mem) {
> > +	struct fsl_qspi *q =3D spi_controller_get_devdata(mem->spi->master);
> > +	struct device *dev =3D &mem->spi->dev;
> > +	const char *name;
> > +
> > +	/*
> > +	 * In order to keep mtdparts compatible with the old MTD driver at
> > +	 * mtd/spi-nor/fsl-quadspi.c, we set a custom name derived from the
> > +	 * platform_device of the controller.
> > +	 */
> > +	if (of_get_available_child_count(q->dev->of_node) =3D=3D 1)
> > +		return dev_name(q->dev);
> > +
> > +	name =3D devm_kasprintf(dev, GFP_KERNEL,
> > +			      "%s-%d", dev_name(q->dev),
> > +			      mem->spi->chip_select);
> > +
> > +	if (!name) {
> > +		dev_err(dev, "failed to get memory for custom flash name\n");
> > +		return ERR_PTR(-ENOMEM);
> > +	}
> > +
> > +	return name;
> > +}
> > +
> > +static const struct spi_controller_mem_ops fsl_qspi_mem_ops =3D {
> > +	.adjust_op_size =3D fsl_qspi_adjust_op_size,
> > +	.supports_op =3D fsl_qspi_supports_op,
> > +	.exec_op =3D fsl_qspi_exec_op,
> > +	.get_name =3D fsl_qspi_get_name,
> > +};
> > +
> > +static int fsl_qspi_probe(struct platform_device *pdev) {
> > +	struct spi_controller *ctlr;
> > +	struct device *dev =3D &pdev->dev;
> > +	struct device_node *np =3D dev->of_node;
> > +	struct resource *res;
> > +	struct fsl_qspi *q;
> > +	int ret;
> > +
> > +	ctlr =3D spi_alloc_master(&pdev->dev, sizeof(*q));
> > +	if (!ctlr)
> > +		return -ENOMEM;
> > +
> > +	ctlr->mode_bits =3D SPI_RX_DUAL | SPI_RX_QUAD |
> > +			  SPI_TX_DUAL | SPI_TX_QUAD;
> > +
> > +	q =3D spi_controller_get_devdata(ctlr);
> > +	q->dev =3D dev;
> > +	q->devtype_data =3D of_device_get_match_data(dev);
> > +	if (!q->devtype_data) {
> > +		ret =3D -ENODEV;
> > +		goto err_put_ctrl;
> > +	}
> > +
> > +	platform_set_drvdata(pdev, q);
> > +
> > +	/* find the resources */
> > +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> > "QuadSPI");
> > +	q->iobase =3D devm_ioremap_resource(dev, res);
> > +	if (IS_ERR(q->iobase)) {
> > +		ret =3D PTR_ERR(q->iobase);
> > +		goto err_put_ctrl;
> > +	}
> > +
> > +	res =3D platform_get_resource_byname(pdev, IORESOURCE_MEM,
> > +					"QuadSPI-memory");
> > +	q->ahb_addr =3D devm_ioremap_resource(dev, res);
> > +	if (IS_ERR(q->ahb_addr)) {
> > +		ret =3D PTR_ERR(q->ahb_addr);
> > +		goto err_put_ctrl;
> > +	}
> > +
> > +	q->memmap_phy =3D res->start;
> > +
> > +	/* find the clocks */
> > +	q->clk_en =3D devm_clk_get(dev, "qspi_en");
> > +	if (IS_ERR(q->clk_en)) {
> > +		ret =3D PTR_ERR(q->clk_en);
> > +		goto err_put_ctrl;
> > +	}
> > +
> > +	q->clk =3D devm_clk_get(dev, "qspi");
> > +	if (IS_ERR(q->clk)) {
> > +		ret =3D PTR_ERR(q->clk);
> > +		goto err_put_ctrl;
> > +	}
> > +
> > +	ret =3D fsl_qspi_clk_prep_enable(q);
> > +	if (ret) {
> > +		dev_err(dev, "can not enable the clock\n");
> > +		goto err_put_ctrl;
> > +	}
> > +
> > +	/* find the irq */
> > +	ret =3D platform_get_irq(pdev, 0);
> > +	if (ret < 0) {
> > +		dev_err(dev, "failed to get the irq: %d\n", ret);
> > +		goto err_disable_clk;
> > +	}
> > +
> > +	ret =3D devm_request_irq(dev, ret,
> > +			fsl_qspi_irq_handler, 0, pdev->name, q);
> > +	if (ret) {
> > +		dev_err(dev, "failed to request irq: %d\n", ret);
> > +		goto err_disable_clk;
> > +	}
> > +
> > +	mutex_init(&q->lock);
> > +
> > +	ctlr->bus_num =3D -1;
> > +	ctlr->num_chipselect =3D 4;
> > +	ctlr->mem_ops =3D &fsl_qspi_mem_ops;
> > +
> > +	fsl_qspi_default_setup(q);
> > +
> > +	ctlr->dev.of_node =3D np;
> > +
> > +	ret =3D spi_register_controller(ctlr);
> > +	if (ret)
> > +		goto err_destroy_mutex;
> > +
> > +	return 0;
> > +
> > +err_destroy_mutex:
> > +	mutex_destroy(&q->lock);
> > +
> > +err_disable_clk:
> > +	fsl_qspi_clk_disable_unprep(q);
> > +
> > +err_put_ctrl:
> > +	spi_controller_put(ctlr);
> > +
> > +	dev_err(dev, "Freescale QuadSPI probe failed\n");
> > +	return ret;
> > +}
> > +
> > +static int fsl_qspi_remove(struct platform_device *pdev) {
> > +	struct fsl_qspi *q =3D platform_get_drvdata(pdev);
> > +
> > +	/* disable the hardware */
> > +	qspi_writel(q, QUADSPI_MCR_MDIS_MASK, q->iobase + QUADSPI_MCR);
> > +	qspi_writel(q, 0x0, q->iobase + QUADSPI_RSER);
> > +
> > +	fsl_qspi_clk_disable_unprep(q);
> > +
> > +	mutex_destroy(&q->lock);
> > +
> > +	return 0;
> > +}
> > +
> > +static int fsl_qspi_suspend(struct device *dev) {
> > +	return 0;
> > +}
> > +
> > +static int fsl_qspi_resume(struct device *dev) {
> > +	struct fsl_qspi *q =3D dev_get_drvdata(dev);
> > +
> > +	fsl_qspi_default_setup(q);
> > +
> > +	return 0;
> > +}
> > +
> > +static const struct of_device_id fsl_qspi_dt_ids[] =3D {
> > +	{ .compatible =3D "fsl,vf610-qspi", .data =3D &vybrid_data, },
> > +	{ .compatible =3D "fsl,imx6sx-qspi", .data =3D &imx6sx_data, },
> > +	{ .compatible =3D "fsl,imx7d-qspi", .data =3D &imx7d_data, },
> > +	{ .compatible =3D "fsl,imx6ul-qspi", .data =3D &imx6ul_data, },
> > +	{ .compatible =3D "fsl,ls1021a-qspi", .data =3D &ls1021a_data, },
> > +	{ .compatible =3D "fsl,ls2080a-qspi", .data =3D &ls2080a_data, },
> > +	{ /* sentinel */ }
> > +};
> > +MODULE_DEVICE_TABLE(of, fsl_qspi_dt_ids);
> > +
> > +static const struct dev_pm_ops fsl_qspi_pm_ops =3D {
> > +	.suspend	=3D fsl_qspi_suspend,
> > +	.resume		=3D fsl_qspi_resume,
> > +};
> > +
> > +static struct platform_driver fsl_qspi_driver =3D {
> > +	.driver =3D {
> > +		.name	=3D "fsl-quadspi",
> > +		.of_match_table =3D fsl_qspi_dt_ids,
> > +		.pm =3D   &fsl_qspi_pm_ops,
> > +	},
> > +	.probe          =3D fsl_qspi_probe,
> > +	.remove		=3D fsl_qspi_remove,
> > +};
> > +module_platform_driver(fsl_qspi_driver);
> > +
> > +MODULE_DESCRIPTION("Freescale QuadSPI Controller Driver");
> > +MODULE_AUTHOR("Freescale Semiconductor Inc.");
> MODULE_AUTHOR("Boris
> > +Brezillion <boris.brezillon@bootlin.com>"); MODULE_AUTHOR("Frieder
> > +Schrempf <frieder.schrempf@kontron.de>"); MODULE_AUTHOR("Yogesh
> Gaur
> > +<yogeshnarayan.gaur@nxp.com>"); MODULE_AUTHOR("Suresh Gupta
> > +<suresh.gupta@nxp.com>"); MODULE_LICENSE("GPL v2");
> > --
> > 2.7.4
