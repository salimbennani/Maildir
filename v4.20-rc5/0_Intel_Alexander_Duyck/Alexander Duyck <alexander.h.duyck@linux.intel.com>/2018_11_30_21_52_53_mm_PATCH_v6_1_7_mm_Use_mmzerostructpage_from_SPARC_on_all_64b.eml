Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 02 Dec 2018 19:23:32 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga005.jf.intel.com (orsmga005.jf.intel.com [10.7.209.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 0BF87580479;
	Fri, 30 Nov 2018 13:53:43 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga005-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 30 Nov 2018 13:53:42 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3ASGe+bRNTPZ1tdunQqwEl6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0KPj8oMbcNUDSrc9gkEXOFd2Cra4c26yO6+jJYi8p2d65qncMcZhBBVcuqP?=
 =?us-ascii?q?49uEgeOvODElDxN/XwbiY3T4xoXV5h+GynYwAOQJ6tL1LdrWev4jEMBx7xKRR6?=
 =?us-ascii?q?JvjvGo7Vks+7y/2+94fcbglUhzexe69+IAmrpgjNq8cahpdvJLwswRXTuHtIfO?=
 =?us-ascii?q?pWxWJsJV2Nmhv3+9m98p1+/SlOovwt78FPX7n0cKQ+VrxYES8pM3sp683xtBnM?=
 =?us-ascii?q?VhWA630BWWgLiBVIAgzF7BbnXpfttybxq+Rw1DWGMcDwULs5Xymp4aV2Rx/ykC?=
 =?us-ascii?q?oJKj43/n/ZhMJzjq1brhyuqBNjzIDbe4GVLPhzc7jBfd4YX2dNQtpdWjZDD466?=
 =?us-ascii?q?coABD/ABPeFdr4Tlu1YOqQWxBAa2C+Pp1zBHmGX21rA03eQ8EQDJwA8gFM8JvX?=
 =?us-ascii?q?vOqNX6KqgTXvqzzKbV0zrDdela2Tfn5IfVbxAgoe2DXbFrfMrVyEkvER7Fj1qK?=
 =?us-ascii?q?pYzkOTOVyvoCs2yB4+V8UuKvjncqpgdsqTas3schkpfFip4Rx1ze6Cl0zpg5Kc?=
 =?us-ascii?q?elREN4fdKoCppduiOCO4drTM4vTHtktDs0x7AJo5K3YSYHxZU9yxLBd/CKdZWD?=
 =?us-ascii?q?7Aj5W+aLOzh4gWpoeLKhiBa29kit0vP8Vsaq31ZQtCZFkcfDtmoL1xPN7siLUP?=
 =?us-ascii?q?x9/l2u2TqX1gDT7P9LIVwsmKbFN5IsxqQ8mocdvEjdBCP6hUb7gLOMekgl+OWk?=
 =?us-ascii?q?8+Hnba/npp+YOY90kAb+MqE2l8y7AOQ4NBUOXmeC9eS/yrLj50v5T6tOjvEvla?=
 =?us-ascii?q?nYvpbaKtoBpqOiHQ9V3Zgs6wylAzelztsYh38HI0xBeB6diIjpIV7OLOjiDfij?=
 =?us-ascii?q?m1SsjCtrx/feM73lA5XNLWbMnK3ufLZg8ENczAszzdZC55NbEL0BIfTzWlPvu9?=
 =?us-ascii?q?zcFBM2Lwu0w+P/AtVnyoweQX6PArOeMK7KsV+H/OMvI/WWa48Sojr9K+Ul6OTo?=
 =?us-ascii?q?jX82glIdeaip3Z0KaHG3BPhmIkOZYWbyjdcFC2sFog0+TOnygl2YTTFTf2qyX7?=
 =?us-ascii?q?475jwjCoKmCpnMSpqugLyG2ie7GJpWa3tCClCNF3foaoqFV+0NaCKUPs9ujDgE?=
 =?us-ascii?q?WaK9RI8m0BGkrBX6xKZ/LurI5i0Ysoru28Ju5+3TkhEy9iZ4D96H3GGPVGx0mm?=
 =?us-ascii?q?IIRzkr3KFwu0B9y1GD0bRmjPxcD9Bc+/RJUgIiP57G0+N6E8zyWh7GftqRS1ap?=
 =?us-ascii?q?WNOmDSs1TtIw2dAOZUl9Fs6mjhDC2SqqHrAUm6aKBJwy7qLTwXzxK9xhxHbB0a?=
 =?us-ascii?q?krl0MmTddXNW26mq5/8BDeCJPTnEWHiammb6Qc0zTL9GeY02WOukZUUApzUaXA?=
 =?us-ascii?q?WXASfU/WrdX/5kPfQL6iE7UnMg1dycGcLqtGcMHmjVJDRP37ItTRf3qxm3usBR?=
 =?us-ascii?q?aP3r6DcZDle3sD0ynHCEgLiQYT/W2YOgg4HSqhp2PeDDpzFVPgeU/s8O9+qG+l?=
 =?us-ascii?q?QU8w1Q2Fc0ph17+t8B4PmfOcU+8T3q4DuCo5tzV0HVO939XKC9qApwttZrlcbc?=
 =?us-ascii?q?k64Fdd0WLZtgp9PpO7IqBmh14edRl3vkz02xV2DIVAjdYlrHcwwAVuLqKY1UtL?=
 =?us-ascii?q?dymE0pDoJr3XNm7y8Qi1ZK7SxF7f38iZ+6cV5PsjtlXsoRumFkwh83VgzdlYyH?=
 =?us-ascii?q?+c5pTMDAoPXpP9SEc39x5mp77EZikx/Z/b1XppMaOsqD/Nx8opBPc5yhanZ9pe?=
 =?us-ascii?q?ML6EGBXuHMEABsmuKPYlm16mbh8fOOBS9ag0P96pdvec2a6rOvpgkyyijWhd/I?=
 =?us-ascii?q?991UeM/TJmSuHUx5YF3+2Y3gyfWjfmjVeurtr4mZpZajEVBGa/zzbrBJRQZqFr?=
 =?us-ascii?q?YYkEE2OuLNCpydVkgJ7tXWVV9FqiB1MAxc+odgCeb1373Q1My0sXpWarlje/zz?=
 =?us-ascii?q?xxizsptLaQ3DTSw+T+cxoKIm5KRGh4gVbsO4S0lM0aXE6zYggtlRul41v6xqdB?=
 =?us-ascii?q?qKR+KWnTXVlHfyzsI25+Vauws6KIY9RT55MwrSVXTOO8bEiYSrHnuRsa0CDjH2?=
 =?us-ascii?q?xEyDAgbT6quZb5nx18iG2DKnZ+t37ZecB2xRfC693QX/9R3jwaRCZmjTnbHESz?=
 =?us-ascii?q?P96s/d+MjZfMrvi+V369Vp1UaSTqzZmPtCyh6W1oAB2/meu+mtnmEQg8zC/62M?=
 =?us-ascii?q?NmVSTOrBbgfIbr0762Pv5gfkltHFX88dZ1Gplikossg5EdwXsaiY+U/XYdkWfz?=
 =?us-ascii?q?LM9U2aTxbHcWQT4LwtjV4BXq2UF5L3KJwZ75WWuZwsd7e9a6ZWYW0Don789WEK?=
 =?us-ascii?q?eU8KBEnSxtr1q9rALRYuJyki0TyPQw834an/8GuBA2wSqDGLASElJVPSjtlxSO?=
 =?us-ascii?q?8tC/o79bZGepcbisykV+mcqtA62FogFZQHz5YIstHTds7sVjN1LByGHz6obheN?=
 =?us-ascii?q?XKbNMcrBuUkwrbj+hOKZI8jf4KhSthOWLgsnwp0e87jRpy3Z6kuIiLMXli/KW8?=
 =?us-ascii?q?AhRALD36e9sT+i3xjaZZhsuZxJqgHpJlGjUWRpfoSe+oHSkWtfTmMQaODTI9pm?=
 =?us-ascii?q?2aGbrZAQ+Q9kNmo2jTHJCsMnGdPGMZwsl6RBmBOExfhxgZXDcgkZ48CA+q39bt?=
 =?us-ascii?q?cFtj6jAS+174qQZMyuRyOBnkSWrfoAaoajEpSJmQNhZW7wdC51vLPsya9O58Ay?=
 =?us-ascii?q?ZY/pi5pgyXNmObfxhIDX0OWkGcB1HjOaSu5cDd8+eCAOqyNeDOYbKIqexRTPqI?=
 =?us-ascii?q?wZOv0o17/zeDLMmPP39iD+El1UpHR3x2B8PZmzAXQSwNiy3Nd9KbpAu7+iBvrs?=
 =?us-ascii?q?Cw7vXrWAHs5YuOEbdSMs9v+xe5gaidLe6QmT15JC1c1pMNw3/I1bce0EQTiyFo?=
 =?us-ascii?q?azmiD7AAuTTRQ6LXn69dFwQbZD9rNMtU86I82RFANtTGitzuzL53kP40B01BVV?=
 =?us-ascii?q?zggcypYc0KI2egNFLIHkqLNbKGJSHVzMHze6+zVbpQjOBMvR2qpTmbC1PjPiiE?=
 =?us-ascii?q?lzTxSxCvMORMgDuHMxBEpI69cghiCW74QdLiax27NsJ3jDIszb01gHPKKXATMT?=
 =?us-ascii?q?xmf0xRqb2Q6DtSgu9jFGxZ8nplMe6Elj6Z7ubCLJYWtPprAiJsmONb4HQ10b1V?=
 =?us-ascii?q?7C5fSfxxmSvSqMNuol68numOzDpnTARBqjJRiI2XukViPPaRyp4VUHXc+ToJ7G?=
 =?us-ascii?q?ONG1EEoMZjBtTzuqdWjN/Vm+a7LDZE7sKR+M40BNbdI8HBN2AuYjTzHzuBJQ8I?=
 =?us-ascii?q?XTetOWzFz2BAgfqRvimcqpUqo57glYBISvlXSU0+FdseC0J4DJoDJot6WnUvlr?=
 =?us-ascii?q?vN351A3ma3sBSEHJYShZvATP/HWfg=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ADAABrsAFch0O0hNFjGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwGBVYIWJ4N5iBhfi1WBPzmSO4R5gXMUGBMBhDsDgzg?=
 =?us-ascii?q?iNAkNAQMBAQEBAQECARMBAQEIDQkIKS+CNiKCZQMDAQIgVgYJAQEcCAImAgIDR?=
 =?us-ascii?q?AIOBxIFgxyCAgWnDoEviiyBC4sPeoEcgUSDOocqglcCiSkEhkM2kA8HAoIijy2?=
 =?us-ascii?q?RHyyIT49igUaCDTMaI4M8giQDFxKOLB4BATEBAYEDAQGKcwSCSQEB?=
X-IPAS-Result: =?us-ascii?q?A0ADAABrsAFch0O0hNFjGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwGBVYIWJ4N5iBhfi1WBPzmSO4R5gXMUGBMBhDsDgzgiNAkNAQMBAQEBA?=
 =?us-ascii?q?QECARMBAQEIDQkIKS+CNiKCZQMDAQIgVgYJAQEcCAImAgIDRAIOBxIFgxyCAgW?=
 =?us-ascii?q?nDoEviiyBC4sPeoEcgUSDOocqglcCiSkEhkM2kA8HAoIijy2RHyyIT49igUaCD?=
 =?us-ascii?q?TMaI4M8giQDFxKOLB4BATEBAYEDAQGKcwSCSQEB?=
X-IronPort-AV: E=Sophos;i="5.56,300,1539673200"; 
   d="scan'208";a="54464685"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 30 Nov 2018 13:52:56 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726817AbeLAJDf (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Sat, 1 Dec 2018 04:03:35 -0500
Received: from mga02.intel.com ([134.134.136.20]:32118 "EHLO mga02.intel.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1725749AbeLAJDf (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sat, 1 Dec 2018 04:03:35 -0500
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from orsmga001.jf.intel.com ([10.7.209.18])
  by orsmga101.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 30 Nov 2018 13:52:53 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="5.56,300,1539673200"; 
   d="scan'208";a="114393654"
Received: from ahduyck-desk1.jf.intel.com (HELO ahduyck-desk1.amr.corp.intel.com) ([10.7.198.76])
  by orsmga001.jf.intel.com with ESMTP; 30 Nov 2018 13:52:53 -0800
Subject: [mm PATCH v6 1/7] mm: Use mm_zero_struct_page from SPARC on all 64b
 architectures
From: Alexander Duyck <alexander.h.duyck@linux.intel.com>
To: akpm@linux-foundation.org, linux-mm@kvack.org
Cc: sparclinux@vger.kernel.org, linux-kernel@vger.kernel.org,
        linux-nvdimm@lists.01.org, davem@davemloft.net,
        pavel.tatashin@microsoft.com, mhocko@suse.com, mingo@kernel.org,
        kirill.shutemov@linux.intel.com, dan.j.williams@intel.com,
        dave.jiang@intel.com, alexander.h.duyck@linux.intel.com,
        rppt@linux.vnet.ibm.com, willy@infradead.org, vbabka@suse.cz,
        khalid.aziz@oracle.com, ldufour@linux.vnet.ibm.com,
        mgorman@techsingularity.net, yi.z.zhang@linux.intel.com,
        alexander.h.duyck@linux.intel.com
Date: Fri, 30 Nov 2018 13:52:53 -0800
Message-ID: <154361477318.7497.13432441396440493352.stgit@ahduyck-desk1.amr.corp.intel.com>
In-Reply-To: <154361452447.7497.1348692079883153517.stgit@ahduyck-desk1.amr.corp.intel.com>
References: <154361452447.7497.1348692079883153517.stgit@ahduyck-desk1.amr.corp.intel.com>
User-Agent: StGit/unknown-version
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Use the same approach that was already in use on Sparc on all the
architectures that support a 64b long.

This is mostly motivated by the fact that 7 to 10 store/move instructions
are likely always going to be faster than having to call into a function
that is not specialized for handling page init.

An added advantage to doing it this way is that the compiler can get away
with combining writes in the __init_single_page call. As a result the
memset call will be reduced to only about 4 write operations, or at least
that is what I am seeing with GCC 6.2 as the flags, LRU pointers, and
count/mapcount seem to be cancelling out at least 4 of the 8 assignments on
my system.

One change I had to make to the function was to reduce the minimum page
size to 56 to support some powerpc64 configurations.

This change should introduce no change on SPARC since it already had this
code. In the case of x86_64 I saw a reduction from 3.75s to 2.80s when
initializing 384GB of RAM per node. Pavel Tatashin tested on a system with
Broadcom's Stingray CPU and 48GB of RAM and found that __init_single_page()
takes 19.30ns / 64-byte struct page before this patch and with this patch
it takes 17.33ns / 64-byte struct page. Mike Rapoport ran a similar test on
a OpenPower (S812LC 8348-21C) with Power8 processor and 128GB or RAM. His
results per 64-byte struct page were 4.68ns before, and 4.59ns after this
patch.

Reviewed-by: Pavel Tatashin <pavel.tatashin@microsoft.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Signed-off-by: Alexander Duyck <alexander.h.duyck@linux.intel.com>
---
 arch/sparc/include/asm/pgtable_64.h |   30 --------------------------
 include/linux/mm.h                  |   41 ++++++++++++++++++++++++++++++++---
 2 files changed, 38 insertions(+), 33 deletions(-)

diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h
index 1393a8ac596b..22500c3be7a9 100644
--- a/arch/sparc/include/asm/pgtable_64.h
+++ b/arch/sparc/include/asm/pgtable_64.h
@@ -231,36 +231,6 @@ extern unsigned long _PAGE_ALL_SZ_BITS;
 extern struct page *mem_map_zero;
 #define ZERO_PAGE(vaddr)	(mem_map_zero)
 
-/* This macro must be updated when the size of struct page grows above 80
- * or reduces below 64.
- * The idea that compiler optimizes out switch() statement, and only
- * leaves clrx instructions
- */
-#define	mm_zero_struct_page(pp) do {					\
-	unsigned long *_pp = (void *)(pp);				\
-									\
-	 /* Check that struct page is either 64, 72, or 80 bytes */	\
-	BUILD_BUG_ON(sizeof(struct page) & 7);				\
-	BUILD_BUG_ON(sizeof(struct page) < 64);				\
-	BUILD_BUG_ON(sizeof(struct page) > 80);				\
-									\
-	switch (sizeof(struct page)) {					\
-	case 80:							\
-		_pp[9] = 0;	/* fallthrough */			\
-	case 72:							\
-		_pp[8] = 0;	/* fallthrough */			\
-	default:							\
-		_pp[7] = 0;						\
-		_pp[6] = 0;						\
-		_pp[5] = 0;						\
-		_pp[4] = 0;						\
-		_pp[3] = 0;						\
-		_pp[2] = 0;						\
-		_pp[1] = 0;						\
-		_pp[0] = 0;						\
-	}								\
-} while (0)
-
 /* PFNs are real physical page numbers.  However, mem_map only begins to record
  * per-page information starting at pfn_base.  This is to handle systems where
  * the first physical page in the machine is at some huge physical address,
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 692158d6c619..eb6e52b66bc2 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -123,10 +123,45 @@ extern int mmap_rnd_compat_bits __read_mostly;
 
 /*
  * On some architectures it is expensive to call memset() for small sizes.
- * Those architectures should provide their own implementation of "struct page"
- * zeroing by defining this macro in <asm/pgtable.h>.
+ * If an architecture decides to implement their own version of
+ * mm_zero_struct_page they should wrap the defines below in a #ifndef and
+ * define their own version of this macro in <asm/pgtable.h>
  */
-#ifndef mm_zero_struct_page
+#if BITS_PER_LONG == 64
+/* This function must be updated when the size of struct page grows above 80
+ * or reduces below 56. The idea that compiler optimizes out switch()
+ * statement, and only leaves move/store instructions. Also the compiler can
+ * combine write statments if they are both assignments and can be reordered,
+ * this can result in several of the writes here being dropped.
+ */
+#define	mm_zero_struct_page(pp) __mm_zero_struct_page(pp)
+static inline void __mm_zero_struct_page(struct page *page)
+{
+	unsigned long *_pp = (void *)page;
+
+	 /* Check that struct page is either 56, 64, 72, or 80 bytes */
+	BUILD_BUG_ON(sizeof(struct page) & 7);
+	BUILD_BUG_ON(sizeof(struct page) < 56);
+	BUILD_BUG_ON(sizeof(struct page) > 80);
+
+	switch (sizeof(struct page)) {
+	case 80:
+		_pp[9] = 0;	/* fallthrough */
+	case 72:
+		_pp[8] = 0;	/* fallthrough */
+	case 64:
+		_pp[7] = 0;	/* fallthrough */
+	case 56:
+		_pp[6] = 0;
+		_pp[5] = 0;
+		_pp[4] = 0;
+		_pp[3] = 0;
+		_pp[2] = 0;
+		_pp[1] = 0;
+		_pp[0] = 0;
+	}
+}
+#else
 #define mm_zero_struct_page(pp)  ((void)memset((pp), 0, sizeof(struct page)))
 #endif
 

