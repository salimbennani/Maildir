Return-Path: <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 30 Nov 2018 08:47:33 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga008.jf.intel.com (orsmga008.jf.intel.com [10.7.209.65])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id CEA92580213
	for <like.xu@linux.intel.com>; Thu, 29 Nov 2018 08:05:41 -0800 (PST)
Received: from orsmga103.jf.intel.com ([10.7.208.35])
  by orsmga008-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 29 Nov 2018 08:05:41 -0800
IronPort-PHdr: =?us-ascii?q?9a23=3APf+XrBNk9EZPDxZylFUl6mtUPXoX/o7sNwtQ0KIM?=
 =?us-ascii?q?zox0I/rzrarrMEGX3/hxlliBBdydt6oUzbKO+4nbGkU4qa6bt34DdJEeHzQksu?=
 =?us-ascii?q?4x2zIaPcieFEfgJ+TrZSFpVO5LVVti4m3peRMNQJW2aFLduGC94iAPERvjKwV1?=
 =?us-ascii?q?Ov71GonPhMiryuy+4ZLebxlLiTanfb9+MAi9oBnMuMURnYZsMLs6xAHTontPde?=
 =?us-ascii?q?RWxGdoKkyWkh3h+Mq+/4Nt/jpJtf45+MFOTav1f6IjTbxFFzsmKHw65NfqtRbY?=
 =?us-ascii?q?UwSC4GYXX3gMnRpJBwjF6wz6Xov0vyDnuOdxxDWWMMvrRr0vRz+s87lkRwPpiC?=
 =?us-ascii?q?cfNj427mfXitBrjKlGpB6tvgFzz5LIbI2QMvd1Y6HTcs4ARWdZQMhRWSxPDICy?=
 =?us-ascii?q?YYQBAOUOP/pXoYbgqVsWrxawBwahCP7hxzNUmHD2xrY30/g4EQzcwAAsA9wDvX?=
 =?us-ascii?q?TSod7oNKkSS+e1zKzQwDjddfRZxC396InUfR85p/+DQ6p/f8vWyUY1CwPKkE+Q?=
 =?us-ascii?q?opHiMjyJ0uQNvHOW7+l6WuKolmErsQZxoiKgxso1jITCm4Ebykjc+Cln3Io4Js?=
 =?us-ascii?q?e0RFNmbdOnCpdcqS+XOotsTs8/QWxkoCI3xqEctZO4eCUG0okryhreZvCdboSE?=
 =?us-ascii?q?/w7vWeCMKjlinn1lYqiwhxOq/Eig1OL8Us603U5OripEidnMqmsN2wbc6siBV/?=
 =?us-ascii?q?tx5ECh2SyA1wzL6+FEJ147lbbDJpI/3rI9lYAfvVneEiL1gkn6kqGbe0U+9uS1?=
 =?us-ascii?q?6enrerDmqYWdN49whAH+KKMumsmnDOQhLAcOWnWb9f2h27L94032XrFKguQtna?=
 =?us-ascii?q?nerZDaI9gUqbCiAwNS1oYj6hW/ACm83NUXgHkKNFZFeBOBj4j0NFDCOvH4DfGj?=
 =?us-ascii?q?g1uylDdn3ezJPrrkApjWKHjDl7Hhfbl7605B0gYzyspf551MBrEbPP3zQlPxtM?=
 =?us-ascii?q?DfDhIhNwy0wuXnB8tn2oIRRGKCGauZMKLUsV+V6eMjOeiMZIkJuDnjL/gp/eLh?=
 =?us-ascii?q?jXg8mQxVQK+ywJFCaGykBu80ZAKdYGHwmZEHFmEFuBd4S/blz1iLUDpWbnD1WL?=
 =?us-ascii?q?og5zY9E8W/AILeA4ygnrGFjxq9BYBcM2VPC1SQFiXxeoCZHvsBdi+WZ9VsiyEJ?=
 =?us-ascii?q?TqSJTYgn2hez8gjgxO18M+DW9yYE4I/lz8V//ObJlBs/pgBzWuiUzWCBB051lH?=
 =?us-ascii?q?gPQXdi0KlhoEBVxVaJyq9+xfBCEsRZ6vpTFAY2c5fBmb9UEdf3DylAcs2IQ2GC?=
 =?us-ascii?q?T+KJBjgtQ8h5l9QKbG5+EtKuyBfZ0Hz5UPcui7WXCclsoern1H/rKpM4ki6e2Q?=
 =?us-ascii?q?=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ACAABeDQBchxHrdtBkGgEBAQEBAgEBA?=
 =?us-ascii?q?QEHAgEBAQGBUQUBAQEBCwGBMCqCOIwRX4spgWAtfJZIFIFjEBgUhECDNCI0CQ0?=
 =?us-ascii?q?BAwEBAQEBAQIBEwEBAQoLCQgbDi+CNgUCAxoBBoJbAQEBAQIBAQIXAQwfCikDA?=
 =?us-ascii?q?gEBAgYBAQoYHAcDCAMBORoGDQYCAQEBglFLgXoIAQMBpygzhUCDXYENjBYRBoF?=
 =?us-ascii?q?/gREngjY1hDsLHwUBFoVbAokHGjiFTRGBN4RcigRVCYgEiSgGGIFaiDSHDol7j?=
 =?us-ascii?q?lOBRoINTTAIO4JsggAnFxJtAQMEjRdxgQQDim8NFwcpgXcBAQ?=
X-IPAS-Result: =?us-ascii?q?A0ACAABeDQBchxHrdtBkGgEBAQEBAgEBAQEHAgEBAQGBUQU?=
 =?us-ascii?q?BAQEBCwGBMCqCOIwRX4spgWAtfJZIFIFjEBgUhECDNCI0CQ0BAwEBAQEBAQIBE?=
 =?us-ascii?q?wEBAQoLCQgbDi+CNgUCAxoBBoJbAQEBAQIBAQIXAQwfCikDAgEBAgYBAQoYHAc?=
 =?us-ascii?q?DCAMBORoGDQYCAQEBglFLgXoIAQMBpygzhUCDXYENjBYRBoF/gREngjY1hDsLH?=
 =?us-ascii?q?wUBFoVbAokHGjiFTRGBN4RcigRVCYgEiSgGGIFaiDSHDol7jlOBRoINTTAIO4J?=
 =?us-ascii?q?sggAnFxJtAQMEjRdxgQQDim8NFwcpgXcBAQ?=
X-IronPort-AV: E=Sophos;i="5.56,295,1539673200"; 
   d="scan'208";a="54249394"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from lists.gnu.org ([208.118.235.17])
  by mtab.intel.com with ESMTP/TLS/AES256-SHA; 29 Nov 2018 08:05:39 -0800
Received: from localhost ([::1]:55010 helo=lists.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>)
	id 1gSOos-0002va-5X
	for like.xu@linux.intel.com; Thu, 29 Nov 2018 11:05:38 -0500
Received: from eggs.gnu.org ([2001:4830:134:3::10]:55187)
	by lists.gnu.org with esmtp (Exim 4.71)
	(envelope-from <clg@kaod.org>) id 1gSOoY-0002vK-I0
	for qemu-devel@nongnu.org; Thu, 29 Nov 2018 11:05:22 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
	(envelope-from <clg@kaod.org>) id 1gSOoO-0001Hz-Op
	for qemu-devel@nongnu.org; Thu, 29 Nov 2018 11:05:16 -0500
Received: from 2.mo173.mail-out.ovh.net ([178.33.251.49]:43152)
	by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71) (envelope-from <clg@kaod.org>) id 1gSOoL-0001BD-09
	for qemu-devel@nongnu.org; Thu, 29 Nov 2018 11:05:08 -0500
Received: from player770.ha.ovh.net (unknown [10.109.160.244])
	by mo173.mail-out.ovh.net (Postfix) with ESMTP id 99982E4E4C
	for <qemu-devel@nongnu.org>; Thu, 29 Nov 2018 17:04:55 +0100 (CET)
Received: from kaod.org (lfbn-1-10605-110.w90-89.abo.wanadoo.fr
	[90.89.196.110]) (Authenticated sender: postmaster@kaod.org)
	by player770.ha.ovh.net (Postfix) with ESMTPSA id CA2185A16B3;
	Thu, 29 Nov 2018 16:04:50 +0000 (UTC)
To: David Gibson <david@gibson.dropbear.id.au>
References: <20181116105729.23240-1-clg@kaod.org>
	<20181116105729.23240-17-clg@kaod.org>
	<20181128042547.GZ2251@umbus.fritz.box>
	<a57f6b4b-414e-efe7-475d-e6cbb87f61a8@kaod.org>
	<20181129012355.GP2251@umbus.fritz.box>
From: =?UTF-8?Q?C=c3=a9dric_Le_Goater?= <clg@kaod.org>
Message-ID: <898d49bd-e430-fd07-e1ee-10d5822e3757@kaod.org>
Date: Thu, 29 Nov 2018 17:04:50 +0100
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
	Thunderbird/60.3.0
MIME-Version: 1.0
In-Reply-To: <20181129012355.GP2251@umbus.fritz.box>
Content-Type: text/plain; charset=windows-1252
Content-Language: en-US
X-Ovh-Tracer-Id: 1019783841777814385
X-VR-SPAMSTATE: OK
X-VR-SPAMSCORE: -100
X-VR-SPAMCAUSE: gggruggvucftvghtrhhoucdtuddrgedtkedruddvfedgkedvucetufdoteggodetrfdotffvucfrrhhofhhilhgvmecuqfggjfdpvefjgfevmfevgfenuceurghilhhouhhtmecuhedttdenucesvcftvggtihhpihgvnhhtshculddquddttddm
Content-Transfer-Encoding: quoted-printable
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 2.2.x-3.x [generic]
	[fuzzy]
X-Received-From: 178.33.251.49
Subject: Re: [Qemu-devel] [PATCH v5 16/36] spapr: add hcalls support for the
 XIVE exploitation interrupt mode
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.21
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <http://lists.nongnu.org/archive/html/qemu-devel/>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
	<mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: qemu-ppc@nongnu.org, qemu-devel@nongnu.org
Errors-To: qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+like.xu=linux.intel.com@nongnu.org>

On 11/29/18 2:23 AM, David Gibson wrote:
> On Wed, Nov 28, 2018 at 11:21:37PM +0100, C=E9dric Le Goater wrote:
>> On 11/28/18 5:25 AM, David Gibson wrote:
>>> On Fri, Nov 16, 2018 at 11:57:09AM +0100, C=E9dric Le Goater wrote:
>>>> The different XIVE virtualization structures (sources and event queu=
es)
>>>> are configured with a set of Hypervisor calls :
>>>>
>>>>  - H_INT_GET_SOURCE_INFO
>>>>
>>>>    used to obtain the address of the MMIO page of the Event State
>>>>    Buffer (ESB) entry associated with the source.
>>>>
>>>>  - H_INT_SET_SOURCE_CONFIG
>>>>
>>>>    assigns a source to a "target".
>>>>
>>>>  - H_INT_GET_SOURCE_CONFIG
>>>>
>>>>    determines which "target" and "priority" is assigned to a source
>>>>
>>>>  - H_INT_GET_QUEUE_INFO
>>>>
>>>>    returns the address of the notification management page associate=
d
>>>>    with the specified "target" and "priority".
>>>>
>>>>  - H_INT_SET_QUEUE_CONFIG
>>>>
>>>>    sets or resets the event queue for a given "target" and "priority=
".
>>>>    It is also used to set the notification configuration associated
>>>>    with the queue, only unconditional notification is supported for
>>>>    the moment. Reset is performed with a queue size of 0 and queuein=
g
>>>>    is disabled in that case.
>>>>
>>>>  - H_INT_GET_QUEUE_CONFIG
>>>>
>>>>    returns the queue settings for a given "target" and "priority".
>>>>
>>>>  - H_INT_RESET
>>>>
>>>>    resets all of the guest's internal interrupt structures to their
>>>>    initial state, losing all configuration set via the hcalls
>>>>    H_INT_SET_SOURCE_CONFIG and H_INT_SET_QUEUE_CONFIG.
>>>>
>>>>  - H_INT_SYNC
>>>>
>>>>    issue a synchronisation on a source to make sure all notification=
s
>>>>    have reached their queue.
>>>>
>>>> Calls that still need to be addressed :
>>>>
>>>>    H_INT_SET_OS_REPORTING_LINE
>>>>    H_INT_GET_OS_REPORTING_LINE
>>>>
>>>> See the code for more documentation on each hcall.
>>>>
>>>> Signed-off-by: C=E9dric Le Goater <clg@kaod.org>
>>>> ---
>>>>  include/hw/ppc/spapr.h      |  15 +-
>>>>  include/hw/ppc/spapr_xive.h |   6 +
>>>>  hw/intc/spapr_xive_hcall.c  | 892 +++++++++++++++++++++++++++++++++=
+++
>>>>  hw/ppc/spapr_irq.c          |   2 +
>>>>  hw/intc/Makefile.objs       |   2 +-
>>>>  5 files changed, 915 insertions(+), 2 deletions(-)
>>>>  create mode 100644 hw/intc/spapr_xive_hcall.c
>>>>
>>>> diff --git a/include/hw/ppc/spapr.h b/include/hw/ppc/spapr.h
>>>> index 1fbc2663e06c..8415faea7b82 100644
>>>> --- a/include/hw/ppc/spapr.h
>>>> +++ b/include/hw/ppc/spapr.h
>>>> @@ -452,7 +452,20 @@ struct sPAPRMachineState {
>>>>  #define H_INVALIDATE_PID        0x378
>>>>  #define H_REGISTER_PROC_TBL     0x37C
>>>>  #define H_SIGNAL_SYS_RESET      0x380
>>>> -#define MAX_HCALL_OPCODE        H_SIGNAL_SYS_RESET
>>>> +
>>>> +#define H_INT_GET_SOURCE_INFO   0x3A8
>>>> +#define H_INT_SET_SOURCE_CONFIG 0x3AC
>>>> +#define H_INT_GET_SOURCE_CONFIG 0x3B0
>>>> +#define H_INT_GET_QUEUE_INFO    0x3B4
>>>> +#define H_INT_SET_QUEUE_CONFIG  0x3B8
>>>> +#define H_INT_GET_QUEUE_CONFIG  0x3BC
>>>> +#define H_INT_SET_OS_REPORTING_LINE 0x3C0
>>>> +#define H_INT_GET_OS_REPORTING_LINE 0x3C4
>>>> +#define H_INT_ESB               0x3C8
>>>> +#define H_INT_SYNC              0x3CC
>>>> +#define H_INT_RESET             0x3D0
>>>> +
>>>> +#define MAX_HCALL_OPCODE        H_INT_RESET
>>>> =20
>>>>  /* The hcalls above are standardized in PAPR and implemented by pHy=
p
>>>>   * as well.
>>>> diff --git a/include/hw/ppc/spapr_xive.h b/include/hw/ppc/spapr_xive=
.h
>>>> index 3f65b8f485fd..418511f3dc10 100644
>>>> --- a/include/hw/ppc/spapr_xive.h
>>>> +++ b/include/hw/ppc/spapr_xive.h
>>>> @@ -60,4 +60,10 @@ int spapr_xive_target_to_end(sPAPRXive *xive, uin=
t32_t target, uint8_t prio,
>>>>  int spapr_xive_cpu_to_end(sPAPRXive *xive, PowerPCCPU *cpu, uint8_t=
 prio,
>>>>                            uint8_t *out_end_blk, uint32_t *out_end_i=
dx);
>>>> =20
>>>> +bool spapr_xive_priority_is_valid(uint8_t priority);
>>>
>>> AFAICT this could be a local function.
>>
>> the KVM model uses it also, when collecting state from the KVM device=20
>> to build the QEMU ENDT.
>>
>>>> +
>>>> +typedef struct sPAPRMachineState sPAPRMachineState;
>>>> +
>>>> +void spapr_xive_hcall_init(sPAPRMachineState *spapr);
>>>> +
>>>>  #endif /* PPC_SPAPR_XIVE_H */
>>>> diff --git a/hw/intc/spapr_xive_hcall.c b/hw/intc/spapr_xive_hcall.c
>>>> new file mode 100644
>>>> index 000000000000..52e4e23995f5
>>>> --- /dev/null
>>>> +++ b/hw/intc/spapr_xive_hcall.c
>>>> @@ -0,0 +1,892 @@
>>>> +/*
>>>> + * QEMU PowerPC sPAPR XIVE interrupt controller model
>>>> + *
>>>> + * Copyright (c) 2017-2018, IBM Corporation.
>>>> + *
>>>> + * This code is licensed under the GPL version 2 or later. See the
>>>> + * COPYING file in the top-level directory.
>>>> + */
>>>> +
>>>> +#include "qemu/osdep.h"
>>>> +#include "qemu/log.h"
>>>> +#include "qapi/error.h"
>>>> +#include "cpu.h"
>>>> +#include "hw/ppc/fdt.h"
>>>> +#include "hw/ppc/spapr.h"
>>>> +#include "hw/ppc/spapr_xive.h"
>>>> +#include "hw/ppc/xive_regs.h"
>>>> +#include "monitor/monitor.h"
>>>
>>> Fwiw, I don't think it's particularly necessary to split the hcall
>>> handling out into a separate .c file.
>>
>> ok. let's move it to spapr_xive then ? It might help in reducing the=20
>> exported funtions.=20
>=20
> Yes, I think so.
>=20
>>>> +/*
>>>> + * OPAL uses the priority 7 EQ to automatically escalate interrupts
>>>> + * for all other queues (DD2.X POWER9). So only priorities [0..6] a=
re
>>>> + * available for the guest.
>>>
>>> Referencing OPAL behaviour doesn't really make sense in the context o=
f
>>> PAPR. =20
>>
>> It's an OPAL constraint which pHyp doesn't have. So its a QEMU/KVM=20
>> constraint also.
>=20
> Right, I realized that a few patches on.  Maybe rephrase this to
>=20
>    Linux hosts under OPAL reserve priority 7 for their own escalation
>    interrupts.  So we only allow the guest to use priorities [0..6].

OK.

> The point here is that we're emphasizing that this is a design
> decision to make the host implementation easier, rather than a
> fundamental constraint.
>=20
>>> What I think you're getting at is that the PAPR spec only
>>> allows a PAPR guest to use priorities 0..6 (or at least it will if th=
e
>>> XIVE updated spec ever gets published). =20
>>
>> It's not in the spec. the XIVE sPAPR spec should be frozen soon btw.=20
>> =20
>>> The fact that this allows the
>>> host use 7 for escalations is a design rationale=20
>>> but not really relevant to the guest device itself.=20
>>
>> The guest should be aware of which priorities are reserved for
>> the hypervisor though.
>>
>>>> + */
>>>> +bool spapr_xive_priority_is_valid(uint8_t priority)
>>>> +{
>>>> +    switch (priority) {
>>>> +    case 0 ... 6:
>>>> +        return true;
>>>> +    case 7: /* OPAL escalation queue */
>>>> +    default:
>>>> +        return false;
>>>> +    }
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_GET_SOURCE_INFO hcall() is used to obtain the logical
>>>> + * real address of the MMIO page through which the Event State Buff=
er
>>>> + * entry associated with the value of the "lisn" parameter is manag=
ed.
>>>> + *
>>>> + * Parameters:
>>>> + * Input
>>>> + * - "flags"
>>>> + *       Bits 0-63 reserved
>>>> + * - "lisn" is per "interrupts", "interrupt-map", or
>>>> + *       "ibm,xive-lisn-ranges" properties, or as returned by the
>>>> + *       ibm,query-interrupt-source-number RTAS call, or as returne=
d
>>>> + *       by the H_ALLOCATE_VAS_WINDOW hcall
>>>
>>> I've not heard of H_ALLOCATE_VAS_WINDOW.  Is that something we intend
>>> to implement in kvm/qemu, or is it only of interest for PowerVM?
>>
>> The hcall is part of the PAPR NX Interfaces and it returns interrupt
>> numbers. I don't know if any work has been done on the topic. =20
>=20
> What's a "PAPR NX"?

A way for the PAPR guests to access the POWER coprocessors doing=20
compression and encryption. I really don't know much about this.

>>> Also, putting the register numbers on the inputs as well as the
>>> outputs would be helpful.
>>
>> yes. I will add them.
>>
>>>> + *
>>>> + * Output
>>>> + * - R4: "flags"
>>>> + *       Bits 0-59: Reserved
>>>> + *       Bit 60: H_INT_ESB must be used for Event State Buffer
>>>> + *               management
>>>> + *       Bit 61: 1 =3D=3D LSI  0 =3D=3D MSI
>>>> + *       Bit 62: the full function page supports trigger
>>>> + *       Bit 63: Store EOI Supported
>>>> + * - R5: Logical Real address of full function Event State Buffer
>>>> + *       management page, -1 if ESB hcall flag is set to 1.
>>>
>>> You've defined what H_INT_ESB means above, so it will be clearer if
>>> you reference that by name here.
>>
>> yes.=20
>>
>>>> + * - R6: Logical Real Address of trigger only Event State Buffer
>>>> + *       management page or -1.
>>>> + * - R7: Power of 2 page size for the ESB management pages returned=
 in
>>>> + *       R5 and R6.
>>>> + */
>>>> +
>>>> +#define SPAPR_XIVE_SRC_H_INT_ESB     PPC_BIT(60) /* ESB manage with=
 H_INT_ESB */
>>>> +#define SPAPR_XIVE_SRC_LSI           PPC_BIT(61) /* Virtual LSI typ=
e */
>>>> +#define SPAPR_XIVE_SRC_TRIGGER       PPC_BIT(62) /* Trigger and man=
agement
>>>> +                                                    on same page */
>>>> +#define SPAPR_XIVE_SRC_STORE_EOI     PPC_BIT(63) /* Store EOI suppo=
rt */
>>>
>>> Probably makes sense to put these #defines in spapr.h since they form
>>> part of the PAPR interface definition.
>>
>> ok.
>>
>>>
>>>> +static target_ulong h_int_get_source_info(PowerPCCPU *cpu,
>>>> +                                          sPAPRMachineState *spapr,
>>>> +                                          target_ulong opcode,
>>>> +                                          target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveSource *xsrc =3D &xive->source;
>>>> +    XiveEAS eas;
>>>> +    target_ulong flags  =3D args[0];
>>>> +    target_ulong lisn   =3D args[1];
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_eas(XIVE_ROUTER(xive), lisn, &eas)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (!(eas.w & EAS_VALID)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    /* All sources are emulated under the main XIVE object and shar=
e
>>>> +     * the same characteristics.
>>>> +     */
>>>> +    args[0] =3D 0;
>>>> +    if (!xive_source_esb_has_2page(xsrc)) {
>>>> +        args[0] |=3D SPAPR_XIVE_SRC_TRIGGER;
>>>> +    }
>>>> +    if (xsrc->esb_flags & XIVE_SRC_STORE_EOI) {
>>>> +        args[0] |=3D SPAPR_XIVE_SRC_STORE_EOI;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * Force the use of the H_INT_ESB hcall in case of an LSI
>>>> +     * interrupt. This is necessary under KVM to re-trigger the
>>>> +     * interrupt if the level is still asserted
>>>> +     */
>>>> +    if (xive_source_irq_is_lsi(xsrc, lisn)) {
>>>> +        args[0] |=3D SPAPR_XIVE_SRC_H_INT_ESB | SPAPR_XIVE_SRC_LSI;
>>>> +    }
>>>> +
>>>> +    if (!(args[0] & SPAPR_XIVE_SRC_H_INT_ESB)) {
>>>> +        args[1] =3D xive->vc_base + xive_source_esb_mgmt(xsrc, lisn=
);
>>>> +    } else {
>>>> +        args[1] =3D -1;
>>>> +    }
>>>> +
>>>> +    if (xive_source_esb_has_2page(xsrc)) {
>>>> +        args[2] =3D xive->vc_base + xive_source_esb_page(xsrc, lisn=
);
>>>> +    } else {
>>>> +        args[2] =3D -1;
>>>> +    }
>>>
>>> Do we also need to keep this address clear in the H_INT_ESB case?
>>
>> I think not, but the specs are not very clear on that topic. I will
>> ask for clarification and use a -1 for now. We can not do loads on
>> the trigger page so it can not be used by the H_INT_ESB hcall.
>>
>>>
>>>> +    args[3] =3D TARGET_PAGE_SIZE;
>>>
>>> That seems wrong. =20
>>
>> This is utterly wrong. it should be a power of 2 number ... I got
>> it right under KVM though. I guess that ioremap() under Linux rounds=20
>> up the size to the page size in use, so, that's why it didn't blow
>> up under TCG.
>>
>>> TARGET_PAGE_SIZE is generally 4kiB, but won't these usually
>>> actually be 64kiB?
>>
>> yes. So what should I use to get a PAGE_SHIFT instead ?=20
>=20
> Erm, that gets a bit tricky, since qemu in a sense doesn't know the
> guest's page size.
>=20
> But.. don't you actually want the esb_shift here, not PAGE_SHIFT - it
> could matter for the 2 page * 64kiB variant, yes?

Yes. we just want the page_shift of the ESB page, whether it's one or
two pages. The other registers inform the guest if there are one or=20
two ESB page in use.=20


>>>> +
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_SET_SOURCE_CONFIG hcall() is used to assign a Logical
>>>> + * Interrupt Source to a target. The Logical Interrupt Source is
>>>> + * designated with the "lisn" parameter and the target is designate=
d
>>>> + * with the "target" and "priority" parameters.  Upon return from t=
he
>>>> + * hcall(), no additional interrupts will be directed to the old EQ=
.
>>>> + *
>>>> + * TODO: The old EQ should be investigated for interrupts that
>>>> + * occurred prior to or during the hcall().
>>>
>>> Isn't that the responsibility of the guest?
>>
>> It should yes.
>=20
> Right, so not a TODO for the qemu code.

yes

>=20
>>
>>>
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-61: Reserved
>>>> + *      Bit 62: set the "eisn" in the EA
>>>
>>> What's the "EA"?  Do you mean the EAS?
>>
>> Another XIVE acronym, EA for Event Assignment. I think we can forget
>> this one and just use EAS.
>> =20
>>>
>>>> + *      Bit 63: masks the interrupt source in the hardware interrup=
t
>>>> + *      control structure. An interrupt masked by this mechanism wi=
ll
>>>> + *      be dropped, but it's source state bits will still be
>>>> + *      set. There is no race-free way of unmasking and restoring t=
he
>>>> + *      source. Thus this should only be used in interrupts that ar=
e
>>>> + *      also masked at the source, and only in cases where the
>>>> + *      interrupt is not meant to be used for a large amount of tim=
e
>>>> + *      because no valid target exists for it for example
>>>> + * - "lisn" is per "interrupts", "interrupt-map", or
>>>> + *      "ibm,xive-lisn-ranges" properties, or as returned by the
>>>> + *      ibm,query-interrupt-source-number RTAS call, or as returned=
 by
>>>> + *      the H_ALLOCATE_VAS_WINDOW hcall
>>>> + * - "target" is per "ibm,ppc-interrupt-server#s" or
>>>> + *      "ibm,ppc-interrupt-gserver#s"
>>>> + * - "priority" is a valid priority not in
>>>> + *      "ibm,plat-res-int-priorities"
>>>> + * - "eisn" is the guest EISN associated with the "lisn"
>>>
>>> I don't think the EISN term has been used before in the series. =20
>>
>> Effective Interrupt Source Number, which is the event data enqueued
>> in the OS EQ.
>>
>> I'm planning on adding some more acronyms used by the sPAPR hcalls
>> in this file. There are only a couple.
>=20
> That would be helpful.
>=20
>>> I'm guessing this is the guest-assigned global interrupt number?
>>
>> yes=20
>>
>>>> + *
>>>> + * Output:
>>>> + * - None
>>>> + */
>>>> +
>>>> +#define SPAPR_XIVE_SRC_SET_EISN PPC_BIT(62)
>>>> +#define SPAPR_XIVE_SRC_MASK     PPC_BIT(63)
>>>> +
>>>> +static target_ulong h_int_set_source_config(PowerPCCPU *cpu,
>>>> +                                            sPAPRMachineState *spap=
r,
>>>> +                                            target_ulong opcode,
>>>> +                                            target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveRouter *xrtr =3D XIVE_ROUTER(xive);
>>>> +    XiveEAS eas, new_eas;
>>>> +    target_ulong flags    =3D args[0];
>>>> +    target_ulong lisn     =3D args[1];
>>>> +    target_ulong target   =3D args[2];
>>>> +    target_ulong priority =3D args[3];
>>>> +    target_ulong eisn     =3D args[4];
>>>> +    uint8_t end_blk;
>>>> +    uint32_t end_idx;
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags & ~(SPAPR_XIVE_SRC_SET_EISN | SPAPR_XIVE_SRC_MASK)) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_eas(xrtr, lisn, &eas)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (!(eas.w & EAS_VALID)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    /* priority 0xff is used to reset the EAS */
>>>> +    if (priority =3D=3D 0xff) {
>>>> +        new_eas.w =3D EAS_VALID | EAS_MASKED;
>>>> +        goto out;
>>>> +    }
>>>> +
>>>> +    if (flags & SPAPR_XIVE_SRC_MASK) {
>>>> +        new_eas.w =3D eas.w | EAS_MASKED;
>>>> +    } else {
>>>> +        new_eas.w =3D eas.w & ~EAS_MASKED;
>>>> +    }
>>>> +
>>>> +    if (!spapr_xive_priority_is_valid(priority)) {
>>>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid priority %ld =
requested\n",
>>>> +                      priority);
>>>> +        return H_P4;
>>>> +    }
>>>> +
>>>> +    /* Validate that "target" is part of the list of threads alloca=
ted
>>>> +     * to the partition. For that, find the END corresponding to th=
e
>>>> +     * target.
>>>> +     */
>>>> +    if (spapr_xive_target_to_end(xive, target, priority, &end_blk, =
&end_idx)) {
>>>> +        return H_P3;
>>>> +    }
>>>> +
>>>> +    new_eas.w =3D SETFIELD(EAS_END_BLOCK, new_eas.w, end_blk);
>>>> +    new_eas.w =3D SETFIELD(EAS_END_INDEX, new_eas.w, end_idx);
>>>> +
>>>> +    if (flags & SPAPR_XIVE_SRC_SET_EISN) {
>>>> +        new_eas.w =3D SETFIELD(EAS_END_DATA, new_eas.w, eisn);
>>>> +    }
>>>> +
>>>> +out:
>>>> +    if (xive_router_set_eas(xrtr, lisn, &new_eas)) {
>>>> +        return H_HARDWARE;
>>>> +    }
>>>
>>> As noted earlier in the series, the spapr specific code owns the
>>> memory backing the EAT, so you can just access it directly rather tha=
n
>>> using a method here.
>>
>> Yes. I will give a try. I wonder if I need accessors for the tables
>> ?
>=20
> You'll still need the read accessor since the routing core uses that.
> I don't think you need a write accessor though.
>=20
>>
>>>
>>>> +
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_GET_SOURCE_CONFIG hcall() is used to determine to whic=
h
>>>> + * target/priority pair is assigned to the specified Logical Interr=
upt
>>>> + * Source.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-63 Reserved
>>>> + * - "lisn" is per "interrupts", "interrupt-map", or
>>>> + *      "ibm,xive-lisn-ranges" properties, or as returned by the
>>>> + *      ibm,query-interrupt-source-number RTAS call, or as
>>>> + *      returned by the H_ALLOCATE_VAS_WINDOW hcall
>>>> + *
>>>> + * Output:
>>>> + * - R4: Target to which the specified Logical Interrupt Source is
>>>> + *       assigned
>>>> + * - R5: Priority to which the specified Logical Interrupt Source i=
s
>>>> + *       assigned
>>>> + * - R6: EISN for the specified Logical Interrupt Source (this will=
 be
>>>> + *       equivalent to the LISN if not changed by H_INT_SET_SOURCE_=
CONFIG)
>>>> + */
>>>> +static target_ulong h_int_get_source_config(PowerPCCPU *cpu,
>>>> +                                            sPAPRMachineState *spap=
r,
>>>> +                                            target_ulong opcode,
>>>> +                                            target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveRouter *xrtr =3D XIVE_ROUTER(xive);
>>>> +    target_ulong flags =3D args[0];
>>>> +    target_ulong lisn =3D args[1];
>>>> +    XiveEAS eas;
>>>> +    XiveEND end;
>>>> +    uint8_t end_blk, nvt_blk;
>>>> +    uint32_t end_idx, nvt_idx;
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_eas(xrtr, lisn, &eas)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (!(eas.w & EAS_VALID)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    end_blk =3D GETFIELD(EAS_END_BLOCK, eas.w);
>>>> +    end_idx =3D GETFIELD(EAS_END_INDEX, eas.w);
>>>> +    if (xive_router_get_end(xrtr, end_blk, end_idx, &end)) {
>>>> +        /* Not sure what to return here */
>>>> +        return H_HARDWARE;
>>>
>>> IIUC this indicates a bug in the PAPR specific code, not the guest, s=
o
>>> an assert() is probably the right answer.
>>
>> ok
>>
>>>> +    }
>>>> +
>>>> +    nvt_blk =3D GETFIELD(END_W6_NVT_BLOCK, end.w6);
>>>> +    nvt_idx =3D GETFIELD(END_W6_NVT_INDEX, end.w6);
>>>> +    args[0] =3D spapr_xive_nvt_to_target(xive, nvt_blk, nvt_idx);
>>>
>>> AIUI there's a specific END for each target & priority, so you could
>>> avoid this second level lookup,=20
>>
>> yes=20
>>
>>> although I guess this might be
>>> valuable if we do more complicated internal routing in the future.
>>
>> I am not sure of that but I'd rather keep these converting helpers
>> for the moment.
>=20
> Ok.
>=20
>>>> +    if (eas.w & EAS_MASKED) {
>>>> +        args[1] =3D 0xff;
>>>> +    } else {
>>>> +        args[1] =3D GETFIELD(END_W7_F0_PRIORITY, end.w7);
>>>> +    }
>>>> +
>>>> +    args[2] =3D GETFIELD(EAS_END_DATA, eas.w);
>>>> +
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_GET_QUEUE_INFO hcall() is used to get the logical real
>>>> + * address of the notification management page associated with the
>>>> + * specified target and priority.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *       Bits 0-63 Reserved
>>>> + * - "target" is per "ibm,ppc-interrupt-server#s" or
>>>> + *       "ibm,ppc-interrupt-gserver#s"
>>>> + * - "priority" is a valid priority not in
>>>> + *       "ibm,plat-res-int-priorities"
>>>> + *
>>>> + * Output:
>>>> + * - R4: Logical real address of notification page
>>>> + * - R5: Power of 2 page size of the notification page
>>>> + */
>>>> +static target_ulong h_int_get_queue_info(PowerPCCPU *cpu,
>>>> +                                         sPAPRMachineState *spapr,
>>>> +                                         target_ulong opcode,
>>>> +                                         target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveENDSource *end_xsrc =3D &xive->end_source;
>>>> +    target_ulong flags =3D args[0];
>>>> +    target_ulong target =3D args[1];
>>>> +    target_ulong priority =3D args[2];
>>>> +    XiveEND end;
>>>> +    uint8_t end_blk;
>>>> +    uint32_t end_idx;
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * H_STATE should be returned if a H_INT_RESET is in progress.
>>>> +     * This is not needed when running the emulation under QEMU
>>>> +     */
>>>> +
>>>> +    if (!spapr_xive_priority_is_valid(priority)) {
>>>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid priority %ld =
requested\n",
>>>> +                      priority);
>>>> +        return H_P3;
>>>> +    }
>>>> +
>>>> +    /* Validate that "target" is part of the list of threads alloca=
ted
>>>> +     * to the partition. For that, find the END corresponding to th=
e
>>>> +     * target.
>>>> +     */
>>>> +    if (spapr_xive_target_to_end(xive, target, priority, &end_blk, =
&end_idx)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_end(XIVE_ROUTER(xive), end_blk, end_idx, &e=
nd)) {
>>>> +        return H_HARDWARE;
>>>> +    }
>>>> +
>>>> +    args[0] =3D xive->end_base + (1ull << (end_xsrc->esb_shift + 1)=
) * end_idx;
>>>> +    if (end.w0 & END_W0_ENQUEUE) {
>>>> +        args[1] =3D GETFIELD(END_W0_QSIZE, end.w0) + 12;
>>>> +    } else {
>>>> +        args[1] =3D 0;
>>>> +    }
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_SET_QUEUE_CONFIG hcall() is used to set or reset a EQ =
for
>>>> + * a given "target" and "priority".  It is also used to set the
>>>> + * notification config associated with the EQ.  An EQ size of 0 is
>>>> + * used to reset the EQ config for a given target and priority. If
>>>> + * resetting the EQ config, the END associated with the given "targ=
et"
>>>> + * and "priority" will be changed to disable queueing.
>>>> + *
>>>> + * Upon return from the hcall(), no additional interrupts will be
>>>> + * directed to the old EQ (if one was set). The old EQ (if one was
>>>> + * set) should be investigated for interrupts that occurred prior t=
o
>>>> + * or during the hcall().
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-62: Reserved
>>>> + *      Bit 63: Unconditional Notify (n) per the XIVE spec
>>>> + * - "target" is per "ibm,ppc-interrupt-server#s" or
>>>> + *       "ibm,ppc-interrupt-gserver#s"
>>>> + * - "priority" is a valid priority not in
>>>> + *       "ibm,plat-res-int-priorities"
>>>> + * - "eventQueue": The logical real address of the start of the EQ
>>>> + * - "eventQueueSize": The power of 2 EQ size per "ibm,xive-eq-size=
s"
>>>> + *
>>>> + * Output:
>>>> + * - None
>>>> + */
>>>> +
>>>> +#define SPAPR_XIVE_END_ALWAYS_NOTIFY PPC_BIT(63)
>>>> +
>>>> +static target_ulong h_int_set_queue_config(PowerPCCPU *cpu,
>>>> +                                           sPAPRMachineState *spapr=
,
>>>> +                                           target_ulong opcode,
>>>> +                                           target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveRouter *xrtr =3D XIVE_ROUTER(xive);
>>>> +    target_ulong flags =3D args[0];
>>>> +    target_ulong target =3D args[1];
>>>> +    target_ulong priority =3D args[2];
>>>> +    target_ulong qpage =3D args[3];
>>>> +    target_ulong qsize =3D args[4];
>>>> +    XiveEND end;
>>>> +    uint8_t end_blk, nvt_blk;
>>>> +    uint32_t end_idx, nvt_idx;
>>>> +    uint32_t qdata;
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags & ~SPAPR_XIVE_END_ALWAYS_NOTIFY) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * H_STATE should be returned if a H_INT_RESET is in progress.
>>>> +     * This is not needed when running the emulation under QEMU
>>>> +     */
>>>> +
>>>> +    if (!spapr_xive_priority_is_valid(priority)) {
>>>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid priority %ld =
requested\n",
>>>> +                      priority);
>>>> +        return H_P3;
>>>> +    }
>>>> +
>>>> +    /* Validate that "target" is part of the list of threads alloca=
ted
>>>> +     * to the partition. For that, find the END corresponding to th=
e
>>>> +     * target.
>>>> +     */
>>>> +
>>>> +    if (spapr_xive_target_to_end(xive, target, priority, &end_blk, =
&end_idx)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_end(xrtr, end_blk, end_idx, &end)) {
>>>> +        return H_HARDWARE;
>>>
>>> Again, I think this indicates a qemu (spapr) code bug, so could be an=
 assert().
>>
>> ok
>>
>>>
>>>> +    }
>>>> +
>>>> +    switch (qsize) {
>>>> +    case 12:
>>>> +    case 16:
>>>> +    case 21:
>>>> +    case 24:
>>>> +        end.w3 =3D ((uint64_t)qpage) & 0xffffffff;
>>>
>>> It just occurred to me that I haven't been looking for this across an=
y
>>> of these reviews.  Don't you need byteswaps when accessing these
>>> in-memory structures?
>>
>> yes this is done when some event data is enqueued in the EQ.
>=20
> I'm not talking about the data in the EQ itself, but the fields in the
> END (and the NVT).

XIVE is all BE.

>=20
>>
>>>
>>>> +        end.w2 =3D (((uint64_t)qpage)) >> 32 & 0x0fffffff;
>>>> +        end.w0 |=3D END_W0_ENQUEUE;
>>>> +        end.w0 =3D SETFIELD(END_W0_QSIZE, end.w0, qsize - 12);
>>>> +        break;
>>>> +    case 0:
>>>> +        /* reset queue and disable queueing */
>>>> +        xive_end_reset(&end);
>>>> +        goto out;
>>>> +
>>>> +    default:
>>>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid EQ size %"PRI=
x64"\n",
>>>> +                      qsize);
>>>> +        return H_P5;
>>>> +    }
>>>> +
>>>> +    if (qsize) {
>>>> +        /*
>>>> +         * Let's validate the EQ address with a read of the first E=
Q
>>>> +         * entry. We could also check that the full queue has been
>>>> +         * zeroed by the OS.
>>>> +         */
>>>> +        if (address_space_read(&address_space_memory, qpage,
>>>> +                               MEMTXATTRS_UNSPECIFIED,
>>>> +                               (uint8_t *) &qdata, sizeof(qdata))) =
{
>>>> +            qemu_log_mask(LOG_GUEST_ERROR, "XIVE: failed to read EQ=
 data @0x%"
>>>> +                          HWADDR_PRIx "\n", qpage);
>>>> +            return H_P4;
>>>
>>> Just checking the first entry doesn't seem entirely safe.  Using
>>> address_space_map() and making sure the returned plen doesn't get
>>> reduced below the queue size might be a better option.
>>
>> ok. That was on my todo list.
>>
>>>
>>>> +        }
>>>> +    }
>>>> +
>>>> +    if (spapr_xive_target_to_nvt(xive, target, &nvt_blk, &nvt_idx))=
 {
>>>> +        return H_HARDWARE;
>>>
>>> That could be caused by a bogus 'target' value, couldn't it? =20
>>
>> yes. It should have returned H_P2 above when spapr_xive_target_to_end(=
)=20
>> is called.
>>
>>> In which
>>> case it a) should probably be checked earlier and b) should be
>>> H_PARAMETER or similar, not H_HARDWARE, yes?
>>
>> H_P2 may be again. It should be checked earlier
>>
>>>
>>>> +    }
>>>> +
>>>> +    /* Ensure the priority and target are correctly set (they will =
not
>>>> +     * be right after allocation)
>>>
>>> AIUI there's a static association from END to target in the PAPR
>>> model.=20
>>
>> yes. 8 priorities per cpu.
>>
>>> So it seems to make more sense to get that set up right at
>>> initialization / reset, rather than doing it lazily when the=20
>>> queue is configured.
>>
>> Ah. You would preconfigure the word6 and word7 then. Yes, it would
>> save us some of the conversion fuss. I will look at it.
>>
>>>> +     */
>>>> +    end.w6 =3D SETFIELD(END_W6_NVT_BLOCK, 0ul, nvt_blk) |
>>>> +        SETFIELD(END_W6_NVT_INDEX, 0ul, nvt_idx);
>>>> +    end.w7 =3D SETFIELD(END_W7_F0_PRIORITY, 0ul, priority);
>>>> +
>>>> +    if (flags & SPAPR_XIVE_END_ALWAYS_NOTIFY) {
>>>> +        end.w0 |=3D END_W0_UCOND_NOTIFY;
>>>> +    } else {
>>>> +        end.w0 &=3D ~END_W0_UCOND_NOTIFY;
>>>> +    }
>>>> +
>>>> +    /* The generation bit for the END starts at 1 and The END page
>>>> +     * offset counter starts at 0.
>>>> +     */
>>>> +    end.w1 =3D END_W1_GENERATION | SETFIELD(END_W1_PAGE_OFF, 0ul, 0=
ul);
>>>> +    end.w0 |=3D END_W0_VALID;
>>>> +
>>>> +    /* TODO: issue syncs required to ensure all in-flight interrupt=
s
>>>> +     * are complete on the old END */
>>>> +out:
>>>> +    /* Update END */
>>>> +    if (xive_router_set_end(xrtr, end_blk, end_idx, &end)) {
>>>> +        return H_HARDWARE;
>>>> +    }
>>>
>>> Again the PAPR code owns the ENDs, so it can update them directly
>>> rather than going through an abstraction.
>>
>> ok.
>>
>>>
>>>> +
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_GET_QUEUE_CONFIG hcall() is used to get a EQ for a giv=
en
>>>> + * target and priority.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-62: Reserved
>>>> + *      Bit 63: Debug: Return debug data
>>>> + * - "target" is per "ibm,ppc-interrupt-server#s" or
>>>> + *       "ibm,ppc-interrupt-gserver#s"
>>>> + * - "priority" is a valid priority not in
>>>> + *       "ibm,plat-res-int-priorities"
>>>> + *
>>>> + * Output:
>>>> + * - R4: "flags":
>>>> + *       Bits 0-61: Reserved
>>>> + *       Bit 62: The value of Event Queue Generation Number (g) per
>>>> + *              the XIVE spec if "Debug" =3D 1
>>>> + *       Bit 63: The value of Unconditional Notify (n) per the XIVE=
 spec
>>>> + * - R5: The logical real address of the start of the EQ
>>>> + * - R6: The power of 2 EQ size per "ibm,xive-eq-sizes"
>>>> + * - R7: The value of Event Queue Offset Counter per XIVE spec
>>>> + *       if "Debug" =3D 1, else 0
>>>> + *
>>>> + */
>>>> +
>>>> +#define SPAPR_XIVE_END_DEBUG     PPC_BIT(63)
>>>> +
>>>> +static target_ulong h_int_get_queue_config(PowerPCCPU *cpu,
>>>> +                                           sPAPRMachineState *spapr=
,
>>>> +                                           target_ulong opcode,
>>>> +                                           target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    target_ulong flags =3D args[0];
>>>> +    target_ulong target =3D args[1];
>>>> +    target_ulong priority =3D args[2];
>>>> +    XiveEND end;
>>>> +    uint8_t end_blk;
>>>> +    uint32_t end_idx;
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags & ~SPAPR_XIVE_END_DEBUG) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * H_STATE should be returned if a H_INT_RESET is in progress.
>>>> +     * This is not needed when running the emulation under QEMU
>>>> +     */
>>>> +
>>>> +    if (!spapr_xive_priority_is_valid(priority)) {
>>>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: invalid priority %ld =
requested\n",
>>>> +                      priority);
>>>> +        return H_P3;
>>>> +    }
>>>> +
>>>> +    /* Validate that "target" is part of the list of threads alloca=
ted
>>>> +     * to the partition. For that, find the END corresponding to th=
e
>>>> +     * target.
>>>> +     */
>>>> +    if (spapr_xive_target_to_end(xive, target, priority, &end_blk, =
&end_idx)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_end(XIVE_ROUTER(xive), end_blk, end_idx, &e=
nd)) {
>>>> +        return H_HARDWARE;
>>>
>>> Again, assert() seems appropriate here.
>>
>> ok
>>
>>>
>>>> +    }
>>>> +
>>>> +    args[0] =3D 0;
>>>> +    if (end.w0 & END_W0_UCOND_NOTIFY) {
>>>> +        args[0] |=3D SPAPR_XIVE_END_ALWAYS_NOTIFY;
>>>> +    }
>>>> +
>>>> +    if (end.w0 & END_W0_ENQUEUE) {
>>>> +        args[1] =3D
>>>> +            (((uint64_t)(end.w2 & 0x0fffffff)) << 32) | end.w3;
>>>> +        args[2] =3D GETFIELD(END_W0_QSIZE, end.w0) + 12;
>>>> +    } else {
>>>> +        args[1] =3D 0;
>>>> +        args[2] =3D 0;
>>>> +    }
>>>> +
>>>> +    /* TODO: do we need any locking on the END ? */
>>>> +    if (flags & SPAPR_XIVE_END_DEBUG) {
>>>> +        /* Load the event queue generation number into the return f=
lags */
>>>> +        args[0] |=3D (uint64_t)GETFIELD(END_W1_GENERATION, end.w1) =
<< 62;
>>>> +
>>>> +        /* Load R7 with the event queue offset counter */
>>>> +        args[3] =3D GETFIELD(END_W1_PAGE_OFF, end.w1);
>>>> +    } else {
>>>> +        args[3] =3D 0;
>>>> +    }
>>>> +
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_SET_OS_REPORTING_LINE hcall() is used to set the
>>>> + * reporting cache line pair for the calling thread.  The reporting
>>>> + * cache lines will contain the OS interrupt context when the OS
>>>> + * issues a CI store byte to @TIMA+0xC10 to acknowledge the OS
>>>> + * interrupt. The reporting cache lines can be reset by inputting -=
1
>>>> + * in "reportingLine".  Issuing the CI store byte without reporting
>>>> + * cache lines registered will result in the data not being accessi=
ble
>>>> + * to the OS.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-63: Reserved
>>>> + * - "reportingLine": The logical real address of the reporting cac=
he
>>>> + *    line pair
>>>> + *
>>>> + * Output:
>>>> + * - None
>>>> + */
>>>> +static target_ulong h_int_set_os_reporting_line(PowerPCCPU *cpu,
>>>> +                                                sPAPRMachineState *=
spapr,
>>>> +                                                target_ulong opcode=
,
>>>> +                                                target_ulong *args)
>>>> +{
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * H_STATE should be returned if a H_INT_RESET is in progress.
>>>> +     * This is not needed when running the emulation under QEMU
>>>> +     */
>>>> +
>>>> +    /* TODO: H_INT_SET_OS_REPORTING_LINE */
>>>> +    return H_FUNCTION;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_GET_OS_REPORTING_LINE hcall() is used to get the logic=
al
>>>> + * real address of the reporting cache line pair set for the input
>>>> + * "target".  If no reporting cache line pair has been set, -1 is
>>>> + * returned.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-63: Reserved
>>>> + * - "target" is per "ibm,ppc-interrupt-server#s" or
>>>> + *       "ibm,ppc-interrupt-gserver#s"
>>>> + * - "reportingLine": The logical real address of the reporting cac=
he
>>>> + *   line pair
>>>> + *
>>>> + * Output:
>>>> + * - R4: The logical real address of the reporting line if set, els=
e -1
>>>> + */
>>>> +static target_ulong h_int_get_os_reporting_line(PowerPCCPU *cpu,
>>>> +                                                sPAPRMachineState *=
spapr,
>>>> +                                                target_ulong opcode=
,
>>>> +                                                target_ulong *args)
>>>> +{
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * H_STATE should be returned if a H_INT_RESET is in progress.
>>>> +     * This is not needed when running the emulation under QEMU
>>>> +     */
>>>> +
>>>> +    /* TODO: H_INT_GET_OS_REPORTING_LINE */
>>>> +    return H_FUNCTION;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_ESB hcall() is used to issue a load or store to the ES=
B
>>>> + * page for the input "lisn".  This hcall is only supported for LIS=
Ns
>>>> + * that have the ESB hcall flag set to 1 when returned from hcall()
>>>> + * H_INT_GET_SOURCE_INFO.
>>>
>>> Is there a reason for specifically restricting this to LISNs which
>>> advertise it, rather than allowing it for anything?=20
>>
>> It's in the specs but I did not implement the check. So H_INT_ESB can =
be=20
>> used today by the OS for any interrupt number. Same under KVM.
>>
>> But I should say so somewhere.
>>
>>> Obviously using
>>> the direct MMIOs will generally be a faster option when possible, but
>>> I could see occasions where it might be simpler for the guest to
>>> always use H_INT_ESB (e.g. for micro-guests like kvm-unit-tests).
>>
>> can not you use direct load and stores in these guests ? I haven't=20
>> looked at how they are implemented.
>=20
> It's not that you can't, but that might involve setting up mappings
> and so forth which could be more trouble than using an hcall.  At the
> very least they'll also need H_INT_ESB support for the irqs that
> require it, so allowing it for everything avoids one code variant.

ok. All good then.

Thanks,

C.

>=20
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-62: Reserved
>>>> + *      bit 63: Store: Store=3D1, store operation, else load operat=
ion
>>>> + * - "lisn" is per "interrupts", "interrupt-map", or
>>>> + *      "ibm,xive-lisn-ranges" properties, or as returned by the
>>>> + *      ibm,query-interrupt-source-number RTAS call, or as
>>>> + *      returned by the H_ALLOCATE_VAS_WINDOW hcall
>>>> + * - "esbOffset" is the offset into the ESB page for the load or st=
ore operation
>>>> + * - "storeData" is the data to write for a store operation
>>>> + *
>>>> + * Output:
>>>> + * - R4: R4: The value of the load if load operation, else -1
>>>> + */
>>>> +
>>>> +#define SPAPR_XIVE_ESB_STORE PPC_BIT(63)
>>>> +
>>>> +static target_ulong h_int_esb(PowerPCCPU *cpu,
>>>> +                              sPAPRMachineState *spapr,
>>>> +                              target_ulong opcode,
>>>> +                              target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveEAS eas;
>>>> +    target_ulong flags  =3D args[0];
>>>> +    target_ulong lisn   =3D args[1];
>>>> +    target_ulong offset =3D args[2];
>>>> +    target_ulong data   =3D args[3];
>>>> +    hwaddr mmio_addr;
>>>> +    XiveSource *xsrc =3D &xive->source;
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags & ~SPAPR_XIVE_ESB_STORE) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_eas(XIVE_ROUTER(xive), lisn, &eas)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (!(eas.w & EAS_VALID)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (offset > (1ull << xsrc->esb_shift)) {
>>>> +        return H_P3;
>>>> +    }
>>>> +
>>>> +    mmio_addr =3D xive->vc_base + xive_source_esb_mgmt(xsrc, lisn) =
+ offset;
>>>> +
>>>> +    if (dma_memory_rw(&address_space_memory, mmio_addr, &data, 8,
>>>> +                      (flags & SPAPR_XIVE_ESB_STORE))) {
>>>> +        qemu_log_mask(LOG_GUEST_ERROR, "XIVE: failed to access ESB =
@0x%"
>>>> +                      HWADDR_PRIx "\n", mmio_addr);
>>>> +        return H_HARDWARE;
>>>> +    }
>>>> +    args[0] =3D (flags & SPAPR_XIVE_ESB_STORE) ? -1 : data;
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_SYNC hcall() is used to issue hardware syncs that will
>>>> + * ensure any in flight events for the input lisn are in the event
>>>> + * queue.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-63: Reserved
>>>> + * - "lisn" is per "interrupts", "interrupt-map", or
>>>> + *      "ibm,xive-lisn-ranges" properties, or as returned by the
>>>> + *      ibm,query-interrupt-source-number RTAS call, or as
>>>> + *      returned by the H_ALLOCATE_VAS_WINDOW hcall
>>>> + *
>>>> + * Output:
>>>> + * - None
>>>> + */
>>>> +static target_ulong h_int_sync(PowerPCCPU *cpu,
>>>> +                               sPAPRMachineState *spapr,
>>>> +                               target_ulong opcode,
>>>> +                               target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    XiveEAS eas;
>>>> +    target_ulong flags =3D args[0];
>>>> +    target_ulong lisn =3D args[1];
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    if (xive_router_get_eas(XIVE_ROUTER(xive), lisn, &eas)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    if (!(eas.w & EAS_VALID)) {
>>>> +        return H_P2;
>>>> +    }
>>>> +
>>>> +    /*
>>>> +     * H_STATE should be returned if a H_INT_RESET is in progress.
>>>> +     * This is not needed when running the emulation under QEMU
>>>> +     */
>>>> +
>>>> +    /* This is not real hardware. Nothing to be done */
>>>
>>> At least, not as long as all the XIVE operations are under the BQL.
>>
>> yes.
>>
>>>
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +/*
>>>> + * The H_INT_RESET hcall() is used to reset all of the partition's
>>>> + * interrupt exploitation structures to their initial state.  This
>>>> + * means losing all previously set interrupt state set via
>>>> + * H_INT_SET_SOURCE_CONFIG and H_INT_SET_QUEUE_CONFIG.
>>>> + *
>>>> + * Parameters:
>>>> + * Input:
>>>> + * - "flags"
>>>> + *      Bits 0-63: Reserved
>>>> + *
>>>> + * Output:
>>>> + * - None
>>>> + */
>>>> +static target_ulong h_int_reset(PowerPCCPU *cpu,
>>>> +                                sPAPRMachineState *spapr,
>>>> +                                target_ulong opcode,
>>>> +                                target_ulong *args)
>>>> +{
>>>> +    sPAPRXive *xive =3D spapr->xive;
>>>> +    target_ulong flags   =3D args[0];
>>>> +
>>>> +    if (!spapr_ovec_test(spapr->ov5_cas, OV5_XIVE_EXPLOIT)) {
>>>> +        return H_FUNCTION;
>>>> +    }
>>>> +
>>>> +    if (flags) {
>>>> +        return H_PARAMETER;
>>>> +    }
>>>> +
>>>> +    device_reset(DEVICE(xive));
>>>> +    return H_SUCCESS;
>>>> +}
>>>> +
>>>> +void spapr_xive_hcall_init(sPAPRMachineState *spapr)
>>>> +{
>>>> +    spapr_register_hypercall(H_INT_GET_SOURCE_INFO, h_int_get_sourc=
e_info);
>>>> +    spapr_register_hypercall(H_INT_SET_SOURCE_CONFIG, h_int_set_sou=
rce_config);
>>>> +    spapr_register_hypercall(H_INT_GET_SOURCE_CONFIG, h_int_get_sou=
rce_config);
>>>> +    spapr_register_hypercall(H_INT_GET_QUEUE_INFO, h_int_get_queue_=
info);
>>>> +    spapr_register_hypercall(H_INT_SET_QUEUE_CONFIG, h_int_set_queu=
e_config);
>>>> +    spapr_register_hypercall(H_INT_GET_QUEUE_CONFIG, h_int_get_queu=
e_config);
>>>> +    spapr_register_hypercall(H_INT_SET_OS_REPORTING_LINE,
>>>> +                             h_int_set_os_reporting_line);
>>>> +    spapr_register_hypercall(H_INT_GET_OS_REPORTING_LINE,
>>>> +                             h_int_get_os_reporting_line);
>>>> +    spapr_register_hypercall(H_INT_ESB, h_int_esb);
>>>> +    spapr_register_hypercall(H_INT_SYNC, h_int_sync);
>>>> +    spapr_register_hypercall(H_INT_RESET, h_int_reset);
>>>> +}
>>>> diff --git a/hw/ppc/spapr_irq.c b/hw/ppc/spapr_irq.c
>>>> index 2569ae1bc7f8..da6fcfaa3c52 100644
>>>> --- a/hw/ppc/spapr_irq.c
>>>> +++ b/hw/ppc/spapr_irq.c
>>>> @@ -258,6 +258,8 @@ static void spapr_irq_init_xive(sPAPRMachineStat=
e *spapr, int nr_irqs,
>>>>          error_propagate(errp, local_err);
>>>>          return;
>>>>      }
>>>> +
>>>> +    spapr_xive_hcall_init(spapr);
>>>>  }
>>>> =20
>>>>  static int spapr_irq_claim_xive(sPAPRMachineState *spapr, int irq, =
bool lsi,
>>>> diff --git a/hw/intc/Makefile.objs b/hw/intc/Makefile.objs
>>>> index 301a8e972d91..eacd26836ebf 100644
>>>> --- a/hw/intc/Makefile.objs
>>>> +++ b/hw/intc/Makefile.objs
>>>> @@ -38,7 +38,7 @@ obj-$(CONFIG_XICS) +=3D xics.o
>>>>  obj-$(CONFIG_XICS_SPAPR) +=3D xics_spapr.o
>>>>  obj-$(CONFIG_XICS_KVM) +=3D xics_kvm.o
>>>>  obj-$(CONFIG_XIVE) +=3D xive.o
>>>> -obj-$(CONFIG_XIVE_SPAPR) +=3D spapr_xive.o
>>>> +obj-$(CONFIG_XIVE_SPAPR) +=3D spapr_xive.o spapr_xive_hcall.o
>>>>  obj-$(CONFIG_POWERNV) +=3D xics_pnv.o
>>>>  obj-$(CONFIG_ALLWINNER_A10_PIC) +=3D allwinner-a10-pic.o
>>>>  obj-$(CONFIG_S390_FLIC) +=3D s390_flic.o
>>>
>>
>=20


