Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by likexu-workstation with
  POP3-SSL; 29 Nov 2018 08:41:02 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga007.jf.intel.com (orsmga007.jf.intel.com [10.7.209.58])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 20AD2580322;
	Wed, 28 Nov 2018 13:00:04 -0800 (PST)
Received: from orsmga101.jf.intel.com ([10.7.208.22])
  by orsmga007-1.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 28 Nov 2018 13:00:03 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AuK+4XhfjjEEzMa6cmnkQ03eKlGMj4u6mDksu8pMi?=
 =?us-ascii?q?zoh2WeGdxc6+YBKN2/xhgRfzUJnB7Loc0qyK6/CmATRIyK3CmUhKSIZLWR4BhJ?=
 =?us-ascii?q?detC0bK+nBN3fGKuX3ZTcxBsVIWQwt1Xi6NU9IBJS2PAWK8TW94jEIBxrwKxd+?=
 =?us-ascii?q?KPjrFY7OlcS30P2594HObwlSizexfbB/IA+qoQnNq8IbnZZsJqEtxxXTv3BGYf?=
 =?us-ascii?q?5WxWRmJVKSmxbz+MK994N9/ipTpvws6ddOXb31cKokQ7NYCi8mM30u683wqRbD?=
 =?us-ascii?q?VwqP6WACXWgQjxFFHhLK7BD+Xpf2ryv6qu9w0zSUMMHqUbw5Xymp4rx1QxH0li?=
 =?us-ascii?q?gIKz858HnWisNuiqJbvAmhrAF7z4LNfY2ZKOZycqbbcNgHR2ROQ9xRWjRODYOy?=
 =?us-ascii?q?bYQBD+QPM+VFoYfju1QOtgO+CAu3CePz1jNFnGP60bEm3+kjFwzNwQwuH8gJsH?=
 =?us-ascii?q?TRtNj7KKASXvuox6fK0zrDdelW2Tb76IjHbxsspuuMXbVrfsrR0kQvFB3Kjk+W?=
 =?us-ascii?q?qYP7OzOZzOMNs3KU7+d5U++klm0pqxlprzSx2sshjpPFip8bx1za7yl13YU4Kc?=
 =?us-ascii?q?GiREN6Y9OoCIVcuz2eOodsQc4vQ3tktDgkxrEYo5K3YSoHxZYhyhXCcfKIaZKI?=
 =?us-ascii?q?7QjmVOuJITd3mnZleLWnihas/kiv1Pf8WtO30FlUtCpFlMfDtnQX2xzU8MiHRe?=
 =?us-ascii?q?Nx/kan2TmRywDe8v9ILVwwmKbBNpIszKA8moAOvUnAAiP6gkT7ga2OekUh4Oeo?=
 =?us-ascii?q?6uDnYrv8pp+bMo95kgX+MqUomsyiDuU0KwsOUHaB+eS6yrLj+VT1QLJEj/0wjK?=
 =?us-ascii?q?bZqovXJdoUpqGnGQ9ZyIUj5AilDzegztsYmWMLLFVfeBKIl4TpIU3BIOjkDfej?=
 =?us-ascii?q?hFShiDNrx/HFPrL/GJnMIWXDnazlfbZ87U5c1QUywcpe55JSFrEOPvbzVlXtu9?=
 =?us-ascii?q?zfCx8zKxa0zPr/CNVhyoMeXnqCAq+DP6PTrV+H/OUvL/OMZI8Iojn9Lfcl6uXq?=
 =?us-ascii?q?jX84n18dYKao0YEWaHC+AvRpPUGZbWDwjdcGFGcAphA+Q/DyiF2eTT5TYG6/X6?=
 =?us-ascii?q?A75j4lEo6mDoDDRoargLyGxyq7GpxWZmZbClGDC3vodoOEW+sSZyKWOMNujjsE?=
 =?us-ascii?q?Vb25QY87yR6urBP6y6ZgLufM4CIYrpLj1N925+HJjxE97z50At+Z02GMSWF0g2?=
 =?us-ascii?q?wJSyU33KB5vUxy1FOD3bJkjPxfENxZ/+lJXRsiNZ7A0+x6DMj/WgHbcdePUlqm?=
 =?us-ascii?q?RtSmDis3TtI+2NIOZ0d9G9O/jhHMxSaqArkVl6CVC5ww6K7Tw3/xJ8NlwXbcyK?=
 =?us-ascii?q?Yhl0UmQtdINWC+m6Fw7RbTCJDTn0WZjamqc78c0zDL9GuEyWqOv0RYUAprXKXB?=
 =?us-ascii?q?XHAfYFbWrNvj6kPDSb+uFaooMg9bxcGeLatKb8XjjU9aS/f7JNTef2Wxln+tCh?=
 =?us-ascii?q?mS2LODcpDme2UH0yXbE0gLjQYT8G2CNQg/ACehvm3fACZvFVLpf0Pj7+1+pGmn?=
 =?us-ascii?q?QU8zygGAd1dh2Kat+h4JmfycTOse3q4FuCckrDV0AFa93tLMB9qcvQZhe79cYd?=
 =?us-ascii?q?c84FdB2mLUrAh9Pp2mL6B/iV8SaQV3v0Xy1xppDoVMi9QlrHQvzABqM6KXzEtB?=
 =?us-ascii?q?dy+E3ZD3IrDYMG3y8w6gaqHI2lDSys2Z+roS5/sirVXjvwapFlQ5/nVj0tlV1W?=
 =?us-ascii?q?ac55rQAAoTV5LxTlg49xxgq77GZSk94pve1WdwPqmsrj/Cx9UpCfMlyxa9ZdtQ?=
 =?us-ascii?q?LLmIFQ7yE8IAAciuJ/cnm1yobhICIeBT+7Q4P8Kgd/uaxqGrOPxsky6hjWRC+I?=
 =?us-ascii?q?p9yF6D9zJgSu7U2JYI2+uY3gqbWDjmlleur8f3lZpCZT4MBGq/yDHoC5JLaa12?=
 =?us-ascii?q?YIkEF32uI8qxxthlg57tWnhY9EOsBl8c2c+pfwaSYEL53QFKyUsXpnmnkzOizz?=
 =?us-ascii?q?NoizEpsraf3CvWzuXidRoLIG5KSHN5jVfxJ4i5lNQaXEmubwg0mxqp/0f6x65H?=
 =?us-ascii?q?pKthK2nfW1tHfy/zL2t6SKu/qqKCY9JT6JMvqShXUv6zYUqZSr7+pBsWyTjjEH?=
 =?us-ascii?q?FdxDA4djGqvIv2nxphhWKZLXZzqmfZeM5qyRfe4tzcWeBe3j4cSCZkjjnXA0C2?=
 =?us-ascii?q?P8O18tWMi5fDrue+WnqhV5JJdinn14GAtCq95WBxBR2/nvazmsDoEAQg0C/70c?=
 =?us-ascii?q?VqWjvMrBrmfobr0KG6O/p9fkZ0HF/899Z6GoZmn4sznp4Q2GIWhpWI/XUdl2fz?=
 =?us-ascii?q?Ps5W2ab/bHoLWD4KzMTZ4Anj2E1/MH2Jw5j1WWmawstkf9O6eH8Z2joh78BWD6?=
 =?us-ascii?q?eZ9LlEnSp2olWitw7Qb+ZyniwByfQw8n4VmP8GuBAiziiGBrASHE9YPTHjlhiS?=
 =?us-ascii?q?7tC+qrlXa3ircbSqyEV+mtWhBqmYog5AQHb5ZosiHSho48VjN1LM1Wf/64D+d9?=
 =?us-ascii?q?nWcNITrQaUkxbbguhRKZIxkOcKhCV9NWL8u30l1/A0jRh00Z6mu4iHLn1n/Lil?=
 =?us-ascii?q?DR5AKj31e8QT9yn2gqlEmcaW252vEo9lGjUWR5boSfOoEDQPtfXoLQqOETs8qm?=
 =?us-ascii?q?uFFrrbBwOQ9EBmr3fXGZCxK36XPGUZzcllRBSFJkxQmgUUUyshnpIjCgCm3s/h?=
 =?us-ascii?q?cFp65jAM4F73sABMx/lsNxn+VGffuQipZi01SJiZMBpZ8AVC613JPsyZ6+J5Bz?=
 =?us-ascii?q?tY8YG5rAyRNmybYBxFDGEOWkyZHlDjI6Oh5d/a/+iDAeq+KfTObK6KqexfUfeI?=
 =?us-ascii?q?2J2u3pFn/zaKKsWAIH1iA+cn1UpEWHBzA97ZlCkXSywLiyLNaNaWpBei9S12rc?=
 =?us-ascii?q?C/8/XrVBjs5YuVDLtSPstg+wqrgaeYLOOQgCd5KTBF1pID33PIyb4f3EIMhCFq?=
 =?us-ascii?q?bTWiDbMAtSvVRqLKhqBXFwIbaz90NMZQ9a08wxJCOdTFhdL1zLJ4iv81BkxBVV?=
 =?us-ascii?q?zgnMGpeMMLL3u8NFPBGEaEKrCGKSfXzMHwZKO2UadQg/lMtx2spTabFFfuPiiC?=
 =?us-ascii?q?lznsTRygLftAgz2bPBNAvoGwaRJtCWnlTNL7ZRy3Kt53jTsqwbIqgnPGL3ITMT?=
 =?us-ascii?q?95c0lVtL2f8TtYguljG2xG9ndkLfOLmyCc7+nZLJYZqfpqAiRumOJc73Q30L9V?=
 =?us-ascii?q?7CBCRPxolyretN9uo1e6kuaRzjprSgZBqjFOhNHDgUI3E7/U8JVJXz7k/R0C7G?=
 =?us-ascii?q?OLQ0AAvdZjBtTpu6FfxdnJj4r8LzBN99+S9swZUZv6MsWCZUAmO1LJFSTODQ0K?=
 =?us-ascii?q?BWqxMmvfr09Qivef8juStJds+cuko4YHVrIODA99LfgdEEkwWYVaeJo=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0ATAACdAP9bh0O0hNFkHQEBBQEHBQGBU?=
 =?us-ascii?q?QgBCwGDayeDeYgYjAiCDRRolkaBJANQEBgTAYduIjQJDQEDAQEBAQEBAgETAQE?=
 =?us-ascii?q?BCA0JCCkjDII2JAGCYQEBAQECAQECFwEIBBkBATcBBAEJAQEKCw0CAiYCAgMfE?=
 =?us-ascii?q?gEFARwGEwWDHIF6CAWbbTyKHXB8M4J2AQEFhycIgQuJb4EcF4FAP4ERghRJNYg?=
 =?us-ascii?q?FgleJAxENCoFuhA13UI8wCYIgg3SEFocHGIFahRCKK4l5jkAPIYElbIEhTTAIO?=
 =?us-ascii?q?zEGgjWCGwwXiF6FXiEygQUBAY1jAQE?=
X-IPAS-Result: =?us-ascii?q?A0ATAACdAP9bh0O0hNFkHQEBBQEHBQGBUQgBCwGDayeDeYg?=
 =?us-ascii?q?YjAiCDRRolkaBJANQEBgTAYduIjQJDQEDAQEBAQEBAgETAQEBCA0JCCkjDII2J?=
 =?us-ascii?q?AGCYQEBAQECAQECFwEIBBkBATcBBAEJAQEKCw0CAiYCAgMfEgEFARwGEwWDHIF?=
 =?us-ascii?q?6CAWbbTyKHXB8M4J2AQEFhycIgQuJb4EcF4FAP4ERghRJNYgFgleJAxENCoFuh?=
 =?us-ascii?q?A13UI8wCYIgg3SEFocHGIFahRCKK4l5jkAPIYElbIEhTTAIOzEGgjWCGwwXiF6?=
 =?us-ascii?q?FXiEygQUBAY1jAQE?=
X-IronPort-AV: E=Sophos;i="5.56,291,1539673200"; 
   d="scan'208";a="42726353"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 28 Nov 2018 13:00:00 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726382AbeK2H7u (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 29 Nov 2018 02:59:50 -0500
Received: from mail.kernel.org ([198.145.29.99]:34778 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1725799AbeK2H7u (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 29 Nov 2018 02:59:50 -0500
Received: from mail-qk1-f177.google.com (mail-qk1-f177.google.com [209.85.222.177])
        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 7149D21104;
        Wed, 28 Nov 2018 20:56:49 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1543438609;
        bh=Voq9/KSYHkL8y+B6QtrS67sV+6wYht5Cxl0+yTiAPys=;
        h=References:In-Reply-To:From:Date:Subject:To:Cc:From;
        b=lwd4ZLA3QQhSLGWgaCqCH/6yu2Ow8smXnHP8TtMUyB4kjVE5ywbIUzqfqPr1dwD+1
         9coyDSeD6rH6pNbv5LvG8IgX3lqmbzbIFU5gReQppzrePcnZRbl3UMMpQFIHQwGIuO
         rBHxz/RsuI1R73NK+KfWLZQImPT7ArXCARJ2zijc=
Received: by mail-qk1-f177.google.com with SMTP id n12so17673531qkh.11;
        Wed, 28 Nov 2018 12:56:49 -0800 (PST)
X-Gm-Message-State: AA+aEWbVR4Z1KEkzgdGEjko8RR182V6lTbP+C/Zwg4h4+Vn3r7bPhzIU
        rlElYlApF2EcIebwQJ1Int3oBB6yERWnIT6fYw==
X-Google-Smtp-Source: AFSGD/VxB2eKGdvcEnX1qX8Gk5r5JI5ncHAUrKop0Wl7MSv6Ud1/nlpa7M3I1L3zRq1Hd+CkdSrbim0qwFqwC2f+Gu4=
X-Received: by 2002:ae9:edd8:: with SMTP id c207mr34305129qkg.184.1543438608189;
 Wed, 28 Nov 2018 12:56:48 -0800 (PST)
MIME-Version: 1.0
References: <20181128193636.254378-1-brendanhiggins@google.com> <20181128193636.254378-18-brendanhiggins@google.com>
In-Reply-To: <20181128193636.254378-18-brendanhiggins@google.com>
From: Rob Herring <robh@kernel.org>
Date: Wed, 28 Nov 2018 14:56:36 -0600
X-Gmail-Original-Message-ID: <CAL_Jsq+09Kx7yMBC_Jw45QGmk6U_fp4N6HOZDwYrM4tWw+_dOA@mail.gmail.com>
Message-ID: <CAL_Jsq+09Kx7yMBC_Jw45QGmk6U_fp4N6HOZDwYrM4tWw+_dOA@mail.gmail.com>
Subject: Re: [RFC v3 17/19] of: unittest: migrate tests to run on KUnit
To: Brendan Higgins <brendanhiggins@google.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        Kees Cook <keescook@google.com>,
        "Luis R. Rodriguez" <mcgrof@kernel.org>, shuah@kernel.org,
        Joel Stanley <joel@jms.id.au>,
        Michael Ellerman <mpe@ellerman.id.au>,
        Joe Perches <joe@perches.com>, brakmo@fb.com,
        Steven Rostedt <rostedt@goodmis.org>,
        "Bird, Timothy" <Tim.Bird@sony.com>,
        Kevin Hilman <khilman@baylibre.com>,
        Julia Lawall <julia.lawall@lip6.fr>,
        linux-kselftest@vger.kernel.org, kunit-dev@googlegroups.com,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
        Jeff Dike <jdike@addtoit.com>,
        Richard Weinberger <richard@nod.at>,
        linux-um@lists.infradead.org, Daniel Vetter <daniel@ffwll.ch>,
        dri-devel <dri-devel@lists.freedesktop.org>,
        Dan Williams <dan.j.williams@intel.com>,
        linux-nvdimm <linux-nvdimm@lists.01.org>,
        Kieran Bingham <kieran.bingham@ideasonboard.com>,
        Frank Rowand <frowand.list@gmail.com>, knut.omang@oracle.com
Content-Type: text/plain; charset="UTF-8"
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Wed, Nov 28, 2018 at 1:38 PM Brendan Higgins
<brendanhiggins@google.com> wrote:
>
> Migrate tests without any cleanup, or modifying test logic in anyway to
> run under KUnit using the KUnit expectation and assertion API.

Nice! You beat me to it. This is probably going to conflict with what
is in the DT tree for 4.21. Also, please Cc the DT list for
drivers/of/ changes.

Looks good to me, but a few mostly formatting comments below.

>
> Signed-off-by: Brendan Higgins <brendanhiggins@google.com>
> ---
>  drivers/of/Kconfig    |    1 +
>  drivers/of/unittest.c | 1405 ++++++++++++++++++++++-------------------
>  2 files changed, 752 insertions(+), 654 deletions(-)
>
> diff --git a/drivers/of/Kconfig b/drivers/of/Kconfig
> index ad3fcad4d75b8..f309399deac20 100644
> --- a/drivers/of/Kconfig
> +++ b/drivers/of/Kconfig
> @@ -15,6 +15,7 @@ if OF
>  config OF_UNITTEST
>         bool "Device Tree runtime unit tests"
>         depends on !SPARC
> +       depends on KUNIT

Unless KUNIT has depends, better to be a select here.

>         select IRQ_DOMAIN
>         select OF_EARLY_FLATTREE
>         select OF_RESOLVE
> diff --git a/drivers/of/unittest.c b/drivers/of/unittest.c
> index 41b49716ac75f..a5ef44730ffdb 100644
> --- a/drivers/of/unittest.c
> +++ b/drivers/of/unittest.c
> @@ -26,186 +26,187 @@
>
>  #include <linux/bitops.h>
>
> +#include <kunit/test.h>
> +
>  #include "of_private.h"
>
> -static struct unittest_results {
> -       int passed;
> -       int failed;
> -} unittest_results;
> -
> -#define unittest(result, fmt, ...) ({ \
> -       bool failed = !(result); \
> -       if (failed) { \
> -               unittest_results.failed++; \
> -               pr_err("FAIL %s():%i " fmt, __func__, __LINE__, ##__VA_ARGS__); \
> -       } else { \
> -               unittest_results.passed++; \
> -               pr_debug("pass %s():%i\n", __func__, __LINE__); \
> -       } \
> -       failed; \
> -})
> -
> -static void __init of_unittest_find_node_by_name(void)
> +static void of_unittest_find_node_by_name(struct kunit *test)

Why do we have to drop __init everywhere? The tests run later?

>  {
>         struct device_node *np;
>         const char *options, *name;
>
>         np = of_find_node_by_path("/testcase-data");
>         name = kasprintf(GFP_KERNEL, "%pOF", np);
> -       unittest(np && !strcmp("/testcase-data", name),
> -               "find /testcase-data failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_STREQ_MSG(test, "/testcase-data", name,
> +                              "find /testcase-data failed\n");
>         of_node_put(np);
>         kfree(name);
>
>         /* Test if trailing '/' works */
> -       np = of_find_node_by_path("/testcase-data/");
> -       unittest(!np, "trailing '/' on /testcase-data/ should fail\n");
> +       KUNIT_EXPECT_EQ_MSG(test, of_find_node_by_path("/testcase-data/"), NULL,
> +                           "trailing '/' on /testcase-data/ should fail\n");
>
>         np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>         name = kasprintf(GFP_KERNEL, "%pOF", np);
> -       unittest(np && !strcmp("/testcase-data/phandle-tests/consumer-a", name),
> -               "find /testcase-data/phandle-tests/consumer-a failed\n");
> +       KUNIT_EXPECT_STREQ_MSG(test,
> +                              "/testcase-data/phandle-tests/consumer-a", name,
> +                              "find /testcase-data/phandle-tests/consumer-a failed\n");
>         of_node_put(np);
>         kfree(name);
>
>         np = of_find_node_by_path("testcase-alias");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>         name = kasprintf(GFP_KERNEL, "%pOF", np);
> -       unittest(np && !strcmp("/testcase-data", name),
> -               "find testcase-alias failed\n");
> +       KUNIT_EXPECT_STREQ_MSG(test, "/testcase-data", name,
> +                              "find testcase-alias failed\n");
>         of_node_put(np);
>         kfree(name);
>
>         /* Test if trailing '/' works on aliases */
> -       np = of_find_node_by_path("testcase-alias/");
> -       unittest(!np, "trailing '/' on testcase-alias/ should fail\n");
> +       KUNIT_EXPECT_EQ_MSG(test, of_find_node_by_path("testcase-alias/"), NULL,
> +                           "trailing '/' on testcase-alias/ should fail\n");
>
>         np = of_find_node_by_path("testcase-alias/phandle-tests/consumer-a");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>         name = kasprintf(GFP_KERNEL, "%pOF", np);
> -       unittest(np && !strcmp("/testcase-data/phandle-tests/consumer-a", name),
> -               "find testcase-alias/phandle-tests/consumer-a failed\n");
> +       KUNIT_EXPECT_STREQ_MSG(test,
> +                              "/testcase-data/phandle-tests/consumer-a", name,
> +                              "find testcase-alias/phandle-tests/consumer-a failed\n");
>         of_node_put(np);
>         kfree(name);
>
> -       np = of_find_node_by_path("/testcase-data/missing-path");
> -       unittest(!np, "non-existent path returned node %pOF\n", np);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_find_node_by_path("/testcase-data/missing-path"),
> +                           NULL,
> +                           "non-existent path returned node %pOF\n", np);

1 tab indent would help with less vertical code (in general, not this
one so much).

>         of_node_put(np);
>
> -       np = of_find_node_by_path("missing-alias");
> -       unittest(!np, "non-existent alias returned node %pOF\n", np);
> +       KUNIT_EXPECT_EQ_MSG(test, of_find_node_by_path("missing-alias"), NULL,
> +                           "non-existent alias returned node %pOF\n", np);
>         of_node_put(np);
>
> -       np = of_find_node_by_path("testcase-alias/missing-path");
> -       unittest(!np, "non-existent alias with relative path returned node %pOF\n", np);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_find_node_by_path("testcase-alias/missing-path"),
> +                           NULL,
> +                           "non-existent alias with relative path returned node %pOF\n",
> +                           np);
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("/testcase-data:testoption", &options);
> -       unittest(np && !strcmp("testoption", options),
> -                "option path test failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_STREQ_MSG(test, "testoption", options,
> +                              "option path test failed\n");
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("/testcase-data:test/option", &options);
> -       unittest(np && !strcmp("test/option", options),
> -                "option path test, subcase #1 failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_STREQ_MSG(test, "test/option", options,
> +                              "option path test, subcase #1 failed\n");
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("/testcase-data/testcase-device1:test/option", &options);
> -       unittest(np && !strcmp("test/option", options),
> -                "option path test, subcase #2 failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_STREQ_MSG(test, "test/option", options,
> +                              "option path test, subcase #2 failed\n");
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("/testcase-data:testoption", NULL);
> -       unittest(np, "NULL option path test failed\n");
> +       KUNIT_EXPECT_NOT_ERR_OR_NULL_MSG(test, np,
> +                                        "NULL option path test failed\n");
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("testcase-alias:testaliasoption",
>                                        &options);
> -       unittest(np && !strcmp("testaliasoption", options),
> -                "option alias path test failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_STREQ_MSG(test, "testaliasoption", options,
> +                              "option alias path test failed\n");
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("testcase-alias:test/alias/option",
>                                        &options);
> -       unittest(np && !strcmp("test/alias/option", options),
> -                "option alias path test, subcase #1 failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_STREQ_MSG(test, "test/alias/option", options,
> +                              "option alias path test, subcase #1 failed\n");
>         of_node_put(np);
>
>         np = of_find_node_opts_by_path("testcase-alias:testaliasoption", NULL);
> -       unittest(np, "NULL option alias path test failed\n");
> +       KUNIT_EXPECT_NOT_ERR_OR_NULL_MSG(test, np,
> +                                        "NULL option alias path test failed\n");
>         of_node_put(np);
>
>         options = "testoption";
>         np = of_find_node_opts_by_path("testcase-alias", &options);
> -       unittest(np && !options, "option clearing test failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_EQ_MSG(test, options, NULL,
> +                           "option clearing test failed\n");
>         of_node_put(np);
>
>         options = "testoption";
>         np = of_find_node_opts_by_path("/", &options);
> -       unittest(np && !options, "option clearing root node test failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +       KUNIT_EXPECT_EQ_MSG(test, options, NULL,
> +                           "option clearing root node test failed\n");
>         of_node_put(np);
>  }
>
> -static void __init of_unittest_dynamic(void)
> +static void of_unittest_dynamic(struct kunit *test)
>  {
>         struct device_node *np;
>         struct property *prop;
>
>         np = of_find_node_by_path("/testcase-data");
> -       if (!np) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         /* Array of 4 properties for the purpose of testing */
>         prop = kcalloc(4, sizeof(*prop), GFP_KERNEL);
> -       if (!prop) {
> -               unittest(0, "kzalloc() failed\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, prop);
>
>         /* Add a new property - should pass*/
>         prop->name = "new-property";
>         prop->value = "new-property-data";
>         prop->length = strlen(prop->value) + 1;
> -       unittest(of_add_property(np, prop) == 0, "Adding a new property failed\n");
> +       KUNIT_EXPECT_EQ_MSG(test, of_add_property(np, prop), 0,
> +                           "Adding a new property failed\n");
>
>         /* Try to add an existing property - should fail */
>         prop++;
>         prop->name = "new-property";
>         prop->value = "new-property-data-should-fail";
>         prop->length = strlen(prop->value) + 1;
> -       unittest(of_add_property(np, prop) != 0,
> -                "Adding an existing property should have failed\n");
> +       KUNIT_EXPECT_NE_MSG(test, of_add_property(np, prop), 0,
> +                           "Adding an existing property should have failed\n");
>
>         /* Try to modify an existing property - should pass */
>         prop->value = "modify-property-data-should-pass";
>         prop->length = strlen(prop->value) + 1;
> -       unittest(of_update_property(np, prop) == 0,
> -                "Updating an existing property should have passed\n");
> +       KUNIT_EXPECT_EQ_MSG(test, of_update_property(np, prop), 0,
> +                           "Updating an existing property should have passed\n");
>
>         /* Try to modify non-existent property - should pass*/
>         prop++;
>         prop->name = "modify-property";
>         prop->value = "modify-missing-property-data-should-pass";
>         prop->length = strlen(prop->value) + 1;
> -       unittest(of_update_property(np, prop) == 0,
> -                "Updating a missing property should have passed\n");
> +       KUNIT_EXPECT_EQ_MSG(test, of_update_property(np, prop), 0,
> +                           "Updating a missing property should have passed\n");
>
>         /* Remove property - should pass */
> -       unittest(of_remove_property(np, prop) == 0,
> -                "Removing a property should have passed\n");
> +       KUNIT_EXPECT_EQ_MSG(test, of_remove_property(np, prop), 0,
> +                           "Removing a property should have passed\n");
>
>         /* Adding very large property - should pass */
>         prop++;
>         prop->name = "large-property-PAGE_SIZEx8";
>         prop->length = PAGE_SIZE * 8;
>         prop->value = kzalloc(prop->length, GFP_KERNEL);
> -       unittest(prop->value != NULL, "Unable to allocate large buffer\n");
> -       if (prop->value)
> -               unittest(of_add_property(np, prop) == 0,
> -                        "Adding a large property should have passed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, prop->value);
> +       KUNIT_EXPECT_EQ_MSG(test, of_add_property(np, prop), 0,
> +                           "Adding a large property should have passed\n");
>  }
>
> -static int __init of_unittest_check_node_linkage(struct device_node *np)
> +static int of_unittest_check_node_linkage(struct device_node *np)
>  {
>         struct device_node *child;
>         int count = 0, rc;
> @@ -230,27 +231,29 @@ static int __init of_unittest_check_node_linkage(struct device_node *np)
>         return rc;
>  }
>
> -static void __init of_unittest_check_tree_linkage(void)
> +static void of_unittest_check_tree_linkage(struct kunit *test)
>  {
>         struct device_node *np;
>         int allnode_count = 0, child_count;
>
> -       if (!of_root)
> -               return;
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, of_root);
>
>         for_each_of_allnodes(np)
>                 allnode_count++;
>         child_count = of_unittest_check_node_linkage(of_root);
>
> -       unittest(child_count > 0, "Device node data structure is corrupted\n");
> -       unittest(child_count == allnode_count,
> -                "allnodes list size (%i) doesn't match sibling lists size (%i)\n",
> -                allnode_count, child_count);
> +       KUNIT_EXPECT_GT_MSG(test, child_count, 0,
> +                           "Device node data structure is corrupted\n");
> +       KUNIT_EXPECT_EQ_MSG(test, child_count, allnode_count,
> +                           "allnodes list size (%i) doesn't match sibling lists size (%i)\n",
> +                           allnode_count, child_count);
>         pr_debug("allnodes list size (%i); sibling lists size (%i)\n", allnode_count, child_count);
>  }
>
> -static void __init of_unittest_printf_one(struct device_node *np, const char *fmt,
> -                                         const char *expected)
> +static void of_unittest_printf_one(struct kunit *test,
> +                                  struct device_node *np,
> +                                  const char *fmt,
> +                                  const char *expected)
>  {
>         unsigned char *buf;
>         int buf_size;
> @@ -266,9 +269,12 @@ static void __init of_unittest_printf_one(struct device_node *np, const char *fm
>         size = snprintf(buf, buf_size - 2, fmt, np);
>
>         /* use strcmp() instead of strncmp() here to be absolutely sure strings match */
> -       unittest((strcmp(buf, expected) == 0) && (buf[size+1] == 0xff),
> -               "sprintf failed; fmt='%s' expected='%s' rslt='%s'\n",
> -               fmt, expected, buf);
> +       KUNIT_EXPECT_STREQ_MSG(test, buf, expected,
> +                              "sprintf failed; fmt='%s' expected='%s' rslt='%s'\n",
> +                              fmt, expected, buf);
> +       KUNIT_EXPECT_EQ_MSG(test, buf[size+1], 0xff,
> +                           "sprintf failed; fmt='%s' expected='%s' rslt='%s'\n",
> +                           fmt, expected, buf);
>
>         /* Make sure length limits work */
>         size++;
> @@ -276,40 +282,43 @@ static void __init of_unittest_printf_one(struct device_node *np, const char *fm
>                 /* Clear the buffer, and make sure it works correctly still */
>                 memset(buf, 0xff, buf_size);
>                 snprintf(buf, size+1, fmt, np);
> -               unittest(strncmp(buf, expected, size) == 0 && (buf[size+1] == 0xff),
> -                       "snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\n",
> -                       size, fmt, expected, buf);
> +               KUNIT_EXPECT_STREQ_MSG(test, buf, expected,
> +                                      "snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\n",
> +                                      size, fmt, expected, buf);
> +               KUNIT_EXPECT_EQ_MSG(test, buf[size+1], 0xff,
> +                                   "snprintf failed; size=%i fmt='%s' expected='%s' rslt='%s'\n",
> +                                   size, fmt, expected, buf);
>         }
>         kfree(buf);
>  }
>
> -static void __init of_unittest_printf(void)
> +static void of_unittest_printf(struct kunit *test)
>  {
>         struct device_node *np;
>         const char *full_name = "/testcase-data/platform-tests/test-device@1/dev@100";
>         char phandle_str[16] = "";
>
>         np = of_find_node_by_path(full_name);
> -       if (!np) {
> -               unittest(np, "testcase data missing\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         num_to_str(phandle_str, sizeof(phandle_str), np->phandle, 0);
>
> -       of_unittest_printf_one(np, "%pOF",  full_name);
> -       of_unittest_printf_one(np, "%pOFf", full_name);
> -       of_unittest_printf_one(np, "%pOFp", phandle_str);
> -       of_unittest_printf_one(np, "%pOFP", "dev@100");
> -       of_unittest_printf_one(np, "ABC %pOFP ABC", "ABC dev@100 ABC");
> -       of_unittest_printf_one(np, "%10pOFP", "   dev@100");
> -       of_unittest_printf_one(np, "%-10pOFP", "dev@100   ");
> -       of_unittest_printf_one(of_root, "%pOFP", "/");
> -       of_unittest_printf_one(np, "%pOFF", "----");
> -       of_unittest_printf_one(np, "%pOFPF", "dev@100:----");
> -       of_unittest_printf_one(np, "%pOFPFPc", "dev@100:----:dev@100:test-sub-device");
> -       of_unittest_printf_one(np, "%pOFc", "test-sub-device");
> -       of_unittest_printf_one(np, "%pOFC",
> +       of_unittest_printf_one(test, np, "%pOF",  full_name);
> +       of_unittest_printf_one(test, np, "%pOFf", full_name);
> +       of_unittest_printf_one(test, np, "%pOFp", phandle_str);
> +       of_unittest_printf_one(test, np, "%pOFP", "dev@100");
> +       of_unittest_printf_one(test, np, "ABC %pOFP ABC", "ABC dev@100 ABC");
> +       of_unittest_printf_one(test, np, "%10pOFP", "   dev@100");
> +       of_unittest_printf_one(test, np, "%-10pOFP", "dev@100   ");
> +       of_unittest_printf_one(test, of_root, "%pOFP", "/");
> +       of_unittest_printf_one(test, np, "%pOFF", "----");
> +       of_unittest_printf_one(test, np, "%pOFPF", "dev@100:----");
> +       of_unittest_printf_one(test,
> +                              np,
> +                              "%pOFPFPc",
> +                              "dev@100:----:dev@100:test-sub-device");
> +       of_unittest_printf_one(test, np, "%pOFc", "test-sub-device");
> +       of_unittest_printf_one(test, np, "%pOFC",
>                         "\"test-sub-device\",\"test-compat2\",\"test-compat3\"");
>  }
>
> @@ -319,7 +328,7 @@ struct node_hash {
>  };
>
>  static DEFINE_HASHTABLE(phandle_ht, 8);
> -static void __init of_unittest_check_phandles(void)
> +static void of_unittest_check_phandles(struct kunit *test)
>  {
>         struct device_node *np;
>         struct node_hash *nh;
> @@ -331,24 +340,25 @@ static void __init of_unittest_check_phandles(void)
>                         continue;
>
>                 hash_for_each_possible(phandle_ht, nh, node, np->phandle) {
> +                       KUNIT_EXPECT_NE_MSG(test, nh->np->phandle, np->phandle,
> +                                           "Duplicate phandle! %i used by %pOF and %pOF\n",
> +                                           np->phandle, nh->np, np);
>                         if (nh->np->phandle == np->phandle) {
> -                               pr_info("Duplicate phandle! %i used by %pOF and %pOF\n",
> -                                       np->phandle, nh->np, np);
>                                 dup_count++;
>                                 break;
>                         }
>                 }
>
>                 nh = kzalloc(sizeof(*nh), GFP_KERNEL);
> -               if (WARN_ON(!nh))
> -                       return;
> +               KUNIT_ASSERT_NOT_ERR_OR_NULL(test, nh);
>
>                 nh->np = np;
>                 hash_add(phandle_ht, &nh->node, np->phandle);
>                 phandle_count++;
>         }
> -       unittest(dup_count == 0, "Found %i duplicates in %i phandles\n",
> -                dup_count, phandle_count);
> +       KUNIT_EXPECT_EQ_MSG(test, dup_count, 0,
> +                           "Found %i duplicates in %i phandles\n",
> +                           dup_count, phandle_count);
>
>         /* Clean up */
>         hash_for_each_safe(phandle_ht, i, tmp, nh, node) {
> @@ -357,20 +367,22 @@ static void __init of_unittest_check_phandles(void)
>         }
>  }
>
> -static void __init of_unittest_parse_phandle_with_args(void)
> +static void of_unittest_parse_phandle_with_args(struct kunit *test)
>  {
>         struct device_node *np;
>         struct of_phandle_args args;
> -       int i, rc;
> +       int i, rc = 0;
>
>         np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
> -       if (!np) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
> -       rc = of_count_phandle_with_args(np, "phandle-list", "#phandle-cells");
> -       unittest(rc == 7, "of_count_phandle_with_args() returned %i, expected 7\n", rc);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_count_phandle_with_args(np,
> +                                                      "phandle-list",
> +                                                      "#phandle-cells"),
> +                           7,
> +                           "of_count_phandle_with_args() returned %i, expected 7\n",
> +                           rc);
>
>         for (i = 0; i < 8; i++) {
>                 bool passed = true;
> @@ -423,81 +435,90 @@ static void __init of_unittest_parse_phandle_with_args(void)
>                         passed = false;
>                 }
>
> -               unittest(passed, "index %i - data error on node %pOF rc=%i\n",
> -                        i, args.np, rc);
> +               KUNIT_EXPECT_TRUE_MSG(test, passed,
> +                                     "index %i - data error on node %pOF rc=%i\n",
> +                                     i, args.np, rc);
>         }
>
>         /* Check for missing list property */
> -       rc = of_parse_phandle_with_args(np, "phandle-list-missing",
> -                                       "#phandle-cells", 0, &args);
> -       unittest(rc == -ENOENT, "expected:%i got:%i\n", -ENOENT, rc);
> -       rc = of_count_phandle_with_args(np, "phandle-list-missing",
> -                                       "#phandle-cells");
> -       unittest(rc == -ENOENT, "expected:%i got:%i\n", -ENOENT, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args(np,
> +                                                  "phandle-list-missing",
> +                                                  "#phandle-cells",
> +                                                  0, &args),
> +                       -ENOENT);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_count_phandle_with_args(np,
> +                                                  "phandle-list-missing",
> +                                                  "#phandle-cells"),
> +                       -ENOENT);
>
>         /* Check for missing cells property */
> -       rc = of_parse_phandle_with_args(np, "phandle-list",
> -                                       "#phandle-cells-missing", 0, &args);
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> -       rc = of_count_phandle_with_args(np, "phandle-list",
> -                                       "#phandle-cells-missing");
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args(np,
> +                                                  "phandle-list",
> +                                                  "#phandle-cells-missing",
> +                                                  0, &args),
> +                       -EINVAL);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_count_phandle_with_args(np,
> +                                                  "phandle-list",
> +                                                  "#phandle-cells-missing"),
> +                       -EINVAL);
>
>         /* Check for bad phandle in list */
> -       rc = of_parse_phandle_with_args(np, "phandle-list-bad-phandle",
> -                                       "#phandle-cells", 0, &args);
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> -       rc = of_count_phandle_with_args(np, "phandle-list-bad-phandle",
> -                                       "#phandle-cells");
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args(np,
> +                                                  "phandle-list-bad-phandle",
> +                                                  "#phandle-cells",
> +                                                  0, &args),
> +                       -EINVAL);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_count_phandle_with_args(np,
> +                                                  "phandle-list-bad-phandle",
> +                                                  "#phandle-cells"),
> +                       -EINVAL);
>
>         /* Check for incorrectly formed argument list */
> -       rc = of_parse_phandle_with_args(np, "phandle-list-bad-args",
> -                                       "#phandle-cells", 1, &args);
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> -       rc = of_count_phandle_with_args(np, "phandle-list-bad-args",
> -                                       "#phandle-cells");
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args(np,
> +                                                  "phandle-list-bad-args",
> +                                                  "#phandle-cells",
> +                                                  1, &args),
> +                       -EINVAL);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_count_phandle_with_args(np,
> +                                                  "phandle-list-bad-args",
> +                                                  "#phandle-cells"),
> +                       -EINVAL);
>  }
>
> -static void __init of_unittest_parse_phandle_with_args_map(void)
> +static void of_unittest_parse_phandle_with_args_map(struct kunit *test)
>  {
>         struct device_node *np, *p0, *p1, *p2, *p3;
>         struct of_phandle_args args;
>         int i, rc;
>
>         np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-b");
> -       if (!np) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         p0 = of_find_node_by_path("/testcase-data/phandle-tests/provider0");
> -       if (!p0) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, p0);
>
>         p1 = of_find_node_by_path("/testcase-data/phandle-tests/provider1");
> -       if (!p1) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, p1);
>
>         p2 = of_find_node_by_path("/testcase-data/phandle-tests/provider2");
> -       if (!p2) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, p2);
>
>         p3 = of_find_node_by_path("/testcase-data/phandle-tests/provider3");
> -       if (!p3) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, p3);
>
> -       rc = of_count_phandle_with_args(np, "phandle-list", "#phandle-cells");
> -       unittest(rc == 7, "of_count_phandle_with_args() returned %i, expected 7\n", rc);
> +       KUNIT_EXPECT_EQ(test,
> +                      of_count_phandle_with_args(np,
> +                                                 "phandle-list",
> +                                                 "#phandle-cells"),
> +                      7);
>
>         for (i = 0; i < 8; i++) {
>                 bool passed = true;
> @@ -554,117 +575,214 @@ static void __init of_unittest_parse_phandle_with_args_map(void)
>                         passed = false;
>                 }
>
> -               unittest(passed, "index %i - data error on node %s rc=%i\n",
> -                        i, args.np->full_name, rc);
> +               KUNIT_EXPECT_TRUE_MSG(test, passed,
> +                                     "index %i - data error on node %s rc=%i\n",
> +                                     i, args.np->full_name, rc);
>         }
>
>         /* Check for missing list property */
> -       rc = of_parse_phandle_with_args_map(np, "phandle-list-missing",
> -                                           "phandle", 0, &args);
> -       unittest(rc == -ENOENT, "expected:%i got:%i\n", -ENOENT, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args_map(np,
> +                                                      "phandle-list-missing",
> +                                                      "phandle",
> +                                                      0, &args),
> +                       -ENOENT);
>
>         /* Check for missing cells,map,mask property */
> -       rc = of_parse_phandle_with_args_map(np, "phandle-list",
> -                                           "phandle-missing", 0, &args);
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args_map(np,
> +                                                      "phandle-list",
> +                                                      "phandle-missing",
> +                                                      0, &args),
> +                       -EINVAL);
>
>         /* Check for bad phandle in list */
> -       rc = of_parse_phandle_with_args_map(np, "phandle-list-bad-phandle",
> -                                           "phandle", 0, &args);
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args_map(np,
> +                                                      "phandle-list-bad-phandle",
> +                                                      "phandle",
> +                                                      0, &args),
> +                       -EINVAL);
>
>         /* Check for incorrectly formed argument list */
> -       rc = of_parse_phandle_with_args_map(np, "phandle-list-bad-args",
> -                                           "phandle", 1, &args);
> -       unittest(rc == -EINVAL, "expected:%i got:%i\n", -EINVAL, rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_parse_phandle_with_args_map(np,
> +                                                      "phandle-list-bad-args",
> +                                                      "phandle",
> +                                                      1, &args),
> +                       -EINVAL);
>  }
>
> -static void __init of_unittest_property_string(void)
> +static void of_unittest_property_string(struct kunit *test)
>  {
>         const char *strings[4];
>         struct device_node *np;
>         int rc;
>
>         np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
> -       if (!np) {
> -               pr_err("No testcase data in device tree\n");
> -               return;
> -       }
> -
> -       rc = of_property_match_string(np, "phandle-list-names", "first");
> -       unittest(rc == 0, "first expected:0 got:%i\n", rc);
> -       rc = of_property_match_string(np, "phandle-list-names", "second");
> -       unittest(rc == 1, "second expected:1 got:%i\n", rc);
> -       rc = of_property_match_string(np, "phandle-list-names", "third");
> -       unittest(rc == 2, "third expected:2 got:%i\n", rc);
> -       rc = of_property_match_string(np, "phandle-list-names", "fourth");
> -       unittest(rc == -ENODATA, "unmatched string; rc=%i\n", rc);
> -       rc = of_property_match_string(np, "missing-property", "blah");
> -       unittest(rc == -EINVAL, "missing property; rc=%i\n", rc);
> -       rc = of_property_match_string(np, "empty-property", "blah");
> -       unittest(rc == -ENODATA, "empty property; rc=%i\n", rc);
> -       rc = of_property_match_string(np, "unterminated-string", "blah");
> -       unittest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
> +
> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_match_string(np,
> +                                                "phandle-list-names",
> +                                                "first"),
> +                       0);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_match_string(np,
> +                                                "phandle-list-names",
> +                                                "second"),
> +                       1);

Fewer lines on these would be better even if we go over 80 chars.

> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_match_string(np,
> +                                                "phandle-list-names",
> +                                                "third"),
> +                       2);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_match_string(np,
> +                                                    "phandle-list-names",
> +                                                    "fourth"),
> +                           -ENODATA,
> +                           "unmatched string");
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_match_string(np,
> +                                                    "missing-property",
> +                                                    "blah"),
> +                           -EINVAL,
> +                           "missing property");
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_match_string(np,
> +                                                    "empty-property",
> +                                                    "blah"),
> +                           -ENODATA,
> +                           "empty property");
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_match_string(np,
> +                                                    "unterminated-string",
> +                                                    "blah"),
> +                           -EILSEQ,
> +                           "unterminated string");
>
>         /* of_property_count_strings() tests */
> -       rc = of_property_count_strings(np, "string-property");
> -       unittest(rc == 1, "Incorrect string count; rc=%i\n", rc);
> -       rc = of_property_count_strings(np, "phandle-list-names");
> -       unittest(rc == 3, "Incorrect string count; rc=%i\n", rc);
> -       rc = of_property_count_strings(np, "unterminated-string");
> -       unittest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
> -       rc = of_property_count_strings(np, "unterminated-string-list");
> -       unittest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_count_strings(np, "string-property"),
> +                       1);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_count_strings(np, "phandle-list-names"),
> +                       3);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_count_strings(np,
> +                                                     "unterminated-string"),
> +                           -EILSEQ,
> +                           "unterminated string");
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_count_strings(
> +                                           np,
> +                                           "unterminated-string-list"),
> +                           -EILSEQ,
> +                           "unterminated string array");
>
>         /* of_property_read_string_index() tests */
>         rc = of_property_read_string_index(np, "string-property", 0, strings);
> -       unittest(rc == 0 && !strcmp(strings[0], "foobar"), "of_property_read_string_index() failure; rc=%i\n", rc);
> +       KUNIT_ASSERT_EQ(test, rc, 0);
> +       KUNIT_EXPECT_STREQ(test, strings[0], "foobar");
>         strings[0] = NULL;
>         rc = of_property_read_string_index(np, "string-property", 1, strings);
> -       unittest(rc == -ENODATA && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
> -       rc = of_property_read_string_index(np, "phandle-list-names", 0, strings);
> -       unittest(rc == 0 && !strcmp(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
> -       rc = of_property_read_string_index(np, "phandle-list-names", 1, strings);
> -       unittest(rc == 0 && !strcmp(strings[0], "second"), "of_property_read_string_index() failure; rc=%i\n", rc);
> -       rc = of_property_read_string_index(np, "phandle-list-names", 2, strings);
> -       unittest(rc == 0 && !strcmp(strings[0], "third"), "of_property_read_string_index() failure; rc=%i\n", rc);
> +       KUNIT_EXPECT_EQ(test, rc, -ENODATA);
> +       KUNIT_EXPECT_EQ(test, strings[0], NULL);
> +       rc = of_property_read_string_index(np,
> +                                          "phandle-list-names",
> +                                          0,
> +                                          strings);
> +       KUNIT_ASSERT_EQ(test, rc, 0);
> +       KUNIT_EXPECT_STREQ(test, strings[0], "first");
> +       rc = of_property_read_string_index(np,
> +                                          "phandle-list-names",
> +                                          1,
> +                                          strings);
> +       KUNIT_ASSERT_EQ(test, rc, 0);
> +       KUNIT_EXPECT_STREQ(test, strings[0], "second");
> +       rc = of_property_read_string_index(np,
> +                                          "phandle-list-names",
> +                                          2,
> +                                          strings);
> +       KUNIT_ASSERT_EQ(test, rc, 0);
> +       KUNIT_EXPECT_STREQ(test, strings[0], "third");
>         strings[0] = NULL;
> -       rc = of_property_read_string_index(np, "phandle-list-names", 3, strings);
> -       unittest(rc == -ENODATA && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
> +       rc = of_property_read_string_index(np,
> +                                          "phandle-list-names", 3, strings);
> +       KUNIT_EXPECT_EQ(test, rc, -ENODATA);
> +       KUNIT_EXPECT_EQ(test, strings[0], NULL);
>         strings[0] = NULL;
> -       rc = of_property_read_string_index(np, "unterminated-string", 0, strings);
> -       unittest(rc == -EILSEQ && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
> -       rc = of_property_read_string_index(np, "unterminated-string-list", 0, strings);
> -       unittest(rc == 0 && !strcmp(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
> +       rc = of_property_read_string_index(np,
> +                                          "unterminated-string",
> +                                          0,
> +                                          strings);
> +       KUNIT_EXPECT_EQ(test, rc, -EILSEQ);
> +       KUNIT_EXPECT_EQ(test, strings[0], NULL);
> +       rc = of_property_read_string_index(np,
> +                                          "unterminated-string-list",
> +                                          0,
> +                                          strings);
> +       KUNIT_ASSERT_EQ(test, rc, 0);
> +       KUNIT_EXPECT_STREQ(test, strings[0], "first");
>         strings[0] = NULL;
> -       rc = of_property_read_string_index(np, "unterminated-string-list", 2, strings); /* should fail */
> -       unittest(rc == -EILSEQ && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
> -       strings[1] = NULL;
> +       rc = of_property_read_string_index(np,
> +                                          "unterminated-string-list",
> +                                          2,
> +                                          strings); /* should fail */
> +       KUNIT_EXPECT_EQ(test, rc, -EILSEQ);
> +       KUNIT_EXPECT_EQ(test, strings[0], NULL);
>
>         /* of_property_read_string_array() tests */
> -       rc = of_property_read_string_array(np, "string-property", strings, 4);
> -       unittest(rc == 1, "Incorrect string count; rc=%i\n", rc);
> -       rc = of_property_read_string_array(np, "phandle-list-names", strings, 4);
> -       unittest(rc == 3, "Incorrect string count; rc=%i\n", rc);
> -       rc = of_property_read_string_array(np, "unterminated-string", strings, 4);
> -       unittest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
> +       strings[1] = NULL;
> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_read_string_array(np,
> +                                                     "string-property",
> +                                                     strings, 4),
> +                       1);
> +       KUNIT_EXPECT_EQ(test,
> +                       of_property_read_string_array(np,
> +                                                     "phandle-list-names",
> +                                                     strings, 4),
> +                       3);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_read_string_array(np,
> +                                                         "unterminated-string",
> +                                                         strings, 4),
> +                           -EILSEQ,
> +                           "unterminated string");
>         /* -- An incorrectly formed string should cause a failure */
> -       rc = of_property_read_string_array(np, "unterminated-string-list", strings, 4);
> -       unittest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
> +       KUNIT_EXPECT_EQ_MSG(test,
> +                           of_property_read_string_array(
> +                                           np,
> +                                           "unterminated-string-list",
> +                                           strings,
> +                                           4),
> +                           -EILSEQ,
> +                           "unterminated string array");
>         /* -- parsing the correctly formed strings should still work: */
>         strings[2] = NULL;
> -       rc = of_property_read_string_array(np, "unterminated-string-list", strings, 2);
> -       unittest(rc == 2 && strings[2] == NULL, "of_property_read_string_array() failure; rc=%i\n", rc);
> +       rc = of_property_read_string_array(np,
> +                                          "unterminated-string-list",
> +                                          strings,
> +                                          2);
> +       KUNIT_EXPECT_EQ(test, rc, 2);
> +       KUNIT_EXPECT_EQ(test, strings[2], NULL);
>         strings[1] = NULL;
> -       rc = of_property_read_string_array(np, "phandle-list-names", strings, 1);
> -       unittest(rc == 1 && strings[1] == NULL, "Overwrote end of string array; rc=%i, str='%s'\n", rc, strings[1]);
> +       rc = of_property_read_string_array(np,
> +                                          "phandle-list-names",
> +                                          strings,
> +                                          1);
> +       KUNIT_ASSERT_EQ(test, rc, 1);
> +       KUNIT_EXPECT_EQ_MSG(test, strings[1], NULL,
> +                           "Overwrote end of string array");
>  }
>
>  #define propcmp(p1, p2) (((p1)->length == (p2)->length) && \
>                         (p1)->value && (p2)->value && \
>                         !memcmp((p1)->value, (p2)->value, (p1)->length) && \
>                         !strcmp((p1)->name, (p2)->name))
> -static void __init of_unittest_property_copy(void)
> +static void of_unittest_property_copy(struct kunit *test)
>  {
>  #ifdef CONFIG_OF_DYNAMIC
>         struct property p1 = { .name = "p1", .length = 0, .value = "" };
> @@ -672,20 +790,24 @@ static void __init of_unittest_property_copy(void)
>         struct property *new;
>
>         new = __of_prop_dup(&p1, GFP_KERNEL);
> -       unittest(new && propcmp(&p1, new), "empty property didn't copy correctly\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, new);
> +       KUNIT_EXPECT_TRUE_MSG(test, propcmp(&p1, new),
> +                             "empty property didn't copy correctly");
>         kfree(new->value);
>         kfree(new->name);
>         kfree(new);
>
>         new = __of_prop_dup(&p2, GFP_KERNEL);
> -       unittest(new && propcmp(&p2, new), "non-empty property didn't copy correctly\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, new);
> +       KUNIT_EXPECT_TRUE_MSG(test, propcmp(&p2, new),
> +                             "non-empty property didn't copy correctly");
>         kfree(new->value);
>         kfree(new->name);
>         kfree(new);
>  #endif
>  }
>
> -static void __init of_unittest_changeset(void)
> +static void of_unittest_changeset(struct kunit *test)
>  {
>  #ifdef CONFIG_OF_DYNAMIC
>         struct property *ppadd, padd = { .name = "prop-add", .length = 1, .value = "" };
> @@ -698,32 +820,32 @@ static void __init of_unittest_changeset(void)
>         struct of_changeset chgset;
>
>         n1 = __of_node_dup(NULL, "n1");
> -       unittest(n1, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, n1);
>
>         n2 = __of_node_dup(NULL, "n2");
> -       unittest(n2, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, n2);
>
>         n21 = __of_node_dup(NULL, "n21");
> -       unittest(n21, "testcase setup failure %p\n", n21);
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, n21);
>
>         nchangeset = of_find_node_by_path("/testcase-data/changeset");
>         nremove = of_get_child_by_name(nchangeset, "node-remove");
> -       unittest(nremove, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, nremove);
>
>         ppadd = __of_prop_dup(&padd, GFP_KERNEL);
> -       unittest(ppadd, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ppadd);
>
>         ppname_n1  = __of_prop_dup(&pname_n1, GFP_KERNEL);
> -       unittest(ppname_n1, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ppname_n1);
>
>         ppname_n2  = __of_prop_dup(&pname_n2, GFP_KERNEL);
> -       unittest(ppname_n2, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ppname_n2);
>
>         ppname_n21 = __of_prop_dup(&pname_n21, GFP_KERNEL);
> -       unittest(ppname_n21, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ppname_n21);
>
>         ppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);
> -       unittest(ppupdate, "testcase setup failure\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ppupdate);
>
>         parent = nchangeset;
>         n1->parent = parent;
> @@ -731,54 +853,82 @@ static void __init of_unittest_changeset(void)
>         n21->parent = n2;
>
>         ppremove = of_find_property(parent, "prop-remove", NULL);
> -       unittest(ppremove, "failed to find removal prop");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, ppremove);
>
>         of_changeset_init(&chgset);
>
> -       unittest(!of_changeset_attach_node(&chgset, n1), "fail attach n1\n");
> -       unittest(!of_changeset_add_property(&chgset, n1, ppname_n1), "fail add prop name\n");
> -
> -       unittest(!of_changeset_attach_node(&chgset, n2), "fail attach n2\n");
> -       unittest(!of_changeset_add_property(&chgset, n2, ppname_n2), "fail add prop name\n");
> -
> -       unittest(!of_changeset_detach_node(&chgset, nremove), "fail remove node\n");
> -       unittest(!of_changeset_add_property(&chgset, n21, ppname_n21), "fail add prop name\n");
> -
> -       unittest(!of_changeset_attach_node(&chgset, n21), "fail attach n21\n");
> -
> -       unittest(!of_changeset_add_property(&chgset, parent, ppadd), "fail add prop prop-add\n");
> -       unittest(!of_changeset_update_property(&chgset, parent, ppupdate), "fail update prop\n");
> -       unittest(!of_changeset_remove_property(&chgset, parent, ppremove), "fail remove prop\n");
> -
> -       unittest(!of_changeset_apply(&chgset), "apply failed\n");
> +       KUNIT_EXPECT_FALSE_MSG(test, of_changeset_attach_node(&chgset, n1),
> +                              "fail attach n1\n");
> +       KUNIT_EXPECT_FALSE_MSG(test,
> +                              of_changeset_add_property(&chgset,
> +                                                        n1,
> +                                                        ppname_n1),
> +                              "fail add prop name\n");
> +
> +       KUNIT_EXPECT_FALSE_MSG(test, of_changeset_attach_node(&chgset, n2),
> +                              "fail attach n2\n");
> +       KUNIT_EXPECT_FALSE_MSG(test,
> +                              of_changeset_add_property(&chgset,
> +                                                        n2,
> +                                                        ppname_n2),
> +                              "fail add prop name\n");
> +
> +       KUNIT_EXPECT_FALSE_MSG(test, of_changeset_detach_node(&chgset, nremove),
> +                              "fail remove node\n");
> +       KUNIT_EXPECT_FALSE_MSG(test,
> +                              of_changeset_add_property(&chgset,
> +                                                        n21,
> +                                                        ppname_n21),
> +                              "fail add prop name\n");
> +
> +       KUNIT_EXPECT_FALSE_MSG(test, of_changeset_attach_node(&chgset, n21),
> +                              "fail attach n21\n");
> +
> +       KUNIT_EXPECT_FALSE_MSG(test,
> +                              of_changeset_add_property(&chgset,
> +                                                        parent,
> +                                                        ppadd),
> +                              "fail add prop prop-add\n");
> +       KUNIT_EXPECT_FALSE_MSG(test,
> +                              of_changeset_update_property(&chgset,
> +                                                           parent,
> +                                                           ppupdate),
> +                              "fail update prop\n");
> +       KUNIT_EXPECT_FALSE_MSG(test,
> +                              of_changeset_remove_property(&chgset,
> +                                                           parent,
> +                                                           ppremove),
> +                              "fail remove prop\n");
> +
> +       KUNIT_EXPECT_FALSE_MSG(test, of_changeset_apply(&chgset),
> +                              "apply failed\n");
>
>         of_node_put(nchangeset);
>
>         /* Make sure node names are constructed correctly */
> -       unittest((np = of_find_node_by_path("/testcase-data/changeset/n2/n21")),
> -                "'%pOF' not added\n", n21);
> +       KUNIT_EXPECT_NOT_ERR_OR_NULL_MSG(
> +                       test,
> +                       np = of_find_node_by_path(
> +                                       "/testcase-data/changeset/n2/n21"),
> +                       "'%pOF' not added\n", n21);
>         of_node_put(np);
>
> -       unittest(!of_changeset_revert(&chgset), "revert failed\n");
> +       KUNIT_EXPECT_FALSE(test, of_changeset_revert(&chgset));
>
>         of_changeset_destroy(&chgset);
>  #endif
>  }
>
> -static void __init of_unittest_parse_interrupts(void)
> +static void of_unittest_parse_interrupts(struct kunit *test)
>  {
>         struct device_node *np;
>         struct of_phandle_args args;
>         int i, rc;
>
> -       if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
> -               return;
> +       KUNIT_ASSERT_FALSE(test, of_irq_workarounds & OF_IMAP_OLDWORLD_MAC);
>
>         np = of_find_node_by_path("/testcase-data/interrupts/interrupts0");
> -       if (!np) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         for (i = 0; i < 4; i++) {
>                 bool passed = true;
> @@ -790,16 +940,14 @@ static void __init of_unittest_parse_interrupts(void)
>                 passed &= (args.args_count == 1);
>                 passed &= (args.args[0] == (i + 1));
>
> -               unittest(passed, "index %i - data error on node %pOF rc=%i\n",
> -                        i, args.np, rc);
> +               KUNIT_EXPECT_TRUE_MSG(test, passed,
> +                                     "index %i - data error on node %pOF rc=%i\n",
> +                                     i, args.np, rc);
>         }
>         of_node_put(np);
>
>         np = of_find_node_by_path("/testcase-data/interrupts/interrupts1");
> -       if (!np) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         for (i = 0; i < 4; i++) {
>                 bool passed = true;
> @@ -836,26 +984,23 @@ static void __init of_unittest_parse_interrupts(void)
>                 default:
>                         passed = false;
>                 }
> -               unittest(passed, "index %i - data error on node %pOF rc=%i\n",
> -                        i, args.np, rc);
> +               KUNIT_EXPECT_TRUE_MSG(test, passed,
> +                                    "index %i - data error on node %pOF rc=%i\n",
> +                                    i, args.np, rc);
>         }
>         of_node_put(np);
>  }
>
> -static void __init of_unittest_parse_interrupts_extended(void)
> +static void of_unittest_parse_interrupts_extended(struct kunit *test)
>  {
>         struct device_node *np;
>         struct of_phandle_args args;
>         int i, rc;
>
> -       if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
> -               return;
> +       KUNIT_ASSERT_FALSE(test, of_irq_workarounds & OF_IMAP_OLDWORLD_MAC);
>
>         np = of_find_node_by_path("/testcase-data/interrupts/interrupts-extended0");
> -       if (!np) {
> -               pr_err("missing testcase data\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         for (i = 0; i < 7; i++) {
>                 bool passed = true;
> @@ -909,8 +1054,9 @@ static void __init of_unittest_parse_interrupts_extended(void)
>                         passed = false;
>                 }
>
> -               unittest(passed, "index %i - data error on node %pOF rc=%i\n",
> -                        i, args.np, rc);
> +               KUNIT_EXPECT_TRUE_MSG(test, passed,
> +                                     "index %i - data error on node %pOF rc=%i\n",
> +                                     i, args.np, rc);
>         }
>         of_node_put(np);
>  }
> @@ -950,7 +1096,7 @@ static struct {
>         { .path = "/testcase-data/match-node/name9", .data = "K", },
>  };
>
> -static void __init of_unittest_match_node(void)
> +static void of_unittest_match_node(struct kunit *test)
>  {
>         struct device_node *np;
>         const struct of_device_id *match;
> @@ -958,26 +1104,19 @@ static void __init of_unittest_match_node(void)
>
>         for (i = 0; i < ARRAY_SIZE(match_node_tests); i++) {
>                 np = of_find_node_by_path(match_node_tests[i].path);
> -               if (!np) {
> -                       unittest(0, "missing testcase node %s\n",
> -                               match_node_tests[i].path);
> -                       continue;
> -               }
> +               KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>                 match = of_match_node(match_node_table, np);
> -               if (!match) {
> -                       unittest(0, "%s didn't match anything\n",
> -                               match_node_tests[i].path);
> -                       continue;
> -               }
> +               KUNIT_ASSERT_NOT_ERR_OR_NULL_MSG(test, np,
> +                                                "%s didn't match anything",
> +                                                match_node_tests[i].path);
>
> -               if (strcmp(match->data, match_node_tests[i].data) != 0) {
> -                       unittest(0, "%s got wrong match. expected %s, got %s\n",
> -                               match_node_tests[i].path, match_node_tests[i].data,
> -                               (const char *)match->data);
> -                       continue;
> -               }
> -               unittest(1, "passed");
> +               KUNIT_EXPECT_STREQ_MSG(test,
> +                                      match->data, match_node_tests[i].data,
> +                                      "%s got wrong match. expected %s, got %s\n",
> +                                      match_node_tests[i].path,
> +                                      match_node_tests[i].data,
> +                                      (const char *)match->data);
>         }
>  }
>
> @@ -989,9 +1128,9 @@ static struct resource test_bus_res = {
>  static const struct platform_device_info test_bus_info = {
>         .name = "unittest-bus",
>  };
> -static void __init of_unittest_platform_populate(void)
> +static void of_unittest_platform_populate(struct kunit *test)
>  {
> -       int irq, rc;
> +       int irq;
>         struct device_node *np, *child, *grandchild;
>         struct platform_device *pdev, *test_bus;
>         const struct of_device_id match[] = {
> @@ -1005,32 +1144,27 @@ static void __init of_unittest_platform_populate(void)
>         /* Test that a missing irq domain returns -EPROBE_DEFER */
>         np = of_find_node_by_path("/testcase-data/testcase-device1");
>         pdev = of_find_device_by_node(np);
> -       unittest(pdev, "device 1 creation failed\n");
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, pdev);
>
>         if (!(of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)) {
>                 irq = platform_get_irq(pdev, 0);
> -               unittest(irq == -EPROBE_DEFER,
> -                        "device deferred probe failed - %d\n", irq);
> +               KUNIT_ASSERT_EQ(test, irq, -EPROBE_DEFER);
>
>                 /* Test that a parsing failure does not return -EPROBE_DEFER */
>                 np = of_find_node_by_path("/testcase-data/testcase-device2");
>                 pdev = of_find_device_by_node(np);
> -               unittest(pdev, "device 2 creation failed\n");
> +               KUNIT_ASSERT_NOT_ERR_OR_NULL(test, pdev);
>                 irq = platform_get_irq(pdev, 0);
> -               unittest(irq < 0 && irq != -EPROBE_DEFER,
> -                        "device parsing error failed - %d\n", irq);
> +               KUNIT_ASSERT_TRUE_MSG(test, irq < 0 && irq != -EPROBE_DEFER,
> +                                     "device parsing error failed - %d\n",
> +                                     irq);
>         }
>
>         np = of_find_node_by_path("/testcase-data/platform-tests");
> -       unittest(np, "No testcase data in device tree\n");
> -       if (!np)
> -               return;
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, np);
>
>         test_bus = platform_device_register_full(&test_bus_info);
> -       rc = PTR_ERR_OR_ZERO(test_bus);
> -       unittest(!rc, "testbus registration failed; rc=%i\n", rc);
> -       if (rc)
> -               return;
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, test_bus);
>         test_bus->dev.of_node = np;
>
>         /*
> @@ -1045,17 +1179,21 @@ static void __init of_unittest_platform_populate(void)
>         of_platform_populate(np, match, NULL, &test_bus->dev);
>         for_each_child_of_node(np, child) {
>                 for_each_child_of_node(child, grandchild)
> -                       unittest(of_find_device_by_node(grandchild),
> -                                "Could not create device for node '%s'\n",
> -                                grandchild->name);
> +                       KUNIT_EXPECT_TRUE_MSG(test,
> +                                             of_find_device_by_node(
> +                                                             grandchild),
> +                                             "Could not create device for node '%s'\n",
> +                                             grandchild->name);
>         }
>
>         of_platform_depopulate(&test_bus->dev);
>         for_each_child_of_node(np, child) {
>                 for_each_child_of_node(child, grandchild)
> -                       unittest(!of_find_device_by_node(grandchild),
> -                                "device didn't get destroyed '%s'\n",
> -                                grandchild->name);
> +                       KUNIT_EXPECT_FALSE_MSG(test,
> +                                              of_find_device_by_node(
> +                                                              grandchild),
> +                                              "device didn't get destroyed '%s'\n",
> +                                              grandchild->name);
>         }
>
>         platform_device_unregister(test_bus);
> @@ -1129,7 +1267,7 @@ static int attach_node_and_children(struct device_node *np)
>   *     unittest_data_add - Reads, copies data from
>   *     linked tree and attaches it to the live tree
>   */
> -static int __init unittest_data_add(void)
> +static int unittest_data_add(void)
>  {
>         void *unittest_data;
>         struct device_node *unittest_data_node, *np;
> @@ -1200,7 +1338,7 @@ static int __init unittest_data_add(void)
>  }
>
>  #ifdef CONFIG_OF_OVERLAY
> -static int __init overlay_data_apply(const char *overlay_name, int *overlay_id);
> +static int overlay_data_apply(const char *overlay_name, int *overlay_id);
>
>  static int unittest_probe(struct platform_device *pdev)
>  {
> @@ -1429,173 +1567,157 @@ static void of_unittest_destroy_tracked_overlays(void)
>         } while (defers > 0);
>  }
>
> -static int __init of_unittest_apply_overlay(int overlay_nr, int unittest_nr,
> -               int *overlay_id)
> +static int of_unittest_apply_overlay(struct kunit *test,
> +                                    int overlay_nr,
> +                                    int unittest_nr,
> +                                    int *overlay_id)
>  {
>         const char *overlay_name;
>
>         overlay_name = overlay_name_from_nr(overlay_nr);
>
> -       if (!overlay_data_apply(overlay_name, overlay_id)) {
> -               unittest(0, "could not apply overlay \"%s\"\n",
> -                               overlay_name);
> -               return -EFAULT;
> -       }
> +       KUNIT_ASSERT_TRUE_MSG(test,
> +                             overlay_data_apply(overlay_name, overlay_id),
> +                             "could not apply overlay \"%s\"\n",
> +                             overlay_name);
>         of_unittest_track_overlay(*overlay_id);
>
>         return 0;
>  }
>
>  /* apply an overlay while checking before and after states */
> -static int __init of_unittest_apply_overlay_check(int overlay_nr,
> +static int of_unittest_apply_overlay_check(struct kunit *test, int overlay_nr,
>                 int unittest_nr, int before, int after,
>                 enum overlay_type ovtype)
>  {
> -       int ret, ovcs_id;
> +       int ovcs_id;
>
>         /* unittest device must not be in before state */
> -       if (of_unittest_device_exists(unittest_nr, ovtype) != before) {
> -               unittest(0, "%s with device @\"%s\" %s\n",
> -                               overlay_name_from_nr(overlay_nr),
> -                               unittest_path(unittest_nr, ovtype),
> -                               !before ? "enabled" : "disabled");
> -               return -EINVAL;
> -       }
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           of_unittest_device_exists(unittest_nr, ovtype),
> +                           before,
> +                           "%s with device @\"%s\" %s\n",
> +                           overlay_name_from_nr(overlay_nr),
> +                           unittest_path(unittest_nr, ovtype),
> +                           !before ? "enabled" : "disabled");
>
>         ovcs_id = 0;
> -       ret = of_unittest_apply_overlay(overlay_nr, unittest_nr, &ovcs_id);
> -       if (ret != 0) {
> -               /* of_unittest_apply_overlay already called unittest() */
> -               return ret;
> -       }
> +       KUNIT_EXPECT_EQ(test,
> +                       of_unittest_apply_overlay(test,
> +                                                 overlay_nr,
> +                                                 unittest_nr,
> +                                                 &ovcs_id),
> +                       0);
>
>         /* unittest device must be to set to after state */
> -       if (of_unittest_device_exists(unittest_nr, ovtype) != after) {
> -               unittest(0, "%s failed to create @\"%s\" %s\n",
> -                               overlay_name_from_nr(overlay_nr),
> -                               unittest_path(unittest_nr, ovtype),
> -                               !after ? "enabled" : "disabled");
> -               return -EINVAL;
> -       }
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           of_unittest_device_exists(unittest_nr, ovtype),
> +                           after,
> +                           "%s failed to create @\"%s\" %s\n",
> +                           overlay_name_from_nr(overlay_nr),
> +                           unittest_path(unittest_nr, ovtype),
> +                           !after ? "enabled" : "disabled");
>
>         return 0;
>  }
>
>  /* apply an overlay and then revert it while checking before, after states */
> -static int __init of_unittest_apply_revert_overlay_check(int overlay_nr,
> +static int of_unittest_apply_revert_overlay_check(
> +               struct kunit *test, int overlay_nr,
>                 int unittest_nr, int before, int after,
>                 enum overlay_type ovtype)
>  {
> -       int ret, ovcs_id;
> +       int ovcs_id;
>
>         /* unittest device must be in before state */
> -       if (of_unittest_device_exists(unittest_nr, ovtype) != before) {
> -               unittest(0, "%s with device @\"%s\" %s\n",
> -                               overlay_name_from_nr(overlay_nr),
> -                               unittest_path(unittest_nr, ovtype),
> -                               !before ? "enabled" : "disabled");
> -               return -EINVAL;
> -       }
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           of_unittest_device_exists(unittest_nr, ovtype),
> +                           before,
> +                           "%s with device @\"%s\" %s\n",
> +                           overlay_name_from_nr(overlay_nr),
> +                           unittest_path(unittest_nr, ovtype),
> +                           !before ? "enabled" : "disabled");
>
>         /* apply the overlay */
>         ovcs_id = 0;
> -       ret = of_unittest_apply_overlay(overlay_nr, unittest_nr, &ovcs_id);
> -       if (ret != 0) {
> -               /* of_unittest_apply_overlay already called unittest() */
> -               return ret;
> -       }
> +       KUNIT_ASSERT_EQ(test,
> +                       of_unittest_apply_overlay(test,
> +                                                 overlay_nr,
> +                                                 unittest_nr,
> +                                                 &ovcs_id),
> +                       0);
>
>         /* unittest device must be in after state */
> -       if (of_unittest_device_exists(unittest_nr, ovtype) != after) {
> -               unittest(0, "%s failed to create @\"%s\" %s\n",
> -                               overlay_name_from_nr(overlay_nr),
> -                               unittest_path(unittest_nr, ovtype),
> -                               !after ? "enabled" : "disabled");
> -               return -EINVAL;
> -       }
> -
> -       ret = of_overlay_remove(&ovcs_id);
> -       if (ret != 0) {
> -               unittest(0, "%s failed to be destroyed @\"%s\"\n",
> -                               overlay_name_from_nr(overlay_nr),
> -                               unittest_path(unittest_nr, ovtype));
> -               return ret;
> -       }
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           of_unittest_device_exists(unittest_nr, ovtype),
> +                           after,
> +                           "%s failed to create @\"%s\" %s\n",
> +                           overlay_name_from_nr(overlay_nr),
> +                           unittest_path(unittest_nr, ovtype),
> +                           !after ? "enabled" : "disabled");
> +
> +       KUNIT_ASSERT_EQ_MSG(test, of_overlay_remove(&ovcs_id), 0,
> +                           "%s failed to be destroyed @\"%s\"\n",
> +                           overlay_name_from_nr(overlay_nr),
> +                           unittest_path(unittest_nr, ovtype));
>
>         /* unittest device must be again in before state */
> -       if (of_unittest_device_exists(unittest_nr, PDEV_OVERLAY) != before) {
> -               unittest(0, "%s with device @\"%s\" %s\n",
> -                               overlay_name_from_nr(overlay_nr),
> -                               unittest_path(unittest_nr, ovtype),
> -                               !before ? "enabled" : "disabled");
> -               return -EINVAL;
> -       }
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           of_unittest_device_exists(unittest_nr,
> +                                                     PDEV_OVERLAY),
> +                           before,
> +                           "%s with device @\"%s\" %s\n",
> +                           overlay_name_from_nr(overlay_nr),
> +                           unittest_path(unittest_nr, ovtype),
> +                           !before ? "enabled" : "disabled");
>
>         return 0;
>  }
>
>  /* test activation of device */
> -static void __init of_unittest_overlay_0(void)
> +static void of_unittest_overlay_0(struct kunit *test)
>  {
>         /* device should enable */
> -       if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 0);
> +       of_unittest_apply_overlay_check(test, 0, 0, 0, 1, PDEV_OVERLAY);
>  }
>
>  /* test deactivation of device */
> -static void __init of_unittest_overlay_1(void)
> +static void of_unittest_overlay_1(struct kunit *test)
>  {
>         /* device should disable */
> -       if (of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 1);
> +       of_unittest_apply_overlay_check(test, 1, 1, 1, 0, PDEV_OVERLAY);
>  }
>
>  /* test activation of device */
> -static void __init of_unittest_overlay_2(void)
> +static void of_unittest_overlay_2(struct kunit *test)
>  {
>         /* device should enable */
> -       if (of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 2);
> +       of_unittest_apply_overlay_check(test, 2, 2, 0, 1, PDEV_OVERLAY);
>  }
>
>  /* test deactivation of device */
> -static void __init of_unittest_overlay_3(void)
> +static void of_unittest_overlay_3(struct kunit *test)
>  {
>         /* device should disable */
> -       if (of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 3);
> +       of_unittest_apply_overlay_check(test, 3, 3, 1, 0, PDEV_OVERLAY);
>  }
>
>  /* test activation of a full device node */
> -static void __init of_unittest_overlay_4(void)
> +static void of_unittest_overlay_4(struct kunit *test)
>  {
>         /* device should disable */
> -       if (of_unittest_apply_overlay_check(4, 4, 0, 1, PDEV_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 4);
> +       of_unittest_apply_overlay_check(test, 4, 4, 0, 1, PDEV_OVERLAY);
>  }
>
>  /* test overlay apply/revert sequence */
> -static void __init of_unittest_overlay_5(void)
> +static void of_unittest_overlay_5(struct kunit *test)
>  {
>         /* device should disable */
> -       if (of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 5);
> +       of_unittest_apply_revert_overlay_check(test, 5, 5, 0, 1, PDEV_OVERLAY);
>  }
>
>  /* test overlay application in sequence */
> -static void __init of_unittest_overlay_6(void)
> +static void of_unittest_overlay_6(struct kunit *test)
>  {
>         int i, ov_id[2], ovcs_id;
>         int overlay_nr = 6, unittest_nr = 6;
> @@ -1604,74 +1726,69 @@ static void __init of_unittest_overlay_6(void)
>
>         /* unittest device must be in before state */
>         for (i = 0; i < 2; i++) {
> -               if (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)
> -                               != before) {
> -                       unittest(0, "%s with device @\"%s\" %s\n",
> -                                       overlay_name_from_nr(overlay_nr + i),
> -                                       unittest_path(unittest_nr + i,
> -                                               PDEV_OVERLAY),
> -                                       !before ? "enabled" : "disabled");
> -                       return;
> -               }
> +               KUNIT_ASSERT_EQ_MSG(test,
> +                                   of_unittest_device_exists(unittest_nr + i,
> +                                                             PDEV_OVERLAY),
> +                                   before,
> +                                   "%s with device @\"%s\" %s\n",
> +                                   overlay_name_from_nr(overlay_nr + i),
> +                                   unittest_path(unittest_nr + i,
> +                                                 PDEV_OVERLAY),
> +                                   !before ? "enabled" : "disabled");
>         }
>
>         /* apply the overlays */
>         for (i = 0; i < 2; i++) {
> -
>                 overlay_name = overlay_name_from_nr(overlay_nr + i);
>
> -               if (!overlay_data_apply(overlay_name, &ovcs_id)) {
> -                       unittest(0, "could not apply overlay \"%s\"\n",
> -                                       overlay_name);
> -                       return;
> -               }
> +               KUNIT_ASSERT_TRUE_MSG(test,
> +                                     overlay_data_apply(overlay_name,
> +                                                        &ovcs_id),
> +                                     "could not apply overlay \"%s\"\n",
> +                                     overlay_name);
>                 ov_id[i] = ovcs_id;
>                 of_unittest_track_overlay(ov_id[i]);
>         }
>
>         for (i = 0; i < 2; i++) {
>                 /* unittest device must be in after state */
> -               if (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)
> -                               != after) {
> -                       unittest(0, "overlay @\"%s\" failed @\"%s\" %s\n",
> -                                       overlay_name_from_nr(overlay_nr + i),
> -                                       unittest_path(unittest_nr + i,
> -                                               PDEV_OVERLAY),
> -                                       !after ? "enabled" : "disabled");
> -                       return;
> -               }
> +               KUNIT_ASSERT_EQ_MSG(test,
> +                                   of_unittest_device_exists(unittest_nr + i,
> +                                                             PDEV_OVERLAY),
> +                                   after,
> +                                   "overlay @\"%s\" failed @\"%s\" %s\n",
> +                                   overlay_name_from_nr(overlay_nr + i),
> +                                   unittest_path(unittest_nr + i,
> +                                                 PDEV_OVERLAY),
> +                                   !after ? "enabled" : "disabled");
>         }
>
>         for (i = 1; i >= 0; i--) {
>                 ovcs_id = ov_id[i];
> -               if (of_overlay_remove(&ovcs_id)) {
> -                       unittest(0, "%s failed destroy @\"%s\"\n",
> -                                       overlay_name_from_nr(overlay_nr + i),
> -                                       unittest_path(unittest_nr + i,
> -                                               PDEV_OVERLAY));
> -                       return;
> -               }
> +               KUNIT_ASSERT_FALSE_MSG(test, of_overlay_remove(&ovcs_id),
> +                                      "%s failed destroy @\"%s\"\n",
> +                                      overlay_name_from_nr(overlay_nr + i),
> +                                      unittest_path(unittest_nr + i,
> +                                                    PDEV_OVERLAY));
>                 of_unittest_untrack_overlay(ov_id[i]);
>         }
>
>         for (i = 0; i < 2; i++) {
>                 /* unittest device must be again in before state */
> -               if (of_unittest_device_exists(unittest_nr + i, PDEV_OVERLAY)
> -                               != before) {
> -                       unittest(0, "%s with device @\"%s\" %s\n",
> -                                       overlay_name_from_nr(overlay_nr + i),
> -                                       unittest_path(unittest_nr + i,
> -                                               PDEV_OVERLAY),
> -                                       !before ? "enabled" : "disabled");
> -                       return;
> -               }
> +               KUNIT_ASSERT_EQ_MSG(test,
> +                                   of_unittest_device_exists(unittest_nr + i,
> +                                                             PDEV_OVERLAY),
> +                                   before,
> +                                   "%s with device @\"%s\" %s\n",
> +                                   overlay_name_from_nr(overlay_nr + i),
> +                                   unittest_path(unittest_nr + i,
> +                                                 PDEV_OVERLAY),
> +                                   !before ? "enabled" : "disabled");
>         }
> -
> -       unittest(1, "overlay test %d passed\n", 6);
>  }
>
>  /* test overlay application in sequence */
> -static void __init of_unittest_overlay_8(void)
> +static void of_unittest_overlay_8(struct kunit *test)
>  {
>         int i, ov_id[2], ovcs_id;
>         int overlay_nr = 8, unittest_nr = 8;
> @@ -1681,76 +1798,73 @@ static void __init of_unittest_overlay_8(void)
>
>         /* apply the overlays */
>         for (i = 0; i < 2; i++) {
> -
>                 overlay_name = overlay_name_from_nr(overlay_nr + i);
>
> -               if (!overlay_data_apply(overlay_name, &ovcs_id)) {
> -                       unittest(0, "could not apply overlay \"%s\"\n",
> -                                       overlay_name);
> -                       return;
> -               }
> +               KUNIT_ASSERT_TRUE_MSG(test,
> +                                     overlay_data_apply(overlay_name,
> +                                                        &ovcs_id),
> +                                     "could not apply overlay \"%s\"\n",
> +                                     overlay_name);
>                 ov_id[i] = ovcs_id;
>                 of_unittest_track_overlay(ov_id[i]);
>         }
>
>         /* now try to remove first overlay (it should fail) */
>         ovcs_id = ov_id[0];
> -       if (!of_overlay_remove(&ovcs_id)) {
> -               unittest(0, "%s was destroyed @\"%s\"\n",
> -                               overlay_name_from_nr(overlay_nr + 0),
> -                               unittest_path(unittest_nr,
> -                                       PDEV_OVERLAY));
> -               return;
> -       }
> +       KUNIT_ASSERT_TRUE_MSG(test, of_overlay_remove(&ovcs_id),
> +                             "%s was destroyed @\"%s\"\n",
> +                             overlay_name_from_nr(overlay_nr + 0),
> +                             unittest_path(unittest_nr,
> +                                           PDEV_OVERLAY));
>
>         /* removing them in order should work */
>         for (i = 1; i >= 0; i--) {
>                 ovcs_id = ov_id[i];
> -               if (of_overlay_remove(&ovcs_id)) {
> -                       unittest(0, "%s not destroyed @\"%s\"\n",
> -                                       overlay_name_from_nr(overlay_nr + i),
> -                                       unittest_path(unittest_nr,
> -                                               PDEV_OVERLAY));
> -                       return;
> -               }
> +               KUNIT_ASSERT_FALSE_MSG(test, of_overlay_remove(&ovcs_id),
> +                                      "%s not destroyed @\"%s\"\n",
> +                                      overlay_name_from_nr(overlay_nr + i),
> +                                      unittest_path(unittest_nr,
> +                                                    PDEV_OVERLAY));
>                 of_unittest_untrack_overlay(ov_id[i]);
>         }
> -
> -       unittest(1, "overlay test %d passed\n", 8);
>  }
>
>  /* test insertion of a bus with parent devices */
> -static void __init of_unittest_overlay_10(void)
> +static void of_unittest_overlay_10(struct kunit *test)
>  {
> -       int ret;
>         char *child_path;
>
>         /* device should disable */
> -       ret = of_unittest_apply_overlay_check(10, 10, 0, 1, PDEV_OVERLAY);
> -       if (unittest(ret == 0,
> -                       "overlay test %d failed; overlay application\n", 10))
> -               return;
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           of_unittest_apply_overlay_check(test,
> +                                                           10,
> +                                                           10,
> +                                                           0,
> +                                                           1,
> +                                                           PDEV_OVERLAY),

I prefer putting multiple args on a line and having fewer lines.

> +                           0,
> +                           "overlay test %d failed; overlay application\n",
> +                           10);
>
>         child_path = kasprintf(GFP_KERNEL, "%s/test-unittest101",
>                         unittest_path(10, PDEV_OVERLAY));
> -       if (unittest(child_path, "overlay test %d failed; kasprintf\n", 10))
> -               return;
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, child_path);
>
> -       ret = of_path_device_type_exists(child_path, PDEV_OVERLAY);
> +       KUNIT_EXPECT_TRUE_MSG(test,
> +                             of_path_device_type_exists(child_path,
> +                                                        PDEV_OVERLAY),
> +                             "overlay test %d failed; no child device\n", 10);
>         kfree(child_path);
> -
> -       unittest(ret, "overlay test %d failed; no child device\n", 10);
>  }
>
>  /* test insertion of a bus with parent devices (and revert) */
> -static void __init of_unittest_overlay_11(void)
> +static void of_unittest_overlay_11(struct kunit *test)
>  {
> -       int ret;
> -
>         /* device should disable */
> -       ret = of_unittest_apply_revert_overlay_check(11, 11, 0, 1,
> -                       PDEV_OVERLAY);
> -       unittest(ret == 0, "overlay test %d failed; overlay apply\n", 11);
> +       KUNIT_EXPECT_FALSE(test,
> +                         of_unittest_apply_revert_overlay_check(test,
> +                                                                11, 11, 0, 1,
> +                                                                PDEV_OVERLAY));
>  }
>
>  #if IS_BUILTIN(CONFIG_I2C) && IS_ENABLED(CONFIG_OF_OVERLAY)
> @@ -1972,25 +2086,23 @@ static struct i2c_driver unittest_i2c_mux_driver = {
>
>  #endif
>
> -static int of_unittest_overlay_i2c_init(void)
> +static int of_unittest_overlay_i2c_init(struct kunit *test)
>  {
> -       int ret;
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           i2c_add_driver(&unittest_i2c_dev_driver),
> +                           0,
> +                           "could not register unittest i2c device driver\n");
>
> -       ret = i2c_add_driver(&unittest_i2c_dev_driver);
> -       if (unittest(ret == 0,
> -                       "could not register unittest i2c device driver\n"))
> -               return ret;
> -
> -       ret = platform_driver_register(&unittest_i2c_bus_driver);
> -       if (unittest(ret == 0,
> -                       "could not register unittest i2c bus driver\n"))
> -               return ret;
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           platform_driver_register(&unittest_i2c_bus_driver),
> +                           0,
> +                           "could not register unittest i2c bus driver\n");
>
>  #if IS_BUILTIN(CONFIG_I2C_MUX)
> -       ret = i2c_add_driver(&unittest_i2c_mux_driver);
> -       if (unittest(ret == 0,
> -                       "could not register unittest i2c mux driver\n"))
> -               return ret;
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                           i2c_add_driver(&unittest_i2c_mux_driver),
> +                           0,
> +                           "could not register unittest i2c mux driver\n");
>  #endif
>
>         return 0;
> @@ -2005,101 +2117,89 @@ static void of_unittest_overlay_i2c_cleanup(void)
>         i2c_del_driver(&unittest_i2c_dev_driver);
>  }
>
> -static void __init of_unittest_overlay_i2c_12(void)
> +static void of_unittest_overlay_i2c_12(struct kunit *test)
>  {
>         /* device should enable */
> -       if (of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 12);
> +       of_unittest_apply_overlay_check(test, 12, 12, 0, 1, I2C_OVERLAY);
>  }
>
>  /* test deactivation of device */
> -static void __init of_unittest_overlay_i2c_13(void)
> +static void of_unittest_overlay_i2c_13(struct kunit *test)
>  {
>         /* device should disable */
> -       if (of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 13);
> +       of_unittest_apply_overlay_check(test, 13, 13, 1, 0, I2C_OVERLAY);
>  }
>
>  /* just check for i2c mux existence */
> -static void of_unittest_overlay_i2c_14(void)
> +static void of_unittest_overlay_i2c_14(struct kunit *test)
>  {
> +       KUNIT_SUCCEED(test);
>  }
>
> -static void __init of_unittest_overlay_i2c_15(void)
> +static void of_unittest_overlay_i2c_15(struct kunit *test)
>  {
>         /* device should enable */
> -       if (of_unittest_apply_overlay_check(15, 15, 0, 1, I2C_OVERLAY))
> -               return;
> -
> -       unittest(1, "overlay test %d passed\n", 15);
> +       of_unittest_apply_overlay_check(test, 15, 15, 0, 1, I2C_OVERLAY);
>  }
>
>  #else
>
> -static inline void of_unittest_overlay_i2c_14(void) { }
> -static inline void of_unittest_overlay_i2c_15(void) { }
> +static inline void of_unittest_overlay_i2c_14(struct kunit *test) { }
> +static inline void of_unittest_overlay_i2c_15(struct kunit *test) { }
>
>  #endif
>
> -static void __init of_unittest_overlay(void)
> +static void of_unittest_overlay(struct kunit *test)
>  {
>         struct device_node *bus_np = NULL;
>
> -       if (platform_driver_register(&unittest_driver)) {
> -               unittest(0, "could not register unittest driver\n");
> -               goto out;
> -       }
> +       KUNIT_ASSERT_FALSE_MSG(test,
> +                              platform_driver_register(&unittest_driver),
> +                              "could not register unittest driver\n");
>
>         bus_np = of_find_node_by_path(bus_path);
> -       if (bus_np == NULL) {
> -               unittest(0, "could not find bus_path \"%s\"\n", bus_path);
> -               goto out;
> -       }
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL_MSG(test, bus_np,
> +                                        "could not find bus_path \"%s\"\n",
> +                                        bus_path);
>
> -       if (of_platform_default_populate(bus_np, NULL, NULL)) {
> -               unittest(0, "could not populate bus @ \"%s\"\n", bus_path);
> -               goto out;
> -       }
> +       KUNIT_ASSERT_FALSE_MSG(test,
> +                              of_platform_default_populate(bus_np, NULL, NULL),
> +                              "could not populate bus @ \"%s\"\n", bus_path);
>
> -       if (!of_unittest_device_exists(100, PDEV_OVERLAY)) {
> -               unittest(0, "could not find unittest0 @ \"%s\"\n",
> -                               unittest_path(100, PDEV_OVERLAY));
> -               goto out;
> -       }
> +       KUNIT_ASSERT_TRUE_MSG(test,
> +                             of_unittest_device_exists(100, PDEV_OVERLAY),
> +                             "could not find unittest0 @ \"%s\"\n",
> +                             unittest_path(100, PDEV_OVERLAY));
>
> -       if (of_unittest_device_exists(101, PDEV_OVERLAY)) {
> -               unittest(0, "unittest1 @ \"%s\" should not exist\n",
> -                               unittest_path(101, PDEV_OVERLAY));
> -               goto out;
> -       }
> -
> -       unittest(1, "basic infrastructure of overlays passed");
> +       KUNIT_ASSERT_FALSE_MSG(test,
> +                              of_unittest_device_exists(101, PDEV_OVERLAY),
> +                              "unittest1 @ \"%s\" should not exist\n",
> +                              unittest_path(101, PDEV_OVERLAY));
>
>         /* tests in sequence */
> -       of_unittest_overlay_0();
> -       of_unittest_overlay_1();
> -       of_unittest_overlay_2();
> -       of_unittest_overlay_3();
> -       of_unittest_overlay_4();
> -       of_unittest_overlay_5();
> -       of_unittest_overlay_6();
> -       of_unittest_overlay_8();
> -
> -       of_unittest_overlay_10();
> -       of_unittest_overlay_11();
> +       of_unittest_overlay_0(test);
> +       of_unittest_overlay_1(test);
> +       of_unittest_overlay_2(test);
> +       of_unittest_overlay_3(test);
> +       of_unittest_overlay_4(test);
> +       of_unittest_overlay_5(test);
> +       of_unittest_overlay_6(test);
> +       of_unittest_overlay_8(test);
> +
> +       of_unittest_overlay_10(test);
> +       of_unittest_overlay_11(test);
>
>  #if IS_BUILTIN(CONFIG_I2C)
> -       if (unittest(of_unittest_overlay_i2c_init() == 0, "i2c init failed\n"))
> +       KUNIT_ASSERT_EQ_MSG(test,
> +                          of_unittest_overlay_i2c_init(test),
> +                          0,
> +                          "i2c init failed\n");
>                 goto out;
>
> -       of_unittest_overlay_i2c_12();
> -       of_unittest_overlay_i2c_13();
> -       of_unittest_overlay_i2c_14();
> -       of_unittest_overlay_i2c_15();
> +       of_unittest_overlay_i2c_12(test);
> +       of_unittest_overlay_i2c_13(test);
> +       of_unittest_overlay_i2c_14(test);
> +       of_unittest_overlay_i2c_15(test);
>
>         of_unittest_overlay_i2c_cleanup();
>  #endif
> @@ -2111,7 +2211,7 @@ static void __init of_unittest_overlay(void)
>  }
>
>  #else
> -static inline void __init of_unittest_overlay(void) { }
> +static inline void of_unittest_overlay(struct kunit *test) { }
>  #endif
>
>  #ifdef CONFIG_OF_OVERLAY
> @@ -2254,7 +2354,7 @@ void __init unittest_unflatten_overlay_base(void)
>   *
>   * Return 0 on unexpected error.
>   */
> -static int __init overlay_data_apply(const char *overlay_name, int *overlay_id)
> +static int overlay_data_apply(const char *overlay_name, int *overlay_id)
>  {
>         struct overlay_info *info;
>         int found = 0;
> @@ -2301,19 +2401,17 @@ static int __init overlay_data_apply(const char *overlay_name, int *overlay_id)
>   * The first part of the function is _not_ normal overlay usage; it is
>   * finishing splicing the base overlay device tree into the live tree.
>   */
> -static __init void of_unittest_overlay_high_level(void)
> +static void of_unittest_overlay_high_level(struct kunit *test)
>  {
>         struct device_node *last_sibling;
>         struct device_node *np;
>         struct device_node *of_symbols;
> -       struct device_node *overlay_base_symbols;
> +       struct device_node *overlay_base_symbols = 0;
>         struct device_node **pprev;
>         struct property *prop;
>
> -       if (!overlay_base_root) {
> -               unittest(0, "overlay_base_root not initialized\n");
> -               return;
> -       }
> +       KUNIT_ASSERT_TRUE_MSG(test, overlay_base_root,
> +                             "overlay_base_root not initialized\n");
>
>         /*
>          * Could not fixup phandles in unittest_unflatten_overlay_base()
> @@ -2358,11 +2456,10 @@ static __init void of_unittest_overlay_high_level(void)
>         }
>
>         for (np = overlay_base_root->child; np; np = np->sibling) {
> -               if (of_get_child_by_name(of_root, np->name)) {
> -                       unittest(0, "illegal node name in overlay_base %s",
> -                               np->name);
> -                       return;
> -               }
> +               KUNIT_ASSERT_FALSE_MSG(test,
> +                                     of_get_child_by_name(of_root, np->name),
> +                                     "illegal node name in overlay_base %s",
> +                                     np->name);
>         }
>
>         /*
> @@ -2395,21 +2492,24 @@ static __init void of_unittest_overlay_high_level(void)
>
>                         new_prop = __of_prop_dup(prop, GFP_KERNEL);
>                         if (!new_prop) {
> -                               unittest(0, "__of_prop_dup() of '%s' from overlay_base node __symbols__",
> -                                        prop->name);
> +                               KUNIT_FAIL(test,
> +                                          "__of_prop_dup() of '%s' from overlay_base node __symbols__",
> +                                          prop->name);
>                                 goto err_unlock;
>                         }
>                         if (__of_add_property(of_symbols, new_prop)) {
>                                 /* "name" auto-generated by unflatten */
>                                 if (!strcmp(new_prop->name, "name"))
>                                         continue;
> -                               unittest(0, "duplicate property '%s' in overlay_base node __symbols__",
> -                                        prop->name);
> +                               KUNIT_FAIL(test,
> +                                          "duplicate property '%s' in overlay_base node __symbols__",
> +                                          prop->name);
>                                 goto err_unlock;
>                         }
>                         if (__of_add_property_sysfs(of_symbols, new_prop)) {
> -                               unittest(0, "unable to add property '%s' in overlay_base node __symbols__ to sysfs",
> -                                        prop->name);
> +                               KUNIT_FAIL(test,
> +                                          "unable to add property '%s' in overlay_base node __symbols__ to sysfs",
> +                                          prop->name);
>                                 goto err_unlock;
>                         }
>                 }
> @@ -2420,14 +2520,16 @@ static __init void of_unittest_overlay_high_level(void)
>
>         /* now do the normal overlay usage test */
>
> -       unittest(overlay_data_apply("overlay", NULL),
> -                "Adding overlay 'overlay' failed\n");
> +       KUNIT_EXPECT_TRUE_MSG(test, overlay_data_apply("overlay", NULL),
> +                             "Adding overlay 'overlay' failed\n");
>
> -       unittest(overlay_data_apply("overlay_bad_phandle", NULL),
> -                "Adding overlay 'overlay_bad_phandle' failed\n");
> +       KUNIT_EXPECT_TRUE_MSG(test,
> +                             overlay_data_apply("overlay_bad_phandle", NULL),
> +                             "Adding overlay 'overlay_bad_phandle' failed\n");
>
> -       unittest(overlay_data_apply("overlay_bad_symbol", NULL),
> -                "Adding overlay 'overlay_bad_symbol' failed\n");
> +       KUNIT_EXPECT_TRUE_MSG(test,
> +                             overlay_data_apply("overlay_bad_symbol", NULL),
> +                             "Adding overlay 'overlay_bad_symbol' failed\n");
>
>         return;
>
> @@ -2437,54 +2539,49 @@ static __init void of_unittest_overlay_high_level(void)
>
>  #else
>
> -static inline __init void of_unittest_overlay_high_level(void) {}
> +static inline void of_unittest_overlay_high_level(struct kunit *test) {}
>
>  #endif
>
> -static int __init of_unittest(void)
> +static int of_test_init(struct kunit *test)
>  {
> -       struct device_node *np;
> -       int res;
> -
>         /* adding data for unittest */
> -       res = unittest_data_add();
> -       if (res)
> -               return res;
> +       KUNIT_ASSERT_EQ(test, 0, unittest_data_add());
> +
>         if (!of_aliases)
>                 of_aliases = of_find_node_by_path("/aliases");
>
> -       np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
> -       if (!np) {
> -               pr_info("No testcase data in device tree; not running tests\n");
> -               return 0;
> -       }
> -       of_node_put(np);
> +       KUNIT_ASSERT_NOT_ERR_OR_NULL(test, of_find_node_by_path(
> +                       "/testcase-data/phandle-tests/consumer-a"));
>
> -       pr_info("start of unittest - you will see error messages\n");
> -       of_unittest_check_tree_linkage();
> -       of_unittest_check_phandles();
> -       of_unittest_find_node_by_name();
> -       of_unittest_dynamic();
> -       of_unittest_parse_phandle_with_args();
> -       of_unittest_parse_phandle_with_args_map();
> -       of_unittest_printf();
> -       of_unittest_property_string();
> -       of_unittest_property_copy();
> -       of_unittest_changeset();
> -       of_unittest_parse_interrupts();
> -       of_unittest_parse_interrupts_extended();
> -       of_unittest_match_node();
> -       of_unittest_platform_populate();
> -       of_unittest_overlay();
> +       return 0;
> +}
>
> +static struct kunit_case of_test_cases[] = {
> +       KUNIT_CASE(of_unittest_check_tree_linkage),
> +       KUNIT_CASE(of_unittest_check_phandles),
> +       KUNIT_CASE(of_unittest_find_node_by_name),
> +       KUNIT_CASE(of_unittest_dynamic),
> +       KUNIT_CASE(of_unittest_parse_phandle_with_args),
> +       KUNIT_CASE(of_unittest_parse_phandle_with_args_map),
> +       KUNIT_CASE(of_unittest_printf),
> +       KUNIT_CASE(of_unittest_property_string),
> +       KUNIT_CASE(of_unittest_property_copy),
> +       KUNIT_CASE(of_unittest_changeset),
> +       KUNIT_CASE(of_unittest_parse_interrupts),
> +       KUNIT_CASE(of_unittest_parse_interrupts_extended),
> +       KUNIT_CASE(of_unittest_match_node),
> +       KUNIT_CASE(of_unittest_platform_populate),
> +       KUNIT_CASE(of_unittest_overlay),
>         /* Double check linkage after removing testcase data */
> -       of_unittest_check_tree_linkage();
> -
> -       of_unittest_overlay_high_level();
> -
> -       pr_info("end of unittest - %i passed, %i failed\n",
> -               unittest_results.passed, unittest_results.failed);
> +       KUNIT_CASE(of_unittest_check_tree_linkage),
> +       KUNIT_CASE(of_unittest_overlay_high_level),
> +       {},
> +};
>
> -       return 0;
> -}
> -late_initcall(of_unittest);
> +static struct kunit_module of_test_module = {
> +       .name = "of-test",
> +       .init = of_test_init,
> +       .test_cases = of_test_cases,
> +};
> +module_test(of_test_module);
> --
> 2.20.0.rc0.387.gc7a69e6b6c-goog
>
