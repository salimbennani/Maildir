Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  13 Dec 2018 21:21:53 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga005.jf.intel.com (orsmga005.jf.intel.com [10.7.209.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id 09CDC58079C;
	Thu, 13 Dec 2018 01:35:42 -0800 (PST)
Received: from orsmga102-1.jf.intel.com (HELO mga09.intel.com) ([10.7.208.27])
  by orsmga005-1.jf.intel.com with ESMTP; 13 Dec 2018 01:35:41 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AzKYn/RB1wt4BGl8cwHniUyQJP3N1i/DPJgcQr6Af?=
 =?us-ascii?q?oPdwSP7/pMqwAkXT6L1XgUPTWs2DsrQY07qQ6/iocFdDyK7JiGoFfp1IWk1Nou?=
 =?us-ascii?q?QttCtkPvS4D1bmJuXhdS0wEZcKflZk+3amLRodQ56mNBXdrXKo8DEdBAj0OxZr?=
 =?us-ascii?q?KeTpAI7SiNm82/yv95HJbAhEmDmwbaluIBmqsA7cqtQYjYx+J6gr1xDHuGFIe+?=
 =?us-ascii?q?NYxWNpIVKcgRPx7dqu8ZBg7ipdpesv+9ZPXqvmcas4S6dYDCk9PGAu+MLrrxjD?=
 =?us-ascii?q?QhCR6XYaT24bjwBHAwnB7BH9Q5fxri73vfdz1SWGIcH7S60/VC+85Kl3VhDnlC?=
 =?us-ascii?q?YHNyY48G7JjMxwkLlbqw+lqxBm3oLYfJ2ZOP94c6jAf90VWHBBU95eWCxPAIyy?=
 =?us-ascii?q?b4UBAekcM+hGs4bzqEAOrQO8CAS3GOPv0yVFimPq0aEm0eksFxzN0gw6H9IJtX?=
 =?us-ascii?q?TZtM/7O7kOUe+r1qnD0CvOb/NI1jf79YPFdRAhoPCUXb1ubcre11MvGB/FjlqO?=
 =?us-ascii?q?r4zoJDyV1uEXvGia6+psT/6gi2kiqwxopDWk28QiipHRi44L1lzJ8T91zJs7KN?=
 =?us-ascii?q?GmUkJ3fN2pHIdKuyybNYZ6Wt0uT31stSogybALuYS3cDULxZkm3RLSav+Kfo6V?=
 =?us-ascii?q?6Rz5TumROy13hHd9dbK/mRmy9U+gx/XiVsm7zllKtDBJktrSuXAX0Rzc9MyHRu?=
 =?us-ascii?q?F6/ke71jaDzwHT6udaLkAojafXNYItz7oqmpYOv0nPADX6lFj1gaOKbEkp++ql?=
 =?us-ascii?q?5/ziYrr8p5+cM4F0ihv5MqQrgsG/BeU4Mg4TX2mU4Oi816Ps/Vf/QLpUiv06i6?=
 =?us-ascii?q?7ZsZ7cJcsFvK60GBFV0ok95BalFTum08oXnWMBLF1bfBKLlY/pO0vBIPzgF/ew?=
 =?us-ascii?q?n0yskCt3x/DBJrDhBpTNLnvdn7v7crd99lVRyA4yzdBZ+pJVBasNIPP1Wk/tqt?=
 =?us-ascii?q?PYCgU1PBCzw+biEN99zJ8RWXqTAq+FN6PfqV+I6fguI+mQfoAVvyzxK/g45/H0?=
 =?us-ascii?q?i385lkQQfa2o3ZsRdXC5Ee5qI0SfYXrwnNgBFX0GsRY5TOzvkFeCSyJcZ26uX6?=
 =?us-ascii?q?Ig4TE2EICmDYDdSYy3g7yB2yG7HptRZm1dDlCMEHHod5iLWvsWaSKSJNNhnSIA?=
 =?us-ascii?q?VbS7V4Ah0hSuvhfgy7V7NurU5jEYtZX72ddv/O3TlRYy9T9uA8SHyW6NTXp5nm?=
 =?us-ascii?q?cJRz8wwaB+rlZxylaF0ahknfNYEcZf6O9OUgc/LZTc1fB1C8juWgLdedeEUFWm?=
 =?us-ascii?q?Tc+gAT0rStIxwsUBY0ByG9i5ihDD3iyqA6IalrCRBZw09L7c0Gb1J8pn13nG06?=
 =?us-ascii?q?whhUE8QsRTLW2mmrJ/9w/LCoHUiUqZibileb4c3CHX8meD1nSBvEdfXA50UqXF?=
 =?us-ascii?q?WHQfa1DSrdT44EPCUrCvBa4mMgtH1c6NNK9KZsf1glVBQffpIM7ebH6pm2esGR?=
 =?us-ascii?q?aIwauBY5fwdGUDwirREkgEnBoV/XadKwc+ADyso2bfDDxoCFLubFng8eh4qHOn?=
 =?us-ascii?q?UEA0yxuGYFFm17qw4hQVn+CTS+sP3rIYvycssyl0HFe439LRF9qApwpgcL9AYd?=
 =?us-ascii?q?8n51dHz2bZtw17PpyvNK1igl8ecwJqv0LhzRl3C4NAkdQ0o3Mu1gZ9NaWY0FZZ?=
 =?us-ascii?q?fTOCwZ/wIqHXKnX1/B23caHW3k/R0dmI9aYP8vg3sEjjsxyzGUok8HVn1MdV3m?=
 =?us-ascii?q?CY5pXLCgoSTJ3wXlw29xh8u7HVfC0965nI2n1rNKm+qiXC1M4xBOs51hageM9S?=
 =?us-ascii?q?MaOZFAPoD8IWHcmvKOwwlFivYRIJJ+RS9K8yP8O7ePqKwq+rPOB8nD24iWRL+p?=
 =?us-ascii?q?xy0kWJ9yBkUO7Hw44Fw+2E3guATzr8llahvdztloBeeD4SGXCzyS76C45LZ61+?=
 =?us-ascii?q?ZJoEBn2qI8Kq2Np+nZntW3hD+V6nBlMG3tKpeBWIY1z82w1QyVoYoXi9lSSkyD?=
 =?us-ascii?q?x0likjrrCD0yzW3+TiaB0HN3ZLRWljl1vtIZK4j8sHXEiudAUpkBql5UDnx6lU?=
 =?us-ascii?q?vqh/Lm/TQVtWcCjyNW1tTqywtr+aac5V9JwoqTlXUPi7YV2CSL7yuQEa0yDgH2?=
 =?us-ascii?q?tZ3jw7bCulupb6nxx7jmKSMnBzoWHdecFxwxff+dPdSeRQ3joAWCl3lz3XCkKg?=
 =?us-ascii?q?MNmu+NWej43DvfymV2K9Sp1TdjHmzIOauyu8/2FqAxy/n/aol93jEAg61zL71t?=
 =?us-ascii?q?ZwWSXJqhb8fpfk16CgPe17eUloAUf269BmFYFmjoswmJYQ1GAZhpqP/HoLi2fz?=
 =?us-ascii?q?MchB1qL4Y3oAXjoLw9/T4Aj410xvNHOJx4TlVnqDxsttfcW1YmQT2igl9cBFFL?=
 =?us-ascii?q?+U7KBYnStyule4qAPRYftnkTsHx/oh9mUag/0Xtwo31SqSHKoSHUZDMCzolhSI?=
 =?us-ascii?q?6c2+rapNaGaud7iwyFRxndS7AL6epQFcXW7zeo0+Ei9o8sV/LFXM3WXv6oHjfd?=
 =?us-ascii?q?ncd9MSuQeSkxfdlOhVM5Mxm+EOhSpmP2L9oHIkx/Q6jRxowZG1ooyHJ39x86K+?=
 =?us-ascii?q?Bx5SLif1aN8L+jHxkaZemd6b0Ju1EZVmHjULQYHkTfa1ED8JsfTnNgCOECAzq3?=
 =?us-ascii?q?uBGLrfGxOf51lir37VD5+rMHSXLmEDzdp+XBmdOFBfgAcMUTU4hJE5Ex6lxNf7?=
 =?us-ascii?q?fEdl/DwR5UP4qhhRyuJuLRb/SXzSpAOpajcyVZieIwBa7gBE50fJL8Oe6vh/ED?=
 =?us-ascii?q?1f/p2ktAaNMHCUZxxUDWEVXUyJH1DiPr6z5dnZ7uiXHOy+I+HVYbWJr+xeWOyF?=
 =?us-ascii?q?xZau0otg4jaNOd+DPnhkD/0nxEVDWWp1FNjemzUKUyYXjT7Cb9aHpBeg/S16ts?=
 =?us-ascii?q?C//+rqWALs5ouPCqFeMdZ1+xCxjqeMKfSQhDtiKTtD0pMMxHnIyKUQ3VIIiiFu?=
 =?us-ascii?q?cSWtHqoEtSLXUK3QnapXBQYBayxvLMtI87483g5VNMHBl9P6zaR4geA1CltfUV?=
 =?us-ascii?q?zhm9qkZcgLI2G7KVPGC1yHNLWAJT3X3c73ZbmwRqFXjOVRrxewoyqUE1f/PjSf?=
 =?us-ascii?q?kDnkTwyvMeBJjC2BIBNSop2ychZzBmjlV9/mbhy7MNlqjTw527E0h3XKNXICPj?=
 =?us-ascii?q?h4aU9CsrqQ7SZAiPVlB2NB9mZlLfWDmyuB7+jXMJAWsf5qAiRyj+1b4XQ6xKFT?=
 =?us-ascii?q?7CFLX/F1nCrSrthzo1CpiOWPyzxnUAZQpTZPno6EoUJiOaCKvqVHDG7N4x8J6U?=
 =?us-ascii?q?2bAhgHodBoTNbovvN+0N/KwZr+NDpYu/nU8M1UU8jGMM+bPWAqMRfvMDHRBQoB?=
 =?us-ascii?q?CzWsMDeM1ARmjPiO+yjN/dABoZ/2lc9LE+cDWQ=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AAAQDxJhJch0O0hNFcBxwBAQEEAQEHB?=
 =?us-ascii?q?AEBgVQEAQELAYFagQ+BAieDfIN7jnyDQRRoiRaEMIkmgWMoAw8BAYFLgnWDAyI?=
 =?us-ascii?q?3Bg0BAwEBAQEBAQIBEwEBAQgNCQgpIwyCNiQBgmEBAQEBAgEBAhcBCAQZARsYB?=
 =?us-ascii?q?QEDAQEJAQEFBQsNAgImAgIDHwERAQUBHBAJBYJRSwGBZwEDDQgFmxI8iw18FgU?=
 =?us-ascii?q?BF4J3BYRGChknDV2BNwIGEnmGCIE9g2wXgX+BEYJdNYRGHwQBBBODBIJXAokbG?=
 =?us-ascii?q?gYBAyaFYn1ShHCLCQmHDYM/hw0YgVxNhE+DKocoijOLYYMmMIE7gXgzGiNQMYI?=
 =?us-ascii?q?7CYISCQMXfwECgkiEUYYPMjOBBQEBigQCJAMEgiABAQ?=
X-IPAS-Result: =?us-ascii?q?A0AAAQDxJhJch0O0hNFcBxwBAQEEAQEHBAEBgVQEAQELAYF?=
 =?us-ascii?q?agQ+BAieDfIN7jnyDQRRoiRaEMIkmgWMoAw8BAYFLgnWDAyI3Bg0BAwEBAQEBA?=
 =?us-ascii?q?QIBEwEBAQgNCQgpIwyCNiQBgmEBAQEBAgEBAhcBCAQZARsYBQEDAQEJAQEFBQs?=
 =?us-ascii?q?NAgImAgIDHwERAQUBHBAJBYJRSwGBZwEDDQgFmxI8iw18FgUBF4J3BYRGChknD?=
 =?us-ascii?q?V2BNwIGEnmGCIE9g2wXgX+BEYJdNYRGHwQBBBODBIJXAokbGgYBAyaFYn1ShHC?=
 =?us-ascii?q?LCQmHDYM/hw0YgVxNhE+DKocoijOLYYMmMIE7gXgzGiNQMYI7CYISCQMXfwECg?=
 =?us-ascii?q?kiEUYYPMjOBBQEBigQCJAMEgiABAQ?=
X-IronPort-AV: E=Sophos;i="5.56,348,1539673200"; 
   d="scan'208";a="57303363"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 13 Dec 2018 01:35:33 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1728067AbeLMJfb (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Thu, 13 Dec 2018 04:35:31 -0500
Received: from mail-io1-f68.google.com ([209.85.166.68]:41493 "EHLO
        mail-io1-f68.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1727890AbeLMJfa (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 13 Dec 2018 04:35:30 -0500
Received: by mail-io1-f68.google.com with SMTP id s22so1053606ioc.8;
        Thu, 13 Dec 2018 01:35:24 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=mime-version:references:in-reply-to:from:date:message-id:subject:to
         :cc:content-transfer-encoding;
        bh=lRsGlXQ65K1RRXMoUD/6qFj++IxtTLqIP9/0souOAt4=;
        b=gdOyyJLHgO/mHIUu3rfayQnCg7Sp1Xq17MaIjePbe2fkJxoXvikf4mtzGp1EjVCblk
         5xmVnUEQrGPvEW4TGZPmQYsuVDdptqQYt0H2OqXpsVYAV6rQg9KtDuwOxjF9GpgPgmRt
         rN8azJgbTWxnetAj6TFM+a5Zms6ekjzNFfE8lHjYqe/SHwKCTZRrZN6Q28NqqX6v6I2v
         sZrHVwlxjYMsWS/KTmZscx2POazadNX4zvAocIIQpibsRrxMRQShVQTRrkr/16qCL+o+
         SRE6VOp7UH5+6GH1xjrXyDJWHHoxvppmAyrJX5jNXu35iOgP9AH2dzeTNzyCZmC8hi2l
         +d5g==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:mime-version:references:in-reply-to:from:date
         :message-id:subject:to:cc:content-transfer-encoding;
        bh=lRsGlXQ65K1RRXMoUD/6qFj++IxtTLqIP9/0souOAt4=;
        b=tjhofOMr8aFfG3IDwwEZUTva3xWFaF7QK9HNQEgVF5vrtEohxXle0WtIEy8Uc19IUB
         TZKIT/P5KoMHK8GcQO/jQkaMWAkTBCmRBbZAUe2BLVGjbY5R0kZYKKj0SvtNvr4wXwz4
         ErqaBmWzWrgNXeE6ZD6ZV46lT3+R1X1Fx3OASYOHKQRTyV5R1G8JHVVhcz+apC91/V9U
         mLCmtmZRe/2D39xHjrFoV0I2utwamInj174YJnnqsKK9fcKA0stHLmay1L1NB+ITkjoU
         pPpACVmU01pp8lQKpL+NR9yYccY5fg8lTAcrILJuuji7JMapQAwQ//bpyEdTje2woduC
         DShQ==
X-Gm-Message-State: AA+aEWZbwCdg00Y8JuablYO4GySjnAiygTtbzRRGcjft0xlp6X3+9gc0
        D/7ccRgyVwh3m3G4viTMHuN/WmHbwzrBk/U3aNg=
X-Google-Smtp-Source: AFSGD/WObA3SwPJWkF18NOFE+9qC+bzlxZAKTdz8pyICmFQiZ23otQkKuAL7jJXz7bXQUhROxRFOlTtTiRkmRS2Rqyw=
X-Received: by 2002:a6b:3806:: with SMTP id f6mr7583284ioa.194.1544693722842;
 Thu, 13 Dec 2018 01:35:22 -0800 (PST)
MIME-Version: 1.0
References: <1544445555-17325-1-git-send-email-pawell@cadence.com> <1544445555-17325-3-git-send-email-pawell@cadence.com>
In-Reply-To: <1544445555-17325-3-git-send-email-pawell@cadence.com>
From: Peter Chen <hzpeterchen@gmail.com>
Date: Thu, 13 Dec 2018 17:35:11 +0800
Message-ID: <CAL411-phi=PV1Voe=mTrjKDXNPL7dt9B-f_RaekCoXy=pqNMPA@mail.gmail.com>
Subject: Re: [PATCH v1 2/2] usb:cdns3 Add Cadence USB3 DRD Driver
To: pawell@cadence.com
Cc: devicetree@vger.kernel.org,
        Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
        linux-usb@vger.kernel.org, balbi@kernel.org, rogerq@ti.com,
        lkml <linux-kernel@vger.kernel.org>, adouglas@cadence.com,
        jbergsagel@ti.com, nsekhar@ti.com, nm@ti.com, sureshp@cadence.com,
        peter.chen@nxp.com, pjez@cadence.com, kurahul@cadence.com
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Mon, Dec 10, 2018 at 8:55 PM Pawel Laszczak <pawell@cadence.com> wrote:
>
> This patch introduce new Cadence USBSS DRD driver
> to linux kernel.
>
> The Cadence USBSS DRD Driver is a highly
> configurable IP Core which can be
> instantiated as Dual-Role Device (DRD),
> Peripheral Only and Host Only (XHCI)
> configurations.
>
> The current driver has been validated with
> FPGA burned. We have support for PCIe
> bus, which is used on FPGA prototyping.
>
> The host side of USBSS-DRD controller is compliance
> with XHCI specification, so it works with
> standard XHCI linux driver.
>
> Signed-off-by: Pawel Laszczak <pawell@cadence.com>
> ---

I have compiled it at my ARM64 platform, and will give you more feedback af=
ter
adding platform support. Below is one compile warning, please fix

  CC      drivers/usb/cdns3/host.o
  AR      drivers/usb/cdns3/cdns3-pci.o
/home/b29397/work/projects/linux-imx/drivers/usb/cdns3/gadget.c: In
function =E2=80=98cdns3_gadget_ep_disable=E2=80=99:
/home/b29397/work/projects/linux-imx/drivers/usb/cdns3/gadget.c:1122:19:
warning: =E2=80=98priv_dev=E2=80=99 may be used uninitialized in this funct=
ion
[-Wmaybe-uninitialized]
   dev_dbg(priv_dev->dev, "usbss: invalid parameters\n");
                   ^~
  AR      drivers/usb/cdns3/cdns3.o

Peter

>  drivers/usb/Kconfig                |    2 +
>  drivers/usb/Makefile               |    2 +
>  drivers/usb/cdns3/Kconfig          |   44 +
>  drivers/usb/cdns3/Makefile         |   16 +
>  drivers/usb/cdns3/cdns3-pci-wrap.c |  157 +++
>  drivers/usb/cdns3/core.c           |  451 +++++++
>  drivers/usb/cdns3/core.h           |  108 ++
>  drivers/usb/cdns3/debug.h          |  346 ++++++
>  drivers/usb/cdns3/debugfs.c        |  168 +++
>  drivers/usb/cdns3/drd.c            |  315 +++++
>  drivers/usb/cdns3/drd.h            |  129 ++
>  drivers/usb/cdns3/ep0.c            |  864 +++++++++++++
>  drivers/usb/cdns3/gadget-export.h  |   28 +
>  drivers/usb/cdns3/gadget.c         | 1802 ++++++++++++++++++++++++++++
>  drivers/usb/cdns3/gadget.h         | 1177 ++++++++++++++++++
>  drivers/usb/cdns3/host-export.h    |   28 +
>  drivers/usb/cdns3/host.c           |   74 ++
>  drivers/usb/cdns3/trace.c          |   11 +
>  drivers/usb/cdns3/trace.h          |  343 ++++++
>  19 files changed, 6065 insertions(+)
>  create mode 100644 drivers/usb/cdns3/Kconfig
>  create mode 100644 drivers/usb/cdns3/Makefile
>  create mode 100644 drivers/usb/cdns3/cdns3-pci-wrap.c
>  create mode 100644 drivers/usb/cdns3/core.c
>  create mode 100644 drivers/usb/cdns3/core.h
>  create mode 100644 drivers/usb/cdns3/debug.h
>  create mode 100644 drivers/usb/cdns3/debugfs.c
>  create mode 100644 drivers/usb/cdns3/drd.c
>  create mode 100644 drivers/usb/cdns3/drd.h
>  create mode 100644 drivers/usb/cdns3/ep0.c
>  create mode 100644 drivers/usb/cdns3/gadget-export.h
>  create mode 100644 drivers/usb/cdns3/gadget.c
>  create mode 100644 drivers/usb/cdns3/gadget.h
>  create mode 100644 drivers/usb/cdns3/host-export.h
>  create mode 100644 drivers/usb/cdns3/host.c
>  create mode 100644 drivers/usb/cdns3/trace.c
>  create mode 100644 drivers/usb/cdns3/trace.h
>
> diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
> index 987fc5ba6321..5f9334019d04 100644
> --- a/drivers/usb/Kconfig
> +++ b/drivers/usb/Kconfig
> @@ -112,6 +112,8 @@ source "drivers/usb/usbip/Kconfig"
>
>  endif
>
> +source "drivers/usb/cdns3/Kconfig"
> +
>  source "drivers/usb/mtu3/Kconfig"
>
>  source "drivers/usb/musb/Kconfig"
> diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
> index 7d1b8c82b208..ab125b966cac 100644
> --- a/drivers/usb/Makefile
> +++ b/drivers/usb/Makefile
> @@ -12,6 +12,8 @@ obj-$(CONFIG_USB_DWC3)                +=3D dwc3/
>  obj-$(CONFIG_USB_DWC2)         +=3D dwc2/
>  obj-$(CONFIG_USB_ISP1760)      +=3D isp1760/
>
> +obj-$(CONFIG_USB_CDNS3)                +=3D cdns3/
> +
>  obj-$(CONFIG_USB_MON)          +=3D mon/
>  obj-$(CONFIG_USB_MTU3)         +=3D mtu3/
>
> diff --git a/drivers/usb/cdns3/Kconfig b/drivers/usb/cdns3/Kconfig
> new file mode 100644
> index 000000000000..4adfd87811e8
> --- /dev/null
> +++ b/drivers/usb/cdns3/Kconfig
> @@ -0,0 +1,44 @@
> +config USB_CDNS3
> +       tristate "Cadence USB3 Dual-Role Controller"
> +       depends on USB_SUPPORT && (USB || USB_GADGET) && HAS_DMA
> +       help
> +         Say Y here if your system has a cadence USB3 dual-role controll=
er.
> +         It supports: dual-role switch, Host-only, and Peripheral-only.
> +
> +         If you choose to build this driver is a dynamically linked
> +         module, the module will be called cdns3.ko.
> +
> +if USB_CDNS3
> +
> +config USB_CDNS3_GADGET
> +        bool "Cadence USB3 device controller"
> +        depends on USB_GADGET
> +        help
> +          Say Y here to enable device controller functionality of the
> +          cadence USBSS-DEV driver.
> +
> +          This controller supports FF, HS and SS mode. It doesn't suppor=
t
> +          LS and SSP mode
> +
> +config USB_CDNS3_HOST
> +        bool "Cadence USB3 host controller"
> +        depends on USB_XHCI_HCD
> +        help
> +          Say Y here to enable host controller functionality of the
> +          cadence driver.
> +
> +          Host controller is compliance with XHCI so it will use
> +          standard XHCI driver.
> +
> +config USB_CDNS3_PCI_WRAP
> +       tristate "Cadence USB3 support on PCIe-based platforms"
> +       depends on USB_PCI && ACPI
> +       default USB_CDNS3
> +       help
> +         If you're using the USBSS Core IP with a PCIe, please say
> +         'Y' or 'M' here.
> +
> +         If you choose to build this driver as module it will
> +         be dynamically linked and module will be called cdns3-pci.ko
> +
> +endif
> diff --git a/drivers/usb/cdns3/Makefile b/drivers/usb/cdns3/Makefile
> new file mode 100644
> index 000000000000..3f63baa24294
> --- /dev/null
> +++ b/drivers/usb/cdns3/Makefile
> @@ -0,0 +1,16 @@
> +# SPDX-License-Identifier: GPL-2.0
> +# define_trace.h needs to know how to find our header
> +CFLAGS_trace.o                         :=3D -I$(src)
> +
> +obj-$(CONFIG_USB_CDNS3)                        +=3D cdns3.o
> +obj-$(CONFIG_USB_CDNS3_PCI_WRAP)       +=3D cdns3-pci.o
> +
> +cdns3-y                                        :=3D core.o drd.o trace.o
> +
> +ifneq ($(CONFIG_DEBUG_FS),)
> +       cdns3-y                         +=3D debugfs.o
> +endif
> +
> +cdns3-$(CONFIG_USB_CDNS3_GADGET)       +=3D gadget.o ep0.o
> +cdns3-$(CONFIG_USB_CDNS3_HOST)         +=3D host.o
> +cdns3-pci-y                            :=3D cdns3-pci-wrap.o
> diff --git a/drivers/usb/cdns3/cdns3-pci-wrap.c b/drivers/usb/cdns3/cdns3=
-pci-wrap.c
> new file mode 100644
> index 000000000000..e93179c45ece
> --- /dev/null
> +++ b/drivers/usb/cdns3/cdns3-pci-wrap.c
> @@ -0,0 +1,157 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS PCI Glue driver
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#include <linux/kernel.h>
> +#include <linux/module.h>
> +#include <linux/pci.h>
> +#include <linux/platform_device.h>
> +#include <linux/dma-mapping.h>
> +#include <linux/slab.h>
> +
> +struct cdns3_wrap {
> +       struct platform_device *plat_dev;
> +       struct pci_dev *hg_dev;
> +       struct resource dev_res[4];
> +};
> +
> +struct cdns3_wrap wrap;
> +
> +#define RES_IRQ_ID             0
> +#define RES_HOST_ID            1
> +#define RES_DEV_ID             2
> +#define RES_DRD_ID             3
> +
> +#define PCI_BAR_HOST           0
> +#define PCI_BAR_DEV            2
> +#define PCI_BAR_OTG            4
> +
> +#define PCI_DEV_FN_HOST_DEVICE 0
> +#define PCI_DEV_FN_OTG         1
> +
> +#define PCI_DRIVER_NAME                "cdns3-pci-usbss"
> +#define PLAT_DRIVER_NAME       "cdns-usb3"
> +
> +#define CDNS_VENDOR_ID 0x17cd
> +#define CDNS_DEVICE_ID 0x0100
> +
> +/**
> + * cdns3_pci_probe - Probe function for Cadence USB wrapper driver
> + * @pdev: platform device object
> + * @id: pci device id
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_pci_probe(struct pci_dev *pdev,
> +                          const struct pci_device_id *id)
> +{
> +       struct platform_device_info plat_info;
> +       struct cdns3_wrap *wrap;
> +       struct resource *res;
> +       int err;
> +
> +       /*
> +        * for GADGET/HOST PCI (devfn) function number is 0,
> +        * for OTG PCI (devfn) function number is 1
> +        */
> +       if (!id || pdev->devfn !=3D PCI_DEV_FN_HOST_DEVICE)
> +               return -EINVAL;
> +
> +       err =3D pcim_enable_device(pdev);
> +       if (err) {
> +               dev_err(&pdev->dev, "Enabling PCI device has failed %d\n"=
, err);
> +               return err;
> +       }
> +
> +       pci_set_master(pdev);
> +       wrap =3D devm_kzalloc(&pdev->dev, sizeof(*wrap), GFP_KERNEL);
> +       if (!wrap) {
> +               dev_err(&pdev->dev, "Failed to allocate memory\n");
> +               return -ENOMEM;
> +       }
> +
> +       /* function 0: host(BAR_0) + device(BAR_1) + otg(BAR_2)). */
> +       memset(wrap->dev_res, 0x00,
> +              sizeof(struct resource) * ARRAY_SIZE(wrap->dev_res));
> +       dev_dbg(&pdev->dev, "Initialize Device resources\n");
> +       res =3D wrap->dev_res;
> +
> +       res[RES_DEV_ID].start =3D pci_resource_start(pdev, PCI_BAR_DEV);
> +       res[RES_DEV_ID].end =3D   pci_resource_end(pdev, PCI_BAR_DEV);
> +       res[RES_DEV_ID].name =3D "cdns3-dev-regs";
> +       res[RES_DEV_ID].flags =3D IORESOURCE_MEM;
> +       dev_dbg(&pdev->dev, "USBSS-DEV physical base addr: %pa\n",
> +               &res[RES_DEV_ID].start);
> +
> +       res[RES_HOST_ID].start =3D pci_resource_start(pdev, PCI_BAR_HOST)=
;
> +       res[RES_HOST_ID].end =3D pci_resource_end(pdev, PCI_BAR_HOST);
> +       res[RES_HOST_ID].name =3D "cdns3-xhci-regs";
> +       res[RES_HOST_ID].flags =3D IORESOURCE_MEM;
> +       dev_dbg(&pdev->dev, "USBSS-XHCI physical base addr: %pa\n",
> +               &res[RES_HOST_ID].start);
> +
> +       res[RES_DRD_ID].start =3D pci_resource_start(pdev, PCI_BAR_OTG);
> +       res[RES_DRD_ID].end =3D   pci_resource_end(pdev, PCI_BAR_OTG);
> +       res[RES_DRD_ID].name =3D "cdns3-otg";
> +       res[RES_DRD_ID].flags =3D IORESOURCE_MEM;
> +       dev_dbg(&pdev->dev, "USBSS-DRD physical base addr: %pa\n",
> +               &res[RES_DRD_ID].start);
> +
> +       /* Interrupt common for both device and XHCI */
> +       wrap->dev_res[RES_IRQ_ID].start =3D pdev->irq;
> +       wrap->dev_res[RES_IRQ_ID].name =3D "cdns3-irq";
> +       wrap->dev_res[RES_IRQ_ID].flags =3D IORESOURCE_IRQ;
> +
> +       /* set up platform device info */
> +       memset(&plat_info, 0, sizeof(plat_info));
> +       plat_info.parent =3D &pdev->dev;
> +       plat_info.fwnode =3D pdev->dev.fwnode;
> +       plat_info.name =3D PLAT_DRIVER_NAME;
> +       plat_info.id =3D pdev->devfn;
> +       plat_info.res =3D wrap->dev_res;
> +       plat_info.num_res =3D ARRAY_SIZE(wrap->dev_res);
> +       plat_info.dma_mask =3D pdev->dma_mask;
> +
> +       /* register platform device */
> +       wrap->plat_dev =3D platform_device_register_full(&plat_info);
> +       if (IS_ERR(wrap->plat_dev)) {
> +               err =3D PTR_ERR(wrap->plat_dev);
> +               return err;
> +       }
> +
> +       pci_set_drvdata(pdev, wrap);
> +
> +       return err;
> +}
> +
> +void cdns3_pci_remove(struct pci_dev *pdev)
> +{
> +       struct cdns3_wrap *wrap =3D (struct cdns3_wrap *)pci_get_drvdata(=
pdev);
> +
> +       platform_device_unregister(wrap->plat_dev);
> +}
> +
> +static const struct pci_device_id cdns3_pci_ids[] =3D {
> +       { PCI_DEVICE(CDNS_VENDOR_ID, CDNS_DEVICE_ID), },
> +       { 0, }
> +};
> +
> +static struct pci_driver cdns3_pci_driver =3D {
> +       .name =3D PCI_DRIVER_NAME,
> +       .id_table =3D cdns3_pci_ids,
> +       .probe =3D cdns3_pci_probe,
> +       .remove =3D cdns3_pci_remove,
> +};
> +
> +module_pci_driver(cdns3_pci_driver);
> +MODULE_DEVICE_TABLE(pci, cdns3_pci_ids);
> +
> +MODULE_AUTHOR("Pawel Laszczak <pawell@cadence.com>");
> +MODULE_LICENSE("GPL v2");
> +MODULE_DESCRIPTION("Cadence USBSS PCI wrapperr");
> +
> diff --git a/drivers/usb/cdns3/core.c b/drivers/usb/cdns3/core.c
> new file mode 100644
> index 000000000000..b93e3788bd33
> --- /dev/null
> +++ b/drivers/usb/cdns3/core.c
> @@ -0,0 +1,451 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Driver.
> + *
> + * Copyright (C) 2018 Cadence.
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Author: Peter Chen <peter.chen@nxp.com>
> + *         Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#include <linux/module.h>
> +#include <linux/kernel.h>
> +#include <linux/platform_device.h>
> +#include <linux/interrupt.h>
> +#include <linux/io.h>
> +#include <linux/pm_runtime.h>
> +
> +#include "gadget.h"
> +#include "core.h"
> +#include "host-export.h"
> +#include "gadget-export.h"
> +#include "drd.h"
> +#include "debug.h"
> +
> +static inline
> +struct cdns3_role_driver *cdns3_get_current_role_driver(struct cdns3 *cd=
ns)
> +{
> +       WARN_ON(cdns->role >=3D CDNS3_ROLE_END || !cdns->roles[cdns->role=
]);
> +       return cdns->roles[cdns->role];
> +}
> +
> +static inline int cdns3_role_start(struct cdns3 *cdns, enum cdns3_roles =
role)
> +{
> +       int ret;
> +
> +       if (WARN_ON(role >=3D CDNS3_ROLE_END))
> +               return 0;
> +
> +       if (!cdns->roles[role])
> +               return -ENXIO;
> +
> +       if (cdns->roles[role]->state =3D=3D CDNS3_ROLE_STATE_ACTIVE)
> +               return 0;
> +
> +       mutex_lock(&cdns->mutex);
> +       cdns->role =3D role;
> +       ret =3D cdns->roles[role]->start(cdns);
> +       if (!ret)
> +               cdns->roles[role]->state =3D CDNS3_ROLE_STATE_ACTIVE;
> +       mutex_unlock(&cdns->mutex);
> +       return ret;
> +}
> +
> +void cdns3_role_stop(struct cdns3 *cdns)
> +{
> +       enum cdns3_roles role =3D cdns->role;
> +
> +       if (role >=3D CDNS3_ROLE_END) {
> +               WARN_ON(role > CDNS3_ROLE_END);
> +               return;
> +       }
> +
> +       if (cdns->roles[role]->state =3D=3D CDNS3_ROLE_STATE_INACTIVE)
> +               return;
> +
> +       mutex_lock(&cdns->mutex);
> +       cdns->roles[role]->stop(cdns);
> +       cdns->roles[role]->state =3D CDNS3_ROLE_STATE_INACTIVE;
> +       mutex_unlock(&cdns->mutex);
> +}
> +
> +/*
> + * cdns->role gets from cdns3_get_initial_role, and this API tells role =
at the
> + * runtime.
> + * If both roles are supported, the role is selected based on vbus/id.
> + * It could be read from OTG register or external connector.
> + * If only single role is supported, only one role structure
> + * is allocated, cdns->roles[CDNS3_ROLE_HOST] or cdns->roles[CDNS3_ROLE_=
GADGET].
> + */
> +static enum cdns3_roles cdns3_get_initial_role(struct cdns3 *cdns)
> +{
> +       if (cdns->roles[CDNS3_ROLE_HOST] && cdns->roles[CDNS3_ROLE_GADGET=
]) {
> +               if (cdns3_is_host(cdns))
> +                       return CDNS3_ROLE_HOST;
> +               if (cdns3_is_device(cdns))
> +                       return CDNS3_ROLE_GADGET;
> +       }
> +       return cdns->roles[CDNS3_ROLE_HOST]
> +               ? CDNS3_ROLE_HOST
> +               : CDNS3_ROLE_GADGET;
> +}
> +
> +static void cdns3_exit_roles(struct cdns3 *cdns)
> +{
> +       cdns3_role_stop(cdns);
> +       cdns3_drd_exit(cdns);
> +}
> +
> +/**
> + * cdns3_core_init_role - initialize role of operation
> + * @cdns: Pointer to cdns3 structure
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_core_init_role(struct cdns3 *cdns)
> +{
> +       struct device *dev =3D cdns->dev;
> +       enum usb_dr_mode best_dr_mode;
> +       enum usb_dr_mode dr_mode;
> +       int ret =3D 0;
> +
> +       dr_mode =3D usb_get_dr_mode(dev);
> +       cdns->role =3D CDNS3_ROLE_END;
> +
> +       /*
> +        * If driver can't read mode by means of usb_get_dr_mdoe function=
 then
> +        * chooses mode according with Kernel configuration. This setting
> +        * can be restricted later depending on strap pin configuration.
> +        */
> +       if (dr_mode =3D=3D USB_DR_MODE_UNKNOWN) {
> +               if (IS_ENABLED(CONFIG_USB_CDNS3_HOST) &&
> +                   IS_ENABLED(CONFIG_USB_CDNS3_GADGET))
> +                       dr_mode =3D USB_DR_MODE_OTG;
> +               else if (IS_ENABLED(CONFIG_USB_CDNS3_HOST))
> +                       dr_mode =3D USB_DR_MODE_HOST;
> +               else if (IS_ENABLED(CONFIG_USB_CDNS3_GADGET))
> +                       dr_mode =3D USB_DR_MODE_PERIPHERAL;
> +       }
> +
> +       best_dr_mode =3D USB_DR_MODE_OTG;
> +
> +       if (dr_mode =3D=3D USB_DR_MODE_OTG) {
> +               best_dr_mode =3D cdns->dr_mode;
> +       } else if (cdns->dr_mode =3D=3D USB_DR_MODE_OTG) {
> +               best_dr_mode =3D dr_mode;
> +       } else if (cdns->dr_mode !=3D dr_mode) {
> +               dev_err(dev, "Incorrect DRD configuration\n");
> +               return -EINVAL;
> +       }
> +
> +       dr_mode =3D best_dr_mode;
> +
> +       if (dr_mode =3D=3D USB_DR_MODE_OTG || dr_mode =3D=3D USB_DR_MODE_=
HOST) {
> +               ret =3D cdns3_host_init(cdns);
> +               if (ret) {
> +                       dev_err(dev, "Host initialization failed with %d\=
n",
> +                               ret);
> +                       goto err;
> +               }
> +       }
> +
> +       if (dr_mode =3D=3D USB_DR_MODE_OTG || dr_mode =3D=3D USB_DR_MODE_=
PERIPHERAL) {
> +               ret =3D cdns3_gadget_init(cdns);
> +               if (ret) {
> +                       dev_err(dev, "Device initialization failed with %=
d\n",
> +                               ret);
> +                       goto err;
> +               }
> +       }
> +
> +       cdns->desired_dr_mode =3D dr_mode;
> +       cdns->dr_mode =3D dr_mode;
> +       /*
> +        * dr_mode could be change so DRD must update controller
> +        * configuration
> +        */
> +       ret =3D cdns3_drd_update_mode(cdns);
> +
> +       cdns->role =3D cdns3_get_initial_role(cdns);
> +
> +       ret =3D cdns3_role_start(cdns, cdns->role);
> +       if (ret) {
> +               dev_err(dev, "can't start %s role\n",
> +                       cdns3_get_current_role_driver(cdns)->name);
> +               goto err;
> +       }
> +
> +       return ret;
> +err:
> +       cdns3_exit_roles(cdns);
> +       return ret;
> +}
> +
> +/**
> + * cdsn3_get_real_role - get real role of controller based on hardware s=
ettings.
> + * @cdns: Pointer to cdns3 structure
> + *
> + * Returns role
> + */
> +enum cdns3_roles cdsn3_get_real_role(struct cdns3 *cdns)
> +{
> +       enum cdns3_roles role =3D CDNS3_ROLE_END;
> +
> +       if (cdns->current_dr_mode =3D=3D USB_DR_MODE_OTG) {
> +               if (cdns3_get_id(cdns))
> +                       role =3D CDNS3_ROLE_GADGET;
> +               else
> +                       role =3D CDNS3_ROLE_HOST;
> +       } else {
> +               if (cdns3_is_host(cdns))
> +                       role =3D CDNS3_ROLE_HOST;
> +               if (cdns3_is_device(cdns))
> +                       role =3D CDNS3_ROLE_GADGET;
> +       }
> +
> +       return role;
> +}
> +
> +/**
> + * cdns3_role_switch - work queue handler for role switch
> + *
> + * @work: work queue item structure
> + *
> + * Handles below events:
> + * - Role switch for dual-role devices
> + * - CDNS3_ROLE_GADGET <--> CDNS3_ROLE_END for peripheral-only devices
> + */
> +static void cdns3_role_switch(struct work_struct *work)
> +{
> +       enum cdns3_roles role =3D CDNS3_ROLE_END;
> +       struct cdns3_role_driver *role_drv;
> +       enum cdns3_roles current_role;
> +       struct cdns3 *cdns;
> +       int ret =3D 0;
> +
> +       cdns =3D container_of(work, struct cdns3, role_switch_wq);
> +
> +       /* During switching cdns->role can be different then role */
> +       role =3D cdsn3_get_real_role(cdns);
> +
> +       role_drv =3D cdns3_get_current_role_driver(cdns);
> +
> +       pm_runtime_get_sync(cdns->dev);
> +
> +       /* Disable current role. This state can be forced from user space=
. */
> +       if (cdns->debug_disable && role_drv->state =3D=3D CDNS3_ROLE_STAT=
E_ACTIVE) {
> +               cdns3_role_stop(cdns);
> +               goto exit;
> +       }
> +
> +       /* Do nothing if nothing changed */
> +       if (cdns->role =3D=3D role && role_drv->state =3D=3D CDNS3_ROLE_S=
TATE_ACTIVE)
> +               goto exit;
> +
> +       cdns3_role_stop(cdns);
> +
> +       role =3D cdsn3_get_real_role(cdns);
> +
> +       current_role =3D cdns->role;
> +       dev_dbg(cdns->dev, "Switching role");
> +
> +       ret =3D cdns3_role_start(cdns, role);
> +
> +       if (ret) {
> +               /* Back to current role */
> +               dev_err(cdns->dev, "set %d has failed, back to %d\n",
> +                       role, current_role);
> +               cdns3_role_start(cdns, current_role);
> +       }
> +exit:
> +       pm_runtime_put_sync(cdns->dev);
> +}
> +
> +/**
> + * cdns3_probe - probe for cdns3 core device
> + * @pdev: Pointer to cdns3 core platform device
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_probe(struct platform_device *pdev)
> +{
> +       struct device *dev =3D &pdev->dev;
> +       struct resource *res;
> +       struct cdns3 *cdns;
> +       void __iomem *regs;
> +       int ret;
> +
> +       cdns =3D devm_kzalloc(dev, sizeof(*cdns), GFP_KERNEL);
> +       if (!cdns)
> +               return -ENOMEM;
> +
> +       cdns->dev =3D dev;
> +
> +       platform_set_drvdata(pdev, cdns);
> +
> +       res =3D platform_get_resource(pdev, IORESOURCE_IRQ, 0);
> +       if (!res) {
> +               dev_err(dev, "missing IRQ\n");
> +               return -ENODEV;
> +       }
> +       cdns->irq =3D res->start;
> +
> +       cdns->xhci_res[0] =3D *res;
> +
> +       /*
> +        * Request memory region
> +        * region-0: xHCI
> +        * region-1: Peripheral
> +        * region-2: OTG registers
> +        */
> +       res =3D platform_get_resource(pdev, IORESOURCE_MEM, 0);
> +       cdns->xhci_res[1] =3D *res;
> +
> +       res =3D platform_get_resource(pdev, IORESOURCE_MEM, 1);
> +       regs =3D devm_ioremap_resource(dev, res);
> +       if (IS_ERR(regs))
> +               return PTR_ERR(regs);
> +       cdns->dev_regs  =3D regs;
> +
> +       res =3D platform_get_resource(pdev, IORESOURCE_MEM, 2);
> +       regs =3D devm_ioremap_resource(dev, res);
> +       if (IS_ERR(regs))
> +               return PTR_ERR(regs);
> +       cdns->otg_regs =3D regs;
> +
> +       mutex_init(&cdns->mutex);
> +
> +       cdns->phy =3D devm_phy_get(dev, "cdns3,usbphy");
> +       if (IS_ERR(cdns->phy)) {
> +               ret =3D PTR_ERR(cdns->phy);
> +               if (ret =3D=3D -ENOSYS || ret =3D=3D -ENODEV) {
> +                       cdns->phy =3D NULL;
> +               } else if (ret =3D=3D -EPROBE_DEFER) {
> +                       return ret;
> +               } else {
> +                       dev_err(dev, "no phy found\n");
> +                       goto err0;
> +               }
> +       }
> +
> +       phy_init(cdns->phy);
> +
> +       INIT_WORK(&cdns->role_switch_wq, cdns3_role_switch);
> +
> +       ret =3D cdns3_drd_init(cdns);
> +       if (ret)
> +               goto err1;
> +
> +       ret =3D cdns3_core_init_role(cdns);
> +       if (ret)
> +               goto err1;
> +
> +       cdns3_debugfs_init(cdns);
> +       device_set_wakeup_capable(dev, true);
> +       pm_runtime_set_active(dev);
> +       pm_runtime_enable(dev);
> +
> +       /*
> +        * The controller needs less time between bus and controller susp=
end,
> +        * and we also needs a small delay to avoid frequently entering l=
ow
> +        * power mode.
> +        */
> +       pm_runtime_set_autosuspend_delay(dev, 20);
> +       pm_runtime_mark_last_busy(dev);
> +       pm_runtime_use_autosuspend(dev);
> +       dev_dbg(dev, "Cadence USB3 core: probe succeed\n");
> +
> +       return 0;
> +
> +err1:
> +       phy_exit(cdns->phy);
> +err0:
> +       return ret;
> +}
> +
> +/**
> + * cdns3_remove - unbind drd driver and clean up
> + * @pdev: Pointer to Linux platform device
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_remove(struct platform_device *pdev)
> +{
> +       struct cdns3 *cdns =3D platform_get_drvdata(pdev);
> +
> +       pm_runtime_get_sync(&pdev->dev);
> +       pm_runtime_disable(&pdev->dev);
> +       pm_runtime_put_noidle(&pdev->dev);
> +       cdns3_debugfs_exit(cdns);
> +       cdns3_exit_roles(cdns);
> +       phy_exit(cdns->phy);
> +       return 0;
> +}
> +
> +#ifdef CONFIG_OF
> +static const struct of_device_id of_cdns3_match[] =3D {
> +       { .compatible =3D "cdns,usb3" },
> +       { },
> +};
> +MODULE_DEVICE_TABLE(of, of_cdns3_match);
> +#endif
> +
> +#ifdef CONFIG_PM
> +
> +#ifdef CONFIG_PM_SLEEP
> +static int cdns3_suspend(struct device *dev)
> +{
> +       /* TODO: Implements this function. */
> +       return 0;
> +}
> +
> +static int cdns3_resume(struct device *dev)
> +{
> +       /* TODO: Implements this function. */
> +       return 0;
> +}
> +#endif /* CONFIG_PM_SLEEP */
> +static int cdns3_runtime_suspend(struct device *dev)
> +{      /* TODO: Implements this function. */
> +       return 0;
> +}
> +
> +static int cdns3_runtime_resume(struct device *dev)
> +{
> +       /* TODO: Implements this function. */
> +       return 0;
> +}
> +#endif /* CONFIG_PM */
> +
> +static const struct dev_pm_ops cdns3_pm_ops =3D {
> +       SET_SYSTEM_SLEEP_PM_OPS(cdns3_suspend, cdns3_resume)
> +       SET_RUNTIME_PM_OPS(cdns3_runtime_suspend, cdns3_runtime_resume, N=
ULL)
> +};
> +
> +static struct platform_driver cdns3_driver =3D {
> +       .probe          =3D cdns3_probe,
> +       .remove         =3D cdns3_remove,
> +       .driver         =3D {
> +               .name   =3D "cdns-usb3",
> +               .of_match_table =3D of_match_ptr(of_cdns3_match),
> +               .pm     =3D &cdns3_pm_ops,
> +       },
> +};
> +
> +static int __init cdns3_driver_platform_register(void)
> +{
> +       return platform_driver_register(&cdns3_driver);
> +}
> +module_init(cdns3_driver_platform_register);
> +
> +static void __exit cdns3_driver_platform_unregister(void)
> +{
> +       platform_driver_unregister(&cdns3_driver);
> +}
> +module_exit(cdns3_driver_platform_unregister);
> +
> +MODULE_ALIAS("platform:cdns3");
> +MODULE_AUTHOR("Pawel Laszczak <pawell@cadence.com>");
> +MODULE_LICENSE("GPL v2");
> +MODULE_DESCRIPTION("Cadence USB3 DRD Controller Driver");
> diff --git a/drivers/usb/cdns3/core.h b/drivers/usb/cdns3/core.h
> new file mode 100644
> index 000000000000..ffd1971ff893
> --- /dev/null
> +++ b/drivers/usb/cdns3/core.h
> @@ -0,0 +1,108 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * Cadence USBSS DRD Header File.
> + *
> + * Copyright (C) 2017-2018 NXP
> + * Copyright (C) 2018 Cadence.
> + *
> + * Authors: Peter Chen <peter.chen@nxp.com>
> + *          Pawel Laszczak <pawell@cadence.com>
> + */
> +#include <linux/usb/otg.h>
> +
> +#ifndef __LINUX_CDNS3_CORE_H
> +#define __LINUX_CDNS3_CORE_H
> +
> +struct cdns3;
> +enum cdns3_roles {
> +       CDNS3_ROLE_HOST =3D 0,
> +       CDNS3_ROLE_GADGET,
> +       CDNS3_ROLE_END,
> +};
> +
> +/**
> + * struct cdns3_role_driver - host/gadget role driver
> + * @start: start this role
> + * @stop: stop this role
> + * @suspend: suspend callback for this role
> + * @resume: resume callback for this role
> + * @irq: irq handler for this role
> + * @name: role name string (host/gadget)
> + * @state: current state
> + */
> +struct cdns3_role_driver {
> +       int (*start)(struct cdns3 *cdns);
> +       void (*stop)(struct cdns3 *cdns);
> +       int (*suspend)(struct cdns3 *cdns, bool do_wakeup);
> +       int (*resume)(struct cdns3 *cdns, bool hibernated);
> +       const char *name;
> +#define CDNS3_ROLE_STATE_INACTIVE      0
> +#define CDNS3_ROLE_STATE_ACTIVE                1
> +       int state;
> +};
> +
> +#define CDNS3_XHCI_RESOURCES_NUM       2
> +/**
> + * struct cdns3 - Representation of Cadence USB3 DRD controller.
> + * @dev: pointer to Cadence device struct
> + * @xhci_regs: pointer to base of xhci registers
> + * @xhci_res: the resource for xhci
> + * @dev_regs: pointer to base of dev registers
> + * @otg_regs: pointer to base of otg registers
> + * @irq: irq number for controller
> + * @roles: array of supported roles for this controller
> + * @role: current role
> + * @host_dev: the child host device pointer for cdns3 core
> + * @gadget_dev: the child gadget device pointer for cdns3 core
> + * @usb: phy for this controller
> + * @role_switch_wq: work queue item for role switch
> + * @in_lpm: the controller in low power mode
> + * @wakeup_int: the wakeup interrupt
> + * @mutex: the mutex for concurrent code at driver
> + * @dr_mode: supported mode of operation it can be only Host, only Devic=
e
> + *           or OTG mode that allow to switch between Device and Host mo=
de.
> + *           This field based on firmware setting, kernel configuration
> + *           and hardware configuration.
> + * @current_dr_mode: current mode of operation when in dual-role mode
> + * @desired_dr_mode: desired mode of operation when in dual-role mode.
> + *           This value can be changed during runtime.
> + *           Available options depends on  dr_mode:
> + *           dr_mode                 |  desired_dr_mode and current_dr_m=
ode
> + *           -----------------------------------------------------------=
-----
> + *           USB_DR_MODE_HOST        | only USB_DR_MODE_HOST
> + *           USB_DR_MODE_PERIPHERAL  | only USB_DR_MODE_PERIPHERAL
> + *           USB_DR_MODE_OTG         | only USB_DR_MODE_HOST
> + *           USB_DR_MODE_OTG         | only USB_DR_MODE_PERIPHERAL
> + *           USB_DR_MODE_OTG         | USB_DR_MODE_OTG
> + *
> + *           Desired_dr_role can be changed by means of debugfs.
> + * @root: debugfs root folder pointer
> + * @debug_disable:
> + */
> +struct cdns3 {
> +       struct device                   *dev;
> +       void __iomem                    *xhci_regs;
> +       struct resource                 xhci_res[CDNS3_XHCI_RESOURCES_NUM=
];
> +       struct cdns3_usb_regs __iomem   *dev_regs;
> +       struct cdns3_otg_regs           *otg_regs;
> +       int irq;
> +       struct cdns3_role_driver        *roles[CDNS3_ROLE_END];
> +       enum cdns3_roles                role;
> +       struct platform_device          *host_dev;
> +       struct cdns3_device             *gadget_dev;
> +       struct phy                      *phy;
> +       struct work_struct              role_switch_wq;
> +       int                             in_lpm:1;
> +       int                             wakeup_int:1;
> +       /* mutext used in workqueue*/
> +       struct mutex                    mutex;
> +       enum usb_dr_mode                dr_mode;
> +       enum usb_dr_mode                current_dr_mode;
> +       enum usb_dr_mode                desired_dr_mode;
> +       struct dentry                   *root;
> +       int                             debug_disable:1;
> +};
> +
> +void cdns3_role_stop(struct cdns3 *cdns);
> +
> +#endif /* __LINUX_CDNS3_CORE_H */
> diff --git a/drivers/usb/cdns3/debug.h b/drivers/usb/cdns3/debug.h
> new file mode 100644
> index 000000000000..afb81d224718
> --- /dev/null
> +++ b/drivers/usb/cdns3/debug.h
> @@ -0,0 +1,346 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * Cadence USBSS DRD Driver.
> + * Debug header file.
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + */
> +#ifndef __LINUX_CDNS3_DEBUG
> +#define __LINUX_CDNS3_DEBUG
> +#include "gadget.h"
> +
> +static inline void cdns3_decode_get_status(u8 bRequestType, u16 wIndex,
> +                                          u16 wLength, char *str)
> +{
> +       switch (bRequestType & USB_RECIP_MASK) {
> +       case USB_RECIP_INTERFACE:
> +               sprintf(str, "Get Interface Status Intf =3D %d, L: =3D %d=
",
> +                       wIndex, wLength);
> +               break;
> +       case USB_RECIP_ENDPOINT:
> +               sprintf(str, "Get Endpoint Status ep%d%s",
> +                       wIndex & ~USB_DIR_IN,
> +                       wIndex & USB_DIR_IN ? "in" : "out");
> +               break;
> +       }
> +}
> +
> +static inline const char *cdns3_decode_device_feature(u16 wValue)
> +{
> +       switch (wValue) {
> +       case USB_DEVICE_SELF_POWERED:
> +               return "Self Powered";
> +       case USB_DEVICE_REMOTE_WAKEUP:
> +               return "Remote Wakeup";
> +       case USB_DEVICE_TEST_MODE:
> +               return "Test Mode";
> +       case USB_DEVICE_U1_ENABLE:
> +               return "U1 Enable";
> +       case USB_DEVICE_U2_ENABLE:
> +               return "U2 Enable";
> +       case USB_DEVICE_LTM_ENABLE:
> +               return "LTM Enable";
> +       default:
> +               return "UNKNOWN";
> +       }
> +}
> +
> +static inline const char *cdns3_decode_test_mode(u16 wIndex)
> +{
> +       switch (wIndex) {
> +       case TEST_J:
> +               return ": TEST_J";
> +       case TEST_K:
> +               return ": TEST_K";
> +       case TEST_SE0_NAK:
> +               return ": TEST_SE0_NAK";
> +       case TEST_PACKET:
> +               return ": TEST_PACKET";
> +       case TEST_FORCE_EN:
> +               return ": TEST_FORCE_EN";
> +       default:
> +               return ": UNKNOWN";
> +       }
> +}
> +
> +static inline void cdns3_decode_set_clear_feature(u8 bRequestType, u8 bR=
equest,
> +                                                 u16 wValue, u16 wIndex,
> +                                                 char *str)
> +{
> +       switch (bRequestType & USB_RECIP_MASK) {
> +       case USB_RECIP_DEVICE:
> +               sprintf(str, "%s Device Feature(%s%s)",
> +                       bRequest =3D=3D USB_REQ_CLEAR_FEATURE ? "Clear" :=
 "Set",
> +                       cdns3_decode_device_feature(wValue),
> +                       wValue =3D=3D USB_DEVICE_TEST_MODE ?
> +                       cdns3_decode_test_mode(wIndex) : "");
> +               break;
> +       case USB_RECIP_INTERFACE:
> +               sprintf(str, "%s Interface Feature(%s)",
> +                       bRequest =3D=3D USB_REQ_CLEAR_FEATURE ? "Clear" :=
 "Set",
> +                       wIndex =3D=3D USB_INTRF_FUNC_SUSPEND ?
> +                       "Function Suspend" : "UNKNOWN");
> +               break;
> +       case USB_RECIP_ENDPOINT:
> +               sprintf(str, "%s Endpoint Feature(%s ep%d%s)",
> +                       bRequest =3D=3D USB_REQ_CLEAR_FEATURE ? "Clear" :=
 "Set",
> +                           wIndex =3D=3D USB_ENDPOINT_HALT ? "Halt" : "U=
NKNOWN",
> +                       wIndex & ~USB_DIR_IN,
> +                       wIndex & USB_DIR_IN ? "in" : "out");
> +               break;
> +       }
> +}
> +
> +static inline const char *cdns3_decode_descriptor(u16 wValue)
> +{
> +       switch (wValue >> 8) {
> +       case USB_DT_DEVICE:
> +               return "Device";
> +       case USB_DT_CONFIG:
> +               return "Configuration";
> +       case USB_DT_STRING:
> +               return "String";
> +       case USB_DT_INTERFACE:
> +               return "Interface";
> +       case USB_DT_ENDPOINT:
> +               return "Endpoint";
> +       case USB_DT_DEVICE_QUALIFIER:
> +               return "Device Qualifier";
> +       case USB_DT_OTHER_SPEED_CONFIG:
> +               return "Other Speed Config";
> +       case USB_DT_INTERFACE_POWER:
> +               return "Interface Power";
> +       case USB_DT_OTG:
> +               return "OTG";
> +       case USB_DT_DEBUG:
> +               return "Debug";
> +       case USB_DT_INTERFACE_ASSOCIATION:
> +               return "Interface Association";
> +       case USB_DT_BOS:
> +               return "BOS";
> +       case USB_DT_DEVICE_CAPABILITY:
> +               return "Device Capability";
> +       case USB_DT_SS_ENDPOINT_COMP:
> +               return "SS Endpoint Companion";
> +       case USB_DT_SSP_ISOC_ENDPOINT_COMP:
> +               return "SSP Isochronous Endpoint Companion";
> +       default:
> +               return "UNKNOWN";
> +       }
> +}
> +
> +/**
> + * cdns3_decode_ctrl - returns a string represetion of ctrl request
> + */
> +static inline const char *cdns3_decode_ctrl(char *str, u8 bRequestType,
> +                                           u8 bRequest, u16 wValue,
> +                                           u16 wIndex, u16 wLength)
> +{
> +       switch (bRequest) {
> +       case USB_REQ_GET_STATUS:
> +               cdns3_decode_get_status(bRequestType, wIndex,
> +                                       wLength, str);
> +               break;
> +       case USB_REQ_CLEAR_FEATURE:
> +       case USB_REQ_SET_FEATURE:
> +               cdns3_decode_set_clear_feature(bRequestType, bRequest,
> +                                              wValue, wIndex, str);
> +               break;
> +       case USB_REQ_SET_ADDRESS:
> +               sprintf(str, "Set Address Addr: %02x", wValue);
> +               break;
> +       case USB_REQ_GET_DESCRIPTOR:
> +               sprintf(str, "GET %s Descriptor I: %d, L: %d",
> +                       cdns3_decode_descriptor(wValue),
> +                       wValue & 0xff, wLength);
> +               break;
> +       case USB_REQ_SET_DESCRIPTOR:
> +               sprintf(str, "SET %s Descriptor I: %d, L: %d",
> +                       cdns3_decode_descriptor(wValue),
> +                       wValue & 0xff, wLength);
> +               break;
> +       case USB_REQ_GET_CONFIGURATION:
> +               sprintf(str, "Get Configuration L: %d", wLength);
> +               break;
> +       case USB_REQ_SET_CONFIGURATION:
> +               sprintf(str, "Set Configuration Config: %d ", wValue);
> +               break;
> +       case USB_REQ_GET_INTERFACE:
> +               sprintf(str, "Get Interface Intf: %d, L: %d", wIndex, wLe=
ngth);
> +               break;
> +       case USB_REQ_SET_INTERFACE:
> +               sprintf(str, "Set Interface Intf: %d, Alt: %d", wIndex, w=
Value);
> +               break;
> +       case USB_REQ_SYNCH_FRAME:
> +               sprintf(str, "Synch Frame Ep: %d, L: %d", wIndex, wLength=
);
> +               break;
> +       case USB_REQ_SET_SEL:
> +               sprintf(str, "Set SEL L: %d", wLength);
> +               break;
> +       case USB_REQ_SET_ISOCH_DELAY:
> +               sprintf(str, "Set Isochronous Delay Delay: %d ns", wValue=
);
> +               break;
> +       default:
> +               sprintf(str,
> +                       "SETUP BRT: %02x BR: %02x V: %04x I: %04x L: %04x=
\n",
> +                       bRequestType, bRequest,
> +                       wValue, wIndex, wLength);
> +       }
> +
> +       return str;
> +}
> +
> +static inline char *cdns3_decode_usb_irq(struct cdns3_device *priv_dev,
> +                                        u32 usb_ists)
> +{
> +       static char str[256];
> +       int ret;
> +
> +       ret =3D sprintf(str, "IRQ %08x =3D ", usb_ists);
> +
> +       if (usb_ists & (USB_ISTS_CON2I | USB_ISTS_CONI)) {
> +               u32 speed =3D cdns3_get_speed(priv_dev);
> +
> +               ret +=3D sprintf(str + ret, "Connection %s\n",
> +                              usb_speed_string(speed));
> +       }
> +       if (usb_ists & USB_ISTS_CON2I || usb_ists & USB_ISTS_CONI)
> +               ret +=3D sprintf(str + ret, "Disconnection ");
> +       if (usb_ists & USB_ISTS_L2ENTI)
> +               ret +=3D sprintf(str + ret, "suspended ");
> +
> +       if (usb_ists & USB_ISTS_L2EXTI)
> +               ret +=3D sprintf(str + ret, "L2 exit ");
> +       if (usb_ists & USB_ISTS_U3EXTI)
> +               ret +=3D sprintf(str + ret, "U3 exit ");
> +       if (usb_ists & USB_ISTS_UWRESI)
> +               ret +=3D sprintf(str + ret, "Warm Reset ");
> +       if (usb_ists & USB_ISTS_UHRESI)
> +               ret +=3D sprintf(str + ret, "Hot Reset ");
> +       if (usb_ists & USB_ISTS_U2RESI)
> +               ret +=3D sprintf(str + ret, "Reset");
> +
> +       return str;
> +}
> +
> +static inline  char *cdns3_decode_ep_irq(u32 ep_sts, const char *ep_name=
)
> +{
> +       static char str[256];
> +       int ret;
> +
> +       ret =3D sprintf(str, "IRQ for %s: %08x ", ep_name, ep_sts);
> +
> +       if (ep_sts & EP_STS_SETUP)
> +               ret +=3D sprintf(str + ret, "SETUP ");
> +       if (ep_sts & EP_STS_IOC)
> +               ret +=3D sprintf(str + ret, "IOC ");
> +       if (ep_sts & EP_STS_ISP)
> +               ret +=3D sprintf(str + ret, "ISP ");
> +       if (ep_sts & EP_STS_DESCMIS)
> +               ret +=3D sprintf(str + ret, "DESCMIS ");
> +       if (ep_sts & EP_STS_STREAMR)
> +               ret +=3D sprintf(str + ret, "STREAMR ");
> +       if (ep_sts & EP_STS_MD_EXIT)
> +               ret +=3D sprintf(str + ret, "MD_EXIT ");
> +       if (ep_sts & EP_STS_TRBERR)
> +               ret +=3D sprintf(str + ret, "TRBERR ");
> +       if (ep_sts & EP_STS_NRDY)
> +               ret +=3D sprintf(str + ret, "NRDY ");
> +       if (ep_sts & EP_STS_PRIME)
> +               ret +=3D sprintf(str + ret, "PRIME ");
> +       if (ep_sts & EP_STS_SIDERR)
> +               ret +=3D sprintf(str + ret, "SIDERRT ");
> +       if (ep_sts & EP_STS_OUTSMM)
> +               ret +=3D sprintf(str + ret, "OUTSMM ");
> +       if (ep_sts & EP_STS_ISOERR)
> +               ret +=3D sprintf(str + ret, "ISOERR ");
> +       if (ep_sts & EP_STS_IOT)
> +               ret +=3D sprintf(str + ret, "IOT ");
> +
> +       return str;
> +}
> +
> +static inline char *cdns3_decode_epx_irq(struct cdns3_endpoint *priv_ep)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +
> +       return cdns3_decode_ep_irq(readl(&priv_dev->regs->ep_sts),
> +                                  priv_ep->name);
> +}
> +
> +static inline char *cdns3_decode_ep0_irq(struct cdns3_device *priv_dev)
> +{
> +       if (priv_dev->ep0_data_dir)
> +               return cdns3_decode_ep_irq(readl(&priv_dev->regs->ep_sts)=
,
> +                                          "ep0IN");
> +       else
> +               return cdns3_decode_ep_irq(readl(&priv_dev->regs->ep_sts)=
,
> +                                          "ep0OUT");
> +}
> +
> +/**
> + * Debug a transfer ring.
> + *
> + * Prints out all TRBs in the endpoint ring, even those after the Link T=
RB.
> + *.
> + */
> +static inline char *cdns3_dbg_ring(struct cdns3_endpoint *priv_ep,
> +                                  int free_trbs, u8 pcs, u8 ccs,
> +                                  int enqueue, int dequeue,
> +                                  struct cdns3_trb *ring, char *str)
> +{
> +       u64 addr =3D priv_ep->trb_pool_dma;
> +       struct cdns3_trb *trb;
> +       int ret =3D 0;
> +       int i;
> +
> +       trb =3D &ring[priv_ep->dequeue];
> +       ret +=3D sprintf(str + ret, "\n\t\tRing contents for %s:", priv_e=
p->name);
> +
> +       ret +=3D sprintf(str + ret,
> +                      "\n\t\tRing deq index: %d, trb: %p (virt), 0x%llx =
(dma)\n",
> +                      dequeue, trb,
> +                      (unsigned long long)cdns3_trb_virt_to_dma(priv_ep,=
 trb));
> +
> +       trb =3D &ring[priv_ep->enqueue];
> +       ret +=3D sprintf(str + ret,
> +                      "\t\tRing enq index: %d, trb: %p (virt), 0x%llx (d=
ma)\n",
> +                      enqueue, trb,
> +                      (unsigned long long)cdns3_trb_virt_to_dma(priv_ep,=
 trb));
> +
> +       ret +=3D sprintf(str + ret,
> +                      "\t\tfree trbs: %d, CCS=3D%d, PCS=3D%d\n", free_tr=
bs, ccs,
> +                      pcs);
> +
> +       if (TRBS_PER_SEGMENT > 64) {
> +               sprintf(str + ret, "\t\tTo big transfer ring %d\n",
> +                       TRBS_PER_SEGMENT);
> +               return str;
> +       }
> +
> +       for (i =3D 0; i < TRBS_PER_SEGMENT; ++i) {
> +               trb =3D &ring[i];
> +               ret +=3D sprintf(str + ret,
> +                       "\t\t@%016llx %08x %08x %08x\n", addr,
> +                       le32_to_cpu(trb->buffer),
> +                       le32_to_cpu(trb->length),
> +                       le32_to_cpu(trb->control));
> +               addr +=3D sizeof(*trb);
> +       }
> +
> +       return str;
> +}
> +
> +#ifdef CONFIG_DEBUG_FS
> +void cdns3_debugfs_init(struct cdns3 *cdns);
> +void cdns3_debugfs_exit(struct cdns3 *cdns);
> +#else
> +void cdns3_debugfs_init(struct cdns3 *cdns);
> +{  }
> +void cdns3_debugfs_exit(struct cdns3 *cdns);
> +{  }
> +#endif
> +
> +#endif /*__LINUX_CDNS3_DEBUG*/
> diff --git a/drivers/usb/cdns3/debugfs.c b/drivers/usb/cdns3/debugfs.c
> new file mode 100644
> index 000000000000..d7919f5c1d90
> --- /dev/null
> +++ b/drivers/usb/cdns3/debugfs.c
> @@ -0,0 +1,168 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Controller DebugFS filer.
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#include <linux/types.h>
> +#include <linux/debugfs.h>
> +#include <linux/seq_file.h>
> +#include <linux/uaccess.h>
> +
> +#include "core.h"
> +#include "gadget.h"
> +#include "drd.h"
> +
> +static int cdns3_mode_show(struct seq_file *s, void *unused)
> +{
> +       struct cdns3 *cdns =3D s->private;
> +
> +       switch (cdns->current_dr_mode) {
> +       case USB_DR_MODE_HOST:
> +               seq_puts(s, "host\n");
> +               break;
> +       case USB_DR_MODE_PERIPHERAL:
> +               seq_puts(s, "device\n");
> +               break;
> +       case USB_DR_MODE_OTG:
> +               seq_puts(s, "otg\n");
> +               break;
> +       default:
> +               seq_puts(s, "UNKNOWN mode\n");
> +       }
> +
> +       return 0;
> +}
> +
> +static int cdns3_mode_open(struct inode *inode, struct file *file)
> +{
> +       return single_open(file, cdns3_mode_show, inode->i_private);
> +}
> +
> +static ssize_t cdns3_mode_write(struct file *file,
> +                               const char __user *ubuf,
> +                               size_t count, loff_t *ppos)
> +{
> +       struct seq_file  *s =3D file->private_data;
> +       struct cdns3 *cdns =3D s->private;
> +       u32 mode =3D USB_DR_MODE_UNKNOWN;
> +       char buf[32];
> +
> +       if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, cou=
nt)))
> +               return -EFAULT;
> +
> +       if (!strncmp(buf, "host", 4)) {
> +               if (cdns->dr_mode =3D=3D USB_DR_MODE_HOST ||
> +                   cdns->dr_mode =3D=3D USB_DR_MODE_OTG) {
> +                       mode =3D USB_DR_MODE_HOST;
> +               }
> +       }
> +
> +       if (!strncmp(buf, "device", 6))
> +               if (cdns->dr_mode =3D=3D USB_DR_MODE_PERIPHERAL ||
> +                   cdns->dr_mode =3D=3D USB_DR_MODE_OTG)
> +                       mode =3D USB_DR_MODE_PERIPHERAL;
> +
> +       if (!strncmp(buf, "otg", 3) && cdns->dr_mode =3D=3D USB_DR_MODE_O=
TG)
> +               mode =3D USB_DR_MODE_OTG;
> +
> +       if (mode =3D=3D USB_DR_MODE_UNKNOWN) {
> +               dev_err(cdns->dev, "Failed: incorrect mode setting\n");
> +               return -EFAULT;
> +       }
> +
> +       if (cdns->current_dr_mode !=3D mode) {
> +               cdns->desired_dr_mode =3D mode;
> +               cdns->debug_disable =3D 0;
> +               cdns3_role_stop(cdns);
> +               cdns3_drd_update_mode(cdns);
> +               queue_work(system_freezable_wq, &cdns->role_switch_wq);
> +       }
> +
> +       return count;
> +}
> +
> +static const struct file_operations cdns3_mode_fops =3D {
> +       .open                   =3D cdns3_mode_open,
> +       .write                  =3D cdns3_mode_write,
> +       .read                   =3D seq_read,
> +       .llseek                 =3D seq_lseek,
> +       .release                =3D single_release,
> +};
> +
> +static int cdns3_disable_show(struct seq_file *s, void *unused)
> +{
> +       struct cdns3 *cdns =3D s->private;
> +
> +       if (!cdns->debug_disable)
> +               seq_puts(s, "0\n");
> +       else
> +               seq_puts(s, "1\n");
> +
> +       return 0;
> +}
> +
> +static ssize_t cdns3_disable_write(struct file *file,
> +                                  const char __user *ubuf,
> +                                  size_t count, loff_t *ppos)
> +{
> +       struct seq_file  *s =3D file->private_data;
> +       struct cdns3 *cdns =3D s->private;
> +       int disable;
> +       char buf[32];
> +
> +       if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, cou=
nt)))
> +               return -EFAULT;
> +
> +       if (!strncmp(buf, "1", 1) || !strncmp(buf, "yes", 3)) {
> +               disable =3D 1;
> +       } else if (!strncmp(buf, "0", 1) || !strncmp(buf, "no", 2)) {
> +               disable =3D 0;
> +       } else {
> +               dev_err(cdns->dev, "Failed: incorrect disable setting\n")=
;
> +               return -EFAULT;
> +       }
> +
> +       if (disable !=3D cdns->debug_disable) {
> +               cdns->debug_disable =3D disable;
> +               queue_work(system_freezable_wq, &cdns->role_switch_wq);
> +       }
> +
> +       return count;
> +}
> +
> +static int cdns3_disable_open(struct inode *inode, struct file *file)
> +{
> +       return single_open(file, cdns3_disable_show, inode->i_private);
> +}
> +
> +static const struct file_operations cdns3_disable_fops =3D {
> +       .open                   =3D cdns3_disable_open,
> +       .write                  =3D cdns3_disable_write,
> +       .read                   =3D seq_read,
> +       .llseek                 =3D seq_lseek,
> +       .release                =3D single_release,
> +};
> +
> +void cdns3_debugfs_init(struct cdns3 *cdns)
> +{
> +       struct dentry *root;
> +
> +       root =3D debugfs_create_dir(dev_name(cdns->dev), NULL);
> +       cdns->root =3D root;
> +       if (IS_ENABLED(CONFIG_USB_CDNS3_GADGET) &&
> +           IS_ENABLED(CONFIG_USB_CDNS3_HOST))
> +               debugfs_create_file("mode", 0644, root, cdns,
> +                                   &cdns3_mode_fops);
> +
> +       debugfs_create_file("disable", 0644, root, cdns,
> +                           &cdns3_disable_fops);
> +}
> +
> +void cdns3_debugfs_exit(struct cdns3 *cdns)
> +{
> +       debugfs_remove_recursive(cdns->root);
> +}
> diff --git a/drivers/usb/cdns3/drd.c b/drivers/usb/cdns3/drd.c
> new file mode 100644
> index 000000000000..45573427ba83
> --- /dev/null
> +++ b/drivers/usb/cdns3/drd.c
> @@ -0,0 +1,315 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Driver.
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com
> + *
> + */
> +#include <linux/kernel.h>
> +#include <linux/interrupt.h>
> +#include <linux/delay.h>
> +#include <linux/usb/otg.h>
> +
> +#include "gadget.h"
> +#include "drd.h"
> +#include "core.h"
> +
> +static int cdns3_drd_switch_gadget(struct cdns3 *cdns, int on);
> +static int cdns3_drd_switch_host(struct cdns3 *cdns, int on);
> +
> +/**
> + * cdns3_set_mode - change mode of OTG Core
> + * @cdns: pointer to context structure
> + * @mode: selected mode from cdns_role
> + */
> +void cdns3_set_mode(struct cdns3 *cdns, enum usb_dr_mode mode)
> +{
> +       u32 reg;
> +
> +       cdns->current_dr_mode =3D mode;
> +
> +       switch (mode) {
> +       case USB_DR_MODE_PERIPHERAL:
> +               dev_info(cdns->dev, "Set controller to Gadget mode\n");
> +               cdns3_drd_switch_gadget(cdns, 1);
> +               break;
> +       case USB_DR_MODE_HOST:
> +               dev_info(cdns->dev, "Set controller to Host mode\n");
> +               cdns3_drd_switch_host(cdns, 1);
> +               break;
> +       case USB_DR_MODE_OTG:
> +               dev_info(cdns->dev, "Set controller to OTG mode\n");
> +               reg =3D readl(&cdns->otg_regs->override);
> +               reg |=3D OVERRIDE_IDPULLUP;
> +               writel(reg, &cdns->otg_regs->override);
> +
> +               /*
> +                * Hardware specification says: "ID_VALUE must be valid w=
ithin
> +                * 50ms after idpullup is set to '1" so driver must wait
> +                * 50ms before reading this pin.
> +                */
> +               usleep_range(50000, 60000);
> +               break;
> +       default:
> +               cdns->current_dr_mode =3D USB_DR_MODE_UNKNOWN;
> +               dev_err(cdns->dev, "Unsupported mode of operation %d\n", =
mode);
> +               return;
> +       }
> +}
> +
> +int cdns3_get_id(struct cdns3 *cdns)
> +{
> +       int id;
> +
> +       id =3D readl(&cdns->otg_regs->sts) & OTGSTS_ID_VALUE;
> +       dev_dbg(cdns->dev, "OTG ID: %d", id);
> +       return  id;
> +}
> +
> +int cdns3_is_host(struct cdns3 *cdns)
> +{
> +       if (cdns->current_dr_mode =3D=3D USB_DR_MODE_HOST)
> +               return 1;
> +       else if (!cdns3_get_id(cdns))
> +               return 1;
> +
> +       return 0;
> +}
> +
> +int cdns3_is_device(struct cdns3 *cdns)
> +{
> +       if (cdns->current_dr_mode =3D=3D USB_DR_MODE_PERIPHERAL)
> +               return 1;
> +       else if (cdns->current_dr_mode =3D=3D USB_DR_MODE_OTG)
> +               if (cdns3_get_id(cdns))
> +                       return 1;
> +
> +       return 0;
> +}
> +
> +/**
> + * cdns3_otg_disable_irq - Disable all OTG interrupts
> + * @cdns: Pointer to controller context structure
> + */
> +static void cdns3_otg_disable_irq(struct cdns3 *cdns)
> +{
> +       writel(0, &cdns->otg_regs->ien);
> +}
> +
> +/**
> + * cdns3_otg_enable_irq - enable id and sess_valid interrupts
> + * @cdns: Pointer to controller context structure
> + */
> +static void cdns3_otg_enable_irq(struct cdns3 *cdns)
> +{
> +       writel(OTGIEN_ID_CHANGE_INT | OTGIEN_VBUSVALID_RISE_INT |
> +              OTGIEN_VBUSVALID_FALL_INT, &cdns->otg_regs->ien);
> +}
> +
> +/**
> + * cdns3_drd_switch_host - start/stop host
> + * @cdns: Pointer to controller context structure
> + * @on: 1 for start, 0 for stop
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_drd_switch_host(struct cdns3 *cdns, int on)
> +{
> +       int ret;
> +       u32 reg =3D OTGCMD_OTG_DIS;
> +
> +       /* switch OTG core */
> +       if (on) {
> +               writel(OTGCMD_HOST_BUS_REQ | reg, &cdns->otg_regs->cmd);
> +
> +               dev_dbg(cdns->dev, "Waiting for Host mode is turned on\n"=
);
> +               ret =3D cdns3_handshake(&cdns->otg_regs->sts, OTGSTS_XHCI=
_READY,
> +                                     OTGSTS_XHCI_READY, 100000);
> +
> +               if (ret)
> +                       return ret;
> +       } else {
> +               usleep_range(30, 40);
> +               writel(OTGCMD_HOST_BUS_DROP | OTGCMD_DEV_BUS_DROP |
> +                      OTGCMD_DEV_POWER_OFF | OTGCMD_HOST_POWER_OFF,
> +                      &cdns->otg_regs->cmd);
> +       }
> +
> +       return 0;
> +}
> +
> +/**
> + * cdns3_drd_switch_gadget - start/stop gadget
> + * @cdns: Pointer to controller context structure
> + * @on: 1 for start, 0 for stop
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static int cdns3_drd_switch_gadget(struct cdns3 *cdns, int on)
> +{
> +       int ret;
> +       u32 reg =3D OTGCMD_OTG_DIS;
> +
> +       /* switch OTG core */
> +       if (on) {
> +               writel(OTGCMD_DEV_BUS_REQ | reg, &cdns->otg_regs->cmd);
> +
> +               dev_dbg(cdns->dev, "Waiting for Device mode is turned on\=
n");
> +
> +               ret =3D cdns3_handshake(&cdns->otg_regs->sts, OTGSTS_DEV_=
READY,
> +                                     OTGSTS_DEV_READY, 100000);
> +
> +               if (ret)
> +                       return ret;
> +       } else {
> +               /*
> +                * driver should wait at least 10us after disabling Devic=
e
> +                * before turning-off Device (DEV_BUS_DROP)
> +                */
> +               usleep_range(20, 30);
> +               writel(OTGCMD_HOST_BUS_DROP | OTGCMD_DEV_BUS_DROP |
> +                      OTGCMD_DEV_POWER_OFF | OTGCMD_HOST_POWER_OFF,
> +                      &cdns->otg_regs->cmd);
> +       }
> +
> +       return 0;
> +}
> +
> +/**
> + * cdns3_init_otg_mode - initialize drd controller
> + * @cdns: Pointer to controller context structure
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +static void cdns3_init_otg_mode(struct cdns3 *cdns)
> +{
> +       cdns3_otg_disable_irq(cdns);
> +       /* clear all interrupts */
> +       writel(~0, &cdns->otg_regs->ivect);
> +
> +       cdns3_set_mode(cdns, USB_DR_MODE_OTG);
> +
> +       if (cdns3_is_host(cdns))
> +               cdns3_drd_switch_host(cdns, 1);
> +       else
> +               cdns3_drd_switch_gadget(cdns, 1);
> +
> +       cdns3_otg_enable_irq(cdns);
> +}
> +
> +/**
> + * cdns3_drd_update_mode - initialize mode of operation
> + * @cdns: Pointer to controller context structure
> + *
> + * Returns 0 on success otherwise negative errno
> + */
> +int cdns3_drd_update_mode(struct cdns3 *cdns)
> +{
> +       int ret =3D 0;
> +
> +       if (cdns->desired_dr_mode =3D=3D cdns->current_dr_mode)
> +               return ret;
> +
> +       cdns3_drd_switch_gadget(cdns, 0);
> +       cdns3_drd_switch_host(cdns, 0);
> +
> +       switch (cdns->desired_dr_mode) {
> +       case USB_DR_MODE_PERIPHERAL:
> +               cdns3_set_mode(cdns, USB_DR_MODE_PERIPHERAL);
> +               break;
> +       case USB_DR_MODE_HOST:
> +               cdns3_set_mode(cdns, USB_DR_MODE_HOST);
> +               break;
> +       case USB_DR_MODE_OTG:
> +               cdns3_init_otg_mode(cdns);
> +               break;
> +       default:
> +               dev_err(cdns->dev, "Unsupported mode of operation %d\n",
> +                       cdns->dr_mode);
> +               return -EINVAL;
> +       }
> +
> +       return ret;
> +}
> +
> +/**
> + * cdns3_drd_irq - interrupt handler for OTG events
> + *
> + * @irq: irq number for cdns3 core device
> + * @data: structure of cdns3
> + *
> + * Returns IRQ_HANDLED or IRQ_NONE
> + */
> +static irqreturn_t cdns3_drd_irq(int irq, void *data)
> +{
> +       irqreturn_t ret =3D IRQ_NONE;
> +       struct cdns3 *cdns =3D data;
> +       u32 reg;
> +
> +       if (cdns->dr_mode !=3D USB_DR_MODE_OTG)
> +               return ret;
> +
> +       reg =3D readl(&cdns->otg_regs->ivect);
> +       if (!reg)
> +               return ret;
> +
> +       if (reg & OTGIEN_ID_CHANGE_INT) {
> +               dev_dbg(cdns->dev, "OTG IRQ: new ID: %d\n",
> +                       cdns3_get_id(cdns));
> +
> +               queue_work(system_freezable_wq, &cdns->role_switch_wq);
> +
> +               ret =3D IRQ_HANDLED;
> +       }
> +
> +       writel(~0, &cdns->otg_regs->ivect);
> +       return ret;
> +}
> +
> +int cdns3_drd_init(struct cdns3 *cdns)
> +{
> +       int ret =3D 0;
> +       u32 state;
> +
> +       state =3D OTGSTS_STRAP(readl(&cdns->otg_regs->sts));
> +
> +       /* Update dr_mode according to STRAP configuration. */
> +       cdns->dr_mode =3D USB_DR_MODE_OTG;
> +       if (state =3D=3D OTGSTS_STRAP_HOST) {
> +               dev_info(cdns->dev, "Controller strapped to HOST\n");
> +               cdns->dr_mode =3D USB_DR_MODE_HOST;
> +       } else if (state =3D=3D OTGSTS_STRAP_GADGET) {
> +               dev_info(cdns->dev, "Controller strapped to PERIPHERAL\n"=
);
> +               cdns->dr_mode =3D USB_DR_MODE_PERIPHERAL;
> +       }
> +
> +       cdns->desired_dr_mode =3D cdns->dr_mode;
> +       cdns->current_dr_mode =3D USB_DR_MODE_UNKNOWN;
> +
> +       ret =3D devm_request_irq(cdns->dev, cdns->irq, cdns3_drd_irq, IRQ=
F_SHARED,
> +                              dev_name(cdns->dev), cdns);
> +
> +       if (ret)
> +               return ret;
> +
> +       state =3D readl(&cdns->otg_regs->sts);
> +       if (OTGSTS_OTG_NRDY(state) !=3D 0) {
> +               dev_err(cdns->dev, "Cadence USB3 OTG device not ready\n")=
;
> +               return -ENODEV;
> +       }
> +
> +       ret =3D cdns3_drd_update_mode(cdns);
> +
> +       dev_info(cdns->dev, "Controller Device ID: %08lx, Revision ID: %0=
8lx\n",
> +                CDNS_RID(readl(&cdns->otg_regs->rid)),
> +                CDNS_DID(readl(&cdns->otg_regs->did)));
> +
> +       return ret;
> +}
> +
> +int cdns3_drd_exit(struct cdns3 *cdns)
> +{
> +       return cdns3_drd_switch_host(cdns, 0);
> +}
> diff --git a/drivers/usb/cdns3/drd.h b/drivers/usb/cdns3/drd.h
> new file mode 100644
> index 000000000000..4159e6e612ac
> --- /dev/null
> +++ b/drivers/usb/cdns3/drd.h
> @@ -0,0 +1,129 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * Cadence USB3 DRD header file.
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + */
> +#ifndef __LINUX_CDNS3_DRD
> +#define __LINUX_CDNS3_DRD
> +
> +#include <linux/usb/otg.h>
> +#include <linux/phy/phy.h>
> +#include "core.h"
> +
> +/*  DRD register interface. */
> +struct cdns3_otg_regs {
> +       __le32 did;
> +       __le32 rid;
> +       __le32 capabilities;
> +       __le32 reserved1;
> +       __le32 cmd;
> +       __le32 sts;
> +       __le32 state;
> +       __le32 reserved2;
> +       __le32 ien;
> +       __le32 ivect;
> +       __le32 refclk;
> +       __le32 tmr;
> +       __le32 reserved3[4];
> +       __le32 simulate;
> +       __le32 override;
> +       __le32 susp_ctrl;
> +       __le32 reserved4;
> +       __le32 anasts;
> +       __le32 adp_ramp_time;
> +       __le32 ctrl1;
> +       __le32 ctrl2;
> +};
> +
> +/* CDNS_RID - bitmasks */
> +#define CDNS_RID(p)                    ((p) & GENMASK(15, 0))
> +
> +/* CDNS_VID - bitmasks */
> +#define CDNS_DID(p)                    ((p) & GENMASK(31, 0))
> +
> +/* OTGCMD - bitmasks */
> +/* "Request the bus for Device mode. */
> +#define OTGCMD_DEV_BUS_REQ             BIT(0)
> +/* Request the bus for Host mode */
> +#define OTGCMD_HOST_BUS_REQ            BIT(1)
> +/* Enable OTG mode. */
> +#define OTGCMD_OTG_EN                  BIT(2)
> +/* Disable OTG mode */
> +#define OTGCMD_OTG_DIS                 BIT(3)
> +/*"Configure OTG as A-Device. */
> +#define OTGCMD_A_DEV_EN                        BIT(4)
> +/*"Configure OTG as A-Device. */
> +#define OTGCMD_A_DEV_DIS               BIT(5)
> +/* Drop the bus for Device mod e. */
> +#define OTGCMD_DEV_BUS_DROP            BIT(8)
> +/* Drop the bus for Host mode*/
> +#define OTGCMD_HOST_BUS_DROP           BIT(9)
> +/* Power Down USBSS-DEV. */
> +#define OTGCMD_DEV_POWER_OFF           BIT(11)
> +/* Power Down CDNSXHCI. */
> +#define OTGCMD_HOST_POWER_OFF          BIT(12)
> +
> +/* OTGIEN - bitmasks */
> +/* ID change interrupt enable */
> +#define OTGIEN_ID_CHANGE_INT           BIT(0)
> +/* Vbusvalid fall detected interrupt enable.*/
> +#define OTGIEN_VBUSVALID_RISE_INT      BIT(4)
> +/* Vbusvalid fall detected interrupt enable */
> +#define OTGIEN_VBUSVALID_FALL_INT      BIT(5)
> +
> +/* OTGSTS - bitmasks */
> +/*
> + * Current value of the ID pin. It is only valid when idpullup in
> + *  OTGCTRL1_TYPE register is set to '1'.
> + */
> +#define OTGSTS_ID_VALUE                        BIT(0)
> +/* Current value of the vbus_valid */
> +#define OTGSTS_VBUS_VALID              BIT(1)
> +/* Current value of the b_sess_vld */
> +#define OTGSTS_SESSION_VALID           BIT(2)
> +/*Device mode is active*/
> +#define OTGSTS_DEV_ACTIVE              BIT(3)
> +/* Host mode is active. */
> +#define OTGSTS_HOST_ACTIVE             BIT(4)
> +/* OTG Controller not ready. */
> +#define OTGSTS_OTG_NRDY_MASK           BIT(11)
> +#define OTGSTS_OTG_NRDY(p)             ((p) & OTGSTS_OTG_NRDY_MASK)
> +/*
> + * Value of the strap pins.
> + * 000 - no default configuration
> + * 010 - Controller initiall configured as Host
> + * 100 - Controller initially configured as Device
> + */
> +#define OTGSTS_STRAP(p)                        (((p) & GENMASK(14, 12)) =
>> 12)
> +#define OTGSTS_STRAP_NO_DEFAULT_CFG    0x00
> +#define OTGSTS_STRAP_HOST_OTG          0x01
> +#define OTGSTS_STRAP_HOST              0x02
> +#define OTGSTS_STRAP_GADGET            0x04
> +/* Host mode is turned on. */
> +#define OTGSTS_XHCI_READY              BIT(26)
> +/* "Device mode is turned on .*/
> +#define OTGSTS_DEV_READY               BIT(27)
> +
> +/* OTGSTATE- bitmasks */
> +#define OTGSTATE_HOST_STATE_MASK       GENMASK(5, 3)
> +#define OTGSTATE_HOST_STATE_IDLE       0x0
> +#define OTGSTATE_HOST_STATE_VBUS_FALL   0x7
> +#define OTGSTATE_HOST_STATE(p)         (((p) & OTGSTATE_HOST_STATE_MASK)=
 >> 3)
> +
> +/* OTGREFCLK - bitmasks */
> +#define OTGREFCLK_STB_CLK_SWITCH_EN    BIT(31)
> +
> +/* OVERRIDE - bitmasks */
> +#define OVERRIDE_IDPULLUP              BIT(0)
> +
> +int cdns3_is_host(struct cdns3 *cdns);
> +int cdns3_is_device(struct cdns3 *cdns);
> +int cdns3_get_id(struct cdns3 *cdns);
> +int cdns3_drd_init(struct cdns3 *cdns);
> +int cdns3_drd_exit(struct cdns3 *cdns);
> +int cdns3_drd_update_mode(struct cdns3 *cdns);
> +
> +#endif /* __LINUX_CDNS3_DRD */
> diff --git a/drivers/usb/cdns3/ep0.c b/drivers/usb/cdns3/ep0.c
> new file mode 100644
> index 000000000000..1ef0e9f73e3e
> --- /dev/null
> +++ b/drivers/usb/cdns3/ep0.c
> @@ -0,0 +1,864 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Driver - gadget side.
> + *
> + * Copyright (C) 2018 Cadence Design Systems.
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Authors: Pawel Jez <pjez@cadence.com>,
> + *          Pawel Laszczak <pawell@cadence.com>
> + *         Peter Chen <peter.chen@nxp.com>
> + */
> +
> +#include <linux/usb/composite.h>
> +
> +#include "gadget.h"
> +#include "trace.h"
> +
> +static struct usb_endpoint_descriptor cdns3_gadget_ep0_desc =3D {
> +       .bLength =3D USB_DT_ENDPOINT_SIZE,
> +       .bDescriptorType =3D USB_DT_ENDPOINT,
> +       .bmAttributes =3D USB_ENDPOINT_XFER_CONTROL,
> +};
> +
> +/**
> + * cdns3_ep0_run_transfer - Do transfer on default endpoint hardware
> + * @priv_dev: extended gadget object
> + * @dma_addr: physical address where data is/will be stored
> + * @length: data length
> + * @erdy: set it to 1 when ERDY packet should be sent -
> + *        exit from flow control state
> + */
> +static void cdns3_ep0_run_transfer(struct cdns3_device *priv_dev,
> +                                  dma_addr_t dma_addr,
> +                                  unsigned int length, int erdy)
> +{
> +       struct cdns3_usb_regs __iomem *regs =3D priv_dev->regs;
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(priv_dev->gadge=
t.ep0);
> +
> +       priv_dev->ep0_trb->buffer =3D TRB_BUFFER(dma_addr);
> +       priv_dev->ep0_trb->length =3D TRB_LEN(length);
> +       priv_dev->ep0_trb->control =3D TRB_CYCLE | TRB_IOC | TRB_TYPE(TRB=
_NORMAL);
> +
> +       trace_cdns3_prepare_trb(priv_ep, priv_dev->ep0_trb);
> +
> +       cdns3_select_ep(priv_dev, priv_dev->ep0_data_dir);
> +
> +       writel(EP_STS_TRBERR, &regs->ep_sts);
> +       writel(EP_TRADDR_TRADDR(priv_dev->ep0_trb_dma), &regs->ep_traddr)=
;
> +       trace_cdns3_doorbell_ep0(priv_dev->ep0_data_dir ? "ep0in" : "ep0o=
ut");
> +
> +       /* TRB should be prepared before starting transfer */
> +       writel(EP_CMD_DRDY, &regs->ep_cmd);
> +
> +       if (erdy)
> +               writel(EP_CMD_ERDY, &priv_dev->regs->ep_cmd);
> +}
> +
> +/**
> + * cdns3_ep0_delegate_req - Returns status of handling setup packet
> + * Setup is handled by gadget driver
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns zero on success or negative value on failure
> + */
> +static int cdns3_ep0_delegate_req(struct cdns3_device *priv_dev,
> +                                 struct usb_ctrlrequest *ctrl_req)
> +{
> +       int ret;
> +
> +       spin_unlock(&priv_dev->lock);
> +       priv_dev->setup_pending =3D 1;
> +       ret =3D priv_dev->gadget_driver->setup(&priv_dev->gadget, ctrl_re=
q);
> +       priv_dev->setup_pending =3D 0;
> +       spin_lock(&priv_dev->lock);
> +       return ret;
> +}
> +
> +static void cdns3_prepare_setup_packet(struct cdns3_device *priv_dev)
> +{
> +       priv_dev->ep0_data_dir =3D 0;
> +       cdns3_ep0_run_transfer(priv_dev, priv_dev->setup_dma,
> +                              sizeof(struct usb_ctrlrequest), 0);
> +}
> +
> +/**
> + * cdns3_req_ep0_set_configuration - Handling of SET_CONFIG standard USB=
 request
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns 0 if success, USB_GADGET_DELAYED_STATUS on deferred status st=
age,
> + * error code on error
> + */
> +static int cdns3_req_ep0_set_configuration(struct cdns3_device *priv_dev=
,
> +                                          struct usb_ctrlrequest *ctrl_r=
eq)
> +{
> +       enum usb_device_state device_state =3D priv_dev->gadget.state;
> +       struct cdns3_endpoint *priv_ep;
> +       u32 config =3D le16_to_cpu(ctrl_req->wValue);
> +       int result =3D 0;
> +       int i;
> +
> +       switch (device_state) {
> +       case USB_STATE_ADDRESS:
> +               /* Configure non-control EPs */
> +               for (i =3D 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++) {
> +                       priv_ep =3D priv_dev->eps[i];
> +                       if (!priv_ep)
> +                               continue;
> +
> +                       if (priv_ep->flags & EP_CLAIMED)
> +                               cdns3_ep_config(priv_ep);
> +               }
> +
> +               result =3D cdns3_ep0_delegate_req(priv_dev, ctrl_req);
> +
> +               if (result)
> +                       return result;
> +
> +               if (config) {
> +                       cdns3_set_hw_configuration(priv_dev);
> +               } else {
> +                       cdns3_gadget_unconfig(priv_dev);
> +                       usb_gadget_set_state(&priv_dev->gadget,
> +                                            USB_STATE_ADDRESS);
> +               }
> +               break;
> +       case USB_STATE_CONFIGURED:
> +               result =3D cdns3_ep0_delegate_req(priv_dev, ctrl_req);
> +
> +               if (!config && !result) {
> +                       cdns3_gadget_unconfig(priv_dev);
> +                       usb_gadget_set_state(&priv_dev->gadget,
> +                                            USB_STATE_ADDRESS);
> +               }
> +               break;
> +       default:
> +               result =3D -EINVAL;
> +       }
> +
> +       return result;
> +}
> +
> +/**
> + * cdns3_req_ep0_set_address - Handling of SET_ADDRESS standard USB requ=
est
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns 0 if success, error code on error
> + */
> +static int cdns3_req_ep0_set_address(struct cdns3_device *priv_dev,
> +                                    struct usb_ctrlrequest *ctrl_req)
> +{
> +       enum usb_device_state device_state =3D priv_dev->gadget.state;
> +       u32 reg;
> +       u32 addr;
> +
> +       addr =3D le16_to_cpu(ctrl_req->wValue);
> +
> +       if (addr > USB_DEVICE_MAX_ADDRESS) {
> +               dev_err(priv_dev->dev,
> +                       "Device address (%d) cannot be greater than %d\n"=
,
> +                       addr, USB_DEVICE_MAX_ADDRESS);
> +               return -EINVAL;
> +       }
> +
> +       if (device_state =3D=3D USB_STATE_CONFIGURED) {
> +               dev_err(priv_dev->dev,
> +                       "can't set_address from configured state\n");
> +               return -EINVAL;
> +       }
> +
> +       reg =3D readl(&priv_dev->regs->usb_cmd);
> +
> +       writel(reg | USB_CMD_FADDR(addr) | USB_CMD_SET_ADDR,
> +              &priv_dev->regs->usb_cmd);
> +
> +       usb_gadget_set_state(&priv_dev->gadget,
> +                            (addr ? USB_STATE_ADDRESS : USB_STATE_DEFAUL=
T));
> +
> +       cdns3_prepare_setup_packet(priv_dev);
> +
> +       writel(EP_CMD_ERDY | EP_CMD_REQ_CMPL, &priv_dev->regs->ep_cmd);
> +
> +       return 0;
> +}
> +
> +/**
> + * cdns3_req_ep0_get_status - Handling of GET_STATUS standard USB reques=
t
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns 0 if success, error code on error
> + */
> +static int cdns3_req_ep0_get_status(struct cdns3_device *priv_dev,
> +                                   struct usb_ctrlrequest *ctrl)
> +{
> +       __le16 *response_pkt;
> +       u16 usb_status =3D 0;
> +       u32 recip;
> +       u32 reg;
> +
> +       recip =3D ctrl->bRequestType & USB_RECIP_MASK;
> +
> +       switch (recip) {
> +       case USB_RECIP_DEVICE:
> +               /* self powered */
> +               if (priv_dev->is_selfpowered)
> +                       usb_status =3D BIT(USB_DEVICE_SELF_POWERED);
> +
> +               if (priv_dev->wake_up_flag)
> +                       usb_status |=3D BIT(USB_DEVICE_REMOTE_WAKEUP);
> +
> +               if (priv_dev->gadget.speed !=3D USB_SPEED_SUPER)
> +                       break;
> +
> +               reg =3D readl(&priv_dev->regs->usb_sts);
> +
> +               if (priv_dev->u1_allowed)
> +                       usb_status |=3D BIT(USB_DEV_STAT_U1_ENABLED);
> +
> +               if (priv_dev->u2_allowed)
> +                       usb_status |=3D BIT(USB_DEV_STAT_U2_ENABLED);
> +
> +               break;
> +       case USB_RECIP_INTERFACE:
> +               return cdns3_ep0_delegate_req(priv_dev, ctrl);
> +       case USB_RECIP_ENDPOINT:
> +               /* check if endpoint is stalled */
> +               cdns3_select_ep(priv_dev, ctrl->wIndex);
> +               if (EP_STS_STALL(readl(&priv_dev->regs->ep_sts)))
> +                       usb_status =3D  BIT(USB_ENDPOINT_HALT);
> +               break;
> +       default:
> +               return -EINVAL;
> +       }
> +
> +       response_pkt =3D (__le16 *)priv_dev->setup_buf;
> +       *response_pkt =3D cpu_to_le16(usb_status);
> +
> +       cdns3_ep0_run_transfer(priv_dev, priv_dev->setup_dma,
> +                              sizeof(*response_pkt), 1);
> +       return 0;
> +}
> +
> +static int cdns3_ep0_feature_handle_device(struct cdns3_device *priv_dev=
,
> +                                          struct usb_ctrlrequest *ctrl,
> +                                          int set)
> +{
> +       enum usb_device_state state;
> +       enum usb_device_speed speed;
> +       int ret =3D 0;
> +       u32 wValue;
> +       u32 wIndex;
> +       u16 tmode;
> +
> +       wValue =3D le16_to_cpu(ctrl->wValue);
> +       wIndex =3D le16_to_cpu(ctrl->wIndex);
> +       state =3D priv_dev->gadget.state;
> +       speed =3D priv_dev->gadget.speed;
> +
> +       switch (ctrl->wValue) {
> +       case USB_DEVICE_REMOTE_WAKEUP:
> +               priv_dev->wake_up_flag =3D !!set;
> +               break;
> +       case USB_DEVICE_U1_ENABLE:
> +               if (state !=3D USB_STATE_CONFIGURED || speed !=3D USB_SPE=
ED_SUPER)
> +                       return -EINVAL;
> +
> +               priv_dev->u1_allowed =3D !!set;
> +               break;
> +       case USB_DEVICE_U2_ENABLE:
> +               if (state !=3D USB_STATE_CONFIGURED || speed !=3D USB_SPE=
ED_SUPER)
> +                       return -EINVAL;
> +
> +               priv_dev->u2_allowed =3D !!set;
> +               break;
> +       case USB_DEVICE_LTM_ENABLE:
> +               ret =3D -EINVAL;
> +               break;
> +       case USB_DEVICE_TEST_MODE:
> +               if (state !=3D USB_STATE_CONFIGURED || speed > USB_SPEED_=
HIGH)
> +                       return -EINVAL;
> +
> +               tmode =3D le16_to_cpu(ctrl->wIndex);
> +
> +               if (!set || (tmode & 0xff) !=3D 0)
> +                       return -EINVAL;
> +
> +               switch (tmode >> 8) {
> +               case TEST_J:
> +               case TEST_K:
> +               case TEST_SE0_NAK:
> +               case TEST_PACKET:
> +                       cdns3_set_register_bit(&priv_dev->regs->usb_cmd,
> +                                              USB_CMD_STMODE |
> +                                              USB_STS_TMODE_SEL(tmode - =
1));
> +                       break;
> +               default:
> +                       ret =3D -EINVAL;
> +               }
> +               break;
> +       default:
> +               ret =3D -EINVAL;
> +       }
> +
> +       return ret;
> +}
> +
> +static int cdns3_ep0_feature_handle_intf(struct cdns3_device *priv_dev,
> +                                        struct usb_ctrlrequest *ctrl,
> +                                        int set)
> +{
> +       u32 wValue;
> +       int ret =3D 0;
> +
> +       wValue =3D le16_to_cpu(ctrl->wValue);
> +
> +       switch (wValue) {
> +       case USB_INTRF_FUNC_SUSPEND:
> +               break;
> +       default:
> +               ret =3D -EINVAL;
> +       }
> +
> +       return ret;
> +}
> +
> +static int cdns3_ep0_feature_handle_endpoint(struct cdns3_device *priv_d=
ev,
> +                                            struct usb_ctrlrequest *ctrl=
,
> +                                            int set)
> +{
> +       struct cdns3_endpoint *priv_ep;
> +       int ret =3D 0;
> +       u8 index;
> +
> +       if (le16_to_cpu(ctrl->wValue) !=3D USB_ENDPOINT_HALT)
> +               return -EINVAL;
> +
> +       if (!(ctrl->wIndex & ~USB_DIR_IN))
> +               return 0;
> +
> +       index =3D cdns3_ep_addr_to_index(ctrl->wIndex);
> +       priv_ep =3D priv_dev->eps[index];
> +
> +       cdns3_select_ep(priv_dev, ctrl->wIndex);
> +
> +       if (set) {
> +               writel(EP_CMD_SSTALL, &priv_dev->regs->ep_cmd);
> +               priv_ep->flags |=3D EP_STALL;
> +       } else {
> +               struct usb_request *request;
> +
> +               if (priv_dev->eps[index]->flags & EP_WEDGE) {
> +                       cdns3_select_ep(priv_dev, 0x00);
> +                       return 0;
> +               }
> +
> +               writel(EP_CMD_CSTALL | EP_CMD_EPRST, &priv_dev->regs->ep_=
cmd);
> +
> +               /* wait for EPRST cleared */
> +               ret =3D cdns3_handshake(&priv_dev->regs->ep_cmd,
> +                                     EP_CMD_EPRST, 0, 100);
> +               if (ret)
> +                       return -EINVAL;
> +
> +               priv_ep->flags &=3D ~EP_STALL;
> +
> +               request =3D cdns3_next_request(&priv_ep->request_list);
> +               if (request)
> +                       cdns3_ep_run_transfer(priv_ep, request);
> +       }
> +       return ret;
> +}
> +
> +/**
> + * cdns3_req_ep0_handle_feature -
> + * Handling of GET/SET_FEATURE standard USB request
> + *
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + * @set: must be set to 1 for SET_FEATURE request
> + *
> + * Returns 0 if success, error code on error
> + */
> +static int cdns3_req_ep0_handle_feature(struct cdns3_device *priv_dev,
> +                                       struct usb_ctrlrequest *ctrl,
> +                                       int set)
> +{
> +       int ret =3D 0;
> +       u32 recip;
> +
> +       recip =3D ctrl->bRequestType & USB_RECIP_MASK;
> +
> +       switch (recip) {
> +       case USB_RECIP_DEVICE:
> +               ret =3D cdns3_ep0_feature_handle_device(priv_dev, ctrl, s=
et);
> +               break;
> +       case USB_RECIP_INTERFACE:
> +               ret =3D cdns3_ep0_feature_handle_intf(priv_dev, ctrl, set=
);
> +               break;
> +       case USB_RECIP_ENDPOINT:
> +               ret =3D cdns3_ep0_feature_handle_endpoint(priv_dev, ctrl,=
 set);
> +               break;
> +       default:
> +               return -EINVAL;
> +       }
> +
> +       if (!ret)
> +               writel(EP_CMD_ERDY | EP_CMD_REQ_CMPL, &priv_dev->regs->ep=
_cmd);
> +
> +       return ret;
> +}
> +
> +/**
> + * cdns3_req_ep0_set_sel - Handling of SET_SEL standard USB request
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns 0 if success, error code on error
> + */
> +static int cdns3_req_ep0_set_sel(struct cdns3_device *priv_dev,
> +                                struct usb_ctrlrequest *ctrl_req)
> +{
> +       if (priv_dev->gadget.state < USB_STATE_ADDRESS)
> +               return -EINVAL;
> +
> +       if (ctrl_req->wLength !=3D 6) {
> +               dev_err(priv_dev->dev, "Set SEL should be 6 bytes, got %d=
\n",
> +                       ctrl_req->wLength);
> +               return -EINVAL;
> +       }
> +
> +       cdns3_ep0_run_transfer(priv_dev, priv_dev->setup_dma, 6, 1);
> +       return 0;
> +}
> +
> +/**
> + * cdns3_req_ep0_set_isoch_delay -
> + * Handling of GET_ISOCH_DELAY standard USB request
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns 0 if success, error code on error
> + */
> +static int cdns3_req_ep0_set_isoch_delay(struct cdns3_device *priv_dev,
> +                                        struct usb_ctrlrequest *ctrl_req=
)
> +{
> +       if (ctrl_req->wIndex || ctrl_req->wLength)
> +               return -EINVAL;
> +
> +       priv_dev->isoch_delay =3D ctrl_req->wValue;
> +       writel(EP_CMD_ERDY | EP_CMD_REQ_CMPL, &priv_dev->regs->ep_cmd);
> +       return 0;
> +}
> +
> +/**
> + * cdns3_ep0_standard_request - Handling standard USB requests
> + * @priv_dev: extended gadget object
> + * @ctrl_req: pointer to received setup packet
> + *
> + * Returns 0 if success, error code on error
> + */
> +static int cdns3_ep0_standard_request(struct cdns3_device *priv_dev,
> +                                     struct usb_ctrlrequest *ctrl_req)
> +{
> +       int ret;
> +
> +       switch (ctrl_req->bRequest) {
> +       case USB_REQ_SET_ADDRESS:
> +               ret =3D cdns3_req_ep0_set_address(priv_dev, ctrl_req);
> +               break;
> +       case USB_REQ_SET_CONFIGURATION:
> +               ret =3D cdns3_req_ep0_set_configuration(priv_dev, ctrl_re=
q);
> +               break;
> +       case USB_REQ_GET_STATUS:
> +               ret =3D cdns3_req_ep0_get_status(priv_dev, ctrl_req);
> +               break;
> +       case USB_REQ_CLEAR_FEATURE:
> +               ret =3D cdns3_req_ep0_handle_feature(priv_dev, ctrl_req, =
0);
> +               break;
> +       case USB_REQ_SET_FEATURE:
> +               ret =3D cdns3_req_ep0_handle_feature(priv_dev, ctrl_req, =
1);
> +               break;
> +       case USB_REQ_SET_SEL:
> +               ret =3D cdns3_req_ep0_set_sel(priv_dev, ctrl_req);
> +               break;
> +       case USB_REQ_SET_ISOCH_DELAY:
> +               ret =3D cdns3_req_ep0_set_isoch_delay(priv_dev, ctrl_req)=
;
> +               break;
> +       default:
> +               ret =3D cdns3_ep0_delegate_req(priv_dev, ctrl_req);
> +               break;
> +       }
> +
> +       return ret;
> +}
> +
> +static void __pending_setup_status_handler(struct cdns3_device *priv_dev=
)
> +{
> +       struct usb_request *request =3D priv_dev->pending_status_request;
> +
> +       if (priv_dev->status_completion_no_call && request &&
> +           request->complete) {
> +               request->complete(priv_dev->gadget.ep0, request);
> +               priv_dev->status_completion_no_call =3D 0;
> +       }
> +}
> +
> +void cdns3_pending_setup_status_handler(struct work_struct *work)
> +{
> +       struct cdns3_device *priv_dev =3D container_of(work, struct cdns3=
_device,
> +                       pending_status_wq);
> +       unsigned long flags;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       __pending_setup_status_handler(priv_dev);
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +}
> +
> +/**
> + * cdns3_gadget_ep_giveback - call struct usb_request's ->complete callb=
ack
> + * @priv_ep: The endpoint to whom the request belongs to
> + * @priv_req: The request we're giving back
> + * @status: completion code for the request
> + *
> + * Must be called with controller's lock held and interrupts disabled. T=
his
> + * function will unmap @req and call its ->complete() callback to notify=
 upper
> + * layers that it has completed.
> + */
> +
> +void cdns3_gadget_ep0_giveback(struct cdns3_device *priv_dev,
> +                              int status)
> +{
> +       struct cdns3_endpoint *priv_ep;
> +       struct usb_request *request;
> +
> +       priv_ep =3D ep_to_cdns3_ep(priv_dev->gadget.ep0);
> +       request =3D cdns3_next_request(&priv_ep->request_list);
> +
> +       priv_ep->dir =3D priv_dev->ep0_data_dir;
> +       cdns3_gadget_giveback(priv_ep, to_cdns3_request(request), status)=
;
> +       priv_dev->ep0_request =3D NULL;
> +}
> +
> +/**
> + * cdns3_ep0_setup_phase - Handling setup USB requests
> + * @priv_dev: extended gadget object
> + */
> +static void cdns3_ep0_setup_phase(struct cdns3_device *priv_dev)
> +{
> +       struct usb_ctrlrequest *ctrl =3D priv_dev->setup_buf;
> +       struct cdns3_endpoint *priv_ep;
> +       int result;
> +
> +       priv_dev->ep0_data_dir =3D ctrl->bRequestType & USB_DIR_IN;
> +       priv_ep =3D ep_to_cdns3_ep(priv_dev->gadget.ep0);
> +
> +       trace_cdns3_ctrl_req(ctrl);
> +
> +       if (!list_empty(&priv_ep->request_list))
> +               cdns3_gadget_ep0_giveback(priv_dev, -ECONNRESET);
> +
> +       if ((ctrl->bRequestType & USB_TYPE_MASK) =3D=3D USB_TYPE_STANDARD=
)
> +               result =3D cdns3_ep0_standard_request(priv_dev, ctrl);
> +       else
> +               result =3D cdns3_ep0_delegate_req(priv_dev, ctrl);
> +
> +       if (result !=3D 0 && result !=3D USB_GADGET_DELAYED_STATUS) {
> +               dev_dbg(priv_dev->dev, "STALL for ep0\n");
> +               /* set_stall on ep0 */
> +               cdns3_select_ep(priv_dev, 0x00);
> +               writel(EP_CMD_SSTALL, &priv_dev->regs->ep_cmd);
> +               writel(EP_CMD_ERDY | EP_CMD_REQ_CMPL, &priv_dev->regs->ep=
_cmd);
> +       }
> +}
> +
> +static void cdns3_transfer_completed(struct cdns3_device *priv_dev)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(priv_dev->gadge=
t.ep0);
> +
> +       if (priv_dev->ep0_request) {
> +               trace_cdns3_complete_trb(priv_ep, priv_dev->ep0_trb);
> +
> +               priv_dev->ep0_request->actual =3D
> +                       TRB_LEN(le32_to_cpu(priv_dev->ep0_trb->length));
> +
> +               cdns3_gadget_ep0_giveback(priv_dev, 0);
> +       }
> +
> +       cdns3_prepare_setup_packet(priv_dev);
> +       writel(EP_CMD_REQ_CMPL, &priv_dev->regs->ep_cmd);
> +}
> +
> +/**
> + * cdns3_check_new_setup - Check if controller receive new SETUP packet.
> + * @priv_dev: extended gadget object
> + *
> + * The SETUP packet can be kept in on-chip memory or in system memory.
> + */
> +static bool cdns3_check_new_setup(struct cdns3_device *priv_dev)
> +{
> +       u32 ep_sts_reg;
> +
> +       cdns3_select_ep(priv_dev, 0 | USB_DIR_OUT);
> +       ep_sts_reg =3D readl(&priv_dev->regs->ep_sts);
> +
> +       return !!(ep_sts_reg & (EP_STS_SETUP | EP_STS_STPWAIT));
> +}
> +
> +/**
> + * cdns3_check_ep0_interrupt_proceed - Processes interrupt related to en=
dpoint 0
> + * @priv_dev: extended gadget object
> + * @dir: USB_DIR_IN for IN direction, USB_DIR_OUT for OUT direction
> + */
> +void cdns3_check_ep0_interrupt_proceed(struct cdns3_device *priv_dev, in=
t dir)
> +{
> +       u32 ep_sts_reg;
> +
> +       cdns3_select_ep(priv_dev, dir);
> +
> +       ep_sts_reg =3D readl(&priv_dev->regs->ep_sts);
> +       writel(ep_sts_reg, &priv_dev->regs->ep_sts);
> +
> +       trace_cdns3_ep0_irq(priv_dev);
> +
> +       __pending_setup_status_handler(priv_dev);
> +
> +       if ((ep_sts_reg & EP_STS_SETUP)) {
> +               cdns3_ep0_setup_phase(priv_dev);
> +       } else if ((ep_sts_reg & EP_STS_IOC) || (ep_sts_reg & EP_STS_ISP)=
) {
> +               priv_dev->ep0_data_dir =3D dir;
> +               cdns3_transfer_completed(priv_dev);
> +       }
> +
> +       if (ep_sts_reg & EP_STS_DESCMIS) {
> +               if (dir =3D=3D 0 && !priv_dev->setup_pending)
> +                       cdns3_prepare_setup_packet(priv_dev);
> +       }
> +}
> +
> +/**
> + * cdns3_gadget_ep0_enable
> + * Function shouldn't be called by gadget driver,
> + * endpoint 0 is allways active
> + */
> +static int cdns3_gadget_ep0_enable(struct usb_ep *ep,
> +                                  const struct usb_endpoint_descriptor *=
desc)
> +{
> +       return -EINVAL;
> +}
> +
> +/**
> + * cdns3_gadget_ep0_disable
> + * Function shouldn't be called by gadget driver,
> + * endpoint 0 is allways active
> + */
> +static int cdns3_gadget_ep0_disable(struct usb_ep *ep)
> +{
> +       return -EINVAL;
> +}
> +
> +/**
> + * cdns3_gadget_ep0_set_halt
> + * @ep: pointer to endpoint zero object
> + * @value: 1 for set stall, 0 for clear stall
> + *
> + * Returns 0
> + */
> +static int cdns3_gadget_ep0_set_halt(struct usb_ep *ep, int value)
> +{
> +       /* TODO */
> +       return 0;
> +}
> +
> +/**
> + * cdns3_gadget_ep0_queue Transfer data on endpoint zero
> + * @ep: pointer to endpoint zero object
> + * @request: pointer to request object
> + * @gfp_flags: gfp flags
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +static int cdns3_gadget_ep0_queue(struct usb_ep *ep,
> +                                 struct usb_request *request,
> +                                 gfp_t gfp_flags)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       unsigned long flags;
> +       int erdy_sent =3D 0;
> +       int ret =3D 0;
> +
> +       dev_dbg(priv_dev->dev, "Queue to Ep0%s L: %d\n",
> +               priv_dev->ep0_data_dir ? "IN" : "OUT",
> +               request->length);
> +
> +       /* cancel the request if controller receive new SETUP packet. */
> +       if (cdns3_check_new_setup(priv_dev))
> +               return -ECONNRESET;
> +
> +       /* send STATUS stage. Should be called only for SET_CONFIGURATION=
 */
> +       if (request->length =3D=3D 0 && request->zero =3D=3D 0) {
> +               spin_lock_irqsave(&priv_dev->lock, flags);
> +               cdns3_select_ep(priv_dev, 0x00);
> +
> +               erdy_sent =3D !priv_dev->hw_configured_flag;
> +               cdns3_set_hw_configuration(priv_dev);
> +
> +               if (!erdy_sent)
> +                       writel(EP_CMD_ERDY | EP_CMD_REQ_CMPL,
> +                              &priv_dev->regs->ep_cmd);
> +
> +               cdns3_prepare_setup_packet(priv_dev);
> +               request->actual =3D 0;
> +               priv_dev->status_completion_no_call =3D true;
> +               priv_dev->pending_status_request =3D request;
> +               spin_unlock_irqrestore(&priv_dev->lock, flags);
> +
> +               /*
> +                * Since there is no completion interrupt for status stag=
e,
> +                * it needs to call ->completion in software after
> +                * ep0_queue is back.
> +                */
> +               queue_work(system_freezable_wq, &priv_dev->pending_status=
_wq);
> +               return 0;
> +       }
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       if (!list_empty(&priv_ep->request_list)) {
> +               dev_err(priv_dev->dev,
> +                       "can't handle multiple requests for ep0\n");
> +               spin_unlock_irqrestore(&priv_dev->lock, flags);
> +               return -EBUSY;
> +       }
> +
> +       ret =3D usb_gadget_map_request_by_dev(priv_dev->sysdev, request,
> +                                           priv_dev->ep0_data_dir);
> +       if (ret) {
> +               spin_unlock_irqrestore(&priv_dev->lock, flags);
> +               dev_err(priv_dev->dev, "failed to map request\n");
> +               return -EINVAL;
> +       }
> +
> +       request->status =3D -EINPROGRESS;
> +       priv_dev->ep0_request =3D request;
> +       list_add_tail(&request->list, &priv_ep->request_list);
> +       cdns3_ep0_run_transfer(priv_dev, request->dma, request->length, 1=
);
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +
> +       return ret;
> +}
> +
> +/**
> + * cdns3_gadget_ep_set_wedge Set wedge on selected endpoint
> + * @ep: endpoint object
> + *
> + * Returns 0
> + */
> +int cdns3_gadget_ep_set_wedge(struct usb_ep *ep)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +
> +       dev_dbg(priv_dev->dev, "Wedge for %s\n", ep->name);
> +       cdns3_gadget_ep_set_halt(ep, 1);
> +       priv_ep->flags |=3D EP_WEDGE;
> +
> +       return 0;
> +}
> +
> +const struct usb_ep_ops cdns3_gadget_ep0_ops =3D {
> +       .enable =3D cdns3_gadget_ep0_enable,
> +       .disable =3D cdns3_gadget_ep0_disable,
> +       .alloc_request =3D cdns3_gadget_ep_alloc_request,
> +       .free_request =3D cdns3_gadget_ep_free_request,
> +       .queue =3D cdns3_gadget_ep0_queue,
> +       .dequeue =3D cdns3_gadget_ep_dequeue,
> +       .set_halt =3D cdns3_gadget_ep0_set_halt,
> +       .set_wedge =3D cdns3_gadget_ep_set_wedge,
> +};
> +
> +/**
> + * cdns3_ep0_config - Configures default endpoint
> + * @priv_dev: extended gadget object
> + *
> + * Functions sets parameters: maximal packet size and enables interrupts
> + */
> +void cdns3_ep0_config(struct cdns3_device *priv_dev)
> +{
> +       struct cdns3_usb_regs __iomem *regs;
> +       u32 max_packet_size =3D 64;
> +
> +       regs =3D priv_dev->regs;
> +
> +       if (priv_dev->gadget.speed =3D=3D USB_SPEED_SUPER)
> +               max_packet_size =3D 512;
> +
> +       if (priv_dev->ep0_request) {
> +               list_del_init(&priv_dev->ep0_request->list);
> +               priv_dev->ep0_request =3D NULL;
> +       }
> +
> +       priv_dev->u1_allowed =3D 0;
> +       priv_dev->u2_allowed =3D 0;
> +
> +       priv_dev->gadget.ep0->maxpacket =3D max_packet_size;
> +       cdns3_gadget_ep0_desc.wMaxPacketSize =3D cpu_to_le16(max_packet_s=
ize);
> +
> +       /* init ep out */
> +       cdns3_select_ep(priv_dev, USB_DIR_OUT);
> +
> +       writel(EP_CFG_ENABLE | EP_CFG_MAXPKTSIZE(max_packet_size),
> +              &regs->ep_cfg);
> +
> +       writel(EP_STS_EN_SETUPEN | EP_STS_EN_DESCMISEN | EP_STS_EN_TRBERR=
EN,
> +              &regs->ep_sts_en);
> +
> +       /* init ep in */
> +       cdns3_select_ep(priv_dev, USB_DIR_IN);
> +
> +       writel(EP_CFG_ENABLE | EP_CFG_MAXPKTSIZE(max_packet_size),
> +              &regs->ep_cfg);
> +
> +       writel(EP_STS_EN_SETUPEN | EP_STS_EN_TRBERREN, &regs->ep_sts_en);
> +
> +       cdns3_set_register_bit(&regs->usb_conf, USB_CONF_U1DS | USB_CONF_=
U2DS);
> +       cdns3_prepare_setup_packet(priv_dev);
> +}
> +
> +/**
> + * cdns3_init_ep0 Initializes software endpoint 0 of gadget
> + * @cdns3: extended gadget object
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +int cdns3_init_ep0(struct cdns3_device *priv_dev)
> +{
> +       struct cdns3_endpoint *ep0;
> +
> +       ep0 =3D devm_kzalloc(priv_dev->dev, sizeof(struct cdns3_endpoint)=
,
> +                          GFP_KERNEL);
> +
> +       if (!ep0)
> +               return -ENOMEM;
> +
> +       ep0->cdns3_dev =3D priv_dev;
> +       sprintf(ep0->name, "ep0");
> +
> +       /* fill linux fields */
> +       ep0->endpoint.ops =3D &cdns3_gadget_ep0_ops;
> +       ep0->endpoint.maxburst =3D 1;
> +       usb_ep_set_maxpacket_limit(&ep0->endpoint, CDNS3_EP0_MAX_PACKET_L=
IMIT);
> +       ep0->endpoint.address =3D 0;
> +       ep0->endpoint.caps.type_control =3D 1;
> +       ep0->endpoint.caps.dir_in =3D 1;
> +       ep0->endpoint.caps.dir_out =3D 1;
> +       ep0->endpoint.name =3D ep0->name;
> +       ep0->endpoint.desc =3D &cdns3_gadget_ep0_desc;
> +       priv_dev->gadget.ep0 =3D &ep0->endpoint;
> +       INIT_LIST_HEAD(&ep0->request_list);
> +
> +       return 0;
> +}
> diff --git a/drivers/usb/cdns3/gadget-export.h b/drivers/usb/cdns3/gadget=
-export.h
> new file mode 100644
> index 000000000000..577469eee961
> --- /dev/null
> +++ b/drivers/usb/cdns3/gadget-export.h
> @@ -0,0 +1,28 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * Cadence USBSS DRD Driver - Gadget Export APIs.
> + *
> + * Copyright (C) 2017 NXP
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Authors: Peter Chen <peter.chen@nxp.com>
> + */
> +#ifndef __LINUX_CDNS3_GADGET_EXPORT
> +#define __LINUX_CDNS3_GADGET_EXPORT
> +
> +#ifdef CONFIG_USB_CDNS3_GADGET
> +
> +int cdns3_gadget_init(struct cdns3 *cdns);
> +void cdns3_gadget_exit(struct cdns3 *cdns);
> +#else
> +
> +static inline int cdns3_gadget_init(struct cdns3 *cdns)
> +{
> +       return -ENXIO;
> +}
> +
> +static inline void cdns3_gadget_exit(struct cdns3 *cdns) { }
> +
> +#endif
> +
> +#endif /* __LINUX_CDNS3_GADGET_EXPORT */
> diff --git a/drivers/usb/cdns3/gadget.c b/drivers/usb/cdns3/gadget.c
> new file mode 100644
> index 000000000000..a021eaf07aee
> --- /dev/null
> +++ b/drivers/usb/cdns3/gadget.c
> @@ -0,0 +1,1802 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Driver - gadget side.
> + *
> + * Copyright (C) 2018 Cadence Design Systems.
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Authors: Pawel Jez <pjez@cadence.com>,
> + *          Pawel Laszczak <pawell@cadence.com>
> + *         Peter Chen <peter.chen@nxp.com>
> + */
> +
> +#include <linux/dma-mapping.h>
> +#include <linux/usb/gadget.h>
> +
> +#include "core.h"
> +#include "gadget-export.h"
> +#include "gadget.h"
> +
> +#include "trace.h"
> +
> +static int __cdns3_gadget_ep_queue(struct usb_ep *ep,
> +                                  struct usb_request *request,
> +                                  gfp_t gfp_flags);
> +
> +/**
> + * cdns3_handshake - spin reading  until handshake completes or fails
> + * @ptr: address of device controller register to be read
> + * @mask: bits to look at in result of read
> + * @done: value of those bits when handshake succeeds
> + * @usec: timeout in microseconds
> + *
> + * Returns negative errno, or zero on success
> + *
> + * Success happens when the "mask" bits have the specified value (hardwa=
re
> + * handshake done). There are two failure modes: "usec" have passed (maj=
or
> + * hardware flakeout), or the register reads as all-ones (hardware remov=
ed).
> + */
> +int cdns3_handshake(void __iomem *ptr, u32 mask, u32 done, int usec)
> +{
> +       u32     result;
> +
> +       do {
> +               result =3D readl(ptr);
> +               if (result =3D=3D ~(u32)0)  /* card removed */
> +                       return -ENODEV;
> +               result &=3D mask;
> +               if (result =3D=3D done)
> +                       return 0;
> +               udelay(1);
> +               usec--;
> +       } while (usec > 0);
> +       return -ETIMEDOUT;
> +}
> +
> +/**
> + * cdns3_set_register_bit - set bit in given register.
> + * @ptr: address of device controller register to be read and changed
> + * @mask: bits requested to set
> + */
> +void cdns3_set_register_bit(void __iomem *ptr, u32 mask)
> +{
> +       mask =3D readl(ptr) | mask;
> +       writel(mask, ptr);
> +}
> +
> +/**
> + * cdns3_ep_reg_pos_to_index - Macro converts bit position of ep_ists re=
gister
> + * to index of endpoint object in cdns3_device.eps[] container
> + * @i: bit position of endpoint for which endpoint object is required
> + *
> + * Remember that endpoint container doesn't contain default endpoint
> + */
> +static u8 cdns3_ep_reg_pos_to_index(int i)
> +{
> +       return ((i / 16) + (((i % 16) - 2) * 2));
> +}
> +
> +/**
> + * cdns3_ep_addr_to_index - Macro converts endpoint address to
> + * index of endpoint object in cdns3_device.eps[] container
> + * @ep_addr: endpoint address for which endpoint object is required
> + *
> + * Remember that endpoint container doesn't contain default endpoint
> + */
> +u8 cdns3_ep_addr_to_index(u8 ep_addr)
> +{
> +       return (((ep_addr & 0x7F) - 1) + ((ep_addr & USB_DIR_IN) ? 1 : 0)=
);
> +}
> +
> +/**
> + * cdns3_ep_addr_to_bit_pos - Macro converts endpoint address to
> + * bit position in ep_ists register
> + * @ep_addr: endpoint address for which bit position is required
> + *
> + * Remember that endpoint container doesn't contain default endpoint
> + */
> +static u32 cdns3_ep_addr_to_bit_pos(u8 ep_addr)
> +{
> +       return (1 << (ep_addr & 0x7F)) << ((ep_addr & 0x80) ? 16 : 0);
> +}
> +
> +/**
> + * cdns3_next_request - returns next request from list
> + * @list: list containing requests
> + *
> + * Returns request or NULL if no requests in list
> + */
> +struct usb_request *cdns3_next_request(struct list_head *list)
> +{
> +       if (list_empty(list))
> +               return NULL;
> +       return list_first_entry(list, struct usb_request, list);
> +}
> +
> +/**
> + * select_ep - selects endpoint
> + * @priv_dev:  extended gadget object
> + * @ep: endpoint address
> + */
> +void cdns3_select_ep(struct cdns3_device *priv_dev, u32 ep)
> +{
> +       if (priv_dev->selected_ep =3D=3D ep)
> +               return;
> +
> +       priv_dev->selected_ep =3D ep;
> +       writel(ep, &priv_dev->regs->ep_sel);
> +}
> +
> +dma_addr_t cdns3_trb_virt_to_dma(struct cdns3_endpoint *priv_ep,
> +                                struct cdns3_trb *trb)
> +{
> +       u32 offset =3D (char *)trb - (char *)priv_ep->trb_pool;
> +
> +       return priv_ep->trb_pool_dma + offset;
> +}
> +
> +/**
> + * cdns3_allocate_trb_pool - Allocates TRB's pool for selected endpoint
> + * @priv_ep:  endpoint object
> + *
> + * Function will return 0 on success or -ENOMEM on allocation error
> + */
> +static int cdns3_allocate_trb_pool(struct cdns3_endpoint *priv_ep)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct cdns3_trb *link_trb;
> +
> +       if (!priv_ep->trb_pool) {
> +               priv_ep->trb_pool =3D dma_zalloc_coherent(priv_dev->sysde=
v,
> +                                                       TRB_RING_SIZE,
> +                                                       &priv_ep->trb_poo=
l_dma,
> +                                                       GFP_DMA);
> +               if (!priv_ep->trb_pool)
> +                       return -ENOMEM;
> +       } else {
> +               memset(priv_ep->trb_pool, 0, TRB_RING_SIZE);
> +       }
> +
> +       if (!priv_ep->aligned_buff) {
> +               void *buff =3D dma_alloc_coherent(priv_dev->sysdev,
> +                                               CDNS3_ALIGNED_BUF_SIZE,
> +                                               &priv_ep->aligned_dma_add=
r,
> +                                               GFP_DMA);
> +
> +               priv_ep->aligned_buff  =3D buff;
> +               if (!priv_ep->aligned_buff) {
> +                       dma_free_coherent(priv_dev->sysdev,
> +                                         TRB_RING_SIZE,
> +                                         priv_ep->trb_pool,
> +                                         priv_ep->trb_pool_dma);
> +                       priv_ep->trb_pool =3D NULL;
> +
> +                       return -ENOMEM;
> +               }
> +       }
> +
> +       /* Initialize the last TRB as Link TRB */
> +       link_trb =3D (priv_ep->trb_pool + TRBS_PER_SEGMENT - 1);
> +       link_trb->buffer =3D TRB_BUFFER(priv_ep->trb_pool_dma);
> +       link_trb->control =3D TRB_CYCLE | TRB_TYPE(TRB_LINK) |
> +                           TRB_CHAIN | TRB_TOGGLE;
> +
> +       return 0;
> +}
> +
> +static void cdns3_free_trb_pool(struct cdns3_endpoint *priv_ep)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +
> +       if (priv_ep->trb_pool) {
> +               dma_free_coherent(priv_dev->sysdev,
> +                                 TRB_RING_SIZE,
> +                                 priv_ep->trb_pool, priv_ep->trb_pool_dm=
a);
> +               priv_ep->trb_pool =3D NULL;
> +       }
> +
> +       if (priv_ep->aligned_buff) {
> +               dma_free_coherent(priv_dev->sysdev, CDNS3_ALIGNED_BUF_SIZ=
E,
> +                                 priv_ep->aligned_buff,
> +                                 priv_ep->aligned_dma_addr);
> +               priv_ep->aligned_buff =3D NULL;
> +       }
> +}
> +
> +/**
> + * cdns3_data_flush - flush data at onchip buffer
> + * @priv_ep: endpoint object
> + *
> + * Endpoint must be selected before call to this function
> + *
> + * Returns zero on success or negative value on failure
> + */
> +static int cdns3_data_flush(struct cdns3_endpoint *priv_ep)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +
> +       writel(EP_CMD_DFLUSH, &priv_dev->regs->ep_cmd);
> +
> +       /* wait for DFLUSH cleared */
> +       return cdns3_handshake(&priv_dev->regs->ep_cmd, EP_CMD_DFLUSH, 0,=
 100);
> +}
> +
> +/**
> + * cdns3_ep_stall_flush - Stalls and flushes selected endpoint
> + * @priv_ep: endpoint object
> + *
> + * Endpoint must be selected before call to this function
> + */
> +static void cdns3_ep_stall_flush(struct cdns3_endpoint *priv_ep)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +
> +       writel(EP_CMD_DFLUSH | EP_CMD_ERDY | EP_CMD_SSTALL,
> +              &priv_dev->regs->ep_cmd);
> +
> +       /* wait for DFLUSH cleared */
> +       cdns3_handshake(&priv_dev->regs->ep_cmd, EP_CMD_DFLUSH, 0, 100);
> +       priv_ep->flags |=3D EP_STALL;
> +}
> +
> +/**
> + * cdns3_gadget_unconfig - reset device configuration
> + * @priv_dev: extended gadget object
> + */
> +void cdns3_gadget_unconfig(struct cdns3_device *priv_dev)
> +{
> +       /* RESET CONFIGURATION */
> +       writel(USB_CONF_CFGRST, &priv_dev->regs->usb_conf);
> +
> +       cdns3_allow_enable_l1(priv_dev, 0);
> +       priv_dev->hw_configured_flag =3D 0;
> +       priv_dev->onchip_mem_allocated_size =3D 0;
> +}
> +
> +/**
> + * cdns3_ep_inc_trb - increment a trb index.
> + * @index: Pointer to the TRB index to increment.
> + * @cs: Cycle state
> + *
> + * The index should never point to the link TRB. After incrementing,
> + * if it is point to the link TRB, wrap around to the beginning and reve=
rt
> + * cycle state bit The
> + * link TRB is always at the last TRB entry.
> + */
> +static void cdns3_ep_inc_trb(int *index, u8 *cs)
> +{
> +       (*index)++;
> +       if (*index =3D=3D (TRBS_PER_SEGMENT - 1)) {
> +               *index =3D 0;
> +               *cs ^=3D  1;
> +       }
> +}
> +
> +/**
> + * cdns3_ep_inc_enq - increment endpoint's enqueue pointer
> + * @priv_ep: The endpoint whose enqueue pointer we're incrementing
> + */
> +static void cdns3_ep_inc_enq(struct cdns3_endpoint *priv_ep)
> +{
> +       priv_ep->free_trbs--;
> +       cdns3_ep_inc_trb(&priv_ep->enqueue, &priv_ep->pcs);
> +}
> +
> +/**
> + * cdns3_ep_inc_deq - increment endpoint's dequeue pointer
> + * @priv_ep: The endpoint whose dequeue pointer we're incrementing
> + */
> +static void cdns3_ep_inc_deq(struct cdns3_endpoint *priv_ep)
> +{
> +       priv_ep->free_trbs++;
> +       cdns3_ep_inc_trb(&priv_ep->dequeue, &priv_ep->ccs);
> +}
> +
> +/**
> + * cdns3_allow_enable_l1 - enable/disable permits to transition to L1.
> + * @priv_dev: Extended gadget object
> + * @enable: Enable/disable permit to transition to L1.
> + *
> + * If bit USB_CONF_L1EN is set and device receive Extended Token packet,
> + * then controller answer with ACK handshake.
> + * If bit USB_CONF_L1DS is set and device receive Extended Token packet,
> + * then controller answer with NYET handshake.
> + */
> +void cdns3_allow_enable_l1(struct cdns3_device *priv_dev, int enable)
> +{
> +       if (enable)
> +               writel(USB_CONF_L1EN, &priv_dev->regs->usb_conf);
> +       else
> +               writel(USB_CONF_L1DS, &priv_dev->regs->usb_conf);
> +}
> +
> +enum usb_device_speed cdns3_get_speed(struct cdns3_device *priv_dev)
> +{
> +       u32 reg;
> +
> +       reg =3D readl(&priv_dev->regs->usb_sts);
> +
> +       if (DEV_SUPERSPEED(reg))
> +               return USB_SPEED_SUPER;
> +       else if (DEV_HIGHSPEED(reg))
> +               return USB_SPEED_HIGH;
> +       else if (DEV_FULLSPEED(reg))
> +               return USB_SPEED_FULL;
> +       else if (DEV_LOWSPEED(reg))
> +               return USB_SPEED_LOW;
> +       return USB_SPEED_UNKNOWN;
> +}
> +
> +/**
> + * cdns3_start_all_request - add to ring all request not started
> + * @priv_dev: Extended gadget object
> + * @priv_ep: The endpoint for whom request will be started.
> + *
> + * Returns return ENOMEM if transfer ring i not enough TRBs to start
> + *         all requests.
> + */
> +static int cdns3_start_all_request(struct cdns3_device *priv_dev,
> +                                  struct cdns3_endpoint *priv_ep)
> +{
> +       struct usb_request *req, *req_temp;
> +       int ret =3D 0;
> +
> +       list_for_each_entry_safe(req, req_temp, &priv_ep->request_list, l=
ist) {
> +               struct cdns3_request *priv_req =3D to_cdns3_request(req);
> +
> +               if (!(priv_req->flags & REQUEST_PENDING)) {
> +                       ret =3D cdns3_ep_run_transfer(priv_ep, req);
> +                       if (ret)
> +                               return ret;
> +               }
> +       }
> +
> +       priv_ep->flags &=3D ~EP_RING_FULL;
> +       return ret;
> +}
> +
> +/**
> + * cdns3_gadget_giveback - call struct usb_request's ->complete callback
> + * @priv_ep: The endpoint to whom the request belongs to
> + * @priv_req: The request we're giving back
> + * @status: completion code for the request
> + *
> + * Must be called with controller's lock held and interrupts disabled. T=
his
> + * function will unmap @req and call its ->complete() callback to notify=
 upper
> + * layers that it has completed.
> + */
> +void cdns3_gadget_giveback(struct cdns3_endpoint *priv_ep,
> +                          struct cdns3_request *priv_req,
> +                          int status)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct usb_request *request =3D &priv_req->request;
> +
> +       list_del_init(&request->list);
> +
> +       if (request->status =3D=3D -EINPROGRESS)
> +               request->status =3D status;
> +
> +       usb_gadget_unmap_request_by_dev(priv_dev->sysdev, request,
> +                                       priv_ep->dir);
> +
> +       priv_req->flags &=3D ~REQUEST_PENDING;
> +       trace_cdns3_gadget_giveback(priv_req);
> +
> +       if (priv_req->flags & REQUEST_INTERNAL) {
> +               struct usb_request *req;
> +
> +               req =3D cdns3_next_request(&priv_ep->request_list);
> +
> +               priv_ep->descmis_pending =3D false;
> +               priv_ep->descmis_finished =3D true;
> +
> +               /*
> +                * If no request is queued then driver can't do nothing
> +                * with just completed request. Request with flag set to
> +                * REQUEST_INTERNAL is only internal used request and dri=
ver
> +                * can't call complete callback. Before calling completio=
n, data
> +                * must be copied to normal usb_request object
> +                */
> +               if (!req)
> +                       return;
> +
> +               req->actual =3D request->actual;
> +               req->status =3D request->status;
> +               memcpy(req->buf, request->buf, request->actual);
> +
> +               request =3D req;
> +               list_del_init(&request->list);
> +               cdns3_start_all_request(priv_dev, priv_ep);
> +               priv_ep->descmis_finished =3D false;
> +       }
> +
> +       /* Start all not pending request */
> +       if (priv_ep->flags & EP_RING_FULL)
> +               cdns3_start_all_request(priv_dev, priv_ep);
> +
> +       if (request->complete) {
> +               spin_unlock(&priv_dev->lock);
> +               usb_gadget_giveback_request(&priv_ep->endpoint,
> +                                           request);
> +               spin_lock(&priv_dev->lock);
> +       }
> +
> +       if (request->buf =3D=3D priv_dev->zlp_buf)
> +               cdns3_gadget_ep_free_request(&priv_ep->endpoint, request)=
;
> +}
> +
> +/**
> + * cdns3_ep_run_transfer - start transfer on no-default endpoint hardwar=
e
> + * @priv_ep: endpoint object
> + *
> + * Returns zero on success or negative value on failure
> + */
> +int cdns3_ep_run_transfer(struct cdns3_endpoint *priv_ep,
> +                         struct usb_request *request)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct cdns3_request *priv_req;
> +       struct cdns3_trb *trb;
> +       dma_addr_t trb_dma;
> +       int sg_iter =3D 0;
> +       u32 first_pcs;
> +       int  num_trb;
> +       int address;
> +       int pcs;
> +
> +       num_trb =3D request->num_sgs ? request->num_sgs : 1;
> +
> +       if (num_trb > priv_ep->free_trbs) {
> +               priv_ep->flags |=3D EP_RING_FULL;
> +               return -ENOMEM;
> +       }
> +
> +       priv_req =3D to_cdns3_request(request);
> +       address =3D priv_ep->endpoint.desc->bEndpointAddress;
> +
> +       if (priv_ep->descmis_pending)
> +               return 0;
> +
> +       if (priv_req->flags & REQUEST_PENDING)
> +               goto arm;
> +
> +       priv_ep->flags |=3D EP_PENDING_REQUEST;
> +       trb_dma =3D request->dma;
> +
> +       /* must allocate buffer aligned to 8 */
> +       if ((request->dma % 8)) {
> +               if (request->length <=3D CDNS3_ALIGNED_BUF_SIZE) {
> +                       memcpy(priv_ep->aligned_buff, request->buf,
> +                              request->length);
> +                       trb_dma =3D priv_ep->aligned_dma_addr;
> +               } else {
> +                       return -ENOMEM;
> +               }
> +       }
> +
> +       trb =3D priv_ep->trb_pool + priv_ep->enqueue;
> +       priv_req->trb =3D trb;
> +       priv_req->start_trb =3D priv_ep->enqueue;
> +
> +       /* prepare ring */
> +       if ((priv_ep->enqueue + num_trb)  >=3D (TRBS_PER_SEGMENT - 1)) {
> +               /*updating C bt in  Link TRB before starting DMA*/
> +               struct cdns3_trb *link_trb =3D priv_ep->trb_pool +
> +                                            (TRBS_PER_SEGMENT - 1);
> +               link_trb->control =3D ((priv_ep->pcs) ? TRB_CYCLE : 0) |
> +                                   TRB_TYPE(TRB_LINK) | TRB_CHAIN |
> +                                   TRB_TOGGLE;
> +       }
> +
> +       first_pcs =3D priv_ep->pcs ? TRB_CYCLE : 0;
> +
> +       do {
> +       /* fill TRB */
> +               trb->buffer =3D TRB_BUFFER(request->num_sgs =3D=3D 0
> +                               ? trb_dma : request->sg[sg_iter].dma_addr=
ess);
> +
> +               trb->length =3D TRB_BURST_LEN(16) |
> +                   TRB_LEN(request->num_sgs =3D=3D 0 ?
> +                               request->length : request->sg[sg_iter].le=
ngth);
> +
> +               trb->control =3D TRB_TYPE(TRB_NORMAL);
> +               pcs =3D priv_ep->pcs ? TRB_CYCLE : 0;
> +
> +               /*
> +                * first trb should be prepared as last to avoid processi=
ng
> +                *  transfer to early
> +                */
> +               if (sg_iter =3D=3D request->num_sgs && sg_iter !=3D 0)
> +                       trb->control |=3D pcs | TRB_IOC | TRB_ISP;
> +               else if (sg_iter !=3D 0)
> +                       trb->control |=3D pcs;
> +
> +               ++sg_iter;
> +               ++trb;
> +               cdns3_ep_inc_enq(priv_ep);
> +       } while (sg_iter < request->num_sgs);
> +
> +       trb =3D priv_req->trb;
> +       /*
> +        * Memory barrier =3D Cycle Bit must be set before trb->length  a=
nd
> +        * trb->buffer fields.
> +        */
> +       wmb();
> +
> +       /* give the TD to the consumer*/
> +       if (sg_iter =3D=3D 1)
> +               trb->control |=3D first_pcs | TRB_IOC | TRB_ISP;
> +       else
> +               trb->control |=3D first_pcs;
> +
> +       priv_req->flags |=3D REQUEST_PENDING;
> +
> +       if (priv_req->flags & REQUEST_INTERNAL)
> +               priv_ep->descmis_pending =3D true;
> +
> +       trace_cdns3_prepare_trb(priv_ep, priv_req->trb);
> +       trace_cdns3_ring(priv_ep);
> +
> +arm:
> +       /* arm transfer on selected endpoint */
> +       cdns3_select_ep(priv_ep->cdns3_dev, address);
> +
> +       /*
> +        * For DMULT mode we can set address to transfer ring only once a=
fter
> +        * enabling endpoint.
> +        */
> +       if (priv_ep->flags & EP_UPDATE_EP_TRBADDR) {
> +               writel(EP_TRADDR_TRADDR(priv_ep->trb_pool_dma),
> +                      &priv_dev->regs->ep_traddr);
> +               priv_ep->flags &=3D ~EP_UPDATE_EP_TRBADDR;
> +       }
> +
> +       if (priv_dev->hw_configured_flag) {
> +               /*clearing TRBERR and EP_STS_DESCMIS before seting DRDY*/
> +               writel(EP_STS_TRBERR | EP_STS_DESCMIS, &priv_dev->regs->e=
p_sts);
> +               trace_cdns3_doorbell_epx(priv_ep->name);
> +               writel(EP_CMD_DRDY, &priv_dev->regs->ep_cmd);
> +       }
> +
> +       return 0;
> +}
> +
> +void cdns3_set_hw_configuration(struct cdns3_device *priv_dev)
> +{
> +       struct cdns3_endpoint *priv_ep;
> +       struct usb_request *request;
> +       struct usb_ep *ep;
> +       int result =3D 0;
> +
> +       if (priv_dev->hw_configured_flag)
> +               return;
> +
> +       writel(USB_CONF_CFGSET, &priv_dev->regs->usb_conf);
> +       writel(EP_CMD_ERDY | EP_CMD_REQ_CMPL, &priv_dev->regs->ep_cmd);
> +
> +       cdns3_set_register_bit(&priv_dev->regs->usb_conf,
> +                              USB_CONF_U1EN | USB_CONF_U2EN);
> +
> +       /* wait until configuration set */
> +       result =3D cdns3_handshake(&priv_dev->regs->usb_sts,
> +                                USB_STS_CFGSTS_MASK, 1, 100);
> +
> +       priv_dev->hw_configured_flag =3D 1;
> +       cdns3_allow_enable_l1(priv_dev, 1);
> +
> +       list_for_each_entry(ep, &priv_dev->gadget.ep_list, ep_list) {
> +               if (ep->enabled) {
> +                       priv_ep =3D ep_to_cdns3_ep(ep);
> +                       request =3D cdns3_next_request(&priv_ep->request_=
list);
> +                       if (request)
> +                               cdns3_ep_run_transfer(priv_ep, request);
> +               }
> +       }
> +}
> +
> +static bool cdns3_request_handled(struct cdns3_endpoint *priv_ep,
> +                                 struct cdns3_request *priv_req)
> +{
> +       int current_index;
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct cdns3_trb *trb =3D priv_req->trb;
> +
> +       if (!(priv_req->flags & REQUEST_PENDING))
> +               return false;
> +
> +       cdns3_select_ep(priv_dev, priv_ep->endpoint.desc->bEndpointAddres=
s);
> +       current_index =3D (readl(&priv_dev->regs->ep_traddr) -
> +                        priv_ep->trb_pool_dma) / TRB_SIZE;
> +
> +       trb =3D &priv_ep->trb_pool[priv_req->start_trb];
> +
> +       if ((trb->control  & TRB_CYCLE) !=3D priv_ep->ccs)
> +               return false;
> +
> +       /**
> +        * case where ep_traddr point to last trb in ring (link trb)
> +        * and dequeue pointer already has been changed to first trb
> +        */
> +       if ((current_index =3D=3D (TRBS_PER_SEGMENT - 1)) && !priv_ep->de=
queue)
> +               return false;
> +
> +       if (priv_req->start_trb !=3D current_index)
> +               return true;
> +
> +       return false;
> +}
> +
> +static void cdns3_transfer_completed(struct cdns3_device *priv_dev,
> +                                    struct cdns3_endpoint *priv_ep)
> +{
> +       struct usb_request *request;
> +       struct cdns3_request *priv_req;
> +       struct cdns3_trb *trb;
> +
> +       while (!list_empty(&priv_ep->request_list)) {
> +               request =3D cdns3_next_request(&priv_ep->request_list);
> +               priv_req =3D to_cdns3_request(request);
> +
> +               if (!cdns3_request_handled(priv_ep, priv_req))
> +                       return;
> +
> +               if (request->dma % 8 && priv_ep->dir =3D=3D USB_DIR_OUT)
> +                       memcpy(request->buf, priv_ep->aligned_buff,
> +                              request->length);
> +
> +               trb =3D priv_ep->trb_pool + priv_ep->dequeue;
> +               trace_cdns3_complete_trb(priv_ep, trb);
> +               if (trb !=3D priv_req->trb)
> +                       dev_warn(priv_dev->dev,
> +                                "request_trb=3D0x%p, queue_trb=3D0x%p\n"=
,
> +                                priv_req->trb, trb);
> +
> +               request->actual =3D TRB_LEN(le32_to_cpu(trb->length));
> +
> +               cdns3_ep_inc_deq(priv_ep);
> +
> +               cdns3_gadget_giveback(priv_ep, priv_req, 0);
> +       }
> +
> +       priv_ep->flags &=3D ~EP_PENDING_REQUEST;
> +}
> +
> +/**
> + * cdns3_descmissing_packet - handles descriptor missing event.
> + * @priv_dev: extended gadget object
> + *
> + * Function protects gadget functions from getting stuck.
> + * Controller for OUT endpoints has shared on-chip buffers for all incom=
ing
> + * packets, including ep0out. It's FIFO buffer, so packets must be handl=
e by DMA
> + * in correct order. If the first packet in the buffer will not be handl=
ed,
> + * then the following packets directed for other endpoints and  function=
s
> + * will be blocked.
> + * Additionally the packets directed to one endpoint can clog entire on-=
chip
> + * buffers. In this case transfer to other endpoints also will blocked.
> + *
> + * To resolve this issue after raising the descriptor missing interrupt
> + * driver prepares internal usb_request object and use it to arm DMA tra=
nsfer
> + * for the right endpoint. Driver use only single usb_request with
> + * allocated 64KB buffer, so if host send more not expected transfers, t=
hen only
> + * the last will be saved and returned to gadget function.
> + * Such blocking situation was observed on ACM gadget, because host send=
 OUT
> + * data packet but ACM function doesn't want their.
> + */
> +static void cdns3_descmissing_packet(struct cdns3_endpoint *priv_ep)
> +{
> +       struct cdns3_request *priv_req =3D priv_ep->descmis_req;
> +       struct usb_request *request;
> +
> +       if (!priv_req) {
> +               request =3D cdns3_gadget_ep_alloc_request(&priv_ep->endpo=
int,
> +                                                       GFP_ATOMIC);
> +               priv_req =3D to_cdns3_request(request);
> +               priv_req->flags |=3D REQUEST_INTERNAL;
> +               priv_req->request.buf =3D kzalloc(CDNS3_DESCMIS_BUF_SIZE,
> +                                               GFP_ATOMIC);
> +               priv_req->request.length =3D CDNS3_DESCMIS_BUF_SIZE;
> +               priv_ep->descmis_req =3D priv_req;
> +       }
> +
> +       priv_ep->descmis_finished =3D false;
> +       __cdns3_gadget_ep_queue(&priv_ep->endpoint,
> +                               &priv_ep->descmis_req->request,
> +                               GFP_ATOMIC);
> +}
> +
> +/**
> + * cdns3_check_ep_interrupt_proceed - Processes interrupt related to end=
point
> + * @priv_ep: endpoint object
> + *
> + * Returns 0
> + */
> +static int cdns3_check_ep_interrupt_proceed(struct cdns3_endpoint *priv_=
ep)
> +{
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       u32 ep_sts_reg;
> +
> +       cdns3_select_ep(priv_dev, priv_ep->endpoint.address);
> +       ep_sts_reg =3D readl(&priv_dev->regs->ep_sts);
> +       writel(ep_sts_reg, &priv_dev->regs->ep_sts);
> +
> +       trace_cdns3_epx_irq(priv_ep);
> +
> +       if ((ep_sts_reg & EP_STS_IOC) || (ep_sts_reg & EP_STS_ISP))
> +               cdns3_transfer_completed(priv_dev, priv_ep);
> +
> +       if (ep_sts_reg & EP_STS_DESCMIS)
> +               cdns3_descmissing_packet(priv_ep);
> +
> +       return 0;
> +}
> +
> +/**
> + * cdns3_check_usb_interrupt_proceed - Processes interrupt related to de=
vice
> + * @priv_dev: extended gadget object
> + * @usb_ists: bitmap representation of device's reported interrupts
> + * (usb_ists register value)
> + */
> +static void cdns3_check_usb_interrupt_proceed(struct cdns3_device *priv_=
dev,
> +                                             u32 usb_ists)
> +{
> +       int speed =3D 0;
> +
> +       trace_cdns3_usb_irq(priv_dev, usb_ists);
> +       /* Connection detected */
> +       if (usb_ists & (USB_ISTS_CON2I | USB_ISTS_CONI)) {
> +               speed =3D cdns3_get_speed(priv_dev);
> +               priv_dev->gadget.speed =3D speed;
> +               usb_gadget_set_state(&priv_dev->gadget, USB_STATE_POWERED=
);
> +               cdns3_ep0_config(priv_dev);
> +       }
> +
> +       /* Disconnection detected */
> +       if (usb_ists & (USB_ISTS_DIS2I | USB_ISTS_DISI)) {
> +               if (priv_dev->gadget_driver &&
> +                   priv_dev->gadget_driver->disconnect) {
> +                       spin_unlock(&priv_dev->lock);
> +                       priv_dev->gadget_driver->disconnect(&priv_dev->ga=
dget);
> +                       spin_lock(&priv_dev->lock);
> +               }
> +
> +               priv_dev->gadget.speed =3D USB_SPEED_UNKNOWN;
> +               usb_gadget_set_state(&priv_dev->gadget, USB_STATE_NOTATTA=
CHED);
> +               cdns3_gadget_unconfig(priv_dev);
> +       }
> +
> +       /* reset*/
> +       if (usb_ists & (USB_ISTS_UWRESI | USB_ISTS_UHRESI | USB_ISTS_U2RE=
SI)) {
> +               /*read again to check the actuall speed*/
> +               speed =3D cdns3_get_speed(priv_dev);
> +               usb_gadget_set_state(&priv_dev->gadget, USB_STATE_DEFAULT=
);
> +               priv_dev->gadget.speed =3D speed;
> +               cdns3_gadget_unconfig(priv_dev);
> +               cdns3_ep0_config(priv_dev);
> +       }
> +}
> +
> +/**
> + * cdns3_device_irq_handler- interrupt handler for device part of contro=
ller
> + *
> + * @irq: irq number for cdns3 core device
> + * @data: structure of cdns3
> + *
> + * Returns IRQ_HANDLED or IRQ_NONE
> + */
> +static irqreturn_t cdns3_device_irq_handler(int irq, void *data)
> +{
> +       struct cdns3_device *priv_dev;
> +       struct cdns3 *cdns =3D data;
> +       irqreturn_t ret =3D IRQ_NONE;
> +       unsigned long flags;
> +       u32 reg;
> +
> +       priv_dev =3D cdns->gadget_dev;
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +
> +       /* check USB device interrupt */
> +       reg =3D readl(&priv_dev->regs->usb_ists);
> +       writel(reg, &priv_dev->regs->usb_ists);
> +
> +       if (reg) {
> +               dev_dbg(priv_dev->dev, "IRQ: usb_ists: %08X\n", reg);
> +               cdns3_check_usb_interrupt_proceed(priv_dev, reg);
> +               ret =3D IRQ_HANDLED;
> +       }
> +
> +       /* check endpoint interrupt */
> +       reg =3D readl(&priv_dev->regs->ep_ists);
> +
> +       /* handle default endpoint OUT */
> +       if (reg & EP_ISTS_EP_OUT0) {
> +               cdns3_check_ep0_interrupt_proceed(priv_dev, USB_DIR_OUT);
> +               ret =3D IRQ_HANDLED;
> +       }
> +
> +       /* handle default endpoint IN */
> +       if (reg & EP_ISTS_EP_IN0) {
> +               cdns3_check_ep0_interrupt_proceed(priv_dev, USB_DIR_IN);
> +               ret =3D IRQ_HANDLED;
> +       }
> +
> +       /* check if interrupt from non default endpoint, if no exit */
> +       reg &=3D ~(EP_ISTS_EP_OUT0 | EP_ISTS_EP_IN0);
> +       if (!reg)
> +               goto irqend;
> +
> +       do {
> +               unsigned int bit_pos =3D ffs(reg);
> +               u32 bit_mask =3D 1 << (bit_pos - 1);
> +               int index;
> +
> +               index =3D cdns3_ep_reg_pos_to_index(bit_pos);
> +               cdns3_check_ep_interrupt_proceed(priv_dev->eps[index]);
> +               reg &=3D ~bit_mask;
> +               ret =3D IRQ_HANDLED;
> +       } while (reg);
> +
> +irqend:
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return ret;
> +}
> +
> +/**
> + * cdns3_ep_onchip_buffer_reserve - Try to reserve onchip buf for EP
> + *
> + * The real reservation will occur during write to EP_CFG register,
> + * this function is used to check if the 'size' reservation is allowed.
> + *
> + * @priv_dev: extended gadget object
> + * @size: the size (KB) for EP would like to allocate
> + *
> + * Return 0 if the required size can met or negative value on failure
> + */
> +static int cdns3_ep_onchip_buffer_reserve(struct cdns3_device *priv_dev,
> +                                         int size)
> +{
> +       u32 onchip_mem;
> +
> +       priv_dev->onchip_mem_allocated_size +=3D size;
> +
> +       onchip_mem =3D USB_CAP2_ACTUAL_MEM_SIZE(readl(&priv_dev->regs->us=
b_cap2));
> +       if (!onchip_mem)
> +               onchip_mem =3D 256;
> +
> +       /* 2KB is reserved for EP0*/
> +       onchip_mem -=3D 2;
> +       if (priv_dev->onchip_mem_allocated_size > onchip_mem) {
> +               priv_dev->onchip_mem_allocated_size -=3D size;
> +               return -EPERM;
> +       }
> +
> +       return 0;
> +}
> +
> +/**
> + * cdns3_ep_config Configure hardware endpoint
> + * @priv_ep: extended endpoint object
> + */
> +void cdns3_ep_config(struct cdns3_endpoint *priv_ep)
> +{
> +       bool is_iso_ep =3D (priv_ep->type =3D=3D USB_ENDPOINT_XFER_ISOC);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       u32 bEndpointAddress =3D priv_ep->num | priv_ep->dir;
> +       u32 interrupt_mask =3D EP_STS_EN_TRBERREN;
> +       u32 max_packet_size =3D 0;
> +       u32 ep_cfg =3D 0;
> +       int ret;
> +
> +       if (!priv_ep->dir)
> +               interrupt_mask |=3D EP_STS_EN_DESCMISEN;
> +
> +       if (priv_ep->type =3D=3D USB_ENDPOINT_XFER_INT) {
> +               ep_cfg =3D EP_CFG_EPTYPE(USB_ENDPOINT_XFER_INT);
> +       } else if (priv_ep->type =3D=3D USB_ENDPOINT_XFER_BULK) {
> +               ep_cfg =3D EP_CFG_EPTYPE(USB_ENDPOINT_XFER_BULK);
> +       } else {
> +               ep_cfg =3D EP_CFG_EPTYPE(USB_ENDPOINT_XFER_ISOC);
> +               interrupt_mask =3D 0xFFFFFFFF;
> +       }
> +
> +       switch (priv_dev->gadget.speed) {
> +       case USB_SPEED_FULL:
> +               max_packet_size =3D is_iso_ep ? 1023 : 64;
> +               break;
> +       case USB_SPEED_HIGH:
> +               max_packet_size =3D is_iso_ep ? 1024 : 512;
> +               break;
> +       case USB_SPEED_SUPER:
> +               max_packet_size =3D 1024;
> +               break;
> +       default:
> +               /* all other speed are not supported */
> +               return;
> +       }
> +
> +       ret =3D cdns3_ep_onchip_buffer_reserve(priv_dev, CDNS3_EP_BUF_SIZ=
E);
> +       if (ret) {
> +               dev_err(priv_dev->dev, "onchip mem is full, ep is invalid=
\n");
> +               return;
> +       }
> +
> +       ep_cfg |=3D EP_CFG_MAXPKTSIZE(max_packet_size) |
> +                 EP_CFG_BUFFERING(CDNS3_EP_BUF_SIZE - 1) |
> +                 EP_CFG_MAXBURST(priv_ep->endpoint.maxburst);
> +
> +       cdns3_select_ep(priv_dev, bEndpointAddress);
> +
> +       writel(ep_cfg, &priv_dev->regs->ep_cfg);
> +       writel(interrupt_mask, &priv_dev->regs->ep_sts_en);
> +
> +       dev_dbg(priv_dev->dev, "Configure %s: with val %08x\n",
> +               priv_ep->name, ep_cfg);
> +
> +       /* enable interrupt for selected endpoint */
> +       cdns3_set_register_bit(&priv_dev->regs->ep_ien,
> +                              cdns3_ep_addr_to_bit_pos(bEndpointAddress)=
);
> +}
> +
> +/* Find correct direction for HW endpoint according to description */
> +static int cdns3_ep_dir_is_correct(struct usb_endpoint_descriptor *desc,
> +                                  struct cdns3_endpoint *priv_ep)
> +{
> +       return (priv_ep->endpoint.caps.dir_in && usb_endpoint_dir_in(desc=
)) ||
> +              (priv_ep->endpoint.caps.dir_out && usb_endpoint_dir_out(de=
sc));
> +}
> +
> +static struct
> +cdns3_endpoint *cdns3_find_available_ep(struct cdns3_device *priv_dev,
> +                                       struct usb_endpoint_descriptor *d=
esc)
> +{
> +       struct usb_ep *ep;
> +       struct cdns3_endpoint *priv_ep;
> +
> +       list_for_each_entry(ep, &priv_dev->gadget.ep_list, ep_list) {
> +               unsigned long num;
> +               int ret;
> +               /* ep name pattern likes epXin or epXout */
> +               char c[2] =3D {ep->name[2], '\0'};
> +
> +               ret =3D kstrtoul(c, 10, &num);
> +               if (ret)
> +                       return ERR_PTR(ret);
> +
> +               priv_ep =3D ep_to_cdns3_ep(ep);
> +               if (cdns3_ep_dir_is_correct(desc, priv_ep)) {
> +                       if (!(priv_ep->flags & EP_CLAIMED)) {
> +                               priv_ep->num  =3D num;
> +                               return priv_ep;
> +                       }
> +               }
> +       }
> +       return ERR_PTR(-ENOENT);
> +}
> +
> +static struct
> +usb_ep *cdns3_gadget_match_ep(struct usb_gadget *gadget,
> +                             struct usb_endpoint_descriptor *desc,
> +                             struct usb_ss_ep_comp_descriptor *comp_desc=
)
> +{
> +       struct cdns3_device *priv_dev =3D gadget_to_cdns3_device(gadget);
> +       struct cdns3_endpoint *priv_ep;
> +       unsigned long flags;
> +
> +       priv_ep =3D cdns3_find_available_ep(priv_dev, desc);
> +       if (IS_ERR(priv_ep)) {
> +               dev_err(priv_dev->dev, "no available ep\n");
> +               return NULL;
> +       }
> +
> +       dev_dbg(priv_dev->dev, "match endpoint: %s\n", priv_ep->name);
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       priv_ep->endpoint.desc =3D desc;
> +       priv_ep->dir  =3D usb_endpoint_dir_in(desc) ? USB_DIR_IN : USB_DI=
R_OUT;
> +       priv_ep->type =3D usb_endpoint_type(desc);
> +       priv_ep->flags |=3D EP_CLAIMED;
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return &priv_ep->endpoint;
> +}
> +
> +/**
> + * cdns3_gadget_ep_alloc_request Allocates request
> + * @ep: endpoint object associated with request
> + * @gfp_flags: gfp flags
> + *
> + * Returns allocated request address, NULL on allocation error
> + */
> +struct usb_request *cdns3_gadget_ep_alloc_request(struct usb_ep *ep,
> +                                                 gfp_t gfp_flags)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_request *priv_req;
> +
> +       priv_req =3D kzalloc(sizeof(*priv_req), gfp_flags);
> +       if (!priv_req)
> +               return NULL;
> +
> +       priv_req->priv_ep =3D priv_ep;
> +
> +       trace_cdns3_alloc_request(priv_req);
> +       return &priv_req->request;
> +}
> +
> +/**
> + * cdns3_gadget_ep_free_request Free memory occupied by request
> + * @ep: endpoint object associated with request
> + * @request: request to free memory
> + */
> +void cdns3_gadget_ep_free_request(struct usb_ep *ep,
> +                                 struct usb_request *request)
> +{
> +       struct cdns3_request *priv_req =3D to_cdns3_request(request);
> +
> +       trace_cdns3_free_request(priv_req);
> +       kfree(priv_req);
> +}
> +
> +/**
> + * cdns3_gadget_ep_enable Enable endpoint
> + * @ep: endpoint object
> + * @desc: endpoint descriptor
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +static int cdns3_gadget_ep_enable(struct usb_ep *ep,
> +                                 const struct usb_endpoint_descriptor *d=
esc)
> +{
> +       struct cdns3_endpoint *priv_ep;
> +       struct cdns3_device *priv_dev;
> +       unsigned long flags;
> +       int ret;
> +       u32 reg;
> +
> +       priv_ep =3D ep_to_cdns3_ep(ep);
> +       priv_dev =3D priv_ep->cdns3_dev;
> +
> +       if (!ep || !desc || desc->bDescriptorType !=3D USB_DT_ENDPOINT) {
> +               dev_dbg(priv_dev->dev, "usbss: invalid parameters\n");
> +               return -EINVAL;
> +       }
> +
> +       if (!desc->wMaxPacketSize) {
> +               dev_err(priv_dev->dev, "usbss: missing wMaxPacketSize\n")=
;
> +               return -EINVAL;
> +       }
> +
> +       if (dev_WARN_ONCE(priv_dev->dev, priv_ep->flags & EP_ENABLED,
> +                         "%s is already enabled\n", priv_ep->name))
> +               return 0;
> +
> +       ret =3D cdns3_allocate_trb_pool(priv_ep);
> +       if (ret)
> +               return ret;
> +
> +       trace_cdns3_gadget_ep_enable(priv_ep);
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +
> +       priv_ep->endpoint.desc =3D desc;
> +       priv_ep->dir =3D usb_endpoint_dir_in(desc) ? USB_DIR_IN : USB_DIR=
_OUT;
> +       priv_ep->type =3D usb_endpoint_type(desc);
> +
> +       cdns3_select_ep(priv_dev, desc->bEndpointAddress);
> +       writel(EP_CMD_EPRST, &priv_dev->regs->ep_cmd);
> +
> +       ret =3D cdns3_handshake(&priv_dev->regs->ep_cmd,
> +                             EP_CMD_CSTALL | EP_CMD_EPRST, 0, 100);
> +
> +       cdns3_set_register_bit(&priv_dev->regs->ep_cfg, EP_CFG_ENABLE);
> +
> +       ep->desc =3D desc;
> +       priv_ep->flags &=3D ~(EP_PENDING_REQUEST | EP_STALL);
> +       priv_ep->flags |=3D EP_ENABLED | EP_UPDATE_EP_TRBADDR;
> +       priv_ep->enqueue =3D 0;
> +       priv_ep->dequeue =3D 0;
> +       reg =3D readl(&priv_dev->regs->ep_sts);
> +       priv_ep->pcs =3D !!EP_STS_CCS(reg);
> +       priv_ep->ccs =3D !!EP_STS_CCS(reg);
> +       /* one TRB is reserved for link TRB used in DMULT mode*/
> +       priv_ep->free_trbs =3D TRBS_PER_SEGMENT - 1;
> +
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return 0;
> +}
> +
> +/**
> + * cdns3_gadget_ep_disable Disable endpoint
> + * @ep: endpoint object
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +static int cdns3_gadget_ep_disable(struct usb_ep *ep)
> +{
> +       struct cdns3_endpoint *priv_ep;
> +       struct cdns3_device *priv_dev;
> +       unsigned long flags;
> +       int ret =3D 0;
> +       struct usb_request *request;
> +       u32 ep_cfg;
> +
> +       if (!ep) {
> +               dev_dbg(priv_dev->dev, "usbss: invalid parameters\n");
> +               return -EINVAL;
> +       }
> +
> +       priv_ep =3D ep_to_cdns3_ep(ep);
> +       priv_dev =3D priv_ep->cdns3_dev;
> +
> +       if (dev_WARN_ONCE(priv_dev->dev, !(priv_ep->flags & EP_ENABLED),
> +                         "%s is already disabled\n", priv_ep->name))
> +               return 0;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +
> +       trace_cdns3_gadget_ep_disable(priv_ep);
> +
> +       cdns3_select_ep(priv_dev, ep->desc->bEndpointAddress);
> +       ret =3D cdns3_data_flush(priv_ep);
> +
> +       ep_cfg =3D readl(&priv_dev->regs->ep_cfg);
> +       ep_cfg &=3D ~EP_CFG_ENABLE;
> +       writel(ep_cfg, &priv_dev->regs->ep_cfg);
> +
> +       while (!list_empty(&priv_ep->request_list)) {
> +               request =3D cdns3_next_request(&priv_ep->request_list);
> +
> +               cdns3_gadget_giveback(priv_ep, to_cdns3_request(request),
> +                                     -ESHUTDOWN);
> +       }
> +
> +       if (priv_ep->descmis_req) {
> +               kfree(priv_ep->descmis_req->request.buf);
> +               cdns3_gadget_ep_free_request(&priv_ep->endpoint,
> +                                            &priv_ep->descmis_req->reque=
st);
> +               priv_ep->descmis_req =3D NULL;
> +               priv_ep->descmis_pending =3D false;
> +               priv_ep->descmis_finished =3D false;
> +       }
> +
> +       ep->desc =3D NULL;
> +       priv_ep->flags &=3D ~EP_ENABLED;
> +
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +
> +       return ret;
> +}
> +
> +/**
> + * cdns3_gadget_ep_queue Transfer data on endpoint
> + * @ep: endpoint object
> + * @request: request object
> + * @gfp_flags: gfp flags
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +static int __cdns3_gadget_ep_queue(struct usb_ep *ep,
> +                                  struct usb_request *request,
> +                                  gfp_t gfp_flags)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct cdns3_request *priv_req;
> +       int ret =3D 0;
> +
> +       request->actual =3D 0;
> +       request->status =3D -EINPROGRESS;
> +       priv_req =3D to_cdns3_request(request);
> +
> +       trace_cdns3_ep_queue(priv_req);
> +
> +       /* Data will be copied from internal usb_request object. */
> +       if (priv_ep->descmis_finished) {
> +               priv_ep->descmis_finished =3D false;
> +               request->actual =3D priv_ep->descmis_req->request.actual;
> +
> +               memcpy(request->buf, priv_ep->descmis_req->request.buf,
> +                      priv_ep->descmis_req->request.actual);
> +               list_add_tail(&request->list, &priv_ep->request_list);
> +
> +               cdns3_gadget_giveback(priv_ep,
> +                                     priv_req,
> +                                     priv_ep->descmis_req->request.statu=
s);
> +
> +               return ret;
> +       }
> +
> +       ret =3D usb_gadget_map_request_by_dev(priv_dev->sysdev, request,
> +                                           usb_endpoint_dir_in(ep->desc)=
);
> +       if (ret)
> +               return ret;
> +
> +       list_add_tail(&request->list, &priv_ep->request_list);
> +
> +       cdns3_ep_run_transfer(priv_ep, request);
> +
> +       return ret;
> +}
> +
> +static int cdns3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *=
request,
> +                                gfp_t gfp_flags)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct usb_request *zlp_request;
> +       unsigned long flags;
> +       int ret;
> +
> +       if (!request || !ep)
> +               return -EINVAL;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       ret =3D __cdns3_gadget_ep_queue(ep, request, gfp_flags);
> +
> +       if (ret =3D=3D 0 && request->zero && request->length &&
> +           (request->length % ep->maxpacket =3D=3D 0)) {
> +               struct cdns3_request *priv_req;
> +
> +               zlp_request =3D cdns3_gadget_ep_alloc_request(ep, GFP_ATO=
MIC);
> +               zlp_request->buf =3D priv_dev->zlp_buf;
> +               zlp_request->length =3D 0;
> +
> +               priv_req =3D to_cdns3_request(zlp_request);
> +               priv_req->flags |=3D REQUEST_ZLP;
> +
> +               dev_dbg(priv_dev->dev, "Queuing ZLP for endpoint: %s\n",
> +                       priv_ep->name);
> +               ret =3D __cdns3_gadget_ep_queue(ep, zlp_request, gfp_flag=
s);
> +       }
> +
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return ret;
> +}
> +
> +/**
> + * cdns3_gadget_ep_dequeue Remove request from transfer queue
> + * @ep: endpoint object associated with request
> + * @request: request object
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +int cdns3_gadget_ep_dequeue(struct usb_ep *ep,
> +                           struct usb_request *request)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       struct usb_request *req, *req_temp;
> +       struct cdns3_request *priv_req;
> +       unsigned long flags;
> +       int ret =3D 0;
> +
> +       if (!ep || !request || !ep->desc)
> +               return -EINVAL;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +
> +       priv_req =3D to_cdns3_request(request);
> +
> +       trace_cdns3_ep_dequeue(priv_req);
> +
> +       cdns3_select_ep(priv_dev, ep->desc->bEndpointAddress);
> +
> +       list_for_each_entry_safe(req, req_temp, &priv_ep->request_list, l=
ist) {
> +               if (request =3D=3D req) {
> +                       cdns3_gadget_giveback(priv_ep,
> +                                             priv_req,
> +                                             -ECONNRESET);
> +                       break;
> +               }
> +       }
> +
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return ret;
> +}
> +
> +/**
> + * cdns3_gadget_ep_set_halt Sets/clears stall on selected endpoint
> + * @ep: endpoint object to set/clear stall on
> + * @value: 1 for set stall, 0 for clear stall
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +int cdns3_gadget_ep_set_halt(struct usb_ep *ep, int value)
> +{
> +       struct cdns3_endpoint *priv_ep =3D ep_to_cdns3_ep(ep);
> +       struct cdns3_device *priv_dev =3D priv_ep->cdns3_dev;
> +       unsigned long flags;
> +       int ret =3D 0;
> +
> +       if (!(priv_ep->flags & EP_ENABLED))
> +               return -EPERM;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +
> +       /* if actual transfer is pending defer setting stall on this endp=
oint */
> +       if ((priv_ep->flags & EP_PENDING_REQUEST) && value) {
> +               priv_ep->flags |=3D EP_STALL;
> +               goto finish;
> +       }
> +
> +       dev_dbg(priv_dev->dev, "Halt endpoint %s\n", priv_ep->name);
> +
> +       cdns3_select_ep(priv_dev, ep->desc->bEndpointAddress);
> +       if (value) {
> +               cdns3_ep_stall_flush(priv_ep);
> +       } else {
> +               priv_ep->flags &=3D ~EP_WEDGE;
> +               writel(EP_CMD_CSTALL | EP_CMD_EPRST, &priv_dev->regs->ep_=
cmd);
> +
> +               /* wait for EPRST cleared */
> +               ret =3D cdns3_handshake(&priv_dev->regs->ep_cmd,
> +                                     EP_CMD_EPRST, 0, 100);
> +               if (unlikely(ret)) {
> +                       dev_err(priv_dev->dev,
> +                               "Clearing halt condition failed for %s\n"=
,
> +                               priv_ep->name);
> +                       goto finish;
> +
> +               } else {
> +                       priv_ep->flags &=3D ~EP_STALL;
> +               }
> +       }
> +
> +       priv_ep->flags &=3D ~EP_PENDING_REQUEST;
> +finish:
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +
> +       return ret;
> +}
> +
> +extern const struct usb_ep_ops cdns3_gadget_ep0_ops;
> +
> +static const struct usb_ep_ops cdns3_gadget_ep_ops =3D {
> +       .enable =3D cdns3_gadget_ep_enable,
> +       .disable =3D cdns3_gadget_ep_disable,
> +       .alloc_request =3D cdns3_gadget_ep_alloc_request,
> +       .free_request =3D cdns3_gadget_ep_free_request,
> +       .queue =3D cdns3_gadget_ep_queue,
> +       .dequeue =3D cdns3_gadget_ep_dequeue,
> +       .set_halt =3D cdns3_gadget_ep_set_halt,
> +       .set_wedge =3D cdns3_gadget_ep_set_wedge,
> +};
> +
> +/**
> + * cdns3_gadget_get_frame Returns number of actual ITP frame
> + * @gadget: gadget object
> + *
> + * Returns number of actual ITP frame
> + */
> +static int cdns3_gadget_get_frame(struct usb_gadget *gadget)
> +{
> +       struct cdns3_device *priv_dev =3D gadget_to_cdns3_device(gadget);
> +
> +       return readl(&priv_dev->regs->usb_iptn);
> +}
> +
> +static int cdns3_gadget_wakeup(struct usb_gadget *gadget)
> +{
> +       return 0;
> +}
> +
> +static int cdns3_gadget_set_selfpowered(struct usb_gadget *gadget,
> +                                       int is_selfpowered)
> +{
> +       struct cdns3_device *priv_dev =3D gadget_to_cdns3_device(gadget);
> +       unsigned long flags;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       priv_dev->is_selfpowered =3D !!is_selfpowered;
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return 0;
> +}
> +
> +static int cdns3_gadget_pullup(struct usb_gadget *gadget, int is_on)
> +{
> +       struct cdns3_device *priv_dev =3D gadget_to_cdns3_device(gadget);
> +
> +       if (is_on)
> +               writel(USB_CONF_DEVEN, &priv_dev->regs->usb_conf);
> +       else
> +               writel(USB_CONF_DEVDS, &priv_dev->regs->usb_conf);
> +
> +       return 0;
> +}
> +
> +static void cdns3_gadget_config(struct cdns3_device *priv_dev)
> +{
> +       struct cdns3_usb_regs __iomem *regs =3D priv_dev->regs;
> +
> +       cdns3_ep0_config(priv_dev);
> +
> +       /* enable interrupts for endpoint 0 (in and out) */
> +       writel(EP_IEN_EP_OUT0 | EP_IEN_EP_IN0, &regs->ep_ien);
> +
> +       /* enable generic interrupt*/
> +       writel(USB_IEN_INIT, &regs->usb_ien);
> +       writel(USB_CONF_CLK2OFFDS | USB_CONF_L1DS, &regs->usb_conf);
> +       writel(USB_CONF_DMULT, &regs->usb_conf);
> +       writel(USB_CONF_DEVEN, &regs->usb_conf);
> +}
> +
> +/**
> + * cdns3_gadget_udc_start Gadget start
> + * @gadget: gadget object
> + * @driver: driver which operates on this gadget
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +static int cdns3_gadget_udc_start(struct usb_gadget *gadget,
> +                                 struct usb_gadget_driver *driver)
> +{
> +       struct cdns3_device *priv_dev =3D gadget_to_cdns3_device(gadget);
> +       unsigned long flags;
> +
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       priv_dev->gadget_driver =3D driver;
> +       cdns3_gadget_config(priv_dev);
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return 0;
> +}
> +
> +/**
> + * cdns3_gadget_udc_stop Stops gadget
> + * @gadget: gadget object
> + *
> + * Returns 0
> + */
> +static int cdns3_gadget_udc_stop(struct usb_gadget *gadget)
> +{
> +       struct cdns3_device *priv_dev =3D gadget_to_cdns3_device(gadget);
> +       struct cdns3_endpoint *priv_ep;
> +       u32 bEndpointAddress;
> +       struct usb_ep *ep;
> +       int ret =3D 0;
> +       int i;
> +
> +       priv_dev->gadget_driver =3D NULL;
> +
> +       priv_dev->onchip_mem_allocated_size =3D 0;
> +       priv_dev->gadget.speed =3D USB_SPEED_UNKNOWN;
> +
> +       for (i =3D 0; i < priv_dev->ep_nums ; i++)
> +               cdns3_free_trb_pool(priv_dev->eps[i]);
> +
> +       list_for_each_entry(ep, &priv_dev->gadget.ep_list, ep_list) {
> +               priv_ep =3D ep_to_cdns3_ep(ep);
> +               bEndpointAddress =3D priv_ep->num | priv_ep->dir;
> +               cdns3_select_ep(priv_dev, bEndpointAddress);
> +               writel(EP_CMD_EPRST, &priv_dev->regs->ep_cmd);
> +               ret =3D cdns3_handshake(&priv_dev->regs->ep_cmd,
> +                                     EP_CMD_EPRST, 0, 100);
> +       }
> +
> +       /* disable interrupt for device */
> +       writel(0, &priv_dev->regs->usb_ien);
> +       writel(USB_CONF_DEVDS, &priv_dev->regs->usb_conf);
> +
> +       return ret;
> +}
> +
> +static const struct usb_gadget_ops cdns3_gadget_ops =3D {
> +       .get_frame =3D cdns3_gadget_get_frame,
> +       .wakeup =3D cdns3_gadget_wakeup,
> +       .set_selfpowered =3D cdns3_gadget_set_selfpowered,
> +       .pullup =3D cdns3_gadget_pullup,
> +       .udc_start =3D cdns3_gadget_udc_start,
> +       .udc_stop =3D cdns3_gadget_udc_stop,
> +       .match_ep =3D cdns3_gadget_match_ep,
> +};
> +
> +static void cdns3_free_all_ep(struct cdns3_device *priv_dev)
> +{
> +       int i;
> +
> +       for (i =3D 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++)
> +               if (priv_dev->eps[i])
> +                       devm_kfree(priv_dev->dev, priv_dev->eps[i]);
> +
> +       if (priv_dev->gadget.ep0)
> +               devm_kfree(priv_dev->dev, priv_dev->gadget.ep0);
> +}
> +
> +/**
> + * cdns3_init_ep Initializes software endpoints of gadget
> + * @cdns3: extended gadget object
> + *
> + * Returns 0 on success, error code elsewhere
> + */
> +static int cdns3_init_ep(struct cdns3_device *priv_dev)
> +{
> +       u32 ep_enabled_reg, iso_ep_reg;
> +       struct cdns3_endpoint *priv_ep;
> +       int found_endpoints =3D 0;
> +       int ep_dir, ep_number;
> +       u32 ep_mask;
> +       int i;
> +
> +       /* Read it from USB_CAP3 to USB_CAP5 */
> +       ep_enabled_reg =3D readl(&priv_dev->regs->usb_cap3);
> +       iso_ep_reg =3D readl(&priv_dev->regs->usb_cap4);
> +
> +       dev_dbg(priv_dev->dev, "Initializing non-zero endpoints\n");
> +
> +       for (i =3D 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++) {
> +               ep_number =3D (i / 2) + 1;
> +               ep_dir =3D i % 2;
> +               ep_mask =3D BIT((16 * ep_dir) + ep_number);
> +
> +               if (!(ep_enabled_reg & ep_mask))
> +                       continue;
> +
> +               priv_ep =3D devm_kzalloc(priv_dev->dev, sizeof(*priv_ep),
> +                                      GFP_KERNEL);
> +               if (!priv_ep)
> +                       return -ENOMEM;
> +
> +               /* set parent of endpoint object */
> +               priv_ep->cdns3_dev =3D priv_dev;
> +               priv_dev->eps[found_endpoints++] =3D priv_ep;
> +
> +               snprintf(priv_ep->name, sizeof(priv_ep->name), "ep%d%s",
> +                        ep_number, !!ep_dir ? "in" : "out");
> +               priv_ep->endpoint.name =3D priv_ep->name;
> +
> +               usb_ep_set_maxpacket_limit(&priv_ep->endpoint,
> +                                          CDNS3_EP_MAX_PACKET_LIMIT);
> +               priv_ep->endpoint.max_streams =3D CDNS3_EP_MAX_STREAMS;
> +               priv_ep->endpoint.ops =3D &cdns3_gadget_ep_ops;
> +               if (ep_dir)
> +                       priv_ep->endpoint.caps.dir_in =3D 1;
> +               else
> +                       priv_ep->endpoint.caps.dir_out =3D 1;
> +
> +               if (iso_ep_reg & ep_mask)
> +                       priv_ep->endpoint.caps.type_iso =3D 1;
> +
> +               priv_ep->endpoint.caps.type_bulk =3D 1;
> +               priv_ep->endpoint.caps.type_int =3D 1;
> +               priv_ep->endpoint.maxburst =3D CDNS3_EP_BUF_SIZE - 1;
> +
> +               priv_ep->flags =3D 0;
> +
> +               dev_info(priv_dev->dev, "Initialized  %s support: %s %s\n=
",
> +                        priv_ep->name,
> +                        priv_ep->endpoint.caps.type_bulk ? "BULK, INT" :=
 "",
> +                        priv_ep->endpoint.caps.type_iso ? "ISO" : "");
> +
> +               list_add_tail(&priv_ep->endpoint.ep_list,
> +                             &priv_dev->gadget.ep_list);
> +               INIT_LIST_HEAD(&priv_ep->request_list);
> +       }
> +
> +       priv_dev->ep_nums =3D found_endpoints;
> +       return 0;
> +}
> +
> +static void cdns3_gadget_disable(struct cdns3 *cdns)
> +{
> +       struct cdns3_device *priv_dev;
> +
> +       priv_dev =3D cdns->gadget_dev;
> +
> +       if (priv_dev->gadget_driver)
> +               priv_dev->gadget_driver->disconnect(&priv_dev->gadget);
> +
> +       usb_gadget_disconnect(&priv_dev->gadget);
> +       priv_dev->gadget.speed =3D USB_SPEED_UNKNOWN;
> +}
> +
> +void cdns3_gadget_exit(struct cdns3 *cdns)
> +{
> +       struct cdns3_device *priv_dev;
> +
> +       priv_dev =3D cdns->gadget_dev;
> +
> +       cdns3_gadget_disable(cdns);
> +
> +       devm_free_irq(cdns->dev, cdns->irq, cdns);
> +
> +       pm_runtime_mark_last_busy(cdns->dev);
> +       pm_runtime_put_autosuspend(cdns->dev);
> +
> +       usb_del_gadget_udc(&priv_dev->gadget);
> +
> +       cdns3_free_all_ep(priv_dev);
> +
> +       dma_free_coherent(priv_dev->sysdev, 8, priv_dev->setup_buf,
> +                         priv_dev->setup_dma);
> +       dma_free_coherent(priv_dev->sysdev, TRB_SIZE * 2, priv_dev->ep0_t=
rb,
> +                         priv_dev->ep0_trb_dma);
> +
> +       kfree(priv_dev->zlp_buf);
> +       kfree(priv_dev);
> +       cdns->gadget_dev =3D NULL;
> +}
> +
> +static int cdns3_gadget_start(struct cdns3 *cdns)
> +{
> +       struct cdns3_device *priv_dev;
> +       u32 max_speed;
> +       int ret;
> +
> +       priv_dev =3D kzalloc(sizeof(*priv_dev), GFP_KERNEL);
> +       if (!priv_dev)
> +               return -ENOMEM;
> +
> +       cdns->gadget_dev =3D priv_dev;
> +       priv_dev->sysdev =3D cdns->dev;
> +       priv_dev->dev =3D cdns->dev;
> +       priv_dev->regs =3D cdns->dev_regs;
> +
> +       max_speed =3D usb_get_maximum_speed(cdns->dev);
> +
> +       /* Check the maximum_speed parameter */
> +       switch (max_speed) {
> +       case USB_SPEED_FULL:
> +       case USB_SPEED_HIGH:
> +       case USB_SPEED_SUPER:
> +               break;
> +       default:
> +               dev_err(cdns->dev, "invalid maximum_speed parameter %d\n"=
,
> +                       max_speed);
> +               /* fall through */
> +       case USB_SPEED_UNKNOWN:
> +               /* default to superspeed */
> +               max_speed =3D USB_SPEED_SUPER;
> +               break;
> +       }
> +
> +       /* fill gadget fields */
> +       priv_dev->gadget.max_speed =3D max_speed;
> +       priv_dev->gadget.speed =3D USB_SPEED_UNKNOWN;
> +       priv_dev->gadget.ops =3D &cdns3_gadget_ops;
> +       priv_dev->gadget.name =3D "usb-ss-gadget";
> +       priv_dev->gadget.sg_supported =3D 1;
> +
> +       spin_lock_init(&priv_dev->lock);
> +       INIT_WORK(&priv_dev->pending_status_wq,
> +                 cdns3_pending_setup_status_handler);
> +
> +       /* initialize endpoint container */
> +       INIT_LIST_HEAD(&priv_dev->gadget.ep_list);
> +
> +       ret =3D cdns3_init_ep0(priv_dev);
> +       if (ret) {
> +               dev_err(priv_dev->dev, "Failed to create endpoint 0\n");
> +               goto err1;
> +       }
> +
> +       ret =3D cdns3_init_ep(priv_dev);
> +       if (ret) {
> +               dev_err(priv_dev->dev, "Failed to create non zero endpoin=
ts\n");
> +               goto err1;
> +       }
> +
> +       /* allocate memory for default endpoint TRB */
> +       priv_dev->ep0_trb =3D dma_alloc_coherent(priv_dev->sysdev, TRB_SI=
ZE * 2,
> +                                              &priv_dev->ep0_trb_dma, GF=
P_DMA);
> +       if (!priv_dev->ep0_trb) {
> +               dev_err(priv_dev->dev, "Failed to allocate memory for ep0=
 TRB\n");
> +               ret =3D -ENOMEM;
> +               goto err1;
> +       }
> +
> +       /* allocate memory for setup packet buffer */
> +       priv_dev->setup_buf =3D dma_alloc_coherent(priv_dev->sysdev, 8,
> +                                                &priv_dev->setup_dma, GF=
P_DMA);
> +       if (!priv_dev->setup_buf) {
> +               dev_err(priv_dev->dev, "Failed to allocate memory for SET=
UP buffer\n");
> +               ret =3D -ENOMEM;
> +               goto err2;
> +       }
> +
> +       dev_dbg(priv_dev->dev, "Device Controller version: %08x\n",
> +               readl(&priv_dev->regs->usb_cap6));
> +       dev_dbg(priv_dev->dev, "USB Capabilities:: %08x\n",
> +               readl(&priv_dev->regs->usb_cap1));
> +       dev_dbg(priv_dev->dev, "On-Chip memory cnfiguration: %08x\n",
> +               readl(&priv_dev->regs->usb_cap2));
> +
> +       priv_dev->zlp_buf =3D kzalloc(CDNS3_EP_ZLP_BUF_SIZE, GFP_KERNEL);
> +       if (!priv_dev->zlp_buf) {
> +               ret =3D -ENOMEM;
> +               goto err3;
> +       }
> +
> +       /* add USB gadget device */
> +       ret =3D usb_add_gadget_udc(priv_dev->dev, &priv_dev->gadget);
> +       if (ret < 0) {
> +               dev_err(priv_dev->dev,
> +                       "Failed to register USB device controller\n");
> +               goto err4;
> +       }
> +
> +       return 0;
> +err4:
> +       kfree(priv_dev->zlp_buf);
> +err3:
> +       dma_free_coherent(priv_dev->sysdev, 8, priv_dev->setup_buf,
> +                         priv_dev->setup_dma);
> +err2:
> +       dma_free_coherent(priv_dev->sysdev, TRB_SIZE * 2, priv_dev->ep0_t=
rb,
> +                         priv_dev->ep0_trb_dma);
> +err1:
> +       cdns->gadget_dev =3D NULL;
> +       return ret;
> +}
> +
> +static int __cdns3_gadget_init(struct cdns3 *cdns)
> +{
> +       struct cdns3_device *priv_dev;
> +       unsigned long flags;
> +       int ret =3D 0;
> +
> +       ret =3D cdns3_gadget_start(cdns);
> +       if (ret)
> +               return ret;
> +
> +       priv_dev =3D cdns->gadget_dev;
> +       ret =3D devm_request_irq(cdns->dev, cdns->irq, cdns3_device_irq_h=
andler,
> +                              IRQF_SHARED, dev_name(cdns->dev), cdns);
> +
> +       if (ret)
> +               goto err0;
> +
> +       pm_runtime_get_sync(cdns->dev);
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return 0;
> +err0:
> +       cdns3_gadget_exit(cdns);
> +       return ret;
> +}
> +
> +static int cdns3_gadget_suspend(struct cdns3 *cdns, bool do_wakeup)
> +{
> +       cdns3_gadget_disable(cdns);
> +       return 0;
> +}
> +
> +static int cdns3_gadget_resume(struct cdns3 *cdns, bool hibernated)
> +{
> +       struct cdns3_device *priv_dev;
> +       unsigned long flags;
> +
> +       priv_dev =3D cdns->gadget_dev;
> +       spin_lock_irqsave(&priv_dev->lock, flags);
> +
> +       if (!priv_dev->gadget_driver) {
> +               spin_unlock_irqrestore(&priv_dev->lock, flags);
> +               return 0;
> +       }
> +
> +       cdns3_gadget_config(priv_dev);
> +       spin_unlock_irqrestore(&priv_dev->lock, flags);
> +       return 0;
> +}
> +
> +/**
> + * cdns3_gadget_init - initialize device structure
> + *
> + * cdns: cdns3 instance
> + *
> + * This function initializes the gadget.
> + */
> +int cdns3_gadget_init(struct cdns3 *cdns)
> +{
> +       struct cdns3_role_driver *rdrv;
> +
> +       rdrv =3D devm_kzalloc(cdns->dev, sizeof(*rdrv), GFP_KERNEL);
> +       if (!rdrv)
> +               return -ENOMEM;
> +
> +       rdrv->start     =3D __cdns3_gadget_init;
> +       rdrv->stop      =3D cdns3_gadget_exit;
> +       rdrv->suspend   =3D cdns3_gadget_suspend;
> +       rdrv->resume    =3D cdns3_gadget_resume;
> +       rdrv->state     =3D CDNS3_ROLE_STATE_INACTIVE;
> +       rdrv->name      =3D "gadget";
> +       cdns->roles[CDNS3_ROLE_GADGET] =3D rdrv;
> +
> +       return 0;
> +}
> diff --git a/drivers/usb/cdns3/gadget.h b/drivers/usb/cdns3/gadget.h
> new file mode 100644
> index 000000000000..db398dff65fc
> --- /dev/null
> +++ b/drivers/usb/cdns3/gadget.h
> @@ -0,0 +1,1177 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * USBSS device controller driver header file
> + *
> + * Copyright (C) 2018 Cadence.
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + *         Pawel Jez <pjez@cadence.com>
> + *         Peter Chen <peter.chen@nxp.com>
> + */
> +#ifndef __LINUX_CDNS3_GADGET
> +#define __LINUX_CDNS3_GADGET
> +#include <linux/usb/gadget.h>
> +
> +/*
> + * USBSS-DEV register interface.
> + * This corresponds to the USBSS Device Controller Interface
> + */
> +
> +/**
> + * struct cdns3_usb_regs - device controller registers.
> + * @usb_conf:      Global Configuration Register.
> + * @usb_sts:       Global Status Register.
> + * @usb_cmd:       Global Command Register.
> + * @usb_iptn:      ITP/SOF number Register.
> + * @usb_lpm:       Global Command Register.
> + * @usb_ien:       USB Interrupt Enable Register.
> + * @usb_ists:      USB Interrupt Status Register.
> + * @ep_sel:        Endpoint Select Register.
> + * @ep_traddr:     Endpoint Transfer Ring Address Register.
> + * @ep_cfg:        Endpoint Configuration Register.
> + * @ep_cmd:        Endpoint Command Register.
> + * @ep_sts:        Endpoint Status Register.
> + * @ep_sts_sid:    Endpoint Status Register.
> + * @ep_sts_en:     Endpoint Status Register Enable.
> + * @drbl:          Doorbell Register.
> + * @ep_ien:        EP Interrupt Enable Register.
> + * @ep_ists:       EP Interrupt Status Register.
> + * @usb_pwr:       Global Power Configuration Register.
> + * @usb_conf2:     Global Configuration Register 2.
> + * @usb_cap1:      Capability Register 1.
> + * @usb_cap2:      Capability Register 2.
> + * @usb_cap3:      Capability Register 3.
> + * @usb_cap4:      Capability Register 4.
> + * @usb_cap5:      Capability Register 5.
> + * @usb_cap6:      Capability Register 6.
> + * @usb_cpkt1:     Custom Packet Register 1.
> + * @usb_cpkt2:     Custom Packet Register 2.
> + * @usb_cpkt3:     Custom Packet Register 3.
> + * @reserved1:     Reserved.
> + * @cfg_regs:      Configuration registers.
> + * @reserved2:     Reserved.
> + * @dma_axi_ctrl:  AXI Control register.
> + * @dma_axi_id:    AXI ID register.
> + * @dma_axi_cap:   AXI Capability register.
> + * @dma_axi_ctrl0: AXI Control 0 register.
> + * @dma_axi_ctrl1: AXI Control 1 register.
> + */
> +struct cdns3_usb_regs {
> +       __le32 usb_conf;
> +       __le32 usb_sts;
> +       __le32 usb_cmd;
> +       __le32 usb_iptn;
> +       __le32 usb_lpm;
> +       __le32 usb_ien;
> +       __le32 usb_ists;
> +       __le32 ep_sel;
> +       __le32 ep_traddr;
> +       __le32 ep_cfg;
> +       __le32 ep_cmd;
> +       __le32 ep_sts;
> +       __le32 ep_sts_sid;
> +       __le32 ep_sts_en;
> +       __le32 drbl;
> +       __le32 ep_ien;
> +       __le32 ep_ists;
> +       __le32 usb_pwr;
> +       __le32 usb_conf2;
> +       __le32 usb_cap1;
> +       __le32 usb_cap2;
> +       __le32 usb_cap3;
> +       __le32 usb_cap4;
> +       __le32 usb_cap5;
> +       __le32 usb_cap6;
> +       __le32 usb_cpkt1;
> +       __le32 usb_cpkt2;
> +       __le32 usb_cpkt3;
> +       __le32 reserved1[36];
> +       __le32 cfg_reg1;
> +       __le32 dbg_link1;
> +       __le32 dbg_link2;
> +       __le32 cfg_regs[74];
> +       __le32 reserved2[34];
> +       __le32 dma_axi_ctrl;
> +       __le32 dma_axi_id;
> +       __le32 dma_axi_cap;
> +       __le32 dma_axi_ctrl0;
> +       __le32 dma_axi_ctrl1;
> +};
> +
> +/* USB_CONF - bitmasks */
> +/* Reset USB device configuration. */
> +#define USB_CONF_CFGRST                BIT(0)
> +/* Set Configuration. */
> +#define USB_CONF_CFGSET                BIT(1)
> +/* Disconnect USB device in SuperSpeed. */
> +#define USB_CONF_USB3DIS       BIT(3)
> +/* Disconnect USB device in HS/FS */
> +#define USB_CONF_USB2DIS       BIT(4)
> +/* Little Endian access - default */
> +#define USB_CONF_LENDIAN       BIT(5)
> +/*
> + * Big Endian access. Driver assume that byte order for
> + * SFRs access always is as Little Endian so this bit
> + * is not used.
> + */
> +#define USB_CONF_BENDIAN       BIT(6)
> +/* Device software reset. */
> +#define USB_CONF_SWRST         BIT(7)
> +/* Singular DMA transfer mode. */
> +#define USB_CONF_DSING         BIT(8)
> +/* Multiple DMA transfers mode. */
> +#define USB_CONF_DMULT         BIT(9)
> +/* DMA clock turn-off enable. */
> +#define USB_CONF_DMAOFFEN      BIT(10)
> +/* DMA clock turn-off disable. */
> +#define USB_CONF_DMAOFFDS      BIT(11)
> +/* Clear Force Full Speed. */
> +#define USB_CONF_CFORCE_FS     BIT(12)
> +/* Set Force Full Speed. */
> +#define USB_CONF_SFORCE_FS     BIT(13)
> +/* Device enable. */
> +#define USB_CONF_DEVEN         BIT(14)
> +/* Device disable. */
> +#define USB_CONF_DEVDS         BIT(15)
> +/* L1 LPM state entry enable (used in HS/FS mode). */
> +#define USB_CONF_L1EN          BIT(16)
> +/* L1 LPM state entry disable (used in HS/FS mode). */
> +#define USB_CONF_L1DS          BIT(17)
> +/* USB 2.0 clock gate disable. */
> +#define USB_CONF_CLK2OFFEN     BIT(18)
> +/* USB 2.0 clock gate enable. */
> +#define USB_CONF_CLK2OFFDS     BIT(19)
> +/* L0 LPM state entry request (used in HS/FS mode). */
> +#define USB_CONF_LGO_L0                BIT(20)
> +/* USB 3.0 clock gate disable. */
> +#define USB_CONF_CLK3OFFEN     BIT(21)
> +/* USB 3.0 clock gate enable. */
> +#define USB_CONF_CLK3OFFDS     BIT(22)
> +/* Bit 23 is reserved*/
> +/* U1 state entry enable (used in SS mode). */
> +#define USB_CONF_U1EN          BIT(24)
> +/* U1 state entry disable (used in SS mode). */
> +#define USB_CONF_U1DS          BIT(25)
> +/* U2 state entry enable (used in SS mode). */
> +#define USB_CONF_U2EN          BIT(26)
> +/* U2 state entry disable (used in SS mode). */
> +#define USB_CONF_U2DS          BIT(27)
> +/* U0 state entry request (used in SS mode). */
> +#define USB_CONF_LGO_U0                BIT(28)
> +/* U1 state entry request (used in SS mode). */
> +#define USB_CONF_LGO_U1                BIT(29)
> +/* U2 state entry request (used in SS mode). */
> +#define USB_CONF_LGO_U2                BIT(30)
> +/* SS.Inactive state entry request (used in SS mode) */
> +#define USB_CONF_LGO_SSINACT   BIT(31)
> +
> +/* USB_STS - bitmasks */
> +/*
> + * Configuration status.
> + * 1 - device is in the configured state.
> + * 0 - device is not configured.
> + */
> +#define USB_STS_CFGSTS_MASK    BIT(0)
> +#define USB_STS_CFGSTS(p)      ((p) & USB_STS_CFGSTS_MASK)
> +/*
> + * On-chip memory overflow.
> + * 0 - On-chip memory status OK.
> + * 1 - On-chip memory overflow.
> + */
> +#define USB_STS_OV_MASK                BIT(1)
> +#define USB_STS_OV(p)          ((p) & USB_STS_OV_MASK)
> +/*
> + * SuperSpeed connection status.
> + * 0 - USB in SuperSpeed mode disconnected.
> + * 1 - USB in SuperSpeed mode connected.
> + */
> +#define USB_STS_USB3CONS_MASK  BIT(2)
> +#define USB_STS_USB3CONS(p)    ((p) & USB_STS_USB3CONS_MASK)
> +/*
> + * DMA transfer configuration status.
> + * 0 - single request.
> + * 1 - multiple TRB chain
> + */
> +#define USB_STS_DTRANS_MASK    BIT(3)
> +#define USB_STS_DTRANS(p)      ((p) & USB_STS_DTRANS_MASK)
> +/*
> + * Device speed.
> + * 0 - Undefined (value after reset).
> + * 1 - Low speed
> + * 2 - Full speed
> + * 3 - High speed
> + * 4 - Super speed
> + */
> +#define USB_STS_USBSPEED_MASK  GENMASK(6, 4)
> +#define USB_STS_USBSPEED(p)    (((p) & USB_STS_USBSPEED_MASK) >> 4)
> +#define USB_STS_LS             (0x1 << 4)
> +#define USB_STS_FS             (0x2 << 4)
> +#define USB_STS_HS             (0x3 << 4)
> +#define USB_STS_SS             (0x4 << 4)
> +#define DEV_UNDEFSPEED(p)      (((p) & USB_STS_USBSPEED_MASK) =3D=3D (0x=
0 << 4))
> +#define DEV_LOWSPEED(p)                (((p) & USB_STS_USBSPEED_MASK) =
=3D=3D USB_STS_LS)
> +#define DEV_FULLSPEED(p)       (((p) & USB_STS_USBSPEED_MASK) =3D=3D USB=
_STS_FS)
> +#define DEV_HIGHSPEED(p)       (((p) & USB_STS_USBSPEED_MASK) =3D=3D USB=
_STS_HS)
> +#define DEV_SUPERSPEED(p)      (((p) & USB_STS_USBSPEED_MASK) =3D=3D USB=
_STS_SS)
> +/*
> + * Endianness for SFR access.
> + * 0 - Little Endian order (default after hardware reset).
> + * 1 - Big Endian order
> + */
> +#define USB_STS_ENDIAN_MASK    BIT(7)
> +#define USB_STS_ENDIAN(p)      ((p) & USB_STS_ENDIAN_MASK)
> +/*
> + * HS/FS clock turn-off status.
> + * 0 - hsfs clock is always on.
> + * 1 - hsfs clock turn-off in L2 (HS/FS mode) is enabled
> + *          (default after hardware reset).
> + */
> +#define USB_STS_CLK2OFF_MASK   BIT(8)
> +#define USB_STS_CLK2OFF(p)     ((p) & USB_STS_CLK2OFF_MASK)
> +/*
> + * PCLK clock turn-off status.
> + * 0 - pclk clock is always on.
> + * 1 - pclk clock turn-off in U3 (SS mode) is enabled
> + *          (default after hardware reset).
> + */
> +#define USB_STS_CLK3OFF_MASK   BIT(9)
> +#define USB_STS_CLK3OFF(p)     ((p) & USB_STS_CLK3OFF_MASK)
> +/*
> + * Controller in reset state.
> + * 0 - Internal reset is active.
> + * 1 - Internal reset is not active and controller is fully operational.
> + */
> +#define USB_STS_IN_RST_MASK    BIT(10)
> +#define USB_STS_IN_RST(p)      ((p) & USB_STS_IN_RST_MASK)
> +/*
> + * Device enable Status.
> + * 0 - USB device is disabled (VBUS input is disconnected from internal =
logic).
> + * 1 - USB device is enabled (VBUS input is connected to the internal lo=
gic).
> + */
> +#define USB_STS_DEVS_MASK      BIT(14)
> +#define USB_STS_DEVS(p)                ((p) & USB_STS_DEVS_MASK)
> +/*
> + * DAddress statuss.
> + * 0 - USB device is default state.
> + * 1 - USB device is at least in address state.
> + */
> +#define USB_STS_ADDRESSED_MASK BIT(15)
> +#define USB_STS_ADDRESSED(p)   ((p) & USB_STS_ADDRESSED_MASK)
> +/*
> + * L1 LPM state enable status (used in HS/FS mode).
> + * 0 - Entering to L1 LPM state disabled.
> + * 1 - Entering to L1 LPM state enabled.
> + */
> +#define USB_STS_L1ENS_MASK     BIT(16)
> +#define USB_STS_L1ENS(p)       ((p) & USB_STS_L1ENS_MASK)
> +/*
> + * Internal VBUS connection status (used both in HS/FS  and SS mode).
> + * 0 - internal VBUS is not detected.
> + * 1 - internal VBUS is detected.
> + */
> +#define USB_STS_VBUSS_MASK     BIT(17)
> +#define USB_STS_VBUSS(p)       ((p) & USB_STS_VBUSS_MASK)
> +/*
> + * HS/FS LPM  state (used in FS/HS mode).
> + * 0 - L0 State
> + * 1 - L1 State
> + * 2 - L2 State
> + * 3 - L3 State
> + */
> +#define USB_STS_LPMST_MASK     GENMASK(19, 18)
> +#define DEV_L0_STATE(p)                (((p) & USB_STS_LPMST_MASK) =3D=
=3D (0x0 << 18))
> +#define DEV_L1_STATE(p)                (((p) & USB_STS_LPMST_MASK) =3D=
=3D (0x1 << 18))
> +#define DEV_L2_STATE(p)                (((p) & USB_STS_LPMST_MASK) =3D=
=3D (0x2 << 18))
> +#define DEV_L3_STATE(p)                (((p) & USB_STS_LPMST_MASK) =3D=
=3D (0x3 << 18))
> +/*
> + * Disable HS status (used in FS/HS mode).
> + * 0 - the disconnect bit for HS/FS mode is set .
> + * 1 - the disconnect bit for HS/FS mode is not set.
> + */
> +#define USB_STS_USB2CONS_MASK  BIT(20)
> +#define USB_STS_USB2CONS(p)    ((p) & USB_STS_USB2CONS_MASK)
> +/*
> + * HS/FS mode connection status (used in FS/HS mode).
> + * 0 - High Speed operations in USB2.0 (FS/HS) mode not disabled.
> + * 1 - High Speed operations in USB2.0 (FS/HS).
> + */
> +#define USB_STS_DISABLE_HS_MASK        BIT(21)
> +#define USB_STS_DISABLE_HS(p)  ((p) & USB_STS_DISABLE_HS_MASK)
> +/*
> + * U1 state enable status (used in SS mode).
> + * 0 - Entering to  U1 state disabled.
> + * 1 - Entering to  U1 state enabled.
> + */
> +#define USB_STS_U1ENS_MASK     BIT(24)
> +#define USB_STS_U1ENS(p)       ((p) & USB_STS_U1ENS_MASK)
> +/*
> + * U2 state enable status (used in SS mode).
> + * 0 - Entering to  U2 state disabled.
> + * 1 - Entering to  U2 state enabled.
> + */
> +#define USB_STS_U2ENS_MASK     BIT(25)
> +#define USB_STS_U2ENS(p)       ((p) & USB_STS_U2ENS_MASK)
> +/*
> + * SuperSpeed Link LTSSM state. This field reflects USBSS-DEV current
> + * SuperSpeed link state
> + */
> +#define USB_STS_LST_MASK       GENMASK(29, 26)
> +#define DEV_LST_U0             (((p) & USB_STS_LST_MASK) =3D=3D (0x0 << =
26))
> +#define DEV_LST_U1             (((p) & USB_STS_LST_MASK) =3D=3D (0x1 << =
26))
> +#define DEV_LST_U2             (((p) & USB_STS_LST_MASK) =3D=3D (0x2 << =
26))
> +#define DEV_LST_U3             (((p) & USB_STS_LST_MASK) =3D=3D (0x3 << =
26))
> +#define DEV_LST_DISABLED       (((p) & USB_STS_LST_MASK) =3D=3D (0x4 << =
26))
> +#define DEV_LST_RXDETECT       (((p) & USB_STS_LST_MASK) =3D=3D (0x5 << =
26))
> +#define DEV_LST_INACTIVE       (((p) & USB_STS_LST_MASK) =3D=3D (0x6 << =
26))
> +#define DEV_LST_POLLING                (((p) & USB_STS_LST_MASK) =3D=3D =
(0x7 << 26))
> +#define DEV_LST_RECOVERY       (((p) & USB_STS_LST_MASK) =3D=3D (0x8 << =
26))
> +#define DEV_LST_HOT_RESET      (((p) & USB_STS_LST_MASK) =3D=3D (0x9 << =
26))
> +#define DEV_LST_COMP_MODE      (((p) & USB_STS_LST_MASK) =3D=3D (0xa << =
26))
> +#define DEV_LST_LB_STATE       (((p) & USB_STS_LST_MASK) =3D=3D (0xb << =
26))
> +/*
> + * DMA clock turn-off status.
> + * 0 - DMA clock is always on (default after hardware reset).
> + * 1 - DMA clock turn-off in U1, U2 and U3 (SS mode) is enabled.
> + */
> +#define USB_STS_DMAOFF_MASK    BIT(30)
> +#define USB_STS_DMAOFF(p)      ((p) & USB_STS_DMAOFF_MASK)
> +/*
> + * SFR Endian statuss.
> + * 0 - Little Endian order (default after hardware reset).
> + * 1 - Big Endian order.
> + */
> +#define USB_STS_ENDIAN2_MASK   BIT(31)
> +#define USB_STS_ENDIAN2(p)     ((p) & USB_STS_ENDIAN2_MASK)
> +
> +/* USB_CMD -  bitmasks */
> +/* Set Function Address */
> +#define USB_CMD_SET_ADDR       BIT(0)
> +/*
> + * Function Address This field is saved to the device only when the fiel=
d
> + * SET_ADDR is set '1 ' during write to USB_CMD register.
> + * Software is responsible for entering the address of the device during
> + * SET_ADDRESS request service. This field should be set immediately aft=
er
> + * the SETUP packet is decoded, and prior to confirmation of the status =
phase
> + */
> +#define USB_CMD_FADDR_MASK     GENMASK(7, 1)
> +#define USB_CMD_FADDR(p)       (((p) << 1) & USB_CMD_FADDR_MASK)
> +/* Send Function Wake Device Notification TP (used only in SS mode). */
> +#define USB_CMD_SDNFW          BIT(8)
> +/* Set Test Mode (used only in HS/FS mode). */
> +#define USB_CMD_STMODE         BIT(9)
> +/* Test mode selector (used only in HS/FS mode) */
> +#define USB_STS_TMODE_SEL_MASK GENMASK(11, 10)
> +#define USB_STS_TMODE_SEL(p)   (((p) << 10) & USB_STS_TMODE_SEL_MASK)
> +/*
> + *  Send Latency Tolerance Message Device Notification TP (used only
> + *  in SS mode).
> + */
> +#define USB_CMD_SDNLTM         BIT(12)
> +/* Send Custom Transaction Packet (used only in SS mode) */
> +#define USB_CMD_SPKT           BIT(13)
> +/*Device Notification 'Function Wake' - Interface value (only in SS mode=
. */
> +#define USB_CMD_DNFW_INT_MASK  GENMASK(23, 16)
> +#define USB_STS_DNFW_INT(p)    (((p) << 16) & USB_CMD_DNFW_INT_MASK)
> +/*
> + * Device Notification 'Latency Tolerance Message' -373 BELT value [7:0]
> + * (used only in SS mode).
> + */
> +#define USB_CMD_DNLTM_BELT_MASK        GENMASK(27, 16)
> +#define USB_STS_DNLTM_BELT(p)  (((p) << 16) & USB_CMD_DNLTM_BELT_MASK)
> +
> +/* USB_ITPN - bitmasks */
> +/*
> + * ITP(SS) / SOF (HS/FS) number
> + * In SS mode this field represent number of last ITP received from host=
.
> + * In HS/FS mode this field represent number of last SOF received from h=
ost.
> + */
> +#define USB_ITPN_MASK          GENMASK(13, 0)
> +#define USB_ITPN(p)            ((p) & USB_ITPN_MASK)
> +
> +/* USB_LPM - bitmasks */
> +/* Host Initiated Resume Duration. */
> +#define USB_LPM_HIRD_MASK      GENMASK(3, 0)
> +#define USB_LPM_HIRD(p)                ((p) & USB_LPM_HIRD_MASK)
> +/* Remote Wakeup Enable (bRemoteWake). */
> +#define USB_LPM_BRW            BIT(4)
> +
> +/* USB_IEN - bitmasks */
> +/* SS connection interrupt enable */
> +#define USB_IEN_CONIEN         BIT(0)
> +/* SS disconnection interrupt enable. */
> +#define USB_IEN_DISIEN         BIT(1)
> +/* USB SS warm reset interrupt enable. */
> +#define USB_IEN_UWRESIEN       BIT(2)
> +/* USB SS hot reset interrupt enable */
> +#define USB_IEN_UHRESIEN       BIT(3)
> +/* SS link U3 state enter interrupt enable (suspend).*/
> +#define USB_IEN_U3ENTIEN       BIT(4)
> +/* SS link U3 state exit interrupt enable (wakeup). */
> +#define USB_IEN_U3EXTIEN       BIT(5)
> +/* SS link U2 state enter interrupt enable.*/
> +#define USB_IEN_U2ENTIEN       BIT(6)
> +/* SS link U2 state exit interrupt enable.*/
> +#define USB_IEN_U2EXTIEN       BIT(7)
> +/* SS link U1 state enter interrupt enable.*/
> +#define USB_IEN_U1ENTIEN       BIT(8)
> +/* SS link U1 state exit interrupt enable.*/
> +#define USB_IEN_U1EXTIEN       BIT(9)
> +/* ITP/SOF packet detected interrupt enable.*/
> +#define USB_IEN_ITPIEN         BIT(10)
> +/* Wakeup interrupt enable.*/
> +#define USB_IEN_WAKEIEN                BIT(11)
> +/* Send Custom Packet interrupt enable.*/
> +#define USB_IEN_SPKTIEN                BIT(12)
> +/* HS/FS mode connection interrupt enable.*/
> +#define USB_IEN_CON2IEN                BIT(16)
> +/* HS/FS mode disconnection interrupt enable.*/
> +#define USB_IEN_DIS2IEN                BIT(17)
> +/* USB reset (HS/FS mode) interrupt enable.*/
> +#define USB_IEN_U2RESIEN       BIT(18)
> +/* LPM L2 state enter interrupt enable.*/
> +#define USB_IEN_L2ENTIEN       BIT(20)
> +/* LPM  L2 state exit interrupt enable.*/
> +#define USB_IEN_L2EXTIEN       BIT(21)
> +/* LPM L1 state enter interrupt enable.*/
> +#define USB_IEN_L1ENTIEN       BIT(24)
> +/* LPM  L1 state exit interrupt enable.*/
> +#define USB_IEN_L1EXTIEN       BIT(25)
> +/* Configuration reset interrupt enable.*/
> +#define USB_IEN_CFGRESIEN      BIT(26)
> +/* Start of the USB SS warm reset interrupt enable.*/
> +#define USB_IEN_UWRESSIEN      BIT(28)
> +/* End of the USB SS warm reset interrupt enable.*/
> +#define USB_IEN_UWRESEIEN      BIT(29)
> +
> +#define USB_IEN_INIT  (USB_IEN_U2RESIEN | USB_ISTS_DIS2I | USB_IEN_CON2I=
EN \
> +                      | USB_IEN_UHRESIEN | USB_IEN_UWRESIEN | USB_IEN_DI=
SIEN \
> +                      | USB_IEN_CONIEN | USB_IEN_U3EXTIEN | USB_IEN_L2EN=
TIEN \
> +                      | USB_IEN_L2EXTIEN)
> +
> +/* USB_ISTS - bitmasks */
> +/* SS Connection detected. */
> +#define USB_ISTS_CONI          BIT(0)
> +/* SS Disconnection detected. */
> +#define USB_ISTS_DISI          BIT(1)
> +/* UUSB warm reset detectede. */
> +#define USB_ISTS_UWRESI                BIT(2)
> +/* USB hot reset detected. */
> +#define USB_ISTS_UHRESI                BIT(3)
> +/* U3 link state enter detected (suspend).*/
> +#define USB_ISTS_U3ENTI                BIT(4)
> +/* U3 link state exit detected (wakeup). */
> +#define USB_ISTS_U3EXTI                BIT(5)
> +/* U2 link state enter detected.*/
> +#define USB_ISTS_U2ENTI                BIT(6)
> +/* U2 link state exit detected.*/
> +#define USB_ISTS_U2EXTI                BIT(7)
> +/* U1 link state enter detected.*/
> +#define USB_ISTS_U1ENTI                BIT(8)
> +/* U1 link state exit detected.*/
> +#define USB_ISTS_U1EXTI                BIT(9)
> +/* ITP/SOF packet detected.*/
> +#define USB_ISTS_ITPI          BIT(10)
> +/* Wakeup detected.*/
> +#define USB_ISTS_WAKEI         BIT(11)
> +/* Send Custom Packet detected.*/
> +#define USB_ISTS_SPKTI         BIT(12)
> +/* HS/FS mode connection detected.*/
> +#define USB_ISTS_CON2I         BIT(16)
> +/* HS/FS mode disconnection detected.*/
> +#define USB_ISTS_DIS2I         BIT(17)
> +/* USB reset (HS/FS mode) detected.*/
> +#define USB_ISTS_U2RESI                BIT(18)
> +/* LPM L2 state enter detected.*/
> +#define USB_ISTS_L2ENTI                BIT(20)
> +/* LPM  L2 state exit detected.*/
> +#define USB_ISTS_L2EXTI                BIT(21)
> +/* LPM L1 state enter detected.*/
> +#define USB_ISTS_L1ENTI                BIT(24)
> +/* LPM L1 state exit detected.*/
> +#define USB_ISTS_L1EXTI                BIT(25)
> +/* USB configuration reset detected.*/
> +#define USB_ISTS_CFGRESI       BIT(26)
> +/* Start of the USB warm reset detected.*/
> +#define USB_ISTS_UWRESSI       BIT(28)
> +/* End of the USB warm reset detected.*/
> +#define USB_ISTS_UWRESEI       BIT(29)
> +
> +/* USB_SEL - bitmasks */
> +#define EP_SEL_EPNO_MASK       GENMASK(3, 0)
> +/* Endpoint number. */
> +#define EP_SEL_EPNO(p)         ((p) & EP_SEL_EPNO_MASK)
> +/* Endpoint direction bit - 0 - OUT, 1 - IN. */
> +#define EP_SEL_DIR             BIT(7)
> +
> +#define select_ep_in(nr)       (EP_SEL_EPNO(p) | EP_SEL_DIR)
> +#define select_ep_out          (EP_SEL_EPNO(p))
> +
> +/* EP_TRADDR - bitmasks */
> +/* Transfer Ring address. */
> +#define EP_TRADDR_TRADDR(p)    ((p))
> +
> +/* EP_CFG - bitmasks */
> +/* Endpoint enable */
> +#define EP_CFG_ENABLE          BIT(0)
> +/*
> + *  Endpoint type.
> + * 1 - isochronous
> + * 2 - bulk
> + * 3 - interrupt
> + */
> +#define EP_CFG_EPTYPE_MASK     GENMASK(2, 1)
> +#define EP_CFG_EPTYPE(p)       (((p) << 1)  & EP_CFG_EPTYPE_MASK)
> +/* Stream support enable (only in SS mode). */
> +#define EP_CFG_STREAM_EN       BIT(3)
> +/* TDL check (only in SS mode for BULK EP). */
> +#define EP_CFG_TDL_CHK         BIT(4)
> +/* SID check (only in SS mode for BULK OUT EP). */
> +#define EP_CFG_SID_CHK         BIT(5)
> +/* DMA transfer endianness. */
> +#define EP_CFG_EPENDIAN                BIT(7)
> +/* Max burst size (used only in SS mode). */
> +#define EP_CFG_MAXBURST_MASK   GENMASK(11, 8)
> +#define EP_CFG_MAXBURST(p)     (((p) << 8) & EP_CFG_MAXBURST_MASK)
> +/* ISO max burst. */
> +#define EP_CFG_MULT_MASK       GENMASK(15, 14)
> +#define EP_CFG_MULT(p)         (((p) << 14) & EP_CFG_MULT)
> +/* ISO max burst. */
> +#define EP_CFG_MAXPKTSIZE_MASK GENMASK(26, 16)
> +#define EP_CFG_MAXPKTSIZE(p)   (((p) << 16) & EP_CFG_MAXPKTSIZE_MASK)
> +/* Max number of buffered packets. */
> +#define EP_CFG_BUFFERING_MASK  GENMASK(31, 27)
> +#define EP_CFG_BUFFERING(p)    (((p) << 27) & EP_CFG_BUFFERING_MASK)
> +
> +/* EP_CMD - bitmasks */
> +/* Endpoint reset. */
> +#define EP_CMD_EPRST           BIT(0)
> +/* Endpoint STALL set. */
> +#define EP_CMD_SSTALL          BIT(1)
> +/* Endpoint STALL clear. */
> +#define EP_CMD_CSTALL          BIT(2)
> +/* Send ERDY TP. */
> +#define EP_CMD_ERDY            BIT(3)
> +/* Request complete. */
> +#define EP_CMD_REQ_CMPL                BIT(5)
> +/* Transfer descriptor ready. */
> +#define EP_CMD_DRDY            BIT(6)
> +/* Data flush. */
> +#define EP_CMD_DFLUSH          BIT(7)
> +/*
> + * Transfer Descriptor Length write  (used only for Bulk Stream capable
> + * endpoints in SS mode).
> + */
> +#define EP_CMD_STDL            BIT(8)
> +/* Transfer Descriptor Length (used only in SS mode for bulk endpoints).=
 */
> +#define EP_CMD_TDL_MASK                GENMASK(15, 9)
> +#define EP_CMD_TDL(p)          (((p) << 9) & EP_CMD_TDL_MASK)
> +/* ERDY Stream ID value (used in SS mode). */
> +#define EP_CMD_ERDY_SID_MASK   GENMASK(31, 16)
> +#define EP_CMD_ERDY_SID(p)     (((p) << 16) & EP_CMD_SID_MASK)
> +
> +/* EP_STS - bitmasks */
> +/* Setup transfer complete. */
> +#define EP_STS_SETUP           BIT(0)
> +/* Endpoint STALL status. */
> +#define EP_STS_STALL(p)                ((p) & BIT(1))
> +/* Interrupt On Complete. */
> +#define EP_STS_IOC             BIT(2)
> +/* Interrupt on Short Packet. */
> +#define EP_STS_ISP             BIT(3)
> +/* Transfer descriptor missing. */
> +#define EP_STS_DESCMIS         BIT(4)
> +/* Stream Rejected (used only in SS mode) */
> +#define EP_STS_STREAMR         BIT(5)
> +/* EXIT from MOVE DATA State (used only for stream transfers in SS mode)=
. */
> +#define EP_STS_MD_EXIT         BIT(6)
> +/* TRB error. */
> +#define EP_STS_TRBERR          BIT(7)
> +/* Not ready (used only in SS mode). */
> +#define EP_STS_NRDY            BIT(8)
> +/* DMA busy. */
> +#define EP_STS_DBUSY(p)                ((p) & BIT(9))
> +/* Endpoint Buffer Empty */
> +#define EP_STS_BUFFEMPTY(p)    ((p) & BIT(10))
> +/* Current Cycle Status */
> +#define EP_STS_CCS(p)          ((p) & BIT(11))
> +/* Prime (used only in SS mode. */
> +#define EP_STS_PRIME           BIT(12)
> +/* Stream error (used only in SS mode). */
> +#define EP_STS_SIDERR          BIT(13)
> +/* OUT size mismatch. */
> +#define EP_STS_OUTSMM          BIT(14)
> +/* ISO transmission error. */
> +#define EP_STS_ISOERR          BIT(15)
> +/* Host Packet Pending (only for SS mode). */
> +#define EP_STS_HOSTPP(p)       ((p) & BIT(16))
> +/* Stream Protocol State Machine State (only for Bulk stream endpoints).=
 */
> +#define EP_STS_SPSMST_MASK             GENMASK(18, 17)
> +#define EP_STS_SPSMST_DISABLED(p)      (((p) & EP_STS_SPSMST_MASK) >> 17=
)
> +#define EP_STS_SPSMST_IDLE(p)          (((p) & EP_STS_SPSMST_MASK) >> 17=
)
> +#define EP_STS_SPSMST_START_STREAM(p)  (((p) & EP_STS_SPSMST_MASK) >> 17=
)
> +#define EP_STS_SPSMST_MOVE_DATA(p)     (((p) & EP_STS_SPSMST_MASK) >> 17=
)
> +/* Interrupt On Transfer complete. */
> +#define EP_STS_IOT             BIT(19)
> +/* OUT queue endpoint number. */
> +#define EP_STS_OUTQ_NO_MASK    GENMASK(27, 24)
> +#define EP_STS_OUTQ_NO(p)      (((p) & EP_STS_OUTQ_NO_MASK) >> 24)
> +/* OUT queue valid flag. */
> +#define EP_STS_OUTQ_VAL_MASK   BIT(28)
> +#define EP_STS_OUTQ_VAL(p)     ((p) & EP_STS_OUTQ_VAL_MASK)
> +/* SETUP WAIT. */
> +#define EP_STS_STPWAIT         BIT(31)
> +
> +/* EP_STS_SID - bitmasks */
> +/* Stream ID (used only in SS mode). */
> +#define EP_STS_SID_MASK                GENMASK(15, 0)
> +#define EP_STS_SID(p)          ((p) & EP_STS_SID_MASK)
> +
> +/* EP_STS_EN - bitmasks */
> +/* SETUP interrupt enable. */
> +#define EP_STS_EN_SETUPEN      BIT(0)
> +/* OUT transfer missing descriptor enable. */
> +#define EP_STS_EN_DESCMISEN    BIT(4)
> +/* Stream Rejected enable. */
> +#define EP_STS_EN_STREAMREN    BIT(5)
> +/* Move Data Exit enable.*/
> +#define EP_STS_EN_MD_EXITEN    BIT(6)
> +/* TRB enable. */
> +#define EP_STS_EN_TRBERREN     BIT(7)
> +/* NRDY enable. */
> +#define EP_STS_EN_NRDYEN       BIT(8)
> +/* Prime enable. */
> +#define EP_STS_EN_PRIMEEEN     BIT(12)
> +/* Stream error enable. */
> +#define EP_STS_EN_SIDERREN     BIT(13)
> +/* OUT size mismatch enable. */
> +#define EP_STS_EN_OUTSMMEN     BIT(14)
> +/* ISO transmission error enable. */
> +#define EP_STS_EN_ISOERREN     BIT(15)
> +/* Interrupt on Transmission complete enable. */
> +#define EP_STS_EN_IOTEN                BIT(19)
> +/* Setup Wait interrupt enable. */
> +#define EP_STS_EN_STPWAITEN    BIT(31)
> +
> +/* DRBL- bitmasks */
> +#define DB_VALUE_BY_INDEX(index) (1 << (index))
> +#define DB_VALUE_EP0_OUT       BIT(0)
> +#define DB_VALUE_EP0_IN                BIT(16)
> +
> +/* EP_IEN - bitmasks */
> +#define EP_IEN(index)          (1 << (index))
> +#define EP_IEN_EP_OUT0         BIT(0)
> +#define EP_IEN_EP_IN0          BIT(16)
> +
> +/* EP_ISTS - bitmasks */
> +#define EP_ISTS(index)         (1 << (index))
> +#define EP_ISTS_EP_OUT0                BIT(0)
> +#define EP_ISTS_EP_IN0         BIT(16)
> +
> +/* EP_PWR- bitmasks */
> +/*Power Shut Off capability enable*/
> +#define PUSB_PWR_PSO_EN                BIT(0)
> +/*Power Shut Off capability disable*/
> +#define PUSB_PWR_PSO_DS                BIT(1)
> +/*
> + * Enables turning-off Reference Clock.
> + * This bit is optional and implemented only when support for OTG is
> + * implemented (indicated by OTG_READY bit set to '1').
> + */
> +#define PUSB_PWR_STB_CLK_SWITCH_EN     BIT(8)
> +/*
> + * Status bit indicating that operation required by STB_CLK_SWITCH_EN wr=
ite
> + * is completed
> + */
> +#define PUSB_PWR_STB_CLK_SWITCH_DONE   BIT(9)
> +/* This bit informs if Fast Registers Access is enabled. */
> +#define PUSB_PWR_FST_REG_ACCESS_STAT   BIT(30)
> +/* Fast Registers Access Enable. */
> +#define PUSB_PWR_FST_REG_ACCESS        BIT(31)
> +
> +/* USB_CAP1- bitmasks */
> +/*
> + * SFR Interface type
> + * These field reflects type of SFR interface implemented:
> + * 0x0 - OCP
> + * 0x1 - AHB,
> + * 0x2 - PLB
> + * 0x3 - AXI
> + * 0x4-0xF - reserved
> + */
> +#define USB_CAP1_SFR_TYPE_MASK GENMASK(3, 0)
> +#define DEV_SFR_TYPE_OCP(p)    (((p) & USB_CAP1_SFR_TYPE_MASK) =3D=3D 0x=
0)
> +#define DEV_SFR_TYPE_AHB(p)    (((p) & USB_CAP1_SFR_TYPE_MASK) =3D=3D 0x=
1)
> +#define DEV_SFR_TYPE_PLB(p)    (((p) & USB_CAP1_SFR_TYPE_MASK) =3D=3D 0x=
2)
> +#define DEV_SFR_TYPE_AXI(p)    (((p) & USB_CAP1_SFR_TYPE_MASK) =3D=3D 0x=
3)
> +/*
> + * SFR Interface width
> + * These field reflects width of SFR interface implemented:
> + * 0x0 - 8 bit interface,
> + * 0x1 - 16 bit interface,
> + * 0x2 - 32 bit interface
> + * 0x3 - 64 bit interface
> + * 0x4-0xF - reserved
> + */
> +#define USB_CAP1_SFR_WIDTH_MASK        GENMASK(7, 4)
> +#define DEV_SFR_WIDTH_8(p)     (((p) & USB_CAP1_SFR_WIDTH_MASK) =3D=3D (=
0x0 << 4))
> +#define DEV_SFR_WIDTH_16(p)    (((p) & USB_CAP1_SFR_WIDTH_MASK) =3D=3D (=
0x1 << 4))
> +#define DEV_SFR_WIDTH_32(p)    (((p) & USB_CAP1_SFR_WIDTH_MASK) =3D=3D (=
0x2 << 4))
> +#define DEV_SFR_WIDTH_64(p)    (((p) & USB_CAP1_SFR_WIDTH_MASK) =3D=3D (=
0x3 << 4))
> +/*
> + * DMA Interface type
> + * These field reflects type of DMA interface implemented:
> + * 0x0 - OCP
> + * 0x1 - AHB,
> + * 0x2 - PLB
> + * 0x3 - AXI
> + * 0x4-0xF - reserved
> + */
> +#define USB_CAP1_DMA_TYPE_MASK GENMASK(11, 8)
> +#define DEV_DMA_TYPE_OCP(p)    (((p) & USB_CAP1_DMA_TYPE_MASK) =3D=3D (0=
x0 << 8))
> +#define DEV_DMA_TYPE_AHB(p)    (((p) & USB_CAP1_DMA_TYPE_MASK) =3D=3D (0=
x1 << 8))
> +#define DEV_DMA_TYPE_PLB(p)    (((p) & USB_CAP1_DMA_TYPE_MASK) =3D=3D (0=
x2 << 8))
> +#define DEV_DMA_TYPE_AXI(p)    (((p) & USB_CAP1_DMA_TYPE_MASK) =3D=3D (0=
x3 << 8))
> +/*
> + * DMA Interface width
> + * These field reflects width of DMA interface implemented:
> + * 0x0 - reserved,
> + * 0x1 - reserved,
> + * 0x2 - 32 bit interface
> + * 0x3 - 64 bit interface
> + * 0x4-0xF - reserved
> + */
> +#define USB_CAP1_DMA_WIDTH_MASK        GENMASK(15, 12)
> +#define DEV_DMA_WIDTH_32(p)    (((p) & USB_CAP1_DMA_WIDTH_MASK) =3D=3D (=
0x2 << 12))
> +#define DEV_DMA_WIDTH_64(p)    (((p) & USB_CAP1_DMA_WIDTH_MASK) =3D=3D (=
0x3 << 12))
> +/*
> + * USB3 PHY Interface type
> + * These field reflects type of USB3 PHY interface implemented:
> + * 0x0 - USB PIPE,
> + * 0x1 - RMMI,
> + * 0x2-0xF - reserved
> + */
> +#define USB_CAP1_U3PHY_TYPE_MASK GENMASK(19, 16)
> +#define DEV_U3PHY_PIPE(p) (((p) & USB_CAP1_U3PHY_TYPE_MASK) =3D=3D (0x0 =
<< 16))
> +#define DEV_U3PHY_RMMI(p) (((p) & USB_CAP1_U3PHY_TYPE_MASK) =3D=3D (0x1 =
<< 16))
> +/*
> + * USB3 PHY Interface width
> + * These field reflects width of USB3 PHY interface implemented:
> + * 0x0 - 8 bit PIPE interface,
> + * 0x1 - 16 bit PIPE interface,
> + * 0x2 - 32 bit PIPE interface,
> + * 0x3 - 64 bit PIPE interface
> + * 0x4-0xF - reserved
> + * Note: When SSIC interface is implemented this field shows the width o=
f
> + * internal PIPE interface. The RMMI interface is always 20bit wide.
> + */
> +#define USB_CAP1_U3PHY_WIDTH_MASK GENMASK(23, 20)
> +#define DEV_U3PHY_WIDTH_8(p) \
> +       (((p) & USB_CAP1_U3PHY_WIDTH_MASK) =3D=3D (0x0 << 20))
> +#define DEV_U3PHY_WIDTH_16(p) \
> +       (((p) & USB_CAP1_U3PHY_WIDTH_MASK) =3D=3D (0x1 << 16))
> +#define DEV_U3PHY_WIDTH_32(p) \
> +       (((p) & USB_CAP1_U3PHY_WIDTH_MASK) =3D=3D (0x2 << 20))
> +#define DEV_U3PHY_WIDTH_64(p) \
> +       (((p) & USB_CAP1_U3PHY_WIDTH_MASK) =3D=3D (0x3 << 16))
> +
> +/*
> + * USB2 PHY Interface enable
> + * These field informs if USB2 PHY interface is implemented:
> + * 0x0 - interface NOT implemented,
> + * 0x1 - interface implemented
> + */
> +#define USB_CAP1_U2PHY_EN(p)   ((p) & BIT(24))
> +/*
> + * USB2 PHY Interface type
> + * These field reflects type of USB2 PHY interface implemented:
> + * 0x0 - UTMI,
> + * 0x1 - ULPI
> + */
> +#define DEV_U2PHY_ULPI(p)      ((p) & BIT(25))
> +/*
> + * USB2 PHY Interface width
> + * These field reflects width of USB2 PHY interface implemented:
> + * 0x0 - 8 bit interface,
> + * 0x1 - 16 bit interface,
> + * Note: The ULPI interface is always 8bit wide.
> + */
> +#define DEV_U2PHY_WIDTH_16(p)  ((p) & BIT(26))
> +/*
> + * OTG Ready
> + * 0x0 - pure device mode
> + * 0x1 - some features and ports for CDNS USB OTG controller are impleme=
nted.
> + */
> +#define USB_CAP1_OTG_READY(p)  ((p) & BIT(27))
> +
> +/* USB_CAP2- bitmasks */
> +/*
> + * The actual size of the connected On-chip RAM memory in kB:
> + * - 0 means 256 kB (max supported mem size)
> + * - value other than 0 reflects the mem size in kB
> + */
> +#define USB_CAP2_ACTUAL_MEM_SIZE(p) ((p) & GENMASK(7, 0))
> +/*
> + * Max supported mem size
> + * These field reflects width of on-chip RAM address bus width,
> + * which determines max supported mem size:
> + * 0x0-0x7 - reserved,
> + * 0x8 - support for 4kB mem,
> + * 0x9 - support for 8kB mem,
> + * 0xA - support for 16kB mem,
> + * 0xB - support for 32kB mem,
> + * 0xC - support for 64kB mem,
> + * 0xD - support for 128kB mem,
> + * 0xE - support for 256kB mem,
> + * 0xF - reserved
> + */
> +#define USB_CAP2_MAX_MEM_SIZE(p) ((p) & GENMASK(11, 8))
> +
> +/* USB_CAP3- bitmasks */
> +#define EP_IS_IMPLEMENTED(reg, index) ((reg) & (1 << (index)))
> +
> +/* USB_CAP4- bitmasks */
> +#define EP_SUPPORT_ISO(reg, index) ((reg) & (1 << (index)))
> +
> +/* USB_CAP5- bitmasks */
> +#define EP_SUPPORT_STREAM(reg, index) ((reg) & (1 << (index)))
> +
> +/* USB_CAP6- bitmasks */
> +/* The USBSS-DEV Controller  Internal build number. */
> +#define GET_DEV_VERSION__INTERNAL_NUMBER(p) ((p) & GENMASK(7, 0))
> +/* The USBSS-DEV Controller  version number. */
> +#define GET_DEV_VERSION(p) ((p) & GENMASK(31, 8))
> +
> +/* DBG_LINK1- bitmasks */
> +/*
> + * LFPS_MIN_DET_U1_EXIT value This parameter configures the minimum
> + * time required for decoding the received LFPS as an LFPS.U1_Exit.
> + */
> +#define DBG_LINK1_LFPS_MIN_DET_U1_EXIT(p)      ((p) & GENMASK(7, 0))
> +/*
> + * LFPS_MIN_GEN_U1_EXIT value This parameter configures the minimum time=
 for
> + * phytxelecidle deassertion when LFPS.U1_Exit
> + */
> +#define DBG_LINK1_LFPS_MIN_GEN_U1_EXIT(p)      (((p) << 8) & GENMASK(15,=
 8))
> +/*
> + * RXDET_BREAK_DIS value This parameter configures terminating the Far-e=
nd
> + * Receiver termination detection sequence:
> + * 0: it is possible that USBSS_DEV will terminate Farend receiver
> + *    termination detection sequence
> + * 1: USBSS_DEV will not terminate Far-end receiver termination
> + *    detection sequence
> + */
> +#define DBG_LINK1_RXDET_BREAK_DIS              BIT(16)
> +/* LFPS_GEN_PING value This parameter configures the LFPS.Ping generatio=
n */
> +#define DBG_LINK1_LFPS_GEN_PING(p)             (((p) << 17) & GENMASK(21=
, 17))
> +/*
> + * Set the LFPS_MIN_DET_U1_EXIT value Writing '1' to this bit writes the
> + * LFPS_MIN_DET_U1_EXIT field value to the device. This bit is automatic=
ally
> + * cleared. Writing '0' has no effect
> + */
> +#define DBG_LINK1_LFPS_MIN_DET_U1_EXIT_SET     BIT(24)
> +/*
> + * Set the LFPS_MIN_GEN_U1_EXIT value. Writing '1' to this bit writes th=
e
> + * LFPS_MIN_GEN_U1_EXIT field value to the device. This bit is automatic=
ally
> + * cleared. Writing '0' has no effect
> + */
> +#define DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_SET     BIT(25)
> +/*
> + * Set the RXDET_BREAK_DIS value Writing '1' to this bit writes
> + * the RXDET_BREAK_DIS field value to the device. This bit is automatica=
lly
> + * cleared. Writing '0' has no effect
> + */
> +#define DBG_LINK1_RXDET_BREAK_DIS_SET          BIT(26)
> +/*
> + * Set the LFPS_GEN_PING_SET value Writing '1' to this bit writes
> + * the LFPS_GEN_PING field value to the device. This bit is automaticall=
y
> + * cleared. Writing '0' has no effect."
> + */
> +#define DBG_LINK1_LFPS_GEN_PING_SET            BIT(27)
> +
> +#define gadget_to_cdns3_device(g) (container_of(g, struct cdns3_device, =
gadget))
> +
> +#define ep_to_cdns3_ep(ep) (container_of(ep, struct cdns3_endpoint, endp=
oint))
> +
> +/*----------------------------------------------------------------------=
---*/
> +/*
> + * USBSS-DEV DMA interface .
> + */
> +#define TRBS_PER_SEGMENT       16
> +
> +/**
> + * struct cdns3_trb - represent Transfer Descriptor block.
> + * @buffer:    pointer to buffer data
> + * @length:    length of data
> + * @control:   control flags.
> + *
> + * This structure describes transfer block serviced by DMA module.
> + */
> +struct cdns3_trb {
> +       __le32 buffer;
> +       __le32 length;
> +       __le32 control;
> +};
> +
> +#define TRB_SIZE               (sizeof(struct cdns3_trb))
> +#define TRB_RING_SIZE          (TRB_SIZE * TRBS_PER_SEGMENT)
> +
> +/* TRB bit mask */
> +#define TRB_TYPE_BITMASK       GENMASK(15, 10)
> +#define TRB_TYPE(p)            ((p) << 10)
> +#define TRB_FIELD_TO_TYPE(p)   (((p) & TRB_TYPE_BITMASK) >> 10)
> +
> +/* TRB type IDs */
> +/* bulk, interrupt, isoc , and control data stage */
> +#define TRB_NORMAL             1
> +/* TRB for linking ring segments */
> +#define TRB_LINK               6
> +
> +/* Cycle bit - indicates TRB ownership by driver or hw*/
> +#define TRB_CYCLE              BIT(0)
> +/*
> + * When set to '1', the device will toggle its interpretation of the Cyc=
le bit
> + */
> +#define TRB_TOGGLE             BIT(1)
> +
> +/* Interrupt on short packet*/
> +#define TRB_ISP                        BIT(2)
> +/*Setting this bit enables FIFO DMA operation mode*/
> +#define TRB_FIFO_MODE          BIT(3)
> +/* Set PCIe no snoop attribute */
> +#define TRB_CHAIN              BIT(4)
> +/* Interrupt on completion */
> +#define TRB_IOC                        BIT(5)
> +
> +/* stream ID bitmasks. */
> +#define TRB_STREAM_ID(p)       ((p) & GENMASK(31, 16))
> +
> +/* transfer_len bitmasks. */
> +#define TRB_LEN(p)             ((p) & GENMASK(16, 0))
> +
> +/* transfer_len bitmasks - bits 31:24 */
> +#define TRB_BURST_LEN(p)       ((p) & GENMASK(31, 24))
> +
> +/* Data buffer pointer bitmasks*/
> +#define TRB_BUFFER(p)          ((p) & GENMASK(31, 0))
> +
> +/*----------------------------------------------------------------------=
---*/
> +/* Driver numeric constants */
> +
> +/* Such declaration should be added to ch9.h */
> +#define USB_DEVICE_MAX_ADDRESS 127
> +
> +/* Endpoint init values */
> +#define CDNS3_EP_MAX_PACKET_LIMIT      1024
> +#define CDNS3_EP_MAX_STREAMS           15
> +
> +#define CDNS3_EP0_MAX_PACKET_LIMIT     512
> +
> +/* All endpoints except EP0 */
> +#define CDNS3_ENDPOINTS_MAX_COUNT      30
> +
> +#define CDNS3_EP_ZLP_BUF_SIZE          1024
> +
> +/*----------------------------------------------------------------------=
---*/
> +#define CDNS3_EP_BUF_SIZE      2       /* KB */
> +#define CDNS3_ALIGNED_BUF_SIZE 16384 /* Bytes */
> +#define CDNS3_DESCMIS_BUF_SIZE 65536 /* Bytes */
> +/*----------------------------------------------------------------------=
---*/
> +/* Used structs */
> +
> +struct cdns3_device;
> +
> +/**
> + * struct cdns3_endpoint - extended device side representation of USB en=
dpoint.
> + * @endpoint: usb endpoint
> + * @request_list: list of request for this endpoint
> + * @trb_pool: transfer ring - array of transaction buffers
> + * @trb_pool_dma: dma address of transfer ring
> + * @cdns3_dev: device associated with this endpoint
> + * @name: a human readable name e.g. ep1out
> + * @flags: specify the current state of endpoint
> + * @descmis_req: internal transfer object used for getting data from on-=
chip
> + *     buffer. It can happen only if function driver doesn't send usb_re=
quest
> + *     object on time.
> + * @descmis_pending: flag specify that internal buffer was used for DMA =
to
> + *     take data from shared on-chip buffers to avoid blocking transfer =
to other
> + *     endpoints. It indicate that is still in progress.
> + * @descmis_finished: flag specify that transfer has armed on descriptor
> + *     missing event has been completed. If function driver requests
> + *     the transfer then controller driver can just return this data.
> + * @aligned_buff: aligned to 8 bytes data buffer. Buffer address used in
> + *     TRB shall be aligned to 8.
> + * @aligned_dma_addr: dma address of aligned_buff
> + * @dir: endpoint direction
> + * @num: endpoint number (1 - 15)
> + * @type: set to bmAttributes & USB_ENDPOINT_XFERTYPE_MASK
> + * @free_trbs: number of free TRBs in transfer ring
> + * @pcs: producer cycle state
> + * @ccs: consumer cycle state
> + * @enqueue: enqueue index in transfer ring
> + * @dequeue: dequeue index in transfer ring
> + */
> +struct cdns3_endpoint {
> +       struct usb_ep           endpoint;
> +       struct list_head        request_list;
> +
> +       struct cdns3_trb        *trb_pool;
> +       dma_addr_t              trb_pool_dma;
> +
> +       struct cdns3_device     *cdns3_dev;
> +       char                    name[20];
> +
> +#define EP_ENABLED             BIT(0)
> +#define EP_STALL               BIT(1)
> +#define EP_WEDGE               BIT(2)
> +#define EP_TRANSFER_STARTED    BIT(3)
> +#define EP_UPDATE_EP_TRBADDR   BIT(4)
> +#define EP_PENDING_REQUEST     BIT(5)
> +#define EP_RING_FULL           BIT(6)
> +#define EP_CLAIMED             BIT(5)
> +       u32                     flags;
> +
> +       struct cdns3_request    *descmis_req;
> +       u32                     descmis_pending:1;
> +       u32                     descmis_finished:1;
> +
> +       void                    *aligned_buff;
> +       dma_addr_t              aligned_dma_addr;
> +       u8                      dir;
> +       u8                      num;
> +       u8                      type;
> +
> +       int                     free_trbs;
> +       u8                      pcs;
> +       u8                      ccs;
> +       int                     enqueue;
> +       int                     dequeue;
> +};
> +
> +/**
> + * struct cdns3_request - extended device side representation of usb_req=
uest
> + *                        object .
> + * @request: generic usb_request object describing single I/O request.
> + * @priv_ep: extended representation of usb_ep object
> + * @trb: the first TRB association with this request
> + * @start_trb: number of the first TRB in transfer ring
> + * @end_trb: number of the last TRB in transfer ring
> + * @flags: flag specifying special usage of request
> + */
> +struct cdns3_request {
> +       struct usb_request request;
> +       struct cdns3_endpoint *priv_ep;
> +       struct cdns3_trb *trb;
> +       int start_trb;
> +       int end_trb;
> +#define REQUEST_PENDING                BIT(0)
> +#define REQUEST_INTERNAL       BIT(1)
> +#define REQUEST_ZLP            BIT(2)
> +       u32 flags;
> +};
> +
> +#define to_cdns3_request(r) (container_of(r, struct cdns3_request, reque=
st))
> +
> +/**
> + * struct cdns3_device - represent USB device.
> + * @dev: pointer to device structure associated whit this controller
> + * @sysdev: pointer to the DMA capable device
> + * @gadget: device side representation of the peripheral controller
> + * @gadget_driver: pointer to the gadget driver
> + * @lock: for synchronizing
> + * @regs: base address for device side registers
> + * @setup_buf: used while processing usb control requests
> + * @setup_dma: dma address for setup_buf
> + * @ep0_trb: TRB used for control transfer
> + * @ep0_trb_dma: dma address of ep0_trb
> + * @zlp_buf - zlp buffer
> + * @ep0_request: dummy request used while handling USB control request
> + * @ep0_data_dir: direction for control transfer
> + * @eps: array of pointers to all endpoints with exclusion ep0
> + * @ep_nums: number of endpoints in eps
> + * @isoch_delay: value from Set Isoch Delay request. Only valid on SS/SS=
P.
> + * @u1_allowed: allow device transition to u1 state
> + * @u2_allowed: allow device transition to u2 state
> + * @is_selfpowered: device is self powered
> + * @setup_pending: setup packet is processing by gadget driver
> + * @hw_configured_flag: hardware endpoint configuration was set.
> + * @wake_up_flag: allow device to remote up the host
> + * @status_completion_no_call: indicate that driver is waiting for statu=
s s
> + *     stage completion. It's used in deferred SET_CONFIGURATION request=
.
> + * @onchip_mem_allocated_size: actual size of on-chip memory assigned
> + *     to endpoints
> + * @pending_status_wq: workqueue handling status stage for deferred requ=
ests.
> + * @pending_status_request: request for which status stage was deferred
> + */
> +struct cdns3_device {
> +       struct device                   *dev;
> +       struct device                   *sysdev;
> +
> +       struct usb_gadget               gadget;
> +       struct usb_gadget_driver        *gadget_driver;
> +
> +       /* generic spin-lock for drivers */
> +       spinlock_t                      lock;
> +
> +       struct cdns3_usb_regs           __iomem *regs;
> +
> +       struct usb_ctrlrequest          *setup_buf;
> +       dma_addr_t                      setup_dma;
> +       struct cdns3_trb                *ep0_trb;
> +       dma_addr_t                      ep0_trb_dma;
> +       void                            *zlp_buf;
> +       struct usb_request              *ep0_request;
> +       int                             ep0_data_dir;
> +
> +       struct cdns3_endpoint           *eps[CDNS3_ENDPOINTS_MAX_COUNT];
> +       int                             ep_nums;
> +
> +       u32                             selected_ep;
> +       u16                             isoch_delay;
> +
> +       unsigned                        u1_allowed:1;
> +       unsigned                        u2_allowed:1;
> +       unsigned                        is_selfpowered:1;
> +       unsigned                        setup_pending:1;
> +       int                             hw_configured_flag:1;
> +       int                             wake_up_flag:1;
> +       unsigned                        status_completion_no_call:1;
> +
> +       struct work_struct              pending_status_wq;
> +       struct usb_request              *pending_status_request;
> +
> +       /*in KB */
> +       int                             onchip_mem_allocated_size;
> +};
> +
> +int cdns3_handshake(void __iomem *ptr, u32 mask, u32 done, int usec);
> +void cdns3_set_register_bit(void __iomem *ptr, u32 mask);
> +dma_addr_t cdns3_trb_virt_to_dma(struct cdns3_endpoint *priv_ep,
> +                                struct cdns3_trb *trb);
> +enum usb_device_speed cdns3_get_speed(struct cdns3_device *priv_dev);
> +void cdns3_pending_setup_status_handler(struct work_struct *work);
> +void cdns3_gadget_unconfig(struct cdns3_device *priv_dev);
> +void cdns3_set_hw_configuration(struct cdns3_device *priv_dev);
> +void cdns3_select_ep(struct cdns3_device *priv_dev, u32 ep);
> +void cdns3_allow_enable_l1(struct cdns3_device *priv_dev, int enable);
> +struct usb_request *cdns3_next_request(struct list_head *list);
> +int cdns3_ep_run_transfer(struct cdns3_endpoint *priv_ep,
> +                         struct usb_request *request);
> +u8 cdns3_ep_addr_to_index(u8 ep_addr);
> +int cdns3_gadget_ep_set_wedge(struct usb_ep *ep);
> +int cdns3_gadget_ep_set_halt(struct usb_ep *ep, int value);
> +struct usb_request *cdns3_gadget_ep_alloc_request(struct usb_ep *ep,
> +                                                 gfp_t gfp_flags);
> +void cdns3_gadget_ep_free_request(struct usb_ep *ep,
> +                                 struct usb_request *request);
> +int cdns3_gadget_ep_dequeue(struct usb_ep *ep, struct usb_request *reque=
st);
> +void cdns3_gadget_giveback(struct cdns3_endpoint *priv_ep,
> +                          struct cdns3_request *priv_req,
> +                          int status);
> +
> +int cdns3_init_ep0(struct cdns3_device *priv_dev);
> +void cdns3_ep0_config(struct cdns3_device *priv_dev);
> +void cdns3_ep_config(struct cdns3_endpoint *priv_ep);
> +void cdns3_check_ep0_interrupt_proceed(struct cdns3_device *priv_dev, in=
t dir);
> +
> +#endif /* __LINUX_CDNS3_GADGET */
> diff --git a/drivers/usb/cdns3/host-export.h b/drivers/usb/cdns3/host-exp=
ort.h
> new file mode 100644
> index 000000000000..b498a170b7e8
> --- /dev/null
> +++ b/drivers/usb/cdns3/host-export.h
> @@ -0,0 +1,28 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * Cadence USBSS DRD Driver - Host Export APIs
> + *
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Authors: Peter Chen <peter.chen@nxp.com>
> + */
> +#ifndef __LINUX_CDNS3_HOST_EXPORT
> +#define __LINUX_CDNS3_HOST_EXPORT
> +
> +#ifdef CONFIG_USB_CDNS3_HOST
> +
> +int cdns3_host_init(struct cdns3 *cdns);
> +void cdns3_host_exit(struct cdns3 *cdns);
> +
> +#else
> +
> +static inline int cdns3_host_init(struct cdns3 *cdns)
> +{
> +       return -ENXIO;
> +}
> +
> +static inline void cdns3_host_exit(struct cdns3 *cdns) { }
> +
> +#endif /* CONFIG_USB_CDNS3_HOST */
> +
> +#endif /* __LINUX_CDNS3_HOST_EXPORT */
> diff --git a/drivers/usb/cdns3/host.c b/drivers/usb/cdns3/host.c
> new file mode 100644
> index 000000000000..e16175e0328a
> --- /dev/null
> +++ b/drivers/usb/cdns3/host.c
> @@ -0,0 +1,74 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * Cadence USBSS DRD Driver - host side
> + *
> + * Copyright (C) 2018 Cadence Design Systems.
> + * Copyright (C) 2017-2018 NXP
> + *
> + * Authors: Peter Chen <peter.chen@nxp.com>
> + *         Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#include <linux/platform_device.h>
> +#include "core.h"
> +
> +static int __cdns3_host_init(struct cdns3 *cdns)
> +{
> +       struct platform_device *xhci;
> +       int ret;
> +
> +       xhci =3D platform_device_alloc("xhci-hcd", PLATFORM_DEVID_AUTO);
> +       if (!xhci) {
> +               dev_err(cdns->dev, "couldn't allocate xHCI device\n");
> +               return -ENOMEM;
> +       }
> +
> +       xhci->dev.parent =3D cdns->dev;
> +       cdns->host_dev =3D xhci;
> +
> +       ret =3D platform_device_add_resources(xhci, cdns->xhci_res,
> +                                           CDNS3_XHCI_RESOURCES_NUM);
> +       if (ret) {
> +               dev_err(cdns->dev, "couldn't add resources to xHCI device=
\n");
> +               goto err1;
> +       }
> +
> +       ret =3D platform_device_add(xhci);
> +       if (ret) {
> +               dev_err(cdns->dev, "failed to register xHCI device\n");
> +               goto err1;
> +       }
> +
> +       return 0;
> +err1:
> +       platform_device_put(xhci);
> +       return ret;
> +}
> +
> +static void cdns3_host_exit(struct cdns3 *cdns)
> +{
> +       platform_device_unregister(cdns->host_dev);
> +       cdns->host_dev =3D NULL;
> +}
> +
> +int cdns3_host_init(struct cdns3 *cdns)
> +{
> +       struct cdns3_role_driver *rdrv;
> +
> +       rdrv =3D devm_kzalloc(cdns->dev, sizeof(*rdrv), GFP_KERNEL);
> +       if (!rdrv)
> +               return -ENOMEM;
> +
> +       rdrv->start     =3D __cdns3_host_init;
> +       rdrv->stop      =3D cdns3_host_exit;
> +       rdrv->state     =3D CDNS3_ROLE_STATE_INACTIVE;
> +#if CONFIG_PM
> +       rdrv->suspend   =3D NULL;
> +       rdrv->resume    =3D NULL;
> +#endif /* CONFIG_PM */
> +       rdrv->name      =3D "host";
> +
> +       cdns->roles[CDNS3_ROLE_HOST] =3D rdrv;
> +
> +       return 0;
> +}
> diff --git a/drivers/usb/cdns3/trace.c b/drivers/usb/cdns3/trace.c
> new file mode 100644
> index 000000000000..587ae08e019d
> --- /dev/null
> +++ b/drivers/usb/cdns3/trace.c
> @@ -0,0 +1,11 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/*
> + * USBSS device controller driver Trace Support
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#define CREATE_TRACE_POINTS
> +#include "trace.h"
> diff --git a/drivers/usb/cdns3/trace.h b/drivers/usb/cdns3/trace.h
> new file mode 100644
> index 000000000000..a5c8b2a756b4
> --- /dev/null
> +++ b/drivers/usb/cdns3/trace.h
> @@ -0,0 +1,343 @@
> +/* SPDX-License-Identifier: GPL-2.0 */
> +/*
> + * USBSS device controller driver.
> + * Trace support header file.
> + *
> + * Copyright (C) 2018 Cadence.
> + *
> + * Author: Pawel Laszczak <pawell@cadence.com>
> + */
> +
> +#undef TRACE_SYSTEM
> +#define TRACE_SYSTEM cdns3
> +
> +#if !defined(__LINUX_CDNS3_TRACE) || defined(TRACE_HEADER_MULTI_READ)
> +#define __LINUX_CDNS3_TRACE
> +
> +#include <linux/types.h>
> +#include <linux/tracepoint.h>
> +#include <asm/byteorder.h>
> +#include "core.h"
> +#include "gadget.h"
> +#include "debug.h"
> +
> +#define CDNS3_MSG_MAX  500
> +
> +DECLARE_EVENT_CLASS(cdns3_log_doorbell,
> +       TP_PROTO(const char *ep_name),
> +       TP_ARGS(ep_name),
> +       TP_STRUCT__entry(
> +               __field(const char *, ep_name)
> +       ),
> +       TP_fast_assign(
> +               __entry->ep_name =3D ep_name;
> +       ),
> +       TP_printk("//Ding Dong %s", __entry->ep_name)
> +);
> +
> +DEFINE_EVENT(cdns3_log_doorbell, cdns3_doorbell_ep0,
> +       TP_PROTO(const char *ep_name),
> +       TP_ARGS(ep_name)
> +);
> +
> +DEFINE_EVENT(cdns3_log_doorbell, cdns3_doorbell_epx,
> +       TP_PROTO(const char *ep_name),
> +       TP_ARGS(ep_name)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_usb_irq,
> +       TP_PROTO(struct cdns3_device *priv_dev, u32 usb_ists),
> +       TP_ARGS(priv_dev, usb_ists),
> +       TP_STRUCT__entry(
> +               __field(struct cdns3_device *, priv_dev)
> +               __field(u32, usb_ists)
> +       ),
> +       TP_fast_assign(
> +               __entry->priv_dev =3D priv_dev;
> +               __entry->usb_ists =3D usb_ists;
> +       ),
> +       TP_printk("%s", cdns3_decode_usb_irq(__entry->priv_dev,
> +                                            __entry->usb_ists))
> +);
> +
> +DEFINE_EVENT(cdns3_log_usb_irq, cdns3_usb_irq,
> +       TP_PROTO(struct cdns3_device *priv_dev, u32 usb_ists),
> +       TP_ARGS(priv_dev, usb_ists)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_epx_irq,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep),
> +       TP_STRUCT__entry(
> +               __field(struct cdns3_endpoint *, priv_ep)
> +       ),
> +       TP_fast_assign(
> +               __entry->priv_ep =3D priv_ep;
> +       ),
> +       TP_printk("%s", cdns3_decode_epx_irq(__entry->priv_ep))
> +);
> +
> +DEFINE_EVENT(cdns3_log_epx_irq, cdns3_epx_irq,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_ep0_irq,
> +       TP_PROTO(struct cdns3_device *priv_dev),
> +       TP_ARGS(priv_dev),
> +       TP_STRUCT__entry(
> +               __field(struct cdns3_device *, priv_dev)
> +       ),
> +       TP_fast_assign(
> +               __entry->priv_dev =3D priv_dev;
> +       ),
> +       TP_printk("%s", cdns3_decode_ep0_irq(__entry->priv_dev))
> +);
> +
> +DEFINE_EVENT(cdns3_log_ep0_irq, cdns3_ep0_irq,
> +       TP_PROTO(struct cdns3_device *priv_dev),
> +       TP_ARGS(priv_dev)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_ctrl,
> +       TP_PROTO(struct usb_ctrlrequest *ctrl),
> +       TP_ARGS(ctrl),
> +       TP_STRUCT__entry(
> +               __field(u8, bRequestType)
> +               __field(u8, bRequest)
> +               __field(u16, wValue)
> +               __field(u16, wIndex)
> +               __field(u16, wLength)
> +               __dynamic_array(char, str, CDNS3_MSG_MAX)
> +       ),
> +       TP_fast_assign(
> +               __entry->bRequestType =3D ctrl->bRequestType;
> +               __entry->bRequest =3D ctrl->bRequest;
> +               __entry->wValue =3D le16_to_cpu(ctrl->wValue);
> +               __entry->wIndex =3D le16_to_cpu(ctrl->wIndex);
> +               __entry->wLength =3D le16_to_cpu(ctrl->wLength);
> +       ),
> +       TP_printk("%s", cdns3_decode_ctrl(__get_str(str), __entry->bReque=
stType,
> +                                       __entry->bRequest, __entry->wValu=
e,
> +                                       __entry->wIndex, __entry->wLength=
)
> +       )
> +);
> +
> +DEFINE_EVENT(cdns3_log_ctrl, cdns3_ctrl_req,
> +       TP_PROTO(struct usb_ctrlrequest *ctrl),
> +       TP_ARGS(ctrl)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_request,
> +       TP_PROTO(struct cdns3_request *req),
> +       TP_ARGS(req),
> +       TP_STRUCT__entry(
> +               __string(name, req->priv_ep->name)
> +               __field(struct cdns3_request *, req)
> +               __field(unsigned int, actual)
> +               __field(unsigned int, length)
> +               __field(int, status)
> +               __field(int, zero)
> +               __field(int, short_not_ok)
> +               __field(int, no_interrupt)
> +               __field(int, start_trb)
> +               __field(int, end_trb)
> +               __field(struct cdns3_trb *, start_trb_addr)
> +               __field(int, flags)
> +       ),
> +       TP_fast_assign(
> +               __assign_str(name, req->priv_ep->name);
> +               __entry->req =3D req;
> +               __entry->actual =3D req->request.actual;
> +               __entry->length =3D req->request.length;
> +               __entry->status =3D req->request.status;
> +               __entry->zero =3D req->request.zero;
> +               __entry->short_not_ok =3D req->request.short_not_ok;
> +               __entry->no_interrupt =3D req->request.no_interrupt;
> +               __entry->start_trb =3D req->start_trb;
> +               __entry->end_trb =3D req->end_trb;
> +               __entry->start_trb_addr =3D req->trb;
> +               __entry->flags =3D req->flags;
> +       ),
> +       TP_printk("%s: req: %p, length: %u/%u %s%s%s, status: %d,"
> +                 " trb: [start:%d, end:%d: virt addr %pa], flags:%x ",
> +               __get_str(name), __entry->req, __entry->actual, __entry->=
length,
> +               __entry->zero ? "zero | " : "",
> +               __entry->short_not_ok ? "short | " : "",
> +               __entry->no_interrupt ? "no int" : "",
> +               __entry->status,
> +               __entry->start_trb,
> +               __entry->end_trb,
> +               __entry->start_trb_addr,
> +               __entry->flags
> +       )
> +);
> +
> +DEFINE_EVENT(cdns3_log_request, cdns3_alloc_request,
> +       TP_PROTO(struct cdns3_request *req),
> +       TP_ARGS(req)
> +);
> +
> +DEFINE_EVENT(cdns3_log_request, cdns3_free_request,
> +       TP_PROTO(struct cdns3_request *req),
> +       TP_ARGS(req)
> +);
> +
> +DEFINE_EVENT(cdns3_log_request, cdns3_ep_queue,
> +       TP_PROTO(struct cdns3_request *req),
> +       TP_ARGS(req)
> +);
> +
> +DEFINE_EVENT(cdns3_log_request, cdns3_ep_dequeue,
> +       TP_PROTO(struct cdns3_request *req),
> +       TP_ARGS(req)
> +);
> +
> +DEFINE_EVENT(cdns3_log_request, cdns3_gadget_giveback,
> +       TP_PROTO(struct cdns3_request *req),
> +       TP_ARGS(req)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_trb,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep, struct cdns3_trb *trb),
> +       TP_ARGS(priv_ep, trb),
> +       TP_STRUCT__entry(
> +               __string(name, priv_ep->name)
> +               __field(struct cdns3_trb *, trb)
> +               __field(u32, buffer)
> +               __field(u32, length)
> +               __field(u32, control)
> +               __field(u32, type)
> +       ),
> +       TP_fast_assign(
> +               __assign_str(name, priv_ep->name);
> +               __entry->trb =3D trb;
> +               __entry->buffer =3D trb->buffer;
> +               __entry->length =3D trb->length;
> +               __entry->control =3D trb->control;
> +               __entry->type =3D usb_endpoint_type(priv_ep->endpoint.des=
c);
> +       ),
> +       TP_printk("%s: trb 0x%pa, dma buf: 0x%08x, size: %ld, ctrl: 0x%08=
x (%s%s%s%s%s%s%s)",
> +               __get_str(name), __entry->trb, __entry->buffer,
> +               TRB_LEN(__entry->length), __entry->control,
> +               __entry->control & TRB_CYCLE ? "C=3D1, " : "C=3D0, ",
> +               __entry->control & TRB_TOGGLE ? "T=3D1, " : "T=3D0, ",
> +               __entry->control & TRB_ISP ? "ISP, " : "",
> +               __entry->control & TRB_FIFO_MODE ? "FIFO, " : "",
> +               __entry->control & TRB_CHAIN ? "CHAIN, " : "",
> +               __entry->control & TRB_IOC ? "IOC, " : "",
> +                 TRB_FIELD_TO_TYPE(__entry->control) =3D=3D TRB_NORMAL ?=
 "Normal" : "LINK"
> +       )
> +);
> +
> +DEFINE_EVENT(cdns3_log_trb, cdns3_prepare_trb,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep, struct cdns3_trb *trb),
> +       TP_ARGS(priv_ep, trb)
> +);
> +
> +DEFINE_EVENT(cdns3_log_trb, cdns3_complete_trb,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep, struct cdns3_trb *trb),
> +       TP_ARGS(priv_ep, trb)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_ring,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep),
> +       TP_STRUCT__entry(
> +               __field(struct cdns3_endpoint *, priv_ep)
> +               __field(int, free_trbs)
> +               __field(u8, pcs)
> +               __field(u8, ccs)
> +               __field(int, enqueue)
> +               __field(int, dequeue)
> +               __dynamic_array(u32, ring, TRB_RING_SIZE)
> +               __dynamic_array(char, buffer,
> +                               (TRBS_PER_SEGMENT * 65) + CDNS3_MSG_MAX)
> +       ),
> +       TP_fast_assign(
> +               __entry->priv_ep =3D priv_ep;
> +               __entry->free_trbs =3D priv_ep->free_trbs;
> +               __entry->pcs =3D priv_ep->pcs;
> +               __entry->ccs =3D priv_ep->ccs;
> +               __entry->enqueue =3D priv_ep->enqueue;
> +               __entry->dequeue =3D priv_ep->dequeue;
> +               memcpy(__get_dynamic_array(ring), priv_ep->trb_pool,
> +                      TRB_RING_SIZE);
> +       ),
> +
> +       TP_printk("%s",
> +                 cdns3_dbg_ring(__entry->priv_ep, __entry->free_trbs,
> +                                __entry->pcs, __entry->ccs,
> +                                __entry->enqueue, __entry->dequeue,
> +                                (struct cdns3_trb *)__get_str(ring),
> +                                __get_str(buffer)))
> +);
> +
> +DEFINE_EVENT(cdns3_log_ring, cdns3_ring,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep)
> +);
> +
> +DECLARE_EVENT_CLASS(cdns3_log_ep,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep),
> +       TP_STRUCT__entry(
> +               __string(name, priv_ep->name)
> +               __field(unsigned int, maxpacket)
> +               __field(unsigned int, maxpacket_limit)
> +               __field(unsigned int, max_streams)
> +               __field(unsigned int, maxburst)
> +               __field(unsigned int, flags)
> +               __field(unsigned int, dir)
> +               __field(u8, enqueue)
> +               __field(u8, dequeue)
> +       ),
> +       TP_fast_assign(
> +               __assign_str(name, priv_ep->name);
> +               __entry->maxpacket =3D priv_ep->endpoint.maxpacket;
> +               __entry->maxpacket_limit =3D priv_ep->endpoint.maxpacket_=
limit;
> +               __entry->max_streams =3D priv_ep->endpoint.max_streams;
> +               __entry->maxburst =3D priv_ep->endpoint.maxburst;
> +               __entry->flags =3D priv_ep->flags;
> +               __entry->dir =3D priv_ep->dir;
> +               __entry->enqueue =3D priv_ep->enqueue;
> +               __entry->dequeue =3D priv_ep->dequeue;
> +       ),
> +       TP_printk("%s: mps: %d/%d. streams: %d, burst: %d, enq idx: %d, "
> +                 "deq idx: %d, flags %s%s%s%s%s%s%s%s, dir: %s",
> +               __get_str(name), __entry->maxpacket,
> +               __entry->maxpacket_limit, __entry->max_streams,
> +               __entry->maxburst, __entry->enqueue,
> +               __entry->dequeue,
> +               __entry->flags & EP_ENABLED ? "EN | " : "",
> +               __entry->flags & EP_STALL ? "STALL | " : "",
> +               __entry->flags & EP_WEDGE ? "WEDGE | " : "",
> +               __entry->flags & EP_TRANSFER_STARTED ? "STARTED | " : "",
> +               __entry->flags & EP_UPDATE_EP_TRBADDR ? "UPD TRB | " : ""=
,
> +               __entry->flags & EP_PENDING_REQUEST ? "REQ PEN | " : "",
> +               __entry->flags & EP_RING_FULL ? "RING FULL |" : "",
> +               __entry->flags & EP_CLAIMED ?  "CLAIMED " : "",
> +               __entry->dir ? "IN" : "OUT"
> +       )
> +);
> +
> +DEFINE_EVENT(cdns3_log_ep, cdns3_gadget_ep_enable,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep)
> +);
> +
> +DEFINE_EVENT(cdns3_log_ep, cdns3_gadget_ep_disable,
> +       TP_PROTO(struct cdns3_endpoint *priv_ep),
> +       TP_ARGS(priv_ep)
> +);
> +#endif /* __LINUX_CDNS3_TRACE */
> +
> +/* this part must be outside header guard */
> +
> +#undef TRACE_INCLUDE_PATH
> +#define TRACE_INCLUDE_PATH .
> +
> +#undef TRACE_INCLUDE_FILE
> +#define TRACE_INCLUDE_FILE trace
> +
> +#include <trace/define_trace.h>
> --
> 2.17.1
>
