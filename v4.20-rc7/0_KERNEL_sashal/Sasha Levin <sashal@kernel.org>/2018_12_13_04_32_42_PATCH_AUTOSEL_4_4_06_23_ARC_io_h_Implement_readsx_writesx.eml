Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from linux.intel.com (10.54.29.200:995) by i7-8700 with POP3-SSL;
  13 Dec 2018 21:18:29 -0000
X-Original-To: like.xu@linux.intel.com
Delivered-To: like.xu@linux.intel.com
Received: from orsmga008.jf.intel.com (orsmga008.jf.intel.com [10.7.209.65])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by linux.intel.com (Postfix) with ESMTPS id C075F58079C;
	Wed, 12 Dec 2018 20:38:25 -0800 (PST)
Received: from orsmga106.jf.intel.com ([10.7.208.65])
  by orsmga008-1.jf.intel.com with ESMTP; 12 Dec 2018 20:38:25 -0800
X-SG-BADATTACHMENTNOREPLY: True
IronPort-PHdr: =?us-ascii?q?9a23=3AgZWXqheyIySHOZcN7s0e2TydlGMj4u6mDksu8pMi?=
 =?us-ascii?q?zoh2WeGdxc6+YRON2/xhgRfzUJnB7Loc0qyK6/CmATRIyK3CmUhKSIZLWR4BhJ?=
 =?us-ascii?q?detC0bK+nBN3fGKuX3ZTcxBsVIWQwt1Xi6NU9IBJS2PAWK8TW94jEIBxrwKxd+?=
 =?us-ascii?q?KPjrFY7OlcS30P2594HObwlSizexfbB/IA+qoQnNq8IbnZZsJqEtxxXTv3BGYf?=
 =?us-ascii?q?5WxWRmJVKSmxbz+MK994N9/ipTpvws6ddOXb31cKokQ7NYCi8mM30u683wqRbD?=
 =?us-ascii?q?VwqP6WACXWgQjxFFHhLK7BD+Xpf2ryv6qu9w0zSUMMHqUbw5Xymp4rx1QxH0li?=
 =?us-ascii?q?gIKz858HnWisNuiqJbvAmhrAF7z4LNfY2ZKOZycqbbcNgHR2ROQ9xRWjRBDI2i?=
 =?us-ascii?q?coUBAekPM+FaoInzqFQAogC+BRGuCe701jNFhWX70bEg3ug9DQ3L2hErEdIUsH?=
 =?us-ascii?q?TTqdX4LLocXvquzKnI1zrIcvVY1inj6IjJdBAqvPaBXalqfsrKyUkgDQfFg06T?=
 =?us-ascii?q?qYP7JTOV0PoCs2yB4+pnT+KvhHcqpgdsqTas3schkpfFip4Rx1ze6Cl0zpg5Kc?=
 =?us-ascii?q?elREN4fdKoCppduiOCO4Z0TM4uWW5ltSQgxrAEp5K3ZiYHxZQhyhXCcfKIaZKI?=
 =?us-ascii?q?7QjmVOuJITd3mnZleLWnihas/kiv1Pf8WtO30FlUtCpFlMfDtnQX2xzU8MiHRe?=
 =?us-ascii?q?Nx/kan2TmRywDe8v9ILVwwmKbBNpIszKA8moAOvUnAAiP6gkT7ga2OekUh4Oeo?=
 =?us-ascii?q?6uDnYrv8pp+bMo95kgX+MqUomsyiDuU0KwsOUHaB+eS6yrLj+VT1QLJEj/0wjK?=
 =?us-ascii?q?bZqovXJdoUpqGnGQ9ZyIUj5AilDzegztsYmWMLLFVfeBKIl4TpIU3BIOjkDfej?=
 =?us-ascii?q?hFShiDNrx/HFPrL/GJnMIWXDnazlfbZ87U5c1QUywcpe55JSFrEOPvbzVlXtu9?=
 =?us-ascii?q?zfCx8zKxa0zPr/CNVhyoMeXnqCAq+DP6PTrV+H/OUvL/OMZI8Iojn9Lfcl6uXq?=
 =?us-ascii?q?jX84n18dYKao0YEWaHC+AvRpPUGZbWDwjdcGFGcAphA+Q/DyiF2eTT5TYG6/X6?=
 =?us-ascii?q?A75j4lEo6mDoDDRoargLyGxyq7GpxWZmZbClGDC3vodoOEW+sSZyKWOMNujjsE?=
 =?us-ascii?q?Vb25QY87yR6urBP6y6ZgLufM4CIYrpLj1N925+HJjxE97z50At+Z02GMSWF0g2?=
 =?us-ascii?q?wJSyU33KB5vUxy1FOD3bJkjPxfENxZ/+lJXRsiNZ7A0+x6DMj/WgHbcdePUlqm?=
 =?us-ascii?q?RtSmDis3TtI+2NIOZ0d9G9O/jhHMxSaqArkVl6CVC5ww6K7Tw3/xJ8NlwXbcyK?=
 =?us-ascii?q?Yhl0UmQtdINWC+m6Fw7RbTCJDTn0WZjamqc78c0zDL9GuEyWqOv0RYUAprXKXB?=
 =?us-ascii?q?XHAfYFbWrNvj6kPDSb+uFaooMg9bxcGeLatKb8XjjU9aS/f7JNTef2Wxln+tCh?=
 =?us-ascii?q?mS2LODcpDme2UH0yXbE0gLjQYT8G2CNQg/ACehvm3fACZvFVLpf0Pj7+1+pGmn?=
 =?us-ascii?q?QU8zygGAd1dh2Kat+h4JmfycTOse3q4FuCckrDV0AFa93tLMB9qcvQZhe79cYd?=
 =?us-ascii?q?c84FdB2mLUrAh9Pp2mL6B/iV8SaQV3v0Xy1xppDoVMi9QlrHQvzABqM6KXzEtB?=
 =?us-ascii?q?dy+E3ZD3IrDYMG3y8w6gaqHI2lDSys2Z+roS5/sirVXjvwapFlQ5/nVj0tlV1W?=
 =?us-ascii?q?ac55rQAAoTV5LxTlg49xxgq77GZSk94pve1WdwPqmsrj/Cx9UpCfMlyxa9ZdtQ?=
 =?us-ascii?q?LLmIFQ7yE8IAAciuJ/cnm1yobhICIeBT+7Q4P8Kgd/uaxqGrOPxsky6hjWRC+I?=
 =?us-ascii?q?p9yF6D9zJgSu7U2JYI2+uY3gqbWDjmlleur8f3lZpCZT4MBGq/yDHoC5JLaa12?=
 =?us-ascii?q?YIkEF32uI8qxxthlg57tWnhY9EOsBl8c2c+pfwaSYEL53QFKyUsXpnmnkzOizz?=
 =?us-ascii?q?NoizEpsraf3CvWzuXidRoLIG5KSHN5jVfxJ4i5lNQaXEmubwg0mxqp/0f6x65H?=
 =?us-ascii?q?pKthK2nfW1tHfy/zL2t6SKu/qqKCY9JT6JMvqShXUv6zYUqZSr7+pBsWyTjjEH?=
 =?us-ascii?q?FdxDA4djGqvIv2nxphhWKZLXZzqmfZeM5qyRfe4tzcWeBe3j4cSCZkjjnXA0C2?=
 =?us-ascii?q?P8O18tWMi5fDrue+WnqhV5JJdinn14GAtCq95WBxBR2/nvazmsDoEAQg0C/70c?=
 =?us-ascii?q?VqWjvMrBrmfobr0KG6O/p9fkZ0HF/899Z6GoZmn4sznp4Q2GIWhpWI/XUdl2fz?=
 =?us-ascii?q?Ps5W2ab/bHoLWD4KzMTZ4Anj2E1/MH2Jw5j1WWmawstkf9O6eH8Z2joh78BWD6?=
 =?us-ascii?q?eZ9LlEnSp2olWitw7Qb+ZyniwByfQw8n4VmP8GuBAiziiGBrASHE9YPTHjlhiS?=
 =?us-ascii?q?7tC+qrlXa3ircbSqyEV+mtWhBqmYog5AQHb5ZosiHSho48VjN1LM1Wf/64D+d9?=
 =?us-ascii?q?nWcNITrQaUkxbbguhRKZIxkOcKhCV9NWL8u30l1/A0jRh00Z6mu4iHLn1n/Lil?=
 =?us-ascii?q?DR5AKj31e8QT9yn2gqlEmcaW252vEo9lGjUWR5boSfOoEDQPtfXoLQqOETs8qm?=
 =?us-ascii?q?uFFrrbBwOQ9EBmr3fXGZCxK36XPGUZzcllRBSFJkxQmgUUUyshnpIjCgCm3s/h?=
 =?us-ascii?q?cFp65jAM4F73sABMx/lsNxn+VGffuQipZi01SJiZMBpZ8AVC613JPsyZ6+J5Bz?=
 =?us-ascii?q?tY8YG5rAyRNmybYBxFDGEOWkyZHlDjI6Oh5d/a/+iDAeq+KfTObK6KqexfUfeI?=
 =?us-ascii?q?2J2u3pFn/zaKKsWAIH1iA+cn1UpEWHBzA97ZlCkXSywLiyLNaNaWpBei9S12rc?=
 =?us-ascii?q?C/8/XrVBjs5YuVDLtSPstg+wqrgaeYLOOQgCd5KTBF1pID33PIyb4f3EIMhCFq?=
 =?us-ascii?q?bTWiDbMAtSvVRqLKhqBXFwIbaz90NMZQ9a08wxJCOdTFhdL1zLJ4iv81BkxBVV?=
 =?us-ascii?q?zgnMGpeMMLL3u8NFPBGEaEKrCGKSfXzMHwZKO2UadQg/lMtx2spTabFFfuPiiC?=
 =?us-ascii?q?lznsTRygLftAgz2bPBNAvoGwaRJtCWnlTNL7ZRy3Kt53jTsqwbIqgnPGL3ITMT?=
 =?us-ascii?q?95c0lVtL2f8TtYguljG2xG9ndkLfOLmyCc7+nZLJYZqfpqAiRumOJc73Q30L9V?=
 =?us-ascii?q?7CBCRPxolyretN9uo1e6kuaRzjprSgZBqjFOhNHDgUI3PaTf64kFWnve+h8JxX?=
 =?us-ascii?q?ufBg5MpNZ/DNDr/adKxZyHj776IjNP28zb8NFaBMXOLs+Ddn07PknHAjnRWTAM?=
 =?us-ascii?q?Vj6ifUXSmU1b2KWJ/2aVp5wSqZX2npcKDLhBWwpmRbshFk15EYlac99MVTQ+nO?=
 =?us-ascii?q?ve1ZZQ6A=3D=3D?=
X-IronPort-Anti-Spam-Filtered: true
X-IronPort-Anti-Spam-Result: =?us-ascii?q?A0AEAAA44RFch0O0hNFjGwEBAQEDAQEBB?=
 =?us-ascii?q?wMBAQGBUQYBAQELAYFVghYnjBVfizOCDRSXP4FzFBgTAYc+IjQJDQEDAQEBAQE?=
 =?us-ascii?q?BAgETAQEBCA0JCCkjDII2JAGCYgMDAQIvAQ0BATcBBQkBAR8xA1QHEgWDHIIBB?=
 =?us-ascii?q?aYXgh+CdgEBBYcxCId9VYJOgRwXgUA/gRGNbok7gXeFE5BJCYIniCOHAgsYgVy?=
 =?us-ascii?q?IQ4cniSmQFoFGgg4zGggoCIMnghsMF4hehV0iMoEFAQGMWgEB?=
X-IPAS-Result: =?us-ascii?q?A0AEAAA44RFch0O0hNFjGwEBAQEDAQEBBwMBAQGBUQYBAQE?=
 =?us-ascii?q?LAYFVghYnjBVfizOCDRSXP4FzFBgTAYc+IjQJDQEDAQEBAQEBAgETAQEBCA0JC?=
 =?us-ascii?q?CkjDII2JAGCYgMDAQIvAQ0BATcBBQkBAR8xA1QHEgWDHIIBBaYXgh+CdgEBBYc?=
 =?us-ascii?q?xCId9VYJOgRwXgUA/gRGNbok7gXeFE5BJCYIniCOHAgsYgVyIQ4cniSmQFoFGg?=
 =?us-ascii?q?g4zGggoCIMnghsMF4hehV0iMoEFAQGMWgEB?=
X-IronPort-AV: E=Sophos;i="5.56,347,1539673200"; 
   d="scan'208";a="43862954"
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from vger.kernel.org ([209.132.180.67])
  by mtab.intel.com with ESMTP; 12 Dec 2018 20:38:23 -0800
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1728997AbeLMEhp (ORCPT <rfc822;like.xu@linux.intel.com>
        + 23 others); Wed, 12 Dec 2018 23:37:45 -0500
Received: from mail.kernel.org ([198.145.29.99]:46012 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1728075AbeLMEdK (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Wed, 12 Dec 2018 23:33:10 -0500
Received: from sasha-vm.mshome.net (c-73-47-72-35.hsd1.nh.comcast.net [73.47.72.35])
        (using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id AFD5720672;
        Thu, 13 Dec 2018 04:33:08 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1544675589;
        bh=UvaFHo+6Kpl14ZS36XmaHRf1R+6LY0g7uri8Q/+EvNU=;
        h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
        b=WkQDwVC+L6M1cijpd7Fywix4zDjf/OSbfLIh+AuWyN2Cvcba7r3in7fKUdMv64tcB
         lrdmcSzH+YHcjmyaav+e+oL/+qiebRlzR+qCkojOuVwAFlZuFzzSAo1gN89eeQpenI
         nCoc496Fog1wQc8x569MXB7mPl61KHfKCuO4W6v8=
From: Sasha Levin <sashal@kernel.org>
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org
Cc: Jose Abreu <joabreu@synopsys.com>,
        Alexey Brodkin <abrodkin@synopsys.com>,
        Joao Pinto <jpinto@synopsys.com>,
        David Laight <David.Laight@ACULAB.COM>,
        Vineet Gupta <vgupta@synopsys.com>,
        Sasha Levin <sashal@kernel.org>,
        linux-snps-arc@lists.infradead.org
Subject: [PATCH AUTOSEL 4.4 06/23] ARC: io.h: Implement reads{x}()/writes{x}()
Date: Wed, 12 Dec 2018 23:32:42 -0500
Message-Id: <20181213043259.76643-6-sashal@kernel.org>
X-Mailer: git-send-email 2.19.1
In-Reply-To: <20181213043259.76643-1-sashal@kernel.org>
References: <20181213043259.76643-1-sashal@kernel.org>
MIME-Version: 1.0
X-Patchwork-Hint: Ignore
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: Jose Abreu <joabreu@synopsys.com>

[ Upstream commit 10d443431dc2bb733cf7add99b453e3fb9047a2e ]

Some ARC CPU's do not support unaligned loads/stores. Currently, generic
implementation of reads{b/w/l}()/writes{b/w/l}() is being used with ARC.
This can lead to misfunction of some drivers as generic functions do a
plain dereference of a pointer that can be unaligned.

Let's use {get/put}_unaligned() helpers instead of plain dereference of
pointer in order to fix. The helpers allow to get and store data from an
unaligned address whilst preserving the CPU internal alignment.
According to [1], the use of these helpers are costly in terms of
performance so we added an initial check for a buffer already aligned so
that the usage of the helpers can be avoided, when possible.

[1] Documentation/unaligned-memory-access.txt

Cc: Alexey Brodkin <abrodkin@synopsys.com>
Cc: Joao Pinto <jpinto@synopsys.com>
Cc: David Laight <David.Laight@ACULAB.COM>
Tested-by: Vitor Soares <soares@synopsys.com>
Signed-off-by: Jose Abreu <joabreu@synopsys.com>
Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
---
 arch/arc/include/asm/io.h | 72 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 72 insertions(+)

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index cb69299a492e..f120d823e8c2 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 #include <asm/page.h>
+#include <asm/unaligned.h>
 
 #ifdef CONFIG_ISA_ARCV2
 #include <asm/barrier.h>
@@ -85,6 +86,42 @@ static inline u32 __raw_readl(const volatile void __iomem *addr)
 	return w;
 }
 
+/*
+ * {read,write}s{b,w,l}() repeatedly access the same IO address in
+ * native endianness in 8-, 16-, 32-bit chunks {into,from} memory,
+ * @count times
+ */
+#define __raw_readsx(t,f) \
+static inline void __raw_reads##f(const volatile void __iomem *addr,	\
+				  void *ptr, unsigned int count)	\
+{									\
+	bool is_aligned = ((unsigned long)ptr % ((t) / 8)) == 0;	\
+	u##t *buf = ptr;						\
+									\
+	if (!count)							\
+		return;							\
+									\
+	/* Some ARC CPU's don't support unaligned accesses */		\
+	if (is_aligned) {						\
+		do {							\
+			u##t x = __raw_read##f(addr);			\
+			*buf++ = x;					\
+		} while (--count);					\
+	} else {							\
+		do {							\
+			u##t x = __raw_read##f(addr);			\
+			put_unaligned(x, buf++);			\
+		} while (--count);					\
+	}								\
+}
+
+#define __raw_readsb __raw_readsb
+__raw_readsx(8, b)
+#define __raw_readsw __raw_readsw
+__raw_readsx(16, w)
+#define __raw_readsl __raw_readsl
+__raw_readsx(32, l)
+
 #define __raw_writeb __raw_writeb
 static inline void __raw_writeb(u8 b, volatile void __iomem *addr)
 {
@@ -117,6 +154,35 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 
 }
 
+#define __raw_writesx(t,f)						\
+static inline void __raw_writes##f(volatile void __iomem *addr, 	\
+				   const void *ptr, unsigned int count)	\
+{									\
+	bool is_aligned = ((unsigned long)ptr % ((t) / 8)) == 0;	\
+	const u##t *buf = ptr;						\
+									\
+	if (!count)							\
+		return;							\
+									\
+	/* Some ARC CPU's don't support unaligned accesses */		\
+	if (is_aligned) {						\
+		do {							\
+			__raw_write##f(*buf++, addr);			\
+		} while (--count);					\
+	} else {							\
+		do {							\
+			__raw_write##f(get_unaligned(buf++), addr);	\
+		} while (--count);					\
+	}								\
+}
+
+#define __raw_writesb __raw_writesb
+__raw_writesx(8, b)
+#define __raw_writesw __raw_writesw
+__raw_writesx(16, w)
+#define __raw_writesl __raw_writesl
+__raw_writesx(32, l)
+
 /*
  * MMIO can also get buffered/optimized in micro-arch, so barriers needed
  * Based on ARM model for the typical use case
@@ -132,10 +198,16 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 #define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
 #define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
 #define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+#define readsb(p,d,l)		({ __raw_readsb(p,d,l); __iormb(); })
+#define readsw(p,d,l)		({ __raw_readsw(p,d,l); __iormb(); })
+#define readsl(p,d,l)		({ __raw_readsl(p,d,l); __iormb(); })
 
 #define writeb(v,c)		({ __iowmb(); writeb_relaxed(v,c); })
 #define writew(v,c)		({ __iowmb(); writew_relaxed(v,c); })
 #define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })
+#define writesb(p,d,l)		({ __iowmb(); __raw_writesb(p,d,l); })
+#define writesw(p,d,l)		({ __iowmb(); __raw_writesw(p,d,l); })
+#define writesl(p,d,l)		({ __iowmb(); __raw_writesl(p,d,l); })
 
 /*
  * Relaxed API for drivers which can handle barrier ordering themselves
-- 
2.19.1

