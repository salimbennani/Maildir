Return-Path: <linux-kernel-owner@vger.kernel.org>
Delivered-To: unknown
Received: from pop3.zju.edu.cn (124.160.105.205:110) by
  likexu-MOBL1.ccr.corp.intel.com with POP3; 12 Nov 2018 00:39:55 -0000
Received: from icoremail.net (unknown [209.85.215.172])
	by mail-app2 (Coremail) with SMTP id by_KCgDHH8IaZehbIvl2AQ--.35989S3;
	Mon, 12 Nov 2018 01:21:31 +0800 (CST)
Received: from mail-pg1-f172.google.com (unknown [209.85.215.172])
	by mx2.icoremail.net (Coremail) with SMTP id AQAAfwCHb0sPZehb8JAtAA--.19521S3;
	Mon, 12 Nov 2018 01:21:19 +0800 (CST)
Received: by mail-pg1-f172.google.com with SMTP id r9-v6so2965288pgv.6
        for <xuliker@zju.edu.cn>; Sun, 11 Nov 2018 09:21:19 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:delivered-to:dkim-signature:date:from:to:cc
         :subject:message-id:mime-version:content-disposition:user-agent
         :sender:precedence:list-id;
        bh=arABP1giNn2WF0uz5/0NRQIH/Dy8JdSr60GIRC/Yo38=;
        b=VE5+F0xRGUZweBv1alHeb/9UEilMWAuZuxo/775cV2gqgTQeNtMz9E8iAolX2B1jBv
         Udp/0EZVdkdb2PNRNDX3qPVbmww24bTKmepOgOr98Y2Yc/wVlUMz4gP0MRrhtzaQgGnI
         imZZr35dY9dnkEpl7syXA9t9A4XocSi5NcIzRVThYPlyqLOMVQRVI2m8FIfQvy9vYbG6
         p1rEip8ydmYFJv8cSLDI0lV4hNWV/FXRis1xfq9Z/A+/DxL+GaTceDSVktCMz6SKRhKr
         qEbTib+pEmmreiixic3gEdGceWPDTFC0p6aCvpsJyq23UtvekxL8pJQwr1pbIN1yhA2C
         wX6w==
X-Gm-Message-State: AGRZ1gLfQD7Vb31CKlJ94YwbZwZP4tyiPBSBIWUnnif2tMVwZrzCEHXB
	ZFY+T6jvy6fGfbgsbwzBLw5WlbVuKgMcVWmA6tNlqZeVH2LZokQ=
X-Received: by 2002:a62:c20b:: with SMTP id l11-v6mr17375528pfg.251.1541956878527;
        Sun, 11 Nov 2018 09:21:18 -0800 (PST)
X-Forwarded-To: xuliker@zju.edu.cn
X-Forwarded-For: liker.xu@gmail.com xuliker@zju.edu.cn
Delivered-To: liker.xu@gmail.com
Received: by 2002:a17:90a:c304:0:0:0:0 with SMTP id g4-v6csp2303620pjt;
        Sun, 11 Nov 2018 09:21:15 -0800 (PST)
X-Google-Smtp-Source: AJdET5cz+7jWEpt3VXeDc2jbOMIyixosfG4C5AFBq84gnHNlZyBVeRFLN+hrcNuw5TFr9MExEA+0
X-Received: by 2002:a63:801:: with SMTP id 1mr14395912pgi.275.1541956875544;
        Sun, 11 Nov 2018 09:21:15 -0800 (PST)
ARC-Seal: i=1; a=rsa-sha256; t=1541956875; cv=none;
        d=google.com; s=arc-20160816;
        b=ePnqf39NkweHQ2XsJIrGALJm8srQWRVfVolLPmkfY1z5czDFxx/AMYwDLEM5L/qYup
         jTASqi0zgbX1YKrZ4lohiaXZyJP8pVAB6i+UN2oqAACyjfHzGHrjaSnEx9WKt8eu9/d4
         YTdf/Tpglt+d6mliR/xdDNVQDSweeAUj8IbyJwpCYTjyEi0If/4a5KzySzmU448xEme5
         /V/zmJYiIxARKATWHtI2EgllhY2GGqIUQYSKe68iW9fOqJiZSKdcvdshxpDtB8xwi5Ng
         v+qUSGyHkOoEDfXDI3ucDaoXZ/dqVvE5RWtGzrwAJ4NyVLizi/HfRxvPLeWfI+UouH2/
         ZNig==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=google.com; s=arc-20160816;
        h=list-id:precedence:sender:user-agent:content-disposition
         :mime-version:message-id:subject:cc:to:from:date:dkim-signature;
        bh=arABP1giNn2WF0uz5/0NRQIH/Dy8JdSr60GIRC/Yo38=;
        b=eQKx9cqTAhc298Q2WlaPXOnv+lDVE4FoGVHkw0D1HLD8J92coAUMWmLvxWU8sAJDTY
         OuejNSaHJXxkxqjZ4spi5cKZUjqI18jIT1VlZh07/P6Ja0NERHdmlxcxHjgk5vl8K2R/
         tDc6w439zlik14ZSQp/U5qhB56QfQWuEl7gmaacXTZsQPPr3fyoibekTdb6hEtGzgrhI
         H7OnNskzwplLNQXS17EtIAWhwhGJ9KGicYaLgv2laQnuyNcqwRY1D7K4Z7wKmcE/wZpv
         kAqujZKDk55sC7aVmgbjra18jgYTOG5hXUQFpLgMAQs6xb0xT+5D13QXlwYZGShR/IR/
         QhgA==
ARC-Authentication-Results: i=1; mx.google.com;
       dkim=pass header.i=@gmail.com header.s=20161025 header.b=NjnbK+S1;
       spf=pass (google.com: best guess record for domain of linux-kernel-owner@vger.kernel.org designates 209.132.180.67 as permitted sender) smtp.mailfrom=linux-kernel-owner@vger.kernel.org;
       dmarc=pass (p=NONE sp=QUARANTINE dis=NONE) header.from=gmail.com
Received: from vger.kernel.org (vger.kernel.org. [209.132.180.67])
        by mx.google.com with ESMTP id u91-v6si16499294plb.180.2018.11.11.09.21.00;
        Sun, 11 Nov 2018 09:21:15 -0800 (PST)
Received-SPF: pass (google.com: best guess record for domain of linux-kernel-owner@vger.kernel.org designates 209.132.180.67 as permitted sender) client-ip=209.132.180.67;
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1729281AbeKLDJs (ORCPT <rfc822;berg.ding@gmail.com> + 99 others);
        Sun, 11 Nov 2018 22:09:48 -0500
Received: from mail-wm1-f65.google.com ([209.85.128.65]:38794 "EHLO
        mail-wm1-f65.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1729233AbeKLDJs (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 11 Nov 2018 22:09:48 -0500
Received: by mail-wm1-f65.google.com with SMTP id f2-v6so6033622wme.3;
        Sun, 11 Nov 2018 09:20:39 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=date:from:to:cc:subject:message-id:mime-version:content-disposition
         :user-agent;
        bh=arABP1giNn2WF0uz5/0NRQIH/Dy8JdSr60GIRC/Yo38=;
        b=NjnbK+S1ftESi6YuHen7WUjgOdtn1KRY2/CYzio6NpgJwZcs0U7OLCyeuNmdKfOrDK
         6gnIUB5H8sgbsSxN7oV/O6XBsSVtgnhq4J3t8cw5cZO6nScB+f0orfH1tuqwqiaVNoNa
         LKLB0HaMnnI+jWqt92BGJ0g3smDw6YVPe6+V3EGhx/MjuqcGfWqHVHRKwsk0nsx7cE1H
         HjmnJc6OMbKWiNnZyfjDWGjBNH3DxA1EFJVt2a0FyBBrzx50RPPH6Z1qEB9vHOMBU6mi
         xMH8Q+4qscn4VayikxFROogeJeJPL8nzO8NZaGDxcKHkx8MX2AS6kxnFuM/n6Hr2HO1C
         +mtg==
X-Received: by 2002:a1c:9c88:: with SMTP id f130-v6mr5727407wme.135.1541956837311;
        Sun, 11 Nov 2018 09:20:37 -0800 (PST)
Received: from syn-yoga530 (acayenne-651-1-173-170.w90-31.abo.wanadoo.fr. [90.31.142.170])
        by smtp.gmail.com with ESMTPSA id s8-v6sm4840891wru.0.2018.11.11.09.20.35
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Sun, 11 Nov 2018 09:20:36 -0800 (PST)
Date: Sun, 11 Nov 2018 14:20:32 -0300
From: Elie Morisse <syniurge@gmail.com>
To: linux-i2c@vger.kernel.org, Wolfram Sang <wsa@the-dreams.de>,
        helgaas@kernel.org, Nehal-bakulchandra.Shah@amd.com,
        Shyam-sundar.S-k@amd.com, sandeep.singh@amd.com,
        linux-kernel@vger.kernel.org
Cc: Tobias Thomer <thomer.tobias@gmail.com>
Subject: [PATCH v9] i2c: Add drivers for the AMD PCIe MP2 I2C controller
Message-ID: <20181111172032.GA5290@syn-yoga530>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Sender: liker.xu+caf_=xuliker=zju.edu.cn@gmail.com
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org
X-CM-TRANSID: AQAAfwCHb0sPZehb8JAtAA--.19521S3
Authentication-Results: mail-app2; spf=pass smtp.mail=liker.xu+caf_=xu
	liker=zju.edu.cn@gmail.com;
X-Coremail-Antispam: 1UD129KBjvAXoWDJr4rArWUAw1fKF4xGFW8tFb_yoWrWw4rto
	ZxZrsxuw1rJr1Dt3yxKryIqFy5Xryvg3s3tr1rJF4vyas2yrZ3Ka15Gw13ZF15ZryrtF4U
	Z3Zaqw1fZFsrJa4fn29KB7ZKAUJUUUUU529EdanIXcx71UUUUU7v73VFW2AGmfu7jjvjm3
	AaLaJ3UjIYCTnIWjp_UUUOn7k0a2IF6F4UM7kC6x804xWl14x267AKxVWUJVW8JwAFIxvE
	14AKwVWUJVWUGwA2ocxC64kIII0Yj41l84x0c7CEw4AK67xGY2AK021l84ACjcxK6xIIjx
	v20xvE14v26ryj6F1UM28EF7xvwVC0I7IYx2IY6xkF7I0E14v26r4j6F4UM28EF7xvwVC2
	z280aVAFwI0_Gr1j6F4UJwA2z4x0Y4vEx4A2jsIEc7CjxVAFwI0_Gr1j6F4UJwAS0I0E0x
	vYzxvE52x082IY62kv0487Mc02F40EFcxC0VAKzVAqx4xG6I80ewAv7VC0I7IYx2IY67AK
	xVWUJVWUGwAv7VC2z280aVAFwI0_Jr0_Gr1lOx8S6xCaFVCjc4AY6r1j6r4UM4x0Y48IcV
	AKI48JMx02cVCv0xWlc7CjxVAKzI0EY4vE52x082I5MxkFs20EY4vE44CYbxCE4x80FwCY
	02Avz4vEIxC_GwCY0x0Ix7I2Y4AK64vIr41lcIIF0xvE2Ix0cI8IcVAFwI0_Jr0_JF4lcI
	IF0xvE2Ix0cI8IcVCY1x0267AKxVWUJVW8JwCYIxAIcVC2z280aVAFwI0_Gr0_Cr1lcIIF
	0xvEx4A2jsIEc7CjxVAFwI0_Gr0_Gr1UMxAIw28IcxkI7VAKI48JMxAIw28IcVAKzI0EY4
	vE52x082I5MxCjnVCjjxCrMxC20s026xCaFVCjc4AY6r1j6r4UMI8I3I0E5I8CrVAFwI0_
	Jr0_Jr4lx2IqxVCjr7xvwVAFwI0_JrI_JrWlx4CE17CEb7AF67AKxVWUtVW8ZwCIc40Y0x
	0EwIxGrwCI42IY6xAIw20EY4v20xvaj40_Wr1j6rW3JrUvcSsGvfC2KfnxnUUI43ZEXa7I
	U5oGQDUUUUU==

I2C communication takes place through iomapped registers, or through DMA
for more than 32 bytes transfers.

MP2 controllers have two separate buses, so may accommodate up to two I2C
adapters. Those adapters are listed in the ACPI namespace with the
"AMDI0011" HID, and probed by a platform driver.

This is major rework of the patch submitted by Nehal-bakulchandra Shah from
AMD (https://patchwork.kernel.org/patch/10597369/).

Most of the event handling of v3 was rewritten to make it work with more
than one bus (e.g on Ryzen-based Lenovo Yoga 530), and this version
contains many more improvements.

Signed-off-by: Elie Morisse <syniurge@gmail.com>
---
Changes since v1:(https://www.spinics.net/lists/linux-i2c/msg34650.html)
-> Add fix for IOMMU
-> Add depedency of ACPI
-> Add locks to avoid the crash

Changes since v2:(https://patchwork.ozlabs.org/patch/961270/)

-> fix for review comments
-> fix for more than 32 bytes write issue

Changes since v3 (https://patchwork.kernel.org/patch/10597369/) by Elie M.:

-> support more than one bus/adapter
-> support more than one slave per bus
-> use the bus speed specified by the slaves declared in the DSDT instead of
   assuming speed == 400kbits/s
-> instead of kzalloc'ing a buffer for every less than 32 bytes reads, simply
   use i2c_msg.buf
-> fix buffer overreads/overflows when (<=32 bytes) message lengths aren't a
   multiple of 4 by using memcpy_fromio and memcpy_toio
-> use streaming DMA mappings instead of allocating a coherent DMA buffer for
   every >32 bytes read/write
-> properly check for timeouts during i2c_amd_xfer and increase it from 50
   jiffies to 250 msecs (which is more in line with other drivers)
-> complete amd_i2c_dev.msg even if the device doesn't return a xxx_success
   event, instead of stalling i2c_amd_xfer
-> removed the spinlock and mdelay during i2c_amd_pci_configure, I didn't see
   the point since it's already waiting for a i2c_busenable_complete event
-> add an adapter-specific mutex lock for i2c_amd_xfer, since we don't want
   parallel calls writing to AMD_C2P_MSG0 (or AMD_C2P_MSG1)
-> add a global mutex lock for registers AMD_C2P_MSG2 to AMD_C2P_MSG9,  which
   are shared across the two busses/adapters
-> add MODULE_DEVICE_TABLE to automatically load i2c-amd-platdrv if the DSDT
   enumerates devices with the "AMDI0011" HID
-> set maximum length of reads/writes to 4095 (event's length field is 12 bits)
-> basic PM support
-> style corrections to match the kernel code style, and tried to reduce code
   duplication whenever possible

Changes since v4 by Elie M.:

-> fix missing typecast warning
-> removed the duplicated entry in Kconfig

Changes since v5 by Elie M.:

-> move DMA mapping from the platform driver to the PCI driver
-> attempt to find the platform device's PCI parent through the _DEP ACPI method
   (if not found take the first MP2 device registred in the i2c-amd-pci-mp2
   driver, like before)
-> do not assume anymore that the PCI device is owned by the i2c-amd-pci-mp2
   driver
-> address other review comments by Bjorn Helgaas (meant for v3)

Changes since v6 by Elie M.:

-> remove unnecessary memcpy from the DMA buffer during i2c_amd_read_completion

Changes since v7 by Elie M.:

-> merge the two modules into one named i2c-amd-mp2, delete now useless exports
-> unlock the C2P mutex if i2c_amd_xfer_msg timeouts, to prevent stalling the
   MP2 controller if a slave doesn't respond to a read or write request
-> unmap the DMA buffer before read/write_complete
-> fix bus_disable commands handling (no more errors during module exit)
-> prefer managed versions of pci_ and dev_ functions whenever possible
-> increase adapter retries from 0 to 3
-> reduce code duplication in debugfs functions
-> address other review points by Bjorn Helgaas (except regarding the _DEP
   hint)

Changes since v8 by Elie M.:

-> remove mostly redundant amd_i2c_rw_config, refer to i2c_msg whenever possible
-> use i2c_get_dma_safe_msg_buf and i2c_put_dma_safe_msg_buf
-> defer probe() by the platform driver if no MP2 device has been probed yet by the PCI driver (which should address Bjorn Helgaas' concern while preserving the platform driver)
-> if the interrupt following a command doesn't get handled after 250ms, zero AMD_P2C_MSG_INTEN to prevent the MP2 from stalling for a few more seconds (there seems to be an interrupt issue with older Zen microcodes, upgrade your amd microcode package if you experience timeouts)
-> include AMD_P2C_MSG3 and fix typo in debugfs output
-> cosmetic fixes, code reduction, and better comments
-> add Nehal Shah and Shyam Sundar S K from AMD to the list of maintainers

 MAINTAINERS                           |   8 +
 drivers/i2c/busses/Kconfig            |  10 +
 drivers/i2c/busses/Makefile           |   2 +
 drivers/i2c/busses/i2c-amd-mp2-pci.c  | 671 ++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-amd-mp2-plat.c | 332 +++++++++++++
 drivers/i2c/busses/i2c-amd-mp2.h      | 212 ++++++++
 6 files changed, 1235 insertions(+)
 create mode 100644 drivers/i2c/busses/i2c-amd-mp2-pci.c
 create mode 100644 drivers/i2c/busses/i2c-amd-mp2-plat.c
 create mode 100644 drivers/i2c/busses/i2c-amd-mp2.h

diff --git a/MAINTAINERS b/MAINTAINERS
index 6ac000cc006d..99382f213b1c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -791,6 +791,14 @@ F:	drivers/gpu/drm/amd/include/vi_structs.h
 F:	drivers/gpu/drm/amd/include/v9_structs.h
 F:	include/uapi/linux/kfd_ioctl.h
 
+AMD MP2 I2C DRIVER
+M:	Elie Morisse <syniurge@gmail.com>
+M:	Nehal Shah <nehal-bakulchandra.shah@amd.com>
+M:	Shyam Sundar S K <shyam-sundar.s-k@amd.com>
+L:	linux-i2c@vger.kernel.org
+S:	Maintained
+F:	drivers/i2c/busses/i2c-amd-mp2*
+
 AMD POWERPLAY
 M:	Rex Zhu <rex.zhu@amd.com>
 M:	Evan Quan <evan.quan@amd.com>
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 451d4ae50e66..70819245919e 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -77,6 +77,16 @@ config I2C_AMD8111
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-amd8111.
 
+config I2C_AMD_MP2_PCI
+	tristate "AMD MP2 PCIe I2C adapter"
+	depends on PCI && ACPI
+	help
+	  If you say yes to this option, support will be included for the AMD
+	  MP2 PCIe I2C adapter.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-amd-mp2.
+
 config I2C_HIX5HD2
 	tristate "Hix5hd2 high-speed I2C driver"
 	depends on ARCH_HISI || ARCH_HIX5HD2 || COMPILE_TEST
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 18b26af82b1c..b036ffab0165 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -32,6 +32,8 @@ obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 
 # Embedded system I2C/SMBus host controller drivers
 obj-$(CONFIG_I2C_ALTERA)	+= i2c-altera.o
+obj-$(CONFIG_I2C_AMD_MP2_PCI)	+= i2c-amd-mp2.o
+i2c-amd-mp2-objs := i2c-amd-mp2-pci.o i2c-amd-mp2-plat.o
 obj-$(CONFIG_I2C_ASPEED)	+= i2c-aspeed.o
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
diff --git a/drivers/i2c/busses/i2c-amd-mp2-pci.c b/drivers/i2c/busses/i2c-amd-mp2-pci.c
new file mode 100644
index 000000000000..32068087e26a
--- /dev/null
+++ b/drivers/i2c/busses/i2c-amd-mp2-pci.c
@@ -0,0 +1,671 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/*
+ * AMD MP2 PCIe communication driver
+ *
+ * Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+ *          Elie Morisse <syniurge@gmail.com>
+ */
+
+#include <linux/debugfs.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+
+#include "i2c-amd-mp2.h"
+
+#define DRIVER_NAME	"i2c_amd_mp2"
+#define DRIVER_DESC	"AMD(R) PCI-E MP2 I2C Controller Driver"
+#define DRIVER_VER	"1.0"
+
+#define write64 _write64
+static inline void _write64(u64 val, void __iomem *mmio)
+{
+	writel(val, mmio);
+	writel(val >> 32, mmio + sizeof(u32));
+}
+
+#define read64 _read64
+static inline u64 _read64(void __iomem *mmio)
+{
+	u64 low, high;
+
+	low = readl(mmio);
+	high = readl(mmio + sizeof(u32));
+	return low | (high << 32);
+}
+
+static void amd_mp2_c2p_mutex_lock(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	/* there is only one data mailbox for two i2c adapters */
+	mutex_lock(&privdata->c2p_lock);
+	privdata->c2p_lock_busid = i2c_common->bus_id;
+}
+
+static void amd_mp2_c2p_mutex_unlock(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	if (unlikely(privdata->c2p_lock_busid != i2c_common->bus_id)) {
+		dev_warn(ndev_dev(privdata),
+			 "bus %d attempting to unlock C2P locked by bus %d\n",
+			 i2c_common->bus_id, privdata->c2p_lock_busid);
+		return;
+	}
+
+	mutex_unlock(&privdata->c2p_lock);
+}
+
+static int amd_mp2_cmd(struct amd_mp2_dev *privdata,
+		       union i2c_cmd_base i2c_cmd_base)
+{
+	void __iomem *reg;
+
+	reg = privdata->mmio + ((i2c_cmd_base.s.bus_id == 1) ?
+				AMD_C2P_MSG1 : AMD_C2P_MSG0);
+	writel(i2c_cmd_base.ul, reg);
+
+	return 0;
+}
+
+int amd_mp2_connect(struct amd_i2c_common *i2c_common, bool enable)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	union i2c_cmd_base i2c_cmd_base;
+
+	dev_dbg(ndev_dev(privdata), "%s id: %d\n", __func__,
+		i2c_common->bus_id);
+
+	i2c_common->reqcmd = enable ? i2c_enable : i2c_disable;
+
+	i2c_cmd_base.ul = 0;
+	i2c_cmd_base.s.i2c_cmd = i2c_common->reqcmd;
+	i2c_cmd_base.s.bus_id = i2c_common->bus_id;
+	i2c_cmd_base.s.i2c_speed = i2c_common->i2c_speed;
+
+	return amd_mp2_cmd(privdata, i2c_cmd_base);
+}
+
+static void amd_mp2_cmd_rw_fill(struct amd_i2c_common *i2c_common,
+				union i2c_cmd_base *i2c_cmd_base,
+				enum i2c_cmd reqcmd)
+{
+	i2c_common->reqcmd = reqcmd;
+
+	i2c_cmd_base->s.i2c_cmd = reqcmd;
+	i2c_cmd_base->s.bus_id = i2c_common->bus_id;
+	i2c_cmd_base->s.i2c_speed = i2c_common->i2c_speed;
+	i2c_cmd_base->s.slave_addr = i2c_common->msg->addr;
+	i2c_cmd_base->s.length = i2c_common->msg->len;
+}
+
+static int amd_mp2_dma_map(struct amd_mp2_dev *privdata,
+			   struct amd_i2c_common *i2c_common)
+{
+	enum dma_data_direction dma_direction =
+			i2c_common->msg->flags & I2C_M_RD ?
+			DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	i2c_common->dma_buf = i2c_get_dma_safe_msg_buf(i2c_common->msg, 0);
+	i2c_common->dma_addr = dma_map_single(&privdata->pci_dev->dev,
+					      i2c_common->dma_buf,
+					      i2c_common->msg->len,
+					      dma_direction);
+
+	if (dma_mapping_error(&privdata->pci_dev->dev,
+			      i2c_common->dma_addr)) {
+		dev_err(ndev_dev(privdata),
+			"Error while mapping dma buffer %p\n",
+			i2c_common->dma_buf);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void amd_mp2_dma_unmap(struct amd_mp2_dev *privdata,
+			      struct amd_i2c_common *i2c_common)
+{
+	enum dma_data_direction dma_direction =
+			i2c_common->msg->flags & I2C_M_RD ?
+			DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	dma_unmap_single(&privdata->pci_dev->dev,
+			 i2c_common->dma_addr,
+			 i2c_common->msg->len,
+			 dma_direction);
+
+	i2c_put_dma_safe_msg_buf(i2c_common->dma_buf, i2c_common->msg, true);
+}
+
+int amd_mp2_read(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	union i2c_cmd_base i2c_cmd_base;
+
+	dev_dbg(ndev_dev(privdata), "%s addr: %x id: %d\n", __func__,
+		i2c_common->msg->addr, i2c_common->bus_id);
+
+	amd_mp2_cmd_rw_fill(i2c_common, &i2c_cmd_base, i2c_read);
+	amd_mp2_c2p_mutex_lock(i2c_common);
+
+	if (i2c_common->msg->len <= 32) {
+		i2c_cmd_base.s.mem_type = use_c2pmsg;
+	} else {
+		i2c_cmd_base.s.mem_type = use_dram;
+		if (amd_mp2_dma_map(privdata, i2c_common))
+			return -EIO;
+		write64((u64)i2c_common->dma_addr,
+			privdata->mmio + AMD_C2P_MSG2);
+	}
+
+	return amd_mp2_cmd(privdata, i2c_cmd_base);
+}
+
+int amd_mp2_write(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	union i2c_cmd_base i2c_cmd_base;
+
+	dev_dbg(ndev_dev(privdata), "%s addr: %x id: %d\n", __func__,
+		i2c_common->msg->addr, i2c_common->bus_id);
+
+	amd_mp2_cmd_rw_fill(i2c_common, &i2c_cmd_base, i2c_write);
+	amd_mp2_c2p_mutex_lock(i2c_common);
+
+	if (i2c_common->msg->len <= 32) {
+		i2c_cmd_base.s.mem_type = use_c2pmsg;
+		memcpy_toio(privdata->mmio + AMD_C2P_MSG2,
+			    i2c_common->msg->buf,
+			    i2c_common->msg->len);
+	} else {
+		i2c_cmd_base.s.mem_type = use_dram;
+		if (amd_mp2_dma_map(privdata, i2c_common))
+			return -EIO;
+		write64((u64)i2c_common->dma_addr,
+			privdata->mmio + AMD_C2P_MSG2);
+	}
+
+	return amd_mp2_cmd(privdata, i2c_cmd_base);
+}
+
+static void amd_mp2_pci_check_rw_event(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	int len = i2c_common->eventval.r.length;
+	u32 slave_addr = i2c_common->eventval.r.slave_addr;
+
+	if (len != i2c_common->msg->len)
+		dev_err(ndev_dev(privdata),
+			"length %d in event doesn't match buffer length %d!\n",
+			len, i2c_common->msg->len);
+	if (slave_addr != i2c_common->msg->addr)
+		dev_err(ndev_dev(privdata),
+			"unexpected slave address %x (expected: %x)!\n",
+			slave_addr, i2c_common->msg->addr);
+}
+
+static void amd_mp2_pci_do_work(struct work_struct *work)
+{
+	struct amd_i2c_common *i2c_common = work_amd_i2c_common(work);
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	int sts = i2c_common->eventval.r.status;
+	int res = i2c_common->eventval.r.response;
+	int len = i2c_common->eventval.r.length;
+
+	if ((i2c_common->reqcmd == i2c_read ||
+	     i2c_common->reqcmd == i2c_write) &&
+	    i2c_common->msg->len > 32)
+		amd_mp2_dma_unmap(privdata, i2c_common);
+
+	if (res != command_success) {
+		if (res == command_failed)
+			dev_err(ndev_dev(privdata), "i2c command failed!\n");
+		else
+			dev_err(ndev_dev(privdata), "invalid response to i2c command!\n");
+		i2c_amd_msg_completion(i2c_common);
+		return;
+	}
+
+	switch (i2c_common->reqcmd) {
+	case i2c_read:
+		if (sts == i2c_readcomplete_event) {
+			amd_mp2_pci_check_rw_event(i2c_common);
+			if (len <= 32)
+				memcpy_fromio(i2c_common->msg->buf,
+					      privdata->mmio + AMD_C2P_MSG2,
+					      i2c_common->msg->len);
+		} else if (sts == i2c_readfail_event) {
+			dev_err(ndev_dev(privdata), "i2c read failed!\n");
+		} else {
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after read (%d)!\n", sts);
+		}
+		break;
+	case i2c_write:
+		if (sts == i2c_writecomplete_event)
+			amd_mp2_pci_check_rw_event(i2c_common);
+		else if (sts == i2c_writefail_event)
+			dev_err(ndev_dev(privdata), "i2c write failed!\n");
+		else
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after write (%d)!\n", sts);
+		break;
+	case i2c_enable:
+		if (sts == i2c_busenable_failed)
+			dev_err(ndev_dev(privdata), "i2c bus enable failed!\n");
+		else if (sts != i2c_busenable_complete)
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after bus enable (%d)!\n",
+				sts);
+		break;
+	case i2c_disable:
+		if (sts == i2c_busdisable_failed)
+			dev_err(ndev_dev(privdata), "i2c bus disable failed!\n");
+		else if (sts != i2c_busdisable_complete)
+			dev_err(ndev_dev(privdata),
+				"invalid i2c status after bus disable (%d)!\n",
+				sts);
+		break;
+	default:
+		break;
+	}
+
+	i2c_amd_msg_completion(i2c_common);
+}
+
+static void amd_mp2_pci_work(struct work_struct *work)
+{
+	struct amd_i2c_common *i2c_common = work_amd_i2c_common(work);
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+	enum i2c_cmd cmd = i2c_common->reqcmd;
+
+	amd_mp2_pci_do_work(work);
+
+	i2c_common->reqcmd = i2c_none;
+
+	if (cmd == i2c_read || cmd == i2c_write)
+		mutex_unlock(&privdata->c2p_lock);
+}
+
+static irqreturn_t amd_mp2_irq_isr(int irq, void *dev)
+{
+	struct amd_mp2_dev *privdata = dev;
+	struct amd_i2c_common *i2c_common;
+	u32 val;
+	unsigned int bus_id;
+	void __iomem *reg;
+	unsigned long flags;
+	enum irqreturn ret = IRQ_NONE;
+
+	raw_spin_lock_irqsave(&privdata->lock, flags);
+
+	for (bus_id = 0; bus_id < 2; bus_id++) {
+		reg = privdata->mmio + ((bus_id == 0) ?
+					AMD_P2C_MSG1 : AMD_P2C_MSG2);
+		val = readl(reg);
+		if (val != 0) {
+			i2c_common = privdata->plat_common[bus_id];
+			if (!i2c_common)
+				continue;
+			i2c_common->eventval.ul = val;
+
+			writel(0, reg);
+			writel(0, privdata->mmio + AMD_P2C_MSG_INTEN);
+
+			if (i2c_common->reqcmd != i2c_none)
+				schedule_delayed_work(&i2c_common->work, 0);
+
+			ret = IRQ_HANDLED;
+		}
+	}
+
+	raw_spin_unlock_irqrestore(&privdata->lock, flags);
+	return ret;
+}
+
+void amd_mp2_rw_timeout(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	writel(0, privdata->mmio + AMD_P2C_MSG_INTEN);
+	amd_mp2_c2p_mutex_unlock(i2c_common);
+}
+
+int amd_mp2_register_cb(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	if (i2c_common->bus_id > 1)
+		return -EINVAL;
+	privdata->plat_common[i2c_common->bus_id] = i2c_common;
+
+	INIT_DELAYED_WORK(&i2c_common->work, amd_mp2_pci_work);
+
+	return 0;
+}
+
+int amd_mp2_unregister_cb(struct amd_i2c_common *i2c_common)
+{
+	struct amd_mp2_dev *privdata = i2c_common->mp2_dev;
+
+	cancel_delayed_work_sync(&i2c_common->work);
+	privdata->plat_common[i2c_common->bus_id] = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static const struct file_operations amd_mp2_debugfs_info;
+static struct dentry *debugfs_root_dir;
+
+static ssize_t amd_mp2_debugfs_read(struct file *filp, char __user *ubuf,
+				    size_t count, loff_t *offp)
+{
+	struct amd_mp2_dev *privdata;
+	void __iomem *mmio;
+	u8 *buf;
+	size_t buf_size;
+	ssize_t ret, off = 0;
+	u32 v32;
+	int i;
+
+	privdata = filp->private_data;
+	mmio = privdata->mmio;
+	buf_size = min_t(size_t, count, 0x800);
+	buf = kmalloc(buf_size, GFP_KERNEL);
+
+	if (!buf)
+		return -ENOMEM;
+
+	off += scnprintf(buf + off, buf_size - off,
+			 "MP2 Device Information:\n");
+
+	off += scnprintf(buf + off, buf_size - off,
+			 "========================\n");
+	off += scnprintf(buf + off, buf_size - off,
+			 "\tMP2 C2P Message Register Dump:\n\n");
+
+	for (i = 0; i < 10; i++) {
+		v32 = readl(privdata->mmio + AMD_C2P_MSG0 + i * 4);
+		off += scnprintf(buf + off, buf_size - off,
+				 "AMD_C2P_MSG%d -\t\t\t%#06x\n", i, v32);
+	}
+
+	off += scnprintf(buf + off, buf_size - off,
+			"\n\tMP2 P2C Message Register Dump:\n\n");
+
+	for (i = 0; i < 3; i++) {
+		v32 = readl(privdata->mmio + AMD_P2C_MSG1 + i * 4);
+		off += scnprintf(buf + off, buf_size - off,
+				 "AMD_P2C_MSG%d -\t\t\t%#06x\n", i + 1, v32);
+	}
+
+	v32 = readl(privdata->mmio + AMD_P2C_MSG_INTEN);
+	off += scnprintf(buf + off, buf_size - off,
+			"AMD_P2C_MSG_INTEN -\t\t%#06x\n", v32);
+
+	v32 = readl(privdata->mmio + AMD_P2C_MSG_INTSTS);
+	off += scnprintf(buf + off, buf_size - off,
+			"AMD_P2C_MSG_INTSTS -\t\t%#06x\n", v32);
+
+	ret = simple_read_from_buffer(ubuf, count, offp, buf, off);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations amd_mp2_debugfs_info = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = amd_mp2_debugfs_read,
+};
+
+static void amd_mp2_init_debugfs(struct amd_mp2_dev *privdata)
+{
+	if (!debugfs_root_dir)
+		return;
+
+	privdata->debugfs_dir = debugfs_create_dir(ndev_name(privdata),
+						   debugfs_root_dir);
+	if (!privdata->debugfs_dir) {
+		privdata->debugfs_info = NULL;
+	} else {
+		privdata->debugfs_info = debugfs_create_file
+			("info", 0400, privdata->debugfs_dir,
+			 privdata, &amd_mp2_debugfs_info);
+	}
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static void amd_mp2_clear_reg(struct amd_mp2_dev *privdata)
+{
+	int reg;
+
+	for (reg = AMD_C2P_MSG0; reg <= AMD_C2P_MSG9; reg += 4)
+		writel(0, privdata->mmio + reg);
+
+	for (reg = AMD_P2C_MSG1; reg <= AMD_P2C_MSG2; reg += 4)
+		writel(0, privdata->mmio + reg);
+}
+
+static int amd_mp2_pci_init(struct amd_mp2_dev *privdata,
+			    struct pci_dev *pci_dev)
+{
+	int rc;
+
+	pci_set_drvdata(pci_dev, privdata);
+
+	rc = pcim_enable_device(pci_dev);
+	if (rc) {
+		dev_err(ndev_dev(privdata), "Failed to enable MP2 PCI device\n");
+		goto err_pci_enable;
+	}
+
+	rc = pcim_iomap_regions(pci_dev, 1 << 2, pci_name(pci_dev));
+	if (rc) {
+		dev_err(ndev_dev(privdata), "I/O memory remapping failed\n");
+		goto err_pci_enable;
+	}
+	privdata->mmio = pcim_iomap_table(pci_dev)[2];
+
+	pci_set_master(pci_dev);
+
+	rc = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(64));
+	if (rc) {
+		rc = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));
+		if (rc)
+			goto err_dma_mask;
+		dev_warn(ndev_dev(privdata), "Cannot DMA highmem\n");
+	}
+
+	mutex_init(&privdata->c2p_lock);
+
+	/* Try to set up intx irq */
+	raw_spin_lock_init(&privdata->lock);
+	pci_intx(pci_dev, 1);
+	rc = devm_request_irq(&pci_dev->dev, pci_dev->irq, amd_mp2_irq_isr,
+			      IRQF_SHARED, dev_name(&pci_dev->dev), privdata);
+	if (rc)
+		dev_err(&pci_dev->dev, "Failure requesting irq %i: %d\n",
+			pci_dev->irq, rc);
+
+	return rc;
+
+err_dma_mask:
+	pci_clear_master(pci_dev);
+err_pci_enable:
+	pci_set_drvdata(pci_dev, NULL);
+	return rc;
+}
+
+static int amd_mp2_pci_probe(struct pci_dev *pci_dev,
+			     const struct pci_device_id *id)
+{
+	struct amd_mp2_dev *privdata;
+	int rc;
+	static bool first_probe = true;
+
+	if (first_probe) {
+		pr_info("%s: %s Version: %s\n", DRIVER_NAME,
+			DRIVER_DESC, DRIVER_VER);
+		first_probe = false;
+	}
+
+	dev_info(&pci_dev->dev, "MP2 device found [%04x:%04x] (rev %x)\n",
+		 (int)pci_dev->vendor, (int)pci_dev->device,
+		 (int)pci_dev->revision);
+
+	privdata = devm_kzalloc(&pci_dev->dev, sizeof(*privdata), GFP_KERNEL);
+	if (!privdata)
+		return -ENOMEM;
+
+	privdata->pci_dev = pci_dev;
+
+	rc = amd_mp2_pci_init(privdata, pci_dev);
+	if (rc)
+		return rc;
+
+	amd_mp2_init_debugfs(privdata);
+	dev_info(&pci_dev->dev, "MP2 device registered.\n");
+	return 0;
+}
+
+static void amd_mp2_pci_remove(struct pci_dev *pci_dev)
+{
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+	unsigned int bus_id;
+
+	for (bus_id = 0; bus_id < 2; bus_id++)
+		if (privdata->plat_common[bus_id])
+			amd_mp2_register_cb(privdata->plat_common[bus_id]);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(privdata->debugfs_dir);
+#endif /* CONFIG_DEBUG_FS */
+
+	amd_mp2_clear_reg(privdata);
+
+	pci_intx(pci_dev, 0);
+	pci_clear_master(pci_dev);
+}
+
+static const struct pci_device_id amd_mp2_pci_tbl[] = {
+	{PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_MP2)},
+	{0}
+};
+MODULE_DEVICE_TABLE(pci, amd_mp2_pci_tbl);
+
+#ifdef CONFIG_PM_SLEEP
+static int amd_mp2_pci_device_suspend(struct pci_dev *pci_dev,
+				      pm_message_t mesg)
+{
+	int ret;
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+
+	if (!privdata)
+		return -EINVAL;
+
+	ret = pci_save_state(pci_dev);
+	if (ret) {
+		dev_err(ndev_dev(privdata),
+			"pci_save_state failed = %d\n", ret);
+		return ret;
+	}
+
+	pci_enable_wake(pci_dev, PCI_D3hot, 0);
+	pci_disable_device(pci_dev);
+	pci_set_power_state(pci_dev, pci_choose_state(pci_dev, mesg));
+
+	return 0;
+}
+
+static int amd_mp2_pci_device_resume(struct pci_dev *pci_dev)
+{
+	struct amd_mp2_dev *privdata = pci_get_drvdata(pci_dev);
+
+	if (!privdata)
+		return -EINVAL;
+
+	pci_set_power_state(pci_dev, PCI_D0);
+	pci_restore_state(pci_dev);
+
+	if (pci_enable_device(pci_dev) < 0) {
+		dev_err(ndev_dev(privdata), "pci_enable_device failed\n");
+		return -EIO;
+	}
+
+	pci_enable_wake(pci_dev, PCI_D3hot, 0);
+
+	return 0;
+}
+#endif
+
+static struct pci_driver amd_mp2_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= amd_mp2_pci_tbl,
+	.probe		= amd_mp2_pci_probe,
+	.remove		= amd_mp2_pci_remove,
+#ifdef CONFIG_PM_SLEEP
+	.suspend	= amd_mp2_pci_device_suspend,
+	.resume		= amd_mp2_pci_device_resume,
+#endif
+};
+
+static int amd_mp2_device_match(struct device *dev, void *data)
+{
+	struct pci_dev *candidate = data;
+
+	if (!candidate)
+		return 1;
+	return (to_pci_dev(dev) == candidate) ? 1 : 0;
+}
+
+struct amd_mp2_dev *amd_mp2_find_device(struct pci_dev *candidate)
+{
+	struct device *dev;
+	struct pci_dev *pci_dev;
+
+	dev = driver_find_device(&amd_mp2_pci_driver.driver, NULL, candidate,
+				 amd_mp2_device_match);
+	if (!dev)
+		return NULL;
+
+	pci_dev = to_pci_dev(dev);
+	return (struct amd_mp2_dev *)pci_get_drvdata(pci_dev);
+}
+
+static int __init amd_mp2_drv_init(void)
+{
+	int rc;
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_root_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+#endif /* CONFIG_DEBUG_FS */
+
+	rc = pci_register_driver(&amd_mp2_pci_driver);
+	if (rc)
+		return rc;
+	return i2c_amd_register_driver();
+}
+module_init(amd_mp2_drv_init);
+
+static void __exit amd_mp2_drv_exit(void)
+{
+	i2c_amd_unregister_driver();
+	pci_unregister_driver(&amd_mp2_pci_driver);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(debugfs_root_dir);
+#endif /* CONFIG_DEBUG_FS */
+}
+module_exit(amd_mp2_drv_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VER);
+MODULE_AUTHOR("Shyam Sundar S K <Shyam-sundar.S-k@amd.com>");
+MODULE_AUTHOR("Nehal Shah <nehal-bakulchandra.shah@amd.com>");
+MODULE_AUTHOR("Elie Morisse <syniurge@gmail.com>");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/i2c/busses/i2c-amd-mp2-plat.c b/drivers/i2c/busses/i2c-amd-mp2-plat.c
new file mode 100644
index 000000000000..6aef411ce837
--- /dev/null
+++ b/drivers/i2c/busses/i2c-amd-mp2-plat.c
@@ -0,0 +1,332 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+/*
+ * AMD MP2 platform driver
+ *
+ * Setup the I2C adapters enumerated in the ACPI namespace.
+ * MP2 controllers have 2 separate buses, i.e up to 2 I2C adapters.
+ *
+ * Authors: Nehal Bakulchandra Shah <Nehal-bakulchandra.shah@amd.com>
+ *          Elie Morisse <syniurge@gmail.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+
+#include "i2c-amd-mp2.h"
+
+#define AMD_MP2_I2C_MAX_RW_LENGTH ((1 << 12) - 1)
+#define AMD_I2C_TIMEOUT (msecs_to_jiffies(250))
+
+/**
+ * struct amd_i2c_dev - MP2 bus/i2c adapter context
+ * @i2c_common: shared context with the MP2 PCI driver
+ * @pdev: platform driver node
+ * @adapter: i2c adapter
+ * @xfer_lock: xfer lock
+ * @completion: xfer completion object
+ */
+struct amd_i2c_dev {
+	struct amd_i2c_common i2c_common;
+	struct platform_device *pdev;
+	struct i2c_adapter adapter;
+	struct mutex xfer_lock;
+	struct completion msg_complete;
+	bool is_configured;
+};
+
+#define amd_i2c_dev_common(__common) \
+	container_of(__common, struct amd_i2c_dev, i2c_common)
+
+void i2c_amd_msg_completion(struct amd_i2c_common *i2c_common)
+{
+	struct amd_i2c_dev *i2c_dev = amd_i2c_dev_common(i2c_common);
+	union i2c_event *event = &i2c_common->eventval;
+
+	if (event->r.status == i2c_readcomplete_event)
+		dev_dbg(&i2c_dev->pdev->dev, "%s readdata:%*ph\n",
+			__func__, event->r.length,
+			i2c_common->msg->buf);
+
+	complete(&i2c_dev->msg_complete);
+}
+
+static int i2c_amd_pci_xconnect(struct amd_i2c_dev *i2c_dev, bool enable)
+{
+	struct amd_i2c_common *i2c_common = &i2c_dev->i2c_common;
+	unsigned long timeout;
+
+	reinit_completion(&i2c_dev->msg_complete);
+
+	amd_mp2_connect(i2c_common, enable);
+	timeout = wait_for_completion_timeout(&i2c_dev->msg_complete,
+					      AMD_I2C_TIMEOUT);
+	if (timeout == 0) {
+		dev_err(&i2c_dev->pdev->dev,
+			"i2c connection timed out\n");
+		mutex_unlock(&i2c_dev->xfer_lock);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int i2c_amd_xfer_msg(struct amd_i2c_dev *i2c_dev, struct i2c_msg *pmsg)
+{
+	struct amd_i2c_common *i2c_common = &i2c_dev->i2c_common;
+	unsigned long timeout;
+	bool is_read = pmsg->flags & I2C_M_RD;
+
+	reinit_completion(&i2c_dev->msg_complete);
+
+	i2c_common->msg = pmsg;
+
+	if (is_read)
+		amd_mp2_read(i2c_common);
+	else
+		amd_mp2_write(i2c_common);
+
+	timeout = wait_for_completion_timeout(&i2c_dev->msg_complete,
+					      AMD_I2C_TIMEOUT);
+	if (timeout == 0) {
+		dev_err(&i2c_dev->pdev->dev, "i2c %s timed out\n",
+			is_read ? "read" : "write");
+		amd_mp2_rw_timeout(i2c_common);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int i2c_amd_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	struct amd_i2c_dev *dev = i2c_get_adapdata(adap);
+	int i;
+	struct i2c_msg *pmsg;
+	int err;
+
+	mutex_lock(&dev->xfer_lock);
+
+	if (unlikely(!dev->is_configured)) {
+		amd_mp2_register_cb(&dev->i2c_common);
+		i2c_amd_pci_xconnect(dev, true);
+		dev->is_configured = 1;
+	}
+
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		err = i2c_amd_xfer_msg(dev, pmsg);
+		if (err)
+			break;
+	}
+
+	mutex_unlock(&dev->xfer_lock);
+
+	if (err)
+		return err;
+	return num;
+}
+
+static u32 i2c_amd_func(struct i2c_adapter *a)
+{
+	return I2C_FUNC_I2C;
+}
+
+static const struct i2c_algorithm i2c_amd_algorithm = {
+	.master_xfer = i2c_amd_xfer,
+	.functionality = i2c_amd_func,
+};
+
+static enum speed_enum i2c_amd_get_bus_speed(struct platform_device *pdev)
+{
+	u32 acpi_speed;
+	int i;
+	static const u32 supported_speeds[] = {
+		0, 100000, 400000, 1000000, 1400000, 3400000
+	};
+
+	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
+	/* round down to the lowest standard speed */
+	for (i = 1; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (acpi_speed < supported_speeds[i])
+			break;
+	}
+	acpi_speed = supported_speeds[i - 1];
+
+	switch (acpi_speed) {
+	case 100000:
+		return speed100k;
+	case 400000:
+		return speed400k;
+	case 1000000:
+		return speed1000k;
+	case 1400000:
+		return speed1400k;
+	case 3400000:
+		return speed3400k;
+	default:
+		return speed400k;
+	}
+}
+
+static struct device *i2c_amd_acpi_get_first_phys_node(struct acpi_device *adev)
+{
+	const struct acpi_device_physical_node *node;
+
+	if (list_empty(&adev->physical_node_list))
+		return NULL;
+
+	node = list_first_entry(&adev->physical_node_list,
+				struct acpi_device_physical_node, node);
+	return node->dev;
+}
+
+/*
+ * Take the first PCI device listed by the _DEP method as a hint.
+ * On Lenovo Ideapad/Yoga _DEP appears to be the only available hint at which
+ * PCI device an AMDI0011 ACPI device corresponds to.
+ */
+static struct pci_dev *i2c_amd_find_pci_parent_hint(struct acpi_device *adev)
+{
+	struct acpi_device *parent_adev;
+	struct device *phys_dev;
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+
+	if (!acpi_has_method(adev->handle, "_DEP"))
+		return NULL;
+
+	status = acpi_evaluate_reference(adev->handle, "_DEP", NULL,
+					 &dep_devices);
+	if (ACPI_FAILURE(status) || !dep_devices.count)
+		return NULL;
+
+	if (acpi_bus_get_device(dep_devices.handles[0], &parent_adev))
+		return NULL;
+	phys_dev = i2c_amd_acpi_get_first_phys_node(parent_adev);
+
+	if (!dev_is_pci(phys_dev))
+		return NULL;
+	return to_pci_dev(phys_dev);
+}
+
+static const struct i2c_adapter_quirks amd_i2c_dev_quirks = {
+	.max_read_len = AMD_MP2_I2C_MAX_RW_LENGTH,
+	.max_write_len = AMD_MP2_I2C_MAX_RW_LENGTH,
+};
+
+static int i2c_amd_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct amd_i2c_dev *i2c_dev;
+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
+	struct acpi_device *adev;
+	struct pci_dev *parent_candidate = NULL;
+	struct amd_mp2_dev *mp2_dev;
+	const char *uid;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return -ENODEV;
+
+	parent_candidate = i2c_amd_find_pci_parent_hint(adev);
+	mp2_dev = amd_mp2_find_device(parent_candidate);
+	if (!mp2_dev && parent_candidate)
+		/* If the hint pointed at a PCI device which isn't a MP2, go
+		 * for the first MP2 device registered in the PCI driver
+		 */
+		mp2_dev = amd_mp2_find_device(NULL);
+	if (!mp2_dev)
+		/* The corresponding MP2 PCI device might get probed later */
+		return -EPROBE_DEFER;
+
+	i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
+	if (!i2c_dev)
+		return -ENOMEM;
+
+	i2c_dev->i2c_common.mp2_dev = mp2_dev;
+	i2c_dev->pdev = pdev;
+	platform_set_drvdata(pdev, i2c_dev);
+
+	uid = adev->pnp.unique_id;
+	if (!uid) {
+		dev_err(&pdev->dev, "missing UID/bus id!\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(uid, "0") == 0) {
+		i2c_dev->i2c_common.bus_id = 0;
+	} else if (strcmp(uid, "1") == 0) {
+		i2c_dev->i2c_common.bus_id = 1;
+	} else {
+		dev_err(&pdev->dev, "incorrect UID/bus id \"%s\"!\n", uid);
+		return -EINVAL;
+	}
+	dev_dbg(&pdev->dev, "bus id is %u\n", i2c_dev->i2c_common.bus_id);
+
+	i2c_dev->i2c_common.i2c_speed = i2c_amd_get_bus_speed(pdev);
+
+	/* setup i2c adapter description */
+	i2c_dev->adapter.owner = THIS_MODULE;
+	i2c_dev->adapter.algo = &i2c_amd_algorithm;
+	i2c_dev->adapter.quirks = &amd_i2c_dev_quirks;
+	i2c_dev->adapter.dev.parent = &pdev->dev;
+	i2c_dev->adapter.algo_data = i2c_dev;
+	ACPI_COMPANION_SET(&i2c_dev->adapter.dev, ACPI_COMPANION(&pdev->dev));
+	i2c_dev->adapter.dev.of_node = pdev->dev.of_node;
+	snprintf(i2c_dev->adapter.name, sizeof(i2c_dev->adapter.name),
+		 "AMD MP2 i2c bus %u", i2c_dev->i2c_common.bus_id);
+	i2c_set_adapdata(&i2c_dev->adapter, i2c_dev);
+
+	init_completion(&i2c_dev->msg_complete);
+	mutex_init(&i2c_dev->xfer_lock);
+
+	/* and finally attach to i2c layer */
+	ret = i2c_add_adapter(&i2c_dev->adapter);
+
+	if (ret < 0)
+		dev_err(&pdev->dev, "i2c add adapter failed = %d\n", ret);
+
+	return ret;
+}
+
+static int i2c_amd_remove(struct platform_device *pdev)
+{
+	struct amd_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
+	struct amd_i2c_common *i2c_common = &i2c_dev->i2c_common;
+
+	i2c_amd_pci_xconnect(i2c_dev, false);
+
+	amd_mp2_register_cb(i2c_common);
+	i2c_del_adapter(&i2c_dev->adapter);
+
+	return 0;
+}
+
+static const struct acpi_device_id i2c_amd_acpi_match[] = {
+	{ "AMDI0011" },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, i2c_amd_acpi_match);
+
+static struct platform_driver i2c_amd_plat_driver = {
+	.probe = i2c_amd_probe,
+	.remove = i2c_amd_remove,
+	.driver = {
+		.name = "i2c_amd_mp2",
+		.acpi_match_table = ACPI_PTR(i2c_amd_acpi_match),
+	},
+};
+
+int i2c_amd_register_driver(void)
+{
+	return platform_driver_register(&i2c_amd_plat_driver);
+}
+
+void i2c_amd_unregister_driver(void)
+{
+	platform_driver_unregister(&i2c_amd_plat_driver);
+}
diff --git a/drivers/i2c/busses/i2c-amd-mp2.h b/drivers/i2c/busses/i2c-amd-mp2.h
new file mode 100644
index 000000000000..c0aa41f393f2
--- /dev/null
+++ b/drivers/i2c/busses/i2c-amd-mp2.h
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause */
+/*
+ * AMD MP2 I2C adapter driver
+ *
+ * Authors: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
+ *          Elie Morisse <syniurge@gmail.com>
+ */
+
+#ifndef I2C_AMD_PCI_MP2_H
+#define I2C_AMD_PCI_MP2_H
+
+#include <linux/i2c.h>
+#include <linux/pci.h>
+
+#define PCI_DEVICE_ID_AMD_MP2	0x15E6
+
+struct amd_i2c_common;
+struct amd_mp2_dev;
+
+enum {
+	/* MP2 C2P Message Registers */
+	AMD_C2P_MSG0 = 0x10500,			/* MP2 Message for I2C0 */
+	AMD_C2P_MSG1 = 0x10504,			/* MP2 Message for I2C1 */
+	AMD_C2P_MSG2 = 0x10508,			/* DRAM Address Lo / Data 0 */
+	AMD_C2P_MSG3 = 0x1050c,			/* DRAM Address HI / Data 1 */
+	AMD_C2P_MSG4 = 0x10510,			/* Data 2 */
+	AMD_C2P_MSG5 = 0x10514,			/* Data 3 */
+	AMD_C2P_MSG6 = 0x10518,			/* Data 4 */
+	AMD_C2P_MSG7 = 0x1051c,			/* Data 5 */
+	AMD_C2P_MSG8 = 0x10520,			/* Data 6 */
+	AMD_C2P_MSG9 = 0x10524,			/* Data 7 */
+
+	/* MP2 P2C Message Registers */
+	AMD_P2C_MSG0 = 0x10680,			/* Do not use */
+	AMD_P2C_MSG1 = 0x10684,			/* I2C0 interrupt register */
+	AMD_P2C_MSG2 = 0x10688,			/* I2C1 interrupt register */
+	AMD_P2C_MSG3 = 0x1068C,			/* MP2 debug info */
+	AMD_P2C_MSG_INTEN = 0x10690,		/* MP2 interrupt gen register */
+	AMD_P2C_MSG_INTSTS = 0x10694,		/* Interrupt status */
+};
+
+/* Command register data structures */
+
+#define i2c_none (-1)
+enum i2c_cmd {
+	i2c_read = 0,
+	i2c_write,
+	i2c_enable,
+	i2c_disable,
+	number_of_sensor_discovered,
+	is_mp2_active,
+	invalid_cmd = 0xF,
+};
+
+enum speed_enum {
+	speed100k = 0,
+	speed400k = 1,
+	speed1000k = 2,
+	speed1400k = 3,
+	speed3400k = 4
+};
+
+enum mem_type {
+	use_dram = 0,
+	use_c2pmsg = 1,
+};
+
+/**
+ * union i2c_cmd_base : bit access of C2P commands
+ * @i2c_cmd: bit 0..3 i2c R/W command
+ * @bus_id: bit 4..7 i2c bus index
+ * @slave_addr: bit 8..15 slave address
+ * @length: bit 16..27 read/write length
+ * @i2c_speed: bit 28..30 bus speed
+ * @mem_type: bit 31 0-DRAM; 1-C2P msg o/p
+ */
+union i2c_cmd_base {
+	u32 ul;
+	struct {
+		enum i2c_cmd i2c_cmd : 4;
+		u8 bus_id : 4;
+		u32 slave_addr : 8;
+		u32 length : 12;
+		enum speed_enum i2c_speed : 3;
+		enum mem_type mem_type : 1;
+	} s;
+};
+
+/* Response - Response of SFI */
+enum response_type {
+	invalid_response = 0,
+	command_success = 1,
+	command_failed = 2,
+};
+
+/* Status - Command ID to indicate a command */
+enum status_type {
+	i2c_readcomplete_event = 0,
+	i2c_readfail_event = 1,
+	i2c_writecomplete_event = 2,
+	i2c_writefail_event = 3,
+	i2c_busenable_complete = 4,
+	i2c_busenable_failed = 5,
+	i2c_busdisable_complete = 6,
+	i2c_busdisable_failed = 7,
+	invalid_data_length = 8,
+	invalid_slave_address = 9,
+	invalid_i2cbus_id = 10,
+	invalid_dram_addr = 11,
+	invalid_command = 12,
+	mp2_active = 13,
+	numberof_sensors_discovered_resp = 14,
+	i2c_bus_notinitialized
+};
+
+/**
+ * union i2c_event : bit access of P2C events
+ * @response: bit 0..1 i2c response type
+ * @status: bit 2..6 status_type
+ * @mem_type: bit 7 0-DRAM; 1-C2P msg o/p
+ * @bus_id: bit 8..11 i2c bus id
+ * @length: bit 12..23 message length
+ * @slave_addr: bit 24-31 slave address
+ */
+union i2c_event {
+	u32 ul;
+	struct {
+		enum response_type response : 2;
+		enum status_type status : 5;
+		enum mem_type mem_type : 1;
+		u8 bus_id : 4;
+		u32 length : 12;
+		u32 slave_addr : 8;
+	} r;
+};
+
+/**
+ * struct amd_i2c_common - per bus/i2c adapter context, shared
+ *	between the pci and the platform driver
+ * @eventval: MP2 event value set by the IRQ handler to be processed
+ *	      by the worker
+ * @msg: i2c message
+ * @work: delayed worker struct
+ * @reqcmd: requested i2c command type
+ * @bus_id: bus index
+ * @i2c_speed: i2c bus speed determined by the slowest slave
+ * @dma_addr: if length > 32, holds the DMA buffer address
+ * @dma_direction: if length > 32, is either FROM or TO device
+ */
+struct amd_i2c_common {
+	union i2c_event eventval;
+	struct amd_mp2_dev *mp2_dev;
+	struct i2c_msg *msg;
+	struct delayed_work work;
+	enum i2c_cmd reqcmd;
+	u8 bus_id;
+	enum speed_enum i2c_speed;
+	u8 *dma_buf;
+	dma_addr_t dma_addr;
+};
+
+/**
+ * struct amd_mp2_dev - per PCI device context
+ * @pci_dev: PCI driver node
+ * @plat_common: MP2 devices may have up to two busses,
+ *		 each bus corresponding to an i2c adapter
+ * @mmio: iommapped registers
+ * @lock: interrupt spinlock
+ * @c2p_lock: controls access to the C2P mailbox shared between
+ *	      the two adapters
+ * @c2p_lock_busid: id of the adapter which locked c2p_lock
+ */
+struct amd_mp2_dev {
+	struct pci_dev *pci_dev;
+	struct amd_i2c_common *plat_common[2];
+	void __iomem *mmio;
+	raw_spinlock_t lock;
+	struct mutex c2p_lock;
+	u8 c2p_lock_busid;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_dir;
+	struct dentry *debugfs_info;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+/* PCIe communication driver */
+
+int amd_mp2_read(struct amd_i2c_common *i2c_common);
+int amd_mp2_write(struct amd_i2c_common *i2c_common);
+int amd_mp2_connect(struct amd_i2c_common *i2c_common, bool enable);
+
+void amd_mp2_rw_timeout(struct amd_i2c_common *i2c_common);
+
+int amd_mp2_register_cb(struct amd_i2c_common *i2c_common);
+int amd_mp2_unregister_cb(struct amd_i2c_common *i2c_common);
+
+struct amd_mp2_dev *amd_mp2_find_device(struct pci_dev *candidate);
+
+/* Platform driver */
+
+void i2c_amd_msg_completion(struct amd_i2c_common *i2c_common);
+
+int i2c_amd_register_driver(void);
+void i2c_amd_unregister_driver(void);
+
+#define ndev_pdev(ndev) ((ndev)->pci_dev)
+#define ndev_name(ndev) pci_name(ndev_pdev(ndev))
+#define ndev_dev(ndev) (&ndev_pdev(ndev)->dev)
+#define work_amd_i2c_common(__work) \
+	container_of(__work, struct amd_i2c_common, work.work)
+
+#endif
-- 
2.17.1
